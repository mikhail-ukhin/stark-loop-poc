"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/starknet";
exports.ids = ["vendor-chunks/starknet"];
exports.modules = {

/***/ "(ssr)/./node_modules/starknet/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/starknet/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountInterface: () => (/* binding */ AccountInterface),\n/* harmony export */   BlockStatus: () => (/* binding */ BlockStatus),\n/* harmony export */   BlockTag: () => (/* binding */ BlockTag),\n/* harmony export */   CairoCustomEnum: () => (/* binding */ CairoCustomEnum),\n/* harmony export */   CairoOption: () => (/* binding */ CairoOption),\n/* harmony export */   CairoOptionVariant: () => (/* binding */ CairoOptionVariant),\n/* harmony export */   CairoResult: () => (/* binding */ CairoResult),\n/* harmony export */   CairoResultVariant: () => (/* binding */ CairoResultVariant),\n/* harmony export */   CairoUint256: () => (/* binding */ CairoUint256),\n/* harmony export */   CairoUint512: () => (/* binding */ CairoUint512),\n/* harmony export */   CallData: () => (/* binding */ CallData),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory),\n/* harmony export */   ContractInterface: () => (/* binding */ ContractInterface),\n/* harmony export */   CustomError: () => (/* binding */ CustomError),\n/* harmony export */   EntryPointType: () => (/* binding */ EntryPointType),\n/* harmony export */   EthSigner: () => (/* binding */ EthSigner),\n/* harmony export */   GatewayError: () => (/* binding */ GatewayError),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LibraryError: () => (/* binding */ LibraryError),\n/* harmony export */   Literal: () => (/* binding */ Literal),\n/* harmony export */   Provider: () => (/* binding */ RpcProvider2),\n/* harmony export */   ProviderInterface: () => (/* binding */ ProviderInterface),\n/* harmony export */   RPC: () => (/* binding */ api_exports),\n/* harmony export */   RPC06: () => (/* binding */ rpc_0_6_exports),\n/* harmony export */   RPC07: () => (/* binding */ rpc_0_7_exports),\n/* harmony export */   RPCResponseParser: () => (/* binding */ RPCResponseParser),\n/* harmony export */   ReceiptTx: () => (/* binding */ ReceiptTx),\n/* harmony export */   ResponseParser: () => (/* binding */ ResponseParser),\n/* harmony export */   RpcChannel: () => (/* binding */ RpcChannel2),\n/* harmony export */   RpcProvider: () => (/* binding */ RpcProvider2),\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   SignerInterface: () => (/* binding */ SignerInterface),\n/* harmony export */   TransactionExecutionStatus: () => (/* binding */ TransactionExecutionStatus),\n/* harmony export */   TransactionFinalityStatus: () => (/* binding */ TransactionFinalityStatus),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   TransactionType: () => (/* binding */ TransactionType),\n/* harmony export */   TypedDataRevision: () => (/* reexport safe */ starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision),\n/* harmony export */   UINT_128_MAX: () => (/* binding */ UINT_128_MAX),\n/* harmony export */   UINT_128_MIN: () => (/* binding */ UINT_128_MIN),\n/* harmony export */   UINT_256_HIGH_MAX: () => (/* binding */ UINT_256_HIGH_MAX),\n/* harmony export */   UINT_256_HIGH_MIN: () => (/* binding */ UINT_256_HIGH_MIN),\n/* harmony export */   UINT_256_LOW_MAX: () => (/* binding */ UINT_256_LOW_MAX),\n/* harmony export */   UINT_256_LOW_MIN: () => (/* binding */ UINT_256_LOW_MIN),\n/* harmony export */   UINT_256_MAX: () => (/* binding */ UINT_256_MAX),\n/* harmony export */   UINT_256_MIN: () => (/* binding */ UINT_256_MIN),\n/* harmony export */   UINT_512_MAX: () => (/* binding */ UINT_512_MAX),\n/* harmony export */   UINT_512_MIN: () => (/* binding */ UINT_512_MIN),\n/* harmony export */   Uint: () => (/* binding */ Uint),\n/* harmony export */   ValidateType: () => (/* binding */ ValidateType),\n/* harmony export */   WalletAccount: () => (/* binding */ WalletAccount),\n/* harmony export */   addAddressPadding: () => (/* binding */ addAddressPadding),\n/* harmony export */   buildUrl: () => (/* binding */ buildUrl),\n/* harmony export */   byteArray: () => (/* binding */ byteArray_exports),\n/* harmony export */   cairo: () => (/* binding */ cairo_exports),\n/* harmony export */   constants: () => (/* binding */ constants_exports),\n/* harmony export */   contractClassResponseToLegacyCompiledContract: () => (/* binding */ contractClassResponseToLegacyCompiledContract),\n/* harmony export */   defaultProvider: () => (/* binding */ defaultProvider),\n/* harmony export */   ec: () => (/* binding */ ec_exports),\n/* harmony export */   encode: () => (/* binding */ encode_exports),\n/* harmony export */   eth: () => (/* binding */ eth_exports),\n/* harmony export */   events: () => (/* binding */ events_exports),\n/* harmony export */   extractContractHashes: () => (/* binding */ extractContractHashes),\n/* harmony export */   fixProto: () => (/* binding */ fixProto),\n/* harmony export */   fixStack: () => (/* binding */ fixStack),\n/* harmony export */   getCalldata: () => (/* binding */ getCalldata),\n/* harmony export */   getChecksumAddress: () => (/* binding */ getChecksumAddress),\n/* harmony export */   hash: () => (/* binding */ hash_exports),\n/* harmony export */   isSierra: () => (/* binding */ isSierra),\n/* harmony export */   isUrl: () => (/* binding */ isUrl),\n/* harmony export */   json: () => (/* binding */ json_exports),\n/* harmony export */   merkle: () => (/* binding */ merkle_exports),\n/* harmony export */   num: () => (/* binding */ num_exports),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   parseCalldataField: () => (/* binding */ parseCalldataField),\n/* harmony export */   provider: () => (/* binding */ provider_exports),\n/* harmony export */   selector: () => (/* binding */ selector_exports),\n/* harmony export */   shortString: () => (/* binding */ shortString_exports),\n/* harmony export */   splitArgsAndOptions: () => (/* binding */ splitArgsAndOptions),\n/* harmony export */   stark: () => (/* binding */ stark_exports),\n/* harmony export */   starknetId: () => (/* binding */ starknetId_exports),\n/* harmony export */   transaction: () => (/* binding */ transaction_exports),\n/* harmony export */   typedData: () => (/* binding */ typedData_exports),\n/* harmony export */   types: () => (/* binding */ types_exports),\n/* harmony export */   uint256: () => (/* binding */ uint256_exports),\n/* harmony export */   v2hash: () => (/* binding */ v2_exports),\n/* harmony export */   v3hash: () => (/* binding */ v3_exports),\n/* harmony export */   validateAndParseAddress: () => (/* binding */ validateAndParseAddress),\n/* harmony export */   validateChecksumAddress: () => (/* binding */ validateChecksumAddress),\n/* harmony export */   wallet: () => (/* binding */ connect_exports)\n/* harmony export */ });\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! starknet-types-07 */ \"(ssr)/./node_modules/starknet-types-07/dist/esm/index.js\");\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! starknet-types-07 */ \"(ssr)/./node_modules/starknet-types-07/dist/esm/api/nonspec.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! starknet-types-07 */ \"(ssr)/./node_modules/starknet-types-07/dist/esm/wallet-api/typedData.js\");\n/* harmony import */ var _scure_starknet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @scure/starknet */ \"(ssr)/./node_modules/@scure/starknet/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var lossless_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lossless-json */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var fetch_cookie__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! fetch-cookie */ \"(ssr)/./node_modules/fetch-cookie/esm/index.js\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! isomorphic-fetch */ \"(ssr)/./node_modules/isomorphic-fetch/fetch-npm-node.js\");\n/* harmony import */ var ts_mixer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ts-mixer */ \"(ssr)/./node_modules/ts-mixer/dist/esm/index.js\");\n/* harmony import */ var url_join__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! url-join */ \"(ssr)/./node_modules/url-join/lib/url-join.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __reExport = (target, mod, secondTarget)=>(__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n// src/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n    ADDR_BOUND: ()=>ADDR_BOUND,\n    API_VERSION: ()=>API_VERSION,\n    BaseUrl: ()=>BaseUrl,\n    FeeMarginPercentage: ()=>FeeMarginPercentage,\n    IS_BROWSER: ()=>IS_BROWSER,\n    MASK_250: ()=>MASK_250,\n    MAX_STORAGE_ITEM_SIZE: ()=>MAX_STORAGE_ITEM_SIZE,\n    NetworkName: ()=>NetworkName,\n    PRIME: ()=>PRIME,\n    RANGE_FELT: ()=>RANGE_FELT,\n    RANGE_I128: ()=>RANGE_I128,\n    RANGE_U128: ()=>RANGE_U128,\n    RPC_DEFAULT_VERSION: ()=>RPC_DEFAULT_VERSION,\n    RPC_NODES: ()=>RPC_NODES,\n    StarknetChainId: ()=>StarknetChainId,\n    TEXT_TO_FELT_MAX_LEN: ()=>TEXT_TO_FELT_MAX_LEN,\n    TRANSACTION_VERSION: ()=>api_exports.ETransactionVersion,\n    TransactionHashPrefix: ()=>TransactionHashPrefix,\n    UDC: ()=>UDC,\n    ZERO: ()=>ZERO\n});\n// src/types/api/index.ts\nvar api_exports = {};\n__export(api_exports, {\n    JRPC: ()=>jsonrpc_exports,\n    RPCSPEC06: ()=>rpcspec_0_6_exports,\n    RPCSPEC07: ()=>starknet_types_07__WEBPACK_IMPORTED_MODULE_0__\n});\n// src/types/api/jsonrpc/index.ts\nvar jsonrpc_exports = {};\n// src/types/api/rpcspec_0_6/index.ts\nvar rpcspec_0_6_exports = {};\n__export(rpcspec_0_6_exports, {\n    EBlockTag: ()=>EBlockTag,\n    EDAMode: ()=>EDAMode,\n    EDataAvailabilityMode: ()=>EDataAvailabilityMode,\n    ESimulationFlag: ()=>ESimulationFlag,\n    ETransactionExecutionStatus: ()=>ETransactionExecutionStatus,\n    ETransactionFinalityStatus: ()=>ETransactionFinalityStatus,\n    ETransactionStatus: ()=>ETransactionStatus,\n    ETransactionType: ()=>ETransactionType,\n    ETransactionVersion: ()=>ETransactionVersion,\n    ETransactionVersion2: ()=>ETransactionVersion2,\n    ETransactionVersion3: ()=>ETransactionVersion3,\n    Errors: ()=>errors_exports,\n    SPEC: ()=>components_exports\n});\n// src/types/api/rpcspec_0_6/errors.ts\nvar errors_exports = {};\n// src/types/api/rpcspec_0_6/components.ts\nvar components_exports = {};\n// src/types/api/rpcspec_0_6/nonspec.ts\nvar ETransactionType = /* @__PURE__ */ ((ETransactionType2)=>{\n    ETransactionType2[\"DECLARE\"] = \"DECLARE\";\n    ETransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n    ETransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n    ETransactionType2[\"INVOKE\"] = \"INVOKE\";\n    ETransactionType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n    return ETransactionType2;\n})(ETransactionType || {});\nvar ESimulationFlag = /* @__PURE__ */ ((ESimulationFlag2)=>{\n    ESimulationFlag2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n    ESimulationFlag2[\"SKIP_FEE_CHARGE\"] = \"SKIP_FEE_CHARGE\";\n    return ESimulationFlag2;\n})(ESimulationFlag || {});\nvar ETransactionStatus = /* @__PURE__ */ ((ETransactionStatus2)=>{\n    ETransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    ETransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n    ETransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    ETransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return ETransactionStatus2;\n})(ETransactionStatus || {});\nvar ETransactionFinalityStatus = /* @__PURE__ */ ((ETransactionFinalityStatus2)=>{\n    ETransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    ETransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return ETransactionFinalityStatus2;\n})(ETransactionFinalityStatus || {});\nvar ETransactionExecutionStatus = /* @__PURE__ */ ((ETransactionExecutionStatus2)=>{\n    ETransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n    ETransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n    return ETransactionExecutionStatus2;\n})(ETransactionExecutionStatus || {});\nvar EBlockTag = /* @__PURE__ */ ((EBlockTag2)=>{\n    EBlockTag2[\"PENDING\"] = \"pending\";\n    EBlockTag2[\"LATEST\"] = \"latest\";\n    return EBlockTag2;\n})(EBlockTag || {});\nvar EDataAvailabilityMode = /* @__PURE__ */ ((EDataAvailabilityMode3)=>{\n    EDataAvailabilityMode3[\"L1\"] = \"L1\";\n    EDataAvailabilityMode3[\"L2\"] = \"L2\";\n    return EDataAvailabilityMode3;\n})(EDataAvailabilityMode || {});\nvar EDAMode = /* @__PURE__ */ ((EDAMode4)=>{\n    EDAMode4[EDAMode4[\"L1\"] = 0] = \"L1\";\n    EDAMode4[EDAMode4[\"L2\"] = 1] = \"L2\";\n    return EDAMode4;\n})(EDAMode || {});\nvar ETransactionVersion = /* @__PURE__ */ ((ETransactionVersion10)=>{\n    ETransactionVersion10[\"V0\"] = \"0x0\";\n    ETransactionVersion10[\"V1\"] = \"0x1\";\n    ETransactionVersion10[\"V2\"] = \"0x2\";\n    ETransactionVersion10[\"V3\"] = \"0x3\";\n    ETransactionVersion10[\"F0\"] = \"0x100000000000000000000000000000000\";\n    ETransactionVersion10[\"F1\"] = \"0x100000000000000000000000000000001\";\n    ETransactionVersion10[\"F2\"] = \"0x100000000000000000000000000000002\";\n    ETransactionVersion10[\"F3\"] = \"0x100000000000000000000000000000003\";\n    return ETransactionVersion10;\n})(ETransactionVersion || {});\nvar ETransactionVersion2 = /* @__PURE__ */ ((ETransactionVersion25)=>{\n    ETransactionVersion25[\"V0\"] = \"0x0\";\n    ETransactionVersion25[\"V1\"] = \"0x1\";\n    ETransactionVersion25[\"V2\"] = \"0x2\";\n    ETransactionVersion25[\"F0\"] = \"0x100000000000000000000000000000000\";\n    ETransactionVersion25[\"F1\"] = \"0x100000000000000000000000000000001\";\n    ETransactionVersion25[\"F2\"] = \"0x100000000000000000000000000000002\";\n    return ETransactionVersion25;\n})(ETransactionVersion2 || {});\nvar ETransactionVersion3 = /* @__PURE__ */ ((ETransactionVersion36)=>{\n    ETransactionVersion36[\"V3\"] = \"0x3\";\n    ETransactionVersion36[\"F3\"] = \"0x100000000000000000000000000000003\";\n    return ETransactionVersion36;\n})(ETransactionVersion3 || {});\n// src/types/api/index.ts\n__reExport(api_exports, starknet_types_07__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// src/utils/encode.ts\nvar encode_exports = {};\n__export(encode_exports, {\n    IS_BROWSER: ()=>IS_BROWSER,\n    addHexPrefix: ()=>addHexPrefix,\n    arrayBufferToString: ()=>arrayBufferToString,\n    atobUniversal: ()=>atobUniversal,\n    btoaUniversal: ()=>btoaUniversal,\n    buf2hex: ()=>buf2hex,\n    calcByteLength: ()=>calcByteLength,\n    padLeft: ()=>padLeft,\n    pascalToSnake: ()=>pascalToSnake,\n    removeHexPrefix: ()=>removeHexPrefix,\n    sanitizeBytes: ()=>sanitizeBytes,\n    sanitizeHex: ()=>sanitizeHex,\n    stringToArrayBuffer: ()=>stringToArrayBuffer,\n    utf8ToArray: ()=>utf8ToArray\n});\n\nvar IS_BROWSER = \"undefined\" !== \"undefined\";\nvar STRING_ZERO = \"0\";\nfunction arrayBufferToString(array) {\n    return new Uint8Array(array).reduce((data, byte)=>data + String.fromCharCode(byte), \"\");\n}\nfunction utf8ToArray(str) {\n    return new TextEncoder().encode(str);\n}\nfunction stringToArrayBuffer(str) {\n    return utf8ToArray(str);\n}\nfunction atobUniversal(a) {\n    return _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64.decode(a);\n}\nfunction btoaUniversal(b) {\n    return _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64.encode(new Uint8Array(b));\n}\nfunction buf2hex(buffer) {\n    return buffer.reduce((r, x)=>r + x.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction removeHexPrefix(hex) {\n    return hex.replace(/^0x/i, \"\");\n}\nfunction addHexPrefix(hex) {\n    return `0x${removeHexPrefix(hex)}`;\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n    const diff = length - str.length;\n    let result = str;\n    if (diff > 0) {\n        const pad = padding.repeat(diff);\n        result = left ? pad + str : str + pad;\n    }\n    return result;\n}\nfunction padLeft(str, length, padding = STRING_ZERO) {\n    return padString(str, length, true, padding);\n}\nfunction calcByteLength(str, byteSize = 8) {\n    const { length } = str;\n    const remainder = length % byteSize;\n    return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nfunction sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n    return padLeft(str, calcByteLength(str, byteSize), padding);\n}\nfunction sanitizeHex(hex) {\n    hex = removeHexPrefix(hex);\n    hex = sanitizeBytes(hex, 2);\n    if (hex) {\n        hex = addHexPrefix(hex);\n    }\n    return hex;\n}\nvar pascalToSnake = (text)=>/[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join(\"_\").toUpperCase() : text;\n// src/constants.ts\nvar TEXT_TO_FELT_MAX_LEN = 31;\nvar ZERO = 0n;\nvar MASK_250 = 2n ** 250n - 1n;\nvar API_VERSION = ZERO;\nvar PRIME = 2n ** 251n + 17n * 2n ** 192n + 1n;\nvar MAX_STORAGE_ITEM_SIZE = 256n;\nvar ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\nvar range = (min, max)=>({\n        min,\n        max\n    });\nvar RANGE_FELT = range(ZERO, PRIME - 1n);\nvar RANGE_I128 = range(-(2n ** 127n), 2n ** 127n - 1n);\nvar RANGE_U128 = range(ZERO, 2n ** 128n - 1n);\nvar BaseUrl = /* @__PURE__ */ ((BaseUrl2)=>{\n    BaseUrl2[\"SN_MAIN\"] = \"https://alpha-mainnet.starknet.io\";\n    BaseUrl2[\"SN_SEPOLIA\"] = \"https://alpha-sepolia.starknet.io\";\n    return BaseUrl2;\n})(BaseUrl || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2)=>{\n    NetworkName2[\"SN_MAIN\"] = \"SN_MAIN\";\n    NetworkName2[\"SN_SEPOLIA\"] = \"SN_SEPOLIA\";\n    return NetworkName2;\n})(NetworkName || {});\nvar StarknetChainId = /* @__PURE__ */ ((StarknetChainId6)=>{\n    StarknetChainId6[\"SN_MAIN\"] = \"0x534e5f4d41494e\";\n    StarknetChainId6[\"SN_SEPOLIA\"] = \"0x534e5f5345504f4c4941\";\n    return StarknetChainId6;\n})(StarknetChainId || {});\nvar TransactionHashPrefix = /* @__PURE__ */ ((TransactionHashPrefix2)=>{\n    TransactionHashPrefix2[\"DECLARE\"] = \"0x6465636c617265\";\n    TransactionHashPrefix2[\"DEPLOY\"] = \"0x6465706c6f79\";\n    TransactionHashPrefix2[\"DEPLOY_ACCOUNT\"] = \"0x6465706c6f795f6163636f756e74\";\n    TransactionHashPrefix2[\"INVOKE\"] = \"0x696e766f6b65\";\n    TransactionHashPrefix2[\"L1_HANDLER\"] = \"0x6c315f68616e646c6572\";\n    return TransactionHashPrefix2;\n})(TransactionHashPrefix || {});\nvar FeeMarginPercentage = /* @__PURE__ */ ((FeeMarginPercentage2)=>{\n    FeeMarginPercentage2[FeeMarginPercentage2[\"L1_BOUND_MAX_AMOUNT\"] = 50] = \"L1_BOUND_MAX_AMOUNT\";\n    FeeMarginPercentage2[FeeMarginPercentage2[\"L1_BOUND_MAX_PRICE_PER_UNIT\"] = 50] = \"L1_BOUND_MAX_PRICE_PER_UNIT\";\n    FeeMarginPercentage2[FeeMarginPercentage2[\"MAX_FEE\"] = 50] = \"MAX_FEE\";\n    return FeeMarginPercentage2;\n})(FeeMarginPercentage || {});\nvar UDC = {\n    ADDRESS: \"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\",\n    ENTRYPOINT: \"deployContract\"\n};\nvar RPC_DEFAULT_VERSION = \"v0_7\";\nvar RPC_NODES = {\n    SN_MAIN: [\n        `https://starknet-mainnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n        `https://free-rpc.nethermind.io/mainnet-juno/${RPC_DEFAULT_VERSION}`\n    ],\n    SN_SEPOLIA: [\n        `https://starknet-sepolia.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n        `https://free-rpc.nethermind.io/sepolia-juno/${RPC_DEFAULT_VERSION}`\n    ]\n};\n// src/provider/rpc.ts\n\n\n// src/channel/rpc_0_6.ts\nvar rpc_0_6_exports = {};\n__export(rpc_0_6_exports, {\n    RpcChannel: ()=>RpcChannel\n});\n// src/provider/errors.ts\nfunction fixStack(target, fn = target.constructor) {\n    const { captureStackTrace } = Error;\n    captureStackTrace && captureStackTrace(target, fn);\n}\nfunction fixProto(target, prototype) {\n    const { setPrototypeOf } = Object;\n    setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n}\nvar CustomError = class extends Error {\n    constructor(message){\n        super(message);\n        Object.defineProperty(this, \"name\", {\n            value: new.target.name,\n            enumerable: false,\n            configurable: true\n        });\n        fixProto(this, new.target.prototype);\n        fixStack(this);\n    }\n};\nvar LibraryError = class extends CustomError {\n};\nvar GatewayError = class extends LibraryError {\n    constructor(message, errorCode){\n        super(message);\n        this.errorCode = errorCode;\n    }\n};\nvar HttpError = class extends LibraryError {\n    constructor(message, errorCode){\n        super(message);\n        this.errorCode = errorCode;\n    }\n};\n// src/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n    BlockStatus: ()=>BlockStatus,\n    BlockTag: ()=>BlockTag,\n    EntryPointType: ()=>EntryPointType,\n    Literal: ()=>Literal,\n    RPC: ()=>api_exports,\n    TransactionExecutionStatus: ()=>TransactionExecutionStatus,\n    TransactionFinalityStatus: ()=>TransactionFinalityStatus,\n    TransactionStatus: ()=>TransactionStatus,\n    TransactionType: ()=>TransactionType,\n    TypedDataRevision: ()=>starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision,\n    Uint: ()=>Uint,\n    ValidateType: ()=>ValidateType\n});\n// src/types/calldata.ts\nvar ValidateType = /* @__PURE__ */ ((ValidateType2)=>{\n    ValidateType2[\"DEPLOY\"] = \"DEPLOY\";\n    ValidateType2[\"CALL\"] = \"CALL\";\n    ValidateType2[\"INVOKE\"] = \"INVOKE\";\n    return ValidateType2;\n})(ValidateType || {});\nvar Uint = /* @__PURE__ */ ((Uint2)=>{\n    Uint2[\"u8\"] = \"core::integer::u8\";\n    Uint2[\"u16\"] = \"core::integer::u16\";\n    Uint2[\"u32\"] = \"core::integer::u32\";\n    Uint2[\"u64\"] = \"core::integer::u64\";\n    Uint2[\"u128\"] = \"core::integer::u128\";\n    Uint2[\"u256\"] = \"core::integer::u256\";\n    Uint2[\"u512\"] = \"core::integer::u512\";\n    return Uint2;\n})(Uint || {});\nvar Literal = /* @__PURE__ */ ((Literal2)=>{\n    Literal2[\"ClassHash\"] = \"core::starknet::class_hash::ClassHash\";\n    Literal2[\"ContractAddress\"] = \"core::starknet::contract_address::ContractAddress\";\n    Literal2[\"Secp256k1Point\"] = \"core::starknet::secp256k1::Secp256k1Point\";\n    return Literal2;\n})(Literal || {});\n// src/types/lib/contract/index.ts\nvar EntryPointType = /* @__PURE__ */ ((EntryPointType2)=>{\n    EntryPointType2[\"EXTERNAL\"] = \"EXTERNAL\";\n    EntryPointType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n    EntryPointType2[\"CONSTRUCTOR\"] = \"CONSTRUCTOR\";\n    return EntryPointType2;\n})(EntryPointType || {});\n// src/types/lib/index.ts\nvar TransactionType = /* @__PURE__ */ ((TransactionType2)=>{\n    TransactionType2[\"DECLARE\"] = \"DECLARE\";\n    TransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n    TransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n    TransactionType2[\"INVOKE\"] = \"INVOKE_FUNCTION\";\n    return TransactionType2;\n})(TransactionType || {});\nvar TransactionStatus = /* @__PURE__ */ ((TransactionStatus2)=>{\n    TransactionStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n    TransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    TransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    TransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    TransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n    TransactionStatus2[\"REVERTED\"] = \"REVERTED\";\n    return TransactionStatus2;\n})(TransactionStatus || {});\nvar TransactionFinalityStatus = /* @__PURE__ */ ((TransactionFinalityStatus2)=>{\n    TransactionFinalityStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n    TransactionFinalityStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    TransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    TransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return TransactionFinalityStatus2;\n})(TransactionFinalityStatus || {});\nvar TransactionExecutionStatus = /* @__PURE__ */ ((TransactionExecutionStatus2)=>{\n    TransactionExecutionStatus2[\"REJECTED\"] = \"REJECTED\";\n    TransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n    TransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n    return TransactionExecutionStatus2;\n})(TransactionExecutionStatus || {});\nvar BlockStatus = /* @__PURE__ */ ((BlockStatus2)=>{\n    BlockStatus2[\"PENDING\"] = \"PENDING\";\n    BlockStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    BlockStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    BlockStatus2[\"REJECTED\"] = \"REJECTED\";\n    return BlockStatus2;\n})(BlockStatus || {});\nvar BlockTag = /* @__PURE__ */ ((BlockTag2)=>{\n    BlockTag2[\"PENDING\"] = \"pending\";\n    BlockTag2[\"LATEST\"] = \"latest\";\n    return BlockTag2;\n})(BlockTag || {});\n// src/types/typedData.ts\n\n// src/utils/assert.ts\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failure\");\n    }\n}\n// src/utils/num.ts\nvar num_exports = {};\n__export(num_exports, {\n    addPercent: ()=>addPercent,\n    assertInRange: ()=>assertInRange,\n    bigNumberishArrayToDecimalStringArray: ()=>bigNumberishArrayToDecimalStringArray,\n    bigNumberishArrayToHexadecimalStringArray: ()=>bigNumberishArrayToHexadecimalStringArray,\n    cleanHex: ()=>cleanHex,\n    getDecimalString: ()=>getDecimalString,\n    getHexString: ()=>getHexString,\n    getHexStringArray: ()=>getHexStringArray,\n    hexToBytes: ()=>hexToBytes,\n    hexToDecimalString: ()=>hexToDecimalString,\n    isBigInt: ()=>isBigInt,\n    isBoolean: ()=>isBoolean,\n    isHex: ()=>isHex,\n    isNumber: ()=>isNumber,\n    isStringWholeNumber: ()=>isStringWholeNumber,\n    toBigInt: ()=>toBigInt,\n    toCairoBool: ()=>toCairoBool,\n    toHex: ()=>toHex,\n    toHexString: ()=>toHexString,\n    toStorageKey: ()=>toStorageKey\n});\n\nfunction isHex(hex) {\n    return /^0x[0-9a-f]*$/i.test(hex);\n}\nfunction toBigInt(value) {\n    return BigInt(value);\n}\nfunction isBigInt(value) {\n    return typeof value === \"bigint\";\n}\nfunction toHex(value) {\n    return addHexPrefix(toBigInt(value).toString(16));\n}\nvar toHexString = toHex;\nfunction toStorageKey(number2) {\n    return addHexPrefix(toBigInt(number2).toString(16).padStart(64, \"0\"));\n}\nfunction hexToDecimalString(hex) {\n    return BigInt(addHexPrefix(hex)).toString(10);\n}\nfunction cleanHex(hex) {\n    return hex.toLowerCase().replace(/^(0x)0+/, \"$1\");\n}\nfunction assertInRange(input, lowerBound, upperBound, inputName = \"\") {\n    const messageSuffix = inputName === \"\" ? \"invalid length\" : `invalid ${inputName} length`;\n    const inputBigInt = BigInt(input);\n    const lowerBoundBigInt = BigInt(lowerBound);\n    const upperBoundBigInt = BigInt(upperBound);\n    assert(inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt, `Message not signable, ${messageSuffix}.`);\n}\nfunction bigNumberishArrayToDecimalStringArray(data) {\n    return data.map((x)=>toBigInt(x).toString(10));\n}\nfunction bigNumberishArrayToHexadecimalStringArray(data) {\n    return data.map((x)=>toHex(x));\n}\nfunction isStringWholeNumber(str) {\n    return /^\\d+$/.test(str);\n}\nfunction getDecimalString(str) {\n    if (isHex(str)) {\n        return hexToDecimalString(str);\n    }\n    if (isStringWholeNumber(str)) {\n        return str;\n    }\n    throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\nfunction getHexString(str) {\n    if (isHex(str)) {\n        return str;\n    }\n    if (isStringWholeNumber(str)) {\n        return toHexString(str);\n    }\n    throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\nfunction getHexStringArray(array) {\n    return array.map(getHexString);\n}\nfunction toCairoBool(value) {\n    return (+value).toString();\n}\nfunction hexToBytes(str) {\n    if (!isHex(str)) throw new Error(`${str} needs to be a hex-string`);\n    let adaptedValue = removeHexPrefix(str);\n    if (adaptedValue.length % 2 !== 0) {\n        adaptedValue = `0${adaptedValue}`;\n    }\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(adaptedValue);\n}\nfunction addPercent(number2, percent) {\n    const bigIntNum = BigInt(number2);\n    return bigIntNum + bigIntNum * BigInt(percent) / 100n;\n}\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\n// src/utils/hash/selector.ts\nvar selector_exports = {};\n__export(selector_exports, {\n    getSelector: ()=>getSelector,\n    getSelectorFromName: ()=>getSelectorFromName,\n    keccakBn: ()=>keccakBn,\n    starknetKeccak: ()=>starknetKeccak\n});\n\nfunction keccakBn(value) {\n    const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n    const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n    return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\nfunction keccakHex(str) {\n    return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak)(utf8ToArray(str)).toString(16));\n}\nfunction starknetKeccak(str) {\n    const hash = BigInt(keccakHex(str));\n    return hash & MASK_250;\n}\nfunction getSelectorFromName(funcName) {\n    return toHex(starknetKeccak(funcName));\n}\nfunction getSelector(value) {\n    if (isHex(value)) {\n        return value;\n    }\n    if (isStringWholeNumber(value)) {\n        return toHexString(value);\n    }\n    return getSelectorFromName(value);\n}\n// src/utils/shortString.ts\nvar shortString_exports = {};\n__export(shortString_exports, {\n    decodeShortString: ()=>decodeShortString,\n    encodeShortString: ()=>encodeShortString,\n    isASCII: ()=>isASCII,\n    isDecimalString: ()=>isDecimalString,\n    isLongText: ()=>isLongText,\n    isShortString: ()=>isShortString,\n    isShortText: ()=>isShortText,\n    isString: ()=>isString,\n    isText: ()=>isText,\n    splitLongString: ()=>splitLongString\n});\nfunction isASCII(str) {\n    return /^[\\x00-\\x7F]*$/.test(str);\n}\nfunction isShortString(str) {\n    return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\nfunction isDecimalString(str) {\n    return /^[0-9]*$/i.test(str);\n}\nfunction isString(value) {\n    return typeof value === \"string\";\n}\nfunction isText(val) {\n    return isString(val) && !isHex(val) && !isStringWholeNumber(val);\n}\nvar isShortText = (val)=>isText(val) && isShortString(val);\nvar isLongText = (val)=>isText(val) && !isShortString(val);\nfunction splitLongString(longStr) {\n    const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, \"g\");\n    return longStr.match(regex) || [];\n}\nfunction encodeShortString(str) {\n    if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n    if (!isShortString(str)) throw new Error(`${str} is too long`);\n    return addHexPrefix(str.replace(/./g, (char)=>char.charCodeAt(0).toString(16)));\n}\nfunction decodeShortString(str) {\n    if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n    if (isHex(str)) {\n        return removeHexPrefix(str).replace(/.{2}/g, (hex)=>String.fromCharCode(parseInt(hex, 16)));\n    }\n    if (isDecimalString(str)) {\n        return decodeShortString(\"0X\".concat(BigInt(str).toString(16)));\n    }\n    throw new Error(`${str} is not Hex or decimal`);\n}\n// src/utils/calldata/byteArray.ts\nvar byteArray_exports = {};\n__export(byteArray_exports, {\n    byteArrayFromString: ()=>byteArrayFromString,\n    stringFromByteArray: ()=>stringFromByteArray\n});\nfunction stringFromByteArray(myByteArray) {\n    const pending_word = BigInt(myByteArray.pending_word) === 0n ? \"\" : decodeShortString(toHex(myByteArray.pending_word));\n    return myByteArray.data.reduce((cumuledString, encodedString)=>{\n        const add = BigInt(encodedString) === 0n ? \"\" : decodeShortString(toHex(encodedString));\n        return cumuledString + add;\n    }, \"\") + pending_word;\n}\nfunction byteArrayFromString(targetString) {\n    const shortStrings = splitLongString(targetString);\n    const remainder = shortStrings[shortStrings.length - 1];\n    const shortStringsEncoded = shortStrings.map(encodeShortString);\n    const [pendingWord, pendingWordLength] = remainder === void 0 || remainder.length === 31 ? [\n        \"0x00\",\n        0\n    ] : [\n        shortStringsEncoded.pop(),\n        remainder.length\n    ];\n    return {\n        data: shortStringsEncoded.length === 0 ? [] : shortStringsEncoded,\n        pending_word: pendingWord,\n        pending_word_len: pendingWordLength\n    };\n}\n// src/utils/calldata/cairo.ts\nvar cairo_exports = {};\n__export(cairo_exports, {\n    felt: ()=>felt,\n    getAbiContractVersion: ()=>getAbiContractVersion,\n    getArrayType: ()=>getArrayType,\n    isCairo1Abi: ()=>isCairo1Abi,\n    isCairo1Type: ()=>isCairo1Type,\n    isLen: ()=>isLen,\n    isTypeArray: ()=>isTypeArray,\n    isTypeBool: ()=>isTypeBool,\n    isTypeByteArray: ()=>isTypeByteArray,\n    isTypeBytes31: ()=>isTypeBytes31,\n    isTypeContractAddress: ()=>isTypeContractAddress,\n    isTypeEnum: ()=>isTypeEnum,\n    isTypeEthAddress: ()=>isTypeEthAddress,\n    isTypeFelt: ()=>isTypeFelt,\n    isTypeLiteral: ()=>isTypeLiteral,\n    isTypeNamedTuple: ()=>isTypeNamedTuple,\n    isTypeNonZero: ()=>isTypeNonZero,\n    isTypeOption: ()=>isTypeOption,\n    isTypeResult: ()=>isTypeResult,\n    isTypeSecp256k1Point: ()=>isTypeSecp256k1Point,\n    isTypeStruct: ()=>isTypeStruct,\n    isTypeTuple: ()=>isTypeTuple,\n    isTypeUint: ()=>isTypeUint,\n    isTypeUint256: ()=>isTypeUint256,\n    tuple: ()=>tuple,\n    uint256: ()=>uint256,\n    uint512: ()=>uint512\n});\n// src/utils/cairoDataTypes/felt.ts\nfunction CairoFelt(it) {\n    if (isBigInt(it) || Number.isInteger(it)) {\n        return it.toString();\n    }\n    if (isString(it)) {\n        if (isHex(it)) {\n            return BigInt(it).toString();\n        }\n        if (isText(it)) {\n            if (!isShortString(it)) {\n                throw new Error(`${it} is a long string > 31 chars. Please split it into an array of short strings.`);\n            }\n            return BigInt(encodeShortString(it)).toString();\n        }\n        if (isStringWholeNumber(it)) {\n            return it;\n        }\n    }\n    if (isBoolean(it)) {\n        return `${+it}`;\n    }\n    throw new Error(`${it} can't be computed by felt()`);\n}\n// src/utils/cairoDataTypes/uint256.ts\nvar UINT_128_MAX = (1n << 128n) - 1n;\nvar UINT_256_MAX = (1n << 256n) - 1n;\nvar UINT_256_MIN = 0n;\nvar UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;\nvar UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;\nvar UINT_256_LOW_MIN = 0n;\nvar UINT_256_HIGH_MIN = 0n;\nvar CairoUint256 = class _CairoUint256 {\n    static{\n        this.abiSelector = \"core::integer::u256\";\n    }\n    constructor(...arr){\n        if (typeof arr[0] === \"object\" && arr.length === 1 && \"low\" in arr[0] && \"high\" in arr[0]) {\n            const props = _CairoUint256.validateProps(arr[0].low, arr[0].high);\n            this.low = props.low;\n            this.high = props.high;\n        } else if (arr.length === 1) {\n            const bigInt = _CairoUint256.validate(arr[0]);\n            this.low = bigInt & UINT_128_MAX;\n            this.high = bigInt >> 128n;\n        } else if (arr.length === 2) {\n            const props = _CairoUint256.validateProps(arr[0], arr[1]);\n            this.low = props.low;\n            this.high = props.high;\n        } else {\n            throw Error(\"Incorrect constructor parameters\");\n        }\n    }\n    /**\n   * Validate if BigNumberish can be represented as Unit256\n   */ static validate(bigNumberish) {\n        const bigInt = BigInt(bigNumberish);\n        if (bigInt < UINT_256_MIN) throw Error(\"bigNumberish is smaller than UINT_256_MIN\");\n        if (bigInt > UINT_256_MAX) throw new Error(\"bigNumberish is bigger than UINT_256_MAX\");\n        return bigInt;\n    }\n    /**\n   * Validate if low and high can be represented as Unit256\n   */ static validateProps(low, high) {\n        const bigIntLow = BigInt(low);\n        const bigIntHigh = BigInt(high);\n        if (bigIntLow < UINT_256_LOW_MIN || bigIntLow > UINT_256_LOW_MAX) {\n            throw new Error(\"low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX\");\n        }\n        if (bigIntHigh < UINT_256_HIGH_MIN || bigIntHigh > UINT_256_HIGH_MAX) {\n            throw new Error(\"high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX\");\n        }\n        return {\n            low: bigIntLow,\n            high: bigIntHigh\n        };\n    }\n    /**\n   * Check if BigNumberish can be represented as Unit256\n   */ static is(bigNumberish) {\n        try {\n            _CairoUint256.validate(bigNumberish);\n        } catch (error) {\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Check if provided abi type is this data type\n   */ static isAbiType(abiType) {\n        return abiType === _CairoUint256.abiSelector;\n    }\n    /**\n   * Return bigint representation\n   */ toBigInt() {\n        return (this.high << 128n) + this.low;\n    }\n    /**\n   * Return Uint256 structure with HexString props\n   * {low: HexString, high: HexString}\n   */ toUint256HexString() {\n        return {\n            low: addHexPrefix(this.low.toString(16)),\n            high: addHexPrefix(this.high.toString(16))\n        };\n    }\n    /**\n   * Return Uint256 structure with DecimalString props\n   * {low: DecString, high: DecString}\n   */ toUint256DecimalString() {\n        return {\n            low: this.low.toString(10),\n            high: this.high.toString(10)\n        };\n    }\n    /**\n   * Return api requests representation witch is felt array\n   */ toApiRequest() {\n        return [\n            CairoFelt(this.low),\n            CairoFelt(this.high)\n        ];\n    }\n};\n// src/utils/cairoDataTypes/uint512.ts\nvar UINT_512_MAX = (1n << 512n) - 1n;\nvar UINT_512_MIN = 0n;\nvar UINT_128_MIN = 0n;\nvar CairoUint512 = class _CairoUint512 {\n    static{\n        this.abiSelector = \"core::integer::u512\";\n    }\n    constructor(...arr){\n        if (typeof arr[0] === \"object\" && arr.length === 1 && \"limb0\" in arr[0] && \"limb1\" in arr[0] && \"limb2\" in arr[0] && \"limb3\" in arr[0]) {\n            const props = _CairoUint512.validateProps(arr[0].limb0, arr[0].limb1, arr[0].limb2, arr[0].limb3);\n            this.limb0 = props.limb0;\n            this.limb1 = props.limb1;\n            this.limb2 = props.limb2;\n            this.limb3 = props.limb3;\n        } else if (arr.length === 1) {\n            const bigInt = _CairoUint512.validate(arr[0]);\n            this.limb0 = bigInt & UINT_128_MAX;\n            this.limb1 = (bigInt & UINT_128_MAX << 128n) >> 128n;\n            this.limb2 = (bigInt & UINT_128_MAX << 256n) >> 256n;\n            this.limb3 = bigInt >> 384n;\n        } else if (arr.length === 4) {\n            const props = _CairoUint512.validateProps(arr[0], arr[1], arr[2], arr[3]);\n            this.limb0 = props.limb0;\n            this.limb1 = props.limb1;\n            this.limb2 = props.limb2;\n            this.limb3 = props.limb3;\n        } else {\n            throw Error(\"Incorrect Uint512 constructor parameters\");\n        }\n    }\n    /**\n   * Validate if BigNumberish can be represented as Uint512\n   */ static validate(bigNumberish) {\n        const bigInt = BigInt(bigNumberish);\n        if (bigInt < UINT_512_MIN) throw Error(\"bigNumberish is smaller than UINT_512_MIN.\");\n        if (bigInt > UINT_512_MAX) throw Error(\"bigNumberish is bigger than UINT_512_MAX.\");\n        return bigInt;\n    }\n    /**\n   * Validate if limbs can be represented as Uint512\n   */ static validateProps(limb0, limb1, limb2, limb3) {\n        const l0 = BigInt(limb0);\n        const l1 = BigInt(limb1);\n        const l2 = BigInt(limb2);\n        const l3 = BigInt(limb3);\n        [\n            l0,\n            l1,\n            l2,\n            l3\n        ].forEach((value, index)=>{\n            if (value < UINT_128_MIN || value > UINT_128_MAX) {\n                throw Error(`limb${index} is not in the range of a u128 number`);\n            }\n        });\n        return {\n            limb0: l0,\n            limb1: l1,\n            limb2: l2,\n            limb3: l3\n        };\n    }\n    /**\n   * Check if BigNumberish can be represented as Uint512\n   */ static is(bigNumberish) {\n        try {\n            _CairoUint512.validate(bigNumberish);\n        } catch (error) {\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Check if provided abi type is this data type\n   */ static isAbiType(abiType) {\n        return abiType === _CairoUint512.abiSelector;\n    }\n    /**\n   * Return bigint representation\n   */ toBigInt() {\n        return (this.limb3 << 384n) + (this.limb2 << 256n) + (this.limb1 << 128n) + this.limb0;\n    }\n    /**\n   * Return Uint512 structure with HexString props\n   * limbx: HexString\n   */ toUint512HexString() {\n        return {\n            limb0: addHexPrefix(this.limb0.toString(16)),\n            limb1: addHexPrefix(this.limb1.toString(16)),\n            limb2: addHexPrefix(this.limb2.toString(16)),\n            limb3: addHexPrefix(this.limb3.toString(16))\n        };\n    }\n    /**\n   * Return Uint512 structure with DecimalString props\n   * limbx DecString\n   */ toUint512DecimalString() {\n        return {\n            limb0: this.limb0.toString(10),\n            limb1: this.limb1.toString(10),\n            limb2: this.limb2.toString(10),\n            limb3: this.limb3.toString(10)\n        };\n    }\n    /**\n   * Return api requests representation witch is felt array\n   */ toApiRequest() {\n        return [\n            CairoFelt(this.limb0),\n            CairoFelt(this.limb1),\n            CairoFelt(this.limb2),\n            CairoFelt(this.limb3)\n        ];\n    }\n};\n// src/utils/calldata/cairo.ts\nvar isLen = (name)=>/_len$/.test(name);\nvar isTypeFelt = (type)=>type === \"felt\" || type === \"core::felt252\";\nvar isTypeArray = (type)=>/\\*/.test(type) || type.startsWith(\"core::array::Array::\") || type.startsWith(\"core::array::Span::\");\nvar isTypeTuple = (type)=>/^\\(.*\\)$/i.test(type);\nvar isTypeNamedTuple = (type)=>/\\(.*\\)/i.test(type) && type.includes(\":\");\nvar isTypeStruct = (type, structs)=>type in structs;\nvar isTypeEnum = (type, enums)=>type in enums;\nvar isTypeOption = (type)=>type.startsWith(\"core::option::Option::\");\nvar isTypeResult = (type)=>type.startsWith(\"core::result::Result::\");\nvar isTypeUint = (type)=>Object.values(Uint).includes(type);\nvar isTypeUint256 = (type)=>CairoUint256.isAbiType(type);\nvar isTypeLiteral = (type)=>Object.values(Literal).includes(type);\nvar isTypeBool = (type)=>type === \"core::bool\";\nvar isTypeContractAddress = (type)=>type === \"core::starknet::contract_address::ContractAddress\";\nvar isTypeEthAddress = (type)=>type === \"core::starknet::eth_address::EthAddress\";\nvar isTypeBytes31 = (type)=>type === \"core::bytes_31::bytes31\";\nvar isTypeByteArray = (type)=>type === \"core::byte_array::ByteArray\";\nvar isTypeSecp256k1Point = (type)=>type === \"core::starknet::secp256k1::Secp256k1Point\";\nvar isCairo1Type = (type)=>type.includes(\"::\");\nvar getArrayType = (type)=>{\n    if (isCairo1Type(type)) {\n        return type.substring(type.indexOf(\"<\") + 1, type.lastIndexOf(\">\"));\n    }\n    return type.replace(\"*\", \"\");\n};\nfunction isCairo1Abi(abi) {\n    const { cairo } = getAbiContractVersion(abi);\n    if (cairo === void 0) {\n        throw Error(\"Unable to determine Cairo version\");\n    }\n    return cairo === \"1\";\n}\nfunction isTypeNonZero(type) {\n    return type.startsWith(\"core::zeroable::NonZero::\");\n}\nfunction getAbiContractVersion(abi) {\n    if (abi.find((it)=>it.type === \"interface\")) {\n        return {\n            cairo: \"1\",\n            compiler: \"2\"\n        };\n    }\n    const testFunction = abi.find((it)=>it.type === \"function\" && (it.inputs.length || it.outputs.length));\n    if (!testFunction) {\n        return {\n            cairo: void 0,\n            compiler: void 0\n        };\n    }\n    const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;\n    if (isCairo1Type(io[0].type)) {\n        return {\n            cairo: \"1\",\n            compiler: \"1\"\n        };\n    }\n    return {\n        cairo: \"0\",\n        compiler: \"0\"\n    };\n}\nvar uint256 = (it)=>{\n    return new CairoUint256(it).toUint256DecimalString();\n};\nvar uint512 = (it)=>{\n    return new CairoUint512(it).toUint512DecimalString();\n};\nvar tuple = (...args)=>({\n        ...args\n    });\nfunction felt(it) {\n    return CairoFelt(it);\n}\n// src/utils/calldata/enum/CairoCustomEnum.ts\nvar CairoCustomEnum = class {\n    /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */ constructor(enumContent){\n        const variantsList = Object.values(enumContent);\n        if (variantsList.length === 0) {\n            throw new Error(\"This Enum must have at least 1 variant\");\n        }\n        const nbActiveVariants = variantsList.filter((content)=>typeof content !== \"undefined\").length;\n        if (nbActiveVariants !== 1) {\n            throw new Error(\"This Enum must have exactly one active variant\");\n        }\n        this.variant = enumContent;\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */ unwrap() {\n        const variants = Object.entries(this.variant);\n        const activeVariant = variants.find((item)=>typeof item[1] !== \"undefined\");\n        if (typeof activeVariant === \"undefined\") {\n            return void 0;\n        }\n        return activeVariant[1];\n    }\n    /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */ activeVariant() {\n        const variants = Object.entries(this.variant);\n        const activeVariant = variants.find((item)=>typeof item[1] !== \"undefined\");\n        if (typeof activeVariant === \"undefined\") {\n            return \"\";\n        }\n        return activeVariant[0];\n    }\n};\n// src/utils/calldata/enum/CairoOption.ts\nvar CairoOptionVariant = /* @__PURE__ */ ((CairoOptionVariant2)=>{\n    CairoOptionVariant2[CairoOptionVariant2[\"Some\"] = 0] = \"Some\";\n    CairoOptionVariant2[CairoOptionVariant2[\"None\"] = 1] = \"None\";\n    return CairoOptionVariant2;\n})(CairoOptionVariant || {});\nvar CairoOption = class {\n    constructor(variant, someContent){\n        if (!(variant in CairoOptionVariant)) {\n            throw new Error(\"Wrong variant : should be CairoOptionVariant.Some or .None.\");\n        }\n        if (variant === 0 /* Some */ ) {\n            if (typeof someContent === \"undefined\") {\n                throw new Error('The creation of a Cairo Option with \"Some\" variant needs a content as input.');\n            }\n            this.Some = someContent;\n            this.None = void 0;\n        } else {\n            this.Some = void 0;\n            this.None = true;\n        }\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */ unwrap() {\n        if (this.None) {\n            return void 0;\n        }\n        return this.Some;\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */ isSome() {\n        return !(typeof this.Some === \"undefined\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */ isNone() {\n        return this.None === true;\n    }\n};\n// src/utils/calldata/enum/CairoResult.ts\nvar CairoResultVariant = /* @__PURE__ */ ((CairoResultVariant2)=>{\n    CairoResultVariant2[CairoResultVariant2[\"Ok\"] = 0] = \"Ok\";\n    CairoResultVariant2[CairoResultVariant2[\"Err\"] = 1] = \"Err\";\n    return CairoResultVariant2;\n})(CairoResultVariant || {});\nvar CairoResult = class {\n    constructor(variant, resultContent){\n        if (!(variant in CairoResultVariant)) {\n            throw new Error(\"Wrong variant : should be CairoResultVariant.Ok or .Err.\");\n        }\n        if (variant === 0 /* Ok */ ) {\n            this.Ok = resultContent;\n            this.Err = void 0;\n        } else {\n            this.Ok = void 0;\n            this.Err = resultContent;\n        }\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */ unwrap() {\n        if (typeof this.Ok !== \"undefined\") {\n            return this.Ok;\n        }\n        if (typeof this.Err !== \"undefined\") {\n            return this.Err;\n        }\n        throw new Error(\"Both Result.Ok and .Err are undefined. Not authorized.\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */ isOk() {\n        return !(typeof this.Ok === \"undefined\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */ isErr() {\n        return !(typeof this.Err === \"undefined\");\n    }\n};\n// src/utils/calldata/formatter.ts\nvar guard = {\n    isBN: (data, type, key)=>{\n        if (!isBigInt(data[key])) throw new Error(`Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`);\n    },\n    unknown: (data, type, key)=>{\n        throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n    }\n};\nfunction formatter(data, type, sameType) {\n    return Object.entries(data).reduce((acc, [key, value])=>{\n        const elType = sameType ?? type[key];\n        if (!(key in type) && !sameType) {\n            acc[key] = value;\n            return acc;\n        }\n        if (elType === \"string\") {\n            if (Array.isArray(data[key])) {\n                const arrayStr = formatter(data[key], data[key].map((_)=>elType));\n                acc[key] = Object.values(arrayStr).join(\"\");\n                return acc;\n            }\n            guard.isBN(data, type, key);\n            acc[key] = decodeShortString(value);\n            return acc;\n        }\n        if (elType === \"number\") {\n            guard.isBN(data, type, key);\n            acc[key] = Number(value);\n            return acc;\n        }\n        if (typeof elType === \"function\") {\n            acc[key] = elType(value);\n            return acc;\n        }\n        if (Array.isArray(elType)) {\n            const arrayObj = formatter(data[key], elType, elType[0]);\n            acc[key] = Object.values(arrayObj);\n            return acc;\n        }\n        if (typeof elType === \"object\") {\n            acc[key] = formatter(data[key], elType);\n            return acc;\n        }\n        guard.unknown(data, type, key);\n        return acc;\n    }, {});\n}\n// src/utils/calldata/parser/parser-0-1.1.0.ts\nvar AbiParser1 = class {\n    constructor(abi){\n        this.abi = abi;\n    }\n    /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */ methodInputsLength(abiMethod) {\n        return abiMethod.inputs.reduce((acc, input)=>!isLen(input.name) ? acc + 1 : acc, 0);\n    }\n    /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */ getMethod(name) {\n        return this.abi.find((it)=>it.name === name);\n    }\n    /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */ getLegacyFormat() {\n        return this.abi;\n    }\n};\n// src/utils/calldata/parser/parser-2.0.0.ts\nvar AbiParser2 = class {\n    constructor(abi){\n        this.abi = abi;\n    }\n    /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */ methodInputsLength(abiMethod) {\n        return abiMethod.inputs.length;\n    }\n    /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */ getMethod(name) {\n        const intf = this.abi.find((it)=>it.type === \"interface\");\n        return intf.items.find((it)=>it.name === name);\n    }\n    /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */ getLegacyFormat() {\n        return this.abi.flatMap((e)=>{\n            if (e.type === \"interface\") {\n                return e.items;\n            }\n            return e;\n        });\n    }\n};\n// src/utils/calldata/parser/index.ts\nfunction createAbiParser(abi) {\n    const version = getAbiVersion(abi);\n    if (version === 0 || version === 1) {\n        return new AbiParser1(abi);\n    }\n    if (version === 2) {\n        return new AbiParser2(abi);\n    }\n    throw Error(`Unsupported ABI version ${version}`);\n}\nfunction getAbiVersion(abi) {\n    if (abi.find((it)=>it.type === \"interface\")) return 2;\n    if (isCairo1Abi(abi)) return 1;\n    return 0;\n}\nfunction isNoConstructorValid(method, argsCalldata, abiMethod) {\n    return method === \"constructor\" && !abiMethod && !argsCalldata.length;\n}\n// src/utils/calldata/tuple.ts\nfunction parseNamedTuple(namedTuple) {\n    const name = namedTuple.substring(0, namedTuple.indexOf(\":\"));\n    const type = namedTuple.substring(name.length + \":\".length);\n    return {\n        name,\n        type\n    };\n}\nfunction parseSubTuple(s) {\n    if (!s.includes(\"(\")) return {\n        subTuple: [],\n        result: s\n    };\n    const subTuple = [];\n    let result = \"\";\n    let i = 0;\n    while(i < s.length){\n        if (s[i] === \"(\") {\n            let counter = 1;\n            const lBracket = i;\n            i++;\n            while(counter){\n                if (s[i] === \")\") counter--;\n                if (s[i] === \"(\") counter++;\n                i++;\n            }\n            subTuple.push(s.substring(lBracket, i));\n            result += \" \";\n            i--;\n        } else {\n            result += s[i];\n        }\n        i++;\n    }\n    return {\n        subTuple,\n        result\n    };\n}\nfunction extractCairo0Tuple(type) {\n    const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n    const { subTuple, result } = parseSubTuple(cleanType);\n    let recomposed = result.split(\",\").map((it)=>{\n        return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n    });\n    if (isTypeNamedTuple(type)) {\n        recomposed = recomposed.reduce((acc, it)=>{\n            return acc.concat(parseNamedTuple(it));\n        }, []);\n    }\n    return recomposed;\n}\nfunction getClosureOffset(input, open, close) {\n    for(let i = 0, counter = 0; i < input.length; i++){\n        if (input[i] === open) {\n            counter++;\n        } else if (input[i] === close && --counter === 0) {\n            return i;\n        }\n    }\n    return Number.POSITIVE_INFINITY;\n}\nfunction extractCairo1Tuple(type) {\n    const input = type.slice(1, -1);\n    const result = [];\n    let currentIndex = 0;\n    let limitIndex;\n    while(currentIndex < input.length){\n        switch(true){\n            case input[currentIndex] === \"(\":\n                {\n                    limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), \"(\", \")\") + 1;\n                    break;\n                }\n            case input.startsWith(\"core::result::Result::<\", currentIndex) || input.startsWith(\"core::array::Array::<\", currentIndex) || input.startsWith(\"core::option::Option::<\", currentIndex):\n                {\n                    limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), \"<\", \">\") + 1;\n                    break;\n                }\n            default:\n                {\n                    const commaIndex = input.indexOf(\",\", currentIndex);\n                    limitIndex = commaIndex !== -1 ? commaIndex : Number.POSITIVE_INFINITY;\n                }\n        }\n        result.push(input.slice(currentIndex, limitIndex));\n        currentIndex = limitIndex + 2;\n    }\n    return result;\n}\nfunction extractTupleMemberTypes(type) {\n    if (isCairo1Type(type)) {\n        return extractCairo1Tuple(type);\n    }\n    return extractCairo0Tuple(type);\n}\n// src/utils/calldata/propertyOrder.ts\nfunction errorU256(key) {\n    return Error(`Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`);\n}\nfunction errorU512(key) {\n    return Error(`Your object includes the property : ${key}, containing an Uint512 object without the 'limb0' to 'limb3' keys.`);\n}\nfunction orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {\n    const orderInput = (unorderedItem, abiType)=>{\n        if (isTypeArray(abiType)) {\n            return orderArray(unorderedItem, abiType);\n        }\n        if (isTypeEnum(abiType, enums)) {\n            const abiObj = enums[abiType];\n            return orderEnum(unorderedItem, abiObj);\n        }\n        if (isTypeTuple(abiType)) {\n            return orderTuple(unorderedItem, abiType);\n        }\n        if (isTypeEthAddress(abiType)) {\n            return unorderedItem;\n        }\n        if (isTypeNonZero(abiType)) {\n            return unorderedItem;\n        }\n        if (isTypeByteArray(abiType)) {\n            return unorderedItem;\n        }\n        if (isTypeSecp256k1Point(abiType)) {\n            return unorderedItem;\n        }\n        if (CairoUint256.isAbiType(abiType)) {\n            const u256 = unorderedItem;\n            if (typeof u256 !== \"object\") {\n                return u256;\n            }\n            if (!(\"low\" in u256 && \"high\" in u256)) {\n                throw errorU256(abiType);\n            }\n            return {\n                low: u256.low,\n                high: u256.high\n            };\n        }\n        if (CairoUint512.isAbiType(abiType)) {\n            const u512 = unorderedItem;\n            if (typeof u512 !== \"object\") {\n                return u512;\n            }\n            if (![\n                \"limb0\",\n                \"limb1\",\n                \"limb2\",\n                \"limb3\"\n            ].every((key)=>key in u512)) {\n                throw errorU512(abiType);\n            }\n            return {\n                limb0: u512.limb0,\n                limb1: u512.limb1,\n                limb2: u512.limb2,\n                limb3: u512.limb3\n            };\n        }\n        if (isTypeStruct(abiType, structs)) {\n            const abiOfStruct = structs[abiType].members;\n            return orderStruct(unorderedItem, abiOfStruct);\n        }\n        return unorderedItem;\n    };\n    const orderStruct = (unorderedObject2, abiObject)=>{\n        const orderedObject2 = abiObject.reduce((orderedObject, abiParam)=>{\n            const setProperty = (value)=>Object.defineProperty(orderedObject, abiParam.name, {\n                    enumerable: true,\n                    value: value ?? unorderedObject2[abiParam.name]\n                });\n            if (unorderedObject2[abiParam.name] === \"undefined\") {\n                if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n                    throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n                }\n            }\n            setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n            return orderedObject;\n        }, {});\n        return orderedObject2;\n    };\n    function orderArray(myArray, abiParam) {\n        const typeInArray = getArrayType(abiParam);\n        if (isString(myArray)) {\n            return myArray;\n        }\n        return myArray.map((myElem)=>orderInput(myElem, typeInArray));\n    }\n    function orderTuple(unorderedObject2, abiParam) {\n        const typeList = extractTupleMemberTypes(abiParam);\n        const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index)=>{\n            const myObjKeys = Object.keys(unorderedObject2);\n            const setProperty = (value)=>Object.defineProperty(orderedObject, index.toString(), {\n                    enumerable: true,\n                    value: value ?? unorderedObject2[myObjKeys[index]]\n                });\n            const abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;\n            setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n            return orderedObject;\n        }, {});\n        return orderedObject2;\n    }\n    const orderEnum = (unorderedObject2, abiObject)=>{\n        if (isTypeResult(abiObject.name)) {\n            const unorderedResult = unorderedObject2;\n            const resultOkType = abiObject.name.substring(abiObject.name.indexOf(\"<\") + 1, abiObject.name.lastIndexOf(\",\"));\n            const resultErrType = abiObject.name.substring(abiObject.name.indexOf(\",\") + 1, abiObject.name.lastIndexOf(\">\"));\n            if (unorderedResult.isOk()) {\n                return new CairoResult(0 /* Ok */ , orderInput(unorderedObject2.unwrap(), resultOkType));\n            }\n            return new CairoResult(1 /* Err */ , orderInput(unorderedObject2.unwrap(), resultErrType));\n        }\n        if (isTypeOption(abiObject.name)) {\n            const unorderedOption = unorderedObject2;\n            const resultSomeType = abiObject.name.substring(abiObject.name.indexOf(\"<\") + 1, abiObject.name.lastIndexOf(\">\"));\n            if (unorderedOption.isSome()) {\n                return new CairoOption(0 /* Some */ , orderInput(unorderedOption.unwrap(), resultSomeType));\n            }\n            return new CairoOption(1 /* None */ , {});\n        }\n        const unorderedCustomEnum = unorderedObject2;\n        const variants = Object.entries(unorderedCustomEnum.variant);\n        const newEntries = variants.map((variant)=>{\n            if (typeof variant[1] === \"undefined\") {\n                return variant;\n            }\n            const variantType = abiObject.type.substring(abiObject.type.lastIndexOf(\"<\") + 1, abiObject.type.lastIndexOf(\">\"));\n            if (variantType === \"()\") {\n                return variant;\n            }\n            return [\n                variant[0],\n                orderInput(unorderedCustomEnum.unwrap(), variantType)\n            ];\n        });\n        return new CairoCustomEnum(Object.fromEntries(newEntries));\n    };\n    const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam)=>{\n        const setProperty = (value)=>Object.defineProperty(orderedObject, abiParam.name, {\n                enumerable: true,\n                value\n            });\n        if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n            return orderedObject;\n        }\n        setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n        return orderedObject;\n    }, {});\n    return finalOrderedObject;\n}\n// src/utils/calldata/requestParser.ts\nfunction parseBaseTypes(type, val) {\n    switch(true){\n        case CairoUint256.isAbiType(type):\n            return new CairoUint256(val).toApiRequest();\n        case CairoUint512.isAbiType(type):\n            return new CairoUint512(val).toApiRequest();\n        case isTypeBytes31(type):\n            return encodeShortString(val.toString());\n        case isTypeSecp256k1Point(type):\n            {\n                const pubKeyETH = removeHexPrefix(toHex(val)).padStart(128, \"0\");\n                const pubKeyETHy = uint256(addHexPrefix(pubKeyETH.slice(-64)));\n                const pubKeyETHx = uint256(addHexPrefix(pubKeyETH.slice(0, -64)));\n                return [\n                    felt(pubKeyETHx.low),\n                    felt(pubKeyETHx.high),\n                    felt(pubKeyETHy.low),\n                    felt(pubKeyETHy.high)\n                ];\n            }\n        default:\n            return felt(val);\n    }\n}\nfunction parseTuple(element, typeStr) {\n    const memberTypes = extractTupleMemberTypes(typeStr);\n    const elements = Object.values(element);\n    if (elements.length !== memberTypes.length) {\n        throw Error(`ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`);\n    }\n    return memberTypes.map((it, dx)=>{\n        return {\n            element: elements[dx],\n            type: it.type ?? it\n        };\n    });\n}\nfunction parseByteArray(element) {\n    const myByteArray = byteArrayFromString(element);\n    return [\n        myByteArray.data.length.toString(),\n        ...myByteArray.data.map((bn)=>bn.toString()),\n        myByteArray.pending_word.toString(),\n        myByteArray.pending_word_len.toString()\n    ];\n}\nfunction parseCalldataValue(element, type, structs, enums) {\n    if (element === void 0) {\n        throw Error(`Missing parameter for type ${type}`);\n    }\n    if (Array.isArray(element)) {\n        const result = [];\n        result.push(felt(element.length));\n        const arrayType = getArrayType(type);\n        return element.reduce((acc, it)=>{\n            return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n        }, result);\n    }\n    if (structs[type] && structs[type].members.length) {\n        if (CairoUint256.isAbiType(type)) {\n            return new CairoUint256(element).toApiRequest();\n        }\n        if (CairoUint512.isAbiType(type)) {\n            return new CairoUint512(element).toApiRequest();\n        }\n        if (type === \"core::starknet::eth_address::EthAddress\") return parseBaseTypes(type, element);\n        if (type === \"core::byte_array::ByteArray\") return parseByteArray(element);\n        const { members } = structs[type];\n        const subElement = element;\n        return members.reduce((acc, it)=>{\n            return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n        }, []);\n    }\n    if (isTypeTuple(type)) {\n        const tupled = parseTuple(element, type);\n        return tupled.reduce((acc, it)=>{\n            const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n            return acc.concat(parsedData);\n        }, []);\n    }\n    if (CairoUint256.isAbiType(type)) {\n        return new CairoUint256(element).toApiRequest();\n    }\n    if (CairoUint512.isAbiType(type)) {\n        return new CairoUint512(element).toApiRequest();\n    }\n    if (isTypeEnum(type, enums)) {\n        const { variants } = enums[type];\n        if (isTypeOption(type)) {\n            const myOption = element;\n            if (myOption.isSome()) {\n                const listTypeVariant2 = variants.find((variant)=>variant.name === \"Some\");\n                if (typeof listTypeVariant2 === \"undefined\") {\n                    throw Error(`Error in abi : Option has no 'Some' variant.`);\n                }\n                const typeVariantSome = listTypeVariant2.type;\n                if (typeVariantSome === \"()\") {\n                    return 0..toString();\n                }\n                const parsedParameter2 = parseCalldataValue(myOption.unwrap(), typeVariantSome, structs, enums);\n                if (Array.isArray(parsedParameter2)) {\n                    return [\n                        0..toString(),\n                        ...parsedParameter2\n                    ];\n                }\n                return [\n                    0..toString(),\n                    parsedParameter2\n                ];\n            }\n            return 1..toString();\n        }\n        if (isTypeResult(type)) {\n            const myResult = element;\n            if (myResult.isOk()) {\n                const listTypeVariant3 = variants.find((variant)=>variant.name === \"Ok\");\n                if (typeof listTypeVariant3 === \"undefined\") {\n                    throw Error(`Error in abi : Result has no 'Ok' variant.`);\n                }\n                const typeVariantOk = listTypeVariant3.type;\n                if (typeVariantOk === \"()\") {\n                    return 0..toString();\n                }\n                const parsedParameter3 = parseCalldataValue(myResult.unwrap(), typeVariantOk, structs, enums);\n                if (Array.isArray(parsedParameter3)) {\n                    return [\n                        0..toString(),\n                        ...parsedParameter3\n                    ];\n                }\n                return [\n                    0..toString(),\n                    parsedParameter3\n                ];\n            }\n            const listTypeVariant2 = variants.find((variant)=>variant.name === \"Err\");\n            if (typeof listTypeVariant2 === \"undefined\") {\n                throw Error(`Error in abi : Result has no 'Err' variant.`);\n            }\n            const typeVariantErr = listTypeVariant2.type;\n            if (typeVariantErr === \"()\") {\n                return 1..toString();\n            }\n            const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n            if (Array.isArray(parsedParameter2)) {\n                return [\n                    1..toString(),\n                    ...parsedParameter2\n                ];\n            }\n            return [\n                1..toString(),\n                parsedParameter2\n            ];\n        }\n        const myEnum = element;\n        const activeVariant = myEnum.activeVariant();\n        const listTypeVariant = variants.find((variant)=>variant.name === activeVariant);\n        if (typeof listTypeVariant === \"undefined\") {\n            throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n        }\n        const typeActiveVariant = listTypeVariant.type;\n        const numActiveVariant = variants.findIndex((variant)=>variant.name === activeVariant);\n        if (typeActiveVariant === \"()\") {\n            return numActiveVariant.toString();\n        }\n        const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n        if (Array.isArray(parsedParameter)) {\n            return [\n                numActiveVariant.toString(),\n                ...parsedParameter\n            ];\n        }\n        return [\n            numActiveVariant.toString(),\n            parsedParameter\n        ];\n    }\n    if (isTypeNonZero(type)) {\n        return parseBaseTypes(getArrayType(type), element);\n    }\n    if (typeof element === \"object\") {\n        throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n    }\n    return parseBaseTypes(type, element);\n}\nfunction parseCalldataField(argsIterator, input, structs, enums) {\n    const { name, type } = input;\n    let { value } = argsIterator.next();\n    switch(true){\n        case isTypeArray(type):\n            if (!Array.isArray(value) && !isText(value)) {\n                throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n            }\n            if (isString(value)) {\n                value = splitLongString(value);\n            }\n            return parseCalldataValue(value, input.type, structs, enums);\n        case isTypeNonZero(type):\n            return parseBaseTypes(getArrayType(type), value);\n        case type === \"core::starknet::eth_address::EthAddress\":\n            return parseBaseTypes(type, value);\n        case isTypeStruct(type, structs) || isTypeTuple(type) || CairoUint256.isAbiType(type) || CairoUint256.isAbiType(type):\n            return parseCalldataValue(value, type, structs, enums);\n        case isTypeEnum(type, enums):\n            return parseCalldataValue(value, type, structs, enums);\n        default:\n            return parseBaseTypes(type, value);\n    }\n}\n// src/utils/calldata/responseParser.ts\nfunction parseBaseTypes2(type, it) {\n    let temp;\n    switch(true){\n        case isTypeBool(type):\n            temp = it.next().value;\n            return Boolean(BigInt(temp));\n        case CairoUint256.isAbiType(type):\n            const low = it.next().value;\n            const high = it.next().value;\n            return new CairoUint256(low, high).toBigInt();\n        case CairoUint512.isAbiType(type):\n            const limb0 = it.next().value;\n            const limb1 = it.next().value;\n            const limb2 = it.next().value;\n            const limb3 = it.next().value;\n            return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n        case type === \"core::starknet::eth_address::EthAddress\":\n            temp = it.next().value;\n            return BigInt(temp);\n        case type === \"core::bytes_31::bytes31\":\n            temp = it.next().value;\n            return decodeShortString(temp);\n        case isTypeSecp256k1Point(type):\n            const xLow = removeHexPrefix(it.next().value).padStart(32, \"0\");\n            const xHigh = removeHexPrefix(it.next().value).padStart(32, \"0\");\n            const yLow = removeHexPrefix(it.next().value).padStart(32, \"0\");\n            const yHigh = removeHexPrefix(it.next().value).padStart(32, \"0\");\n            const pubK = BigInt(addHexPrefix(xHigh + xLow + yHigh + yLow));\n            return pubK;\n        default:\n            temp = it.next().value;\n            return BigInt(temp);\n    }\n}\nfunction parseResponseValue(responseIterator, element, structs, enums) {\n    if (element.type === \"()\") {\n        return {};\n    }\n    if (CairoUint256.isAbiType(element.type)) {\n        const low = responseIterator.next().value;\n        const high = responseIterator.next().value;\n        return new CairoUint256(low, high).toBigInt();\n    }\n    if (CairoUint512.isAbiType(element.type)) {\n        const limb0 = responseIterator.next().value;\n        const limb1 = responseIterator.next().value;\n        const limb2 = responseIterator.next().value;\n        const limb3 = responseIterator.next().value;\n        return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n    }\n    if (isTypeByteArray(element.type)) {\n        const parsedBytes31Arr = [];\n        const bytes31ArrLen = BigInt(responseIterator.next().value);\n        while(parsedBytes31Arr.length < bytes31ArrLen){\n            parsedBytes31Arr.push(toHex(responseIterator.next().value));\n        }\n        const pending_word = toHex(responseIterator.next().value);\n        const pending_word_len = BigInt(responseIterator.next().value);\n        const myByteArray = {\n            data: parsedBytes31Arr,\n            pending_word,\n            pending_word_len\n        };\n        return stringFromByteArray(myByteArray);\n    }\n    if (isTypeArray(element.type)) {\n        const parsedDataArr = [];\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        const len = BigInt(responseIterator.next().value);\n        while(parsedDataArr.length < len){\n            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n        }\n        return parsedDataArr;\n    }\n    if (isTypeNonZero(element.type)) {\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        return parseResponseValue(responseIterator, el, structs, enums);\n    }\n    if (structs && element.type in structs && structs[element.type]) {\n        if (element.type === \"core::starknet::eth_address::EthAddress\") {\n            return parseBaseTypes2(element.type, responseIterator);\n        }\n        return structs[element.type].members.reduce((acc, el)=>{\n            acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n            return acc;\n        }, {});\n    }\n    if (enums && element.type in enums && enums[element.type]) {\n        const variantNum = Number(responseIterator.next().value);\n        const rawEnum = enums[element.type].variants.reduce((acc, variant, num)=>{\n            if (num === variantNum) {\n                acc[variant.name] = parseResponseValue(responseIterator, {\n                    name: \"\",\n                    type: variant.type\n                }, structs, enums);\n                return acc;\n            }\n            acc[variant.name] = void 0;\n            return acc;\n        }, {});\n        if (element.type.startsWith(\"core::option::Option\")) {\n            const content = variantNum === 0 /* Some */  ? rawEnum.Some : void 0;\n            return new CairoOption(variantNum, content);\n        }\n        if (element.type.startsWith(\"core::result::Result\")) {\n            let content;\n            if (variantNum === 0 /* Ok */ ) {\n                content = rawEnum.Ok;\n            } else {\n                content = rawEnum.Err;\n            }\n            return new CairoResult(variantNum, content);\n        }\n        const customEnum = new CairoCustomEnum(rawEnum);\n        return customEnum;\n    }\n    if (isTypeTuple(element.type)) {\n        const memberTypes = extractTupleMemberTypes(element.type);\n        return memberTypes.reduce((acc, it, idx)=>{\n            const name = it?.name ? it.name : idx;\n            const type = it?.type ? it.type : it;\n            const el = {\n                name,\n                type\n            };\n            acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n            return acc;\n        }, {});\n    }\n    if (isTypeArray(element.type)) {\n        const parsedDataArr = [];\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        const len = BigInt(responseIterator.next().value);\n        while(parsedDataArr.length < len){\n            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n        }\n        return parsedDataArr;\n    }\n    return parseBaseTypes2(element.type, responseIterator);\n}\nfunction responseParser(responseIterator, output, structs, enums, parsedResult) {\n    const { name, type } = output;\n    let temp;\n    switch(true){\n        case isLen(name):\n            temp = responseIterator.next().value;\n            return BigInt(temp);\n        case structs && type in structs || isTypeTuple(type):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        case enums && isTypeEnum(type, enums):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        case isTypeArray(type):\n            if (isCairo1Type(type)) {\n                return parseResponseValue(responseIterator, output, structs, enums);\n            }\n            const parsedDataArr = [];\n            if (parsedResult && parsedResult[`${name}_len`]) {\n                const arrLen = parsedResult[`${name}_len`];\n                while(parsedDataArr.length < arrLen){\n                    parsedDataArr.push(parseResponseValue(responseIterator, {\n                        name,\n                        type: output.type.replace(\"*\", \"\")\n                    }, structs, enums));\n                }\n            }\n            return parsedDataArr;\n        case isTypeNonZero(type):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        default:\n            return parseBaseTypes2(type, responseIterator);\n    }\n}\n// src/utils/calldata/validate.ts\nvar validateFelt = (parameter, input)=>{\n    assert(isString(parameter) || isNumber(parameter) || isBigInt(parameter), `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`);\n    if (isString(parameter) && !isHex(parameter)) return;\n    const param = BigInt(parameter.toString(10));\n    assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n};\nvar validateBytes31 = (parameter, input)=>{\n    assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n    assert(parameter.length < 32, `Validate: arg ${input.name} cairo typed ${input.type} should be a string of less than 32 characters.`);\n};\nvar validateByteArray = (parameter, input)=>{\n    assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n};\nvar validateUint = (parameter, input)=>{\n    if (isNumber(parameter)) {\n        assert(parameter <= Number.MAX_SAFE_INTEGER, `Validation: Parameter is to large to be typed as Number use (BigInt or String)`);\n    }\n    assert(isString(parameter) || isNumber(parameter) || isBigInt(parameter) || typeof parameter === \"object\" && \"low\" in parameter && \"high\" in parameter || typeof parameter === \"object\" && [\n        \"limb0\",\n        \"limb1\",\n        \"limb2\",\n        \"limb3\"\n    ].every((key)=>key in parameter), `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`);\n    let param;\n    switch(input.type){\n        case \"core::integer::u256\" /* u256 */ :\n            param = new CairoUint256(parameter).toBigInt();\n            break;\n        case \"core::integer::u512\" /* u512 */ :\n            param = new CairoUint512(parameter).toBigInt();\n            break;\n        default:\n            param = toBigInt(parameter);\n    }\n    switch(input.type){\n        case \"core::integer::u8\" /* u8 */ :\n            assert(param >= 0n && param <= 255n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`);\n            break;\n        case \"core::integer::u16\" /* u16 */ :\n            assert(param >= 0n && param <= 65535n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`);\n            break;\n        case \"core::integer::u32\" /* u32 */ :\n            assert(param >= 0n && param <= 4294967295n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`);\n            break;\n        case \"core::integer::u64\" /* u64 */ :\n            assert(param >= 0n && param <= 2n ** 64n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`);\n            break;\n        case \"core::integer::u128\" /* u128 */ :\n            assert(param >= 0n && param <= 2n ** 128n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`);\n            break;\n        case \"core::integer::u256\" /* u256 */ :\n            assert(param >= 0n && param <= 2n ** 256n - 1n, `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`);\n            break;\n        case \"core::integer::u512\" /* u512 */ :\n            assert(CairoUint512.is(param), `Validate: arg ${input.name} is ${input.type} 0 - 2^512-1`);\n            break;\n        case \"core::starknet::class_hash::ClassHash\" /* ClassHash */ :\n            assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n            param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n            break;\n        case \"core::starknet::contract_address::ContractAddress\" /* ContractAddress */ :\n            assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n            param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n            break;\n        case \"core::starknet::secp256k1::Secp256k1Point\" /* Secp256k1Point */ :\n            {\n                assert(param >= 0n && param <= 2n ** 512n - 1n, `Validate: arg ${input.name} must be ${input.type} : a 512 bits number.`);\n                break;\n            }\n        default:\n            break;\n    }\n};\nvar validateBool = (parameter, input)=>{\n    assert(isBoolean(parameter), `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`);\n};\nvar validateStruct = (parameter, input, structs)=>{\n    if (input.type === \"core::integer::u256\" /* u256 */  || input.type === \"core::integer::u512\" /* u512 */ ) {\n        validateUint(parameter, input);\n        return;\n    }\n    if (input.type === \"core::starknet::eth_address::EthAddress\") {\n        assert(typeof parameter !== \"object\", `EthAddress type is waiting a BigNumberish. Got ${parameter}`);\n        const param = BigInt(parameter.toString(10));\n        assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n        param >= 0n && param <= 2n ** 160n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`);\n        return;\n    }\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`);\n    structs[input.type].members.forEach(({ name })=>{\n        assert(Object.keys(parameter).includes(name), `Validate: arg ${input.name} should have a property ${name}`);\n    });\n};\nvar validateEnum = (parameter, input)=>{\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`);\n    const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n    const keys = [\n        ...Object.getOwnPropertyNames(parameter),\n        ...methodsKeys\n    ];\n    if (isTypeOption(input.type) && keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n        return;\n    }\n    if (isTypeResult(input.type) && keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n        return;\n    }\n    if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n        return;\n    }\n    throw new Error(`Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`);\n};\nvar validateTuple = (parameter, input)=>{\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} should be a tuple (defined as object)`);\n};\nvar validateArray = (parameter, input, structs, enums)=>{\n    const baseType = getArrayType(input.type);\n    if (isTypeFelt(baseType) && isLongText(parameter)) {\n        return;\n    }\n    assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);\n    switch(true){\n        case isTypeFelt(baseType):\n            parameter.forEach((param)=>validateFelt(param, input));\n            break;\n        case isTypeTuple(baseType):\n            parameter.forEach((it)=>validateTuple(it, {\n                    name: input.name,\n                    type: baseType\n                }));\n            break;\n        case isTypeArray(baseType):\n            parameter.forEach((param)=>validateArray(param, {\n                    name: \"\",\n                    type: baseType\n                }, structs, enums));\n            break;\n        case isTypeStruct(baseType, structs):\n            parameter.forEach((it)=>validateStruct(it, {\n                    name: input.name,\n                    type: baseType\n                }, structs));\n            break;\n        case isTypeEnum(baseType, enums):\n            parameter.forEach((it)=>validateEnum(it, {\n                    name: input.name,\n                    type: baseType\n                }));\n            break;\n        case isTypeUint(baseType) || isTypeLiteral(baseType):\n            parameter.forEach((param)=>validateUint(param, {\n                    name: \"\",\n                    type: baseType\n                }));\n            break;\n        case isTypeBool(baseType):\n            parameter.forEach((param)=>validateBool(param, input));\n            break;\n        default:\n            throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n    }\n};\nvar validateNonZero = (parameter, input)=>{\n    const baseType = getArrayType(input.type);\n    assert(isTypeUint(baseType) && baseType !== CairoUint512.abiSelector || isTypeFelt(baseType), `Validate: ${input.name} type is not authorized for NonZero type.`);\n    switch(true){\n        case isTypeFelt(baseType):\n            validateFelt(parameter, input);\n            assert(BigInt(parameter.toString(10)) > 0, \"Validate: value 0 is not authorized in NonZero felt252 type.\");\n            break;\n        case isTypeUint(baseType):\n            validateUint(parameter, {\n                name: \"\",\n                type: baseType\n            });\n            switch(input.type){\n                case \"core::integer::u256\" /* u256 */ :\n                    assert(new CairoUint256(parameter).toBigInt() > 0, \"Validate: value 0 is not authorized in NonZero uint256 type.\");\n                    break;\n                default:\n                    assert(toBigInt(parameter) > 0, \"Validate: value 0 is not authorized in NonZero uint type.\");\n            }\n            break;\n        default:\n            throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n    }\n};\nfunction validateFields(abiMethod, args, structs, enums) {\n    abiMethod.inputs.reduce((acc, input)=>{\n        const parameter = args[acc];\n        switch(true){\n            case isLen(input.name):\n                return acc;\n            case isTypeFelt(input.type):\n                validateFelt(parameter, input);\n                break;\n            case isTypeBytes31(input.type):\n                validateBytes31(parameter, input);\n                break;\n            case isTypeUint(input.type) || isTypeLiteral(input.type):\n                validateUint(parameter, input);\n                break;\n            case isTypeBool(input.type):\n                validateBool(parameter, input);\n                break;\n            case isTypeByteArray(input.type):\n                validateByteArray(parameter, input);\n                break;\n            case isTypeArray(input.type):\n                validateArray(parameter, input, structs, enums);\n                break;\n            case isTypeStruct(input.type, structs):\n                validateStruct(parameter, input, structs);\n                break;\n            case isTypeEnum(input.type, enums):\n                validateEnum(parameter, input);\n                break;\n            case isTypeTuple(input.type):\n                validateTuple(parameter, input);\n                break;\n            case isTypeNonZero(input.type):\n                validateNonZero(parameter, input);\n                break;\n            default:\n                throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n        }\n        return acc + 1;\n    }, 0);\n}\n// src/utils/calldata/index.ts\nvar CallData = class _CallData {\n    constructor(abi){\n        this.structs = _CallData.getAbiStruct(abi);\n        this.enums = _CallData.getAbiEnum(abi);\n        this.parser = createAbiParser(abi);\n        this.abi = this.parser.getLegacyFormat();\n    }\n    /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */ validate(type, method, args = []) {\n        if (type !== \"DEPLOY\" /* DEPLOY */ ) {\n            const invocableFunctionNames = this.abi.filter((abi)=>{\n                if (abi.type !== \"function\") return false;\n                const isView = abi.stateMutability === \"view\" || abi.state_mutability === \"view\";\n                return type === \"INVOKE\" /* INVOKE */  ? !isView : isView;\n            }).map((abi)=>abi.name);\n            assert(invocableFunctionNames.includes(method), `${type === \"INVOKE\" /* INVOKE */  ? \"invocable\" : \"viewable\"} method not found in abi`);\n        }\n        const abiMethod = this.abi.find((abi)=>type === \"DEPLOY\" /* DEPLOY */  ? abi.name === method && abi.type === \"constructor\" : abi.name === method && abi.type === \"function\");\n        if (isNoConstructorValid(method, args, abiMethod)) {\n            return;\n        }\n        const inputsLength = this.parser.methodInputsLength(abiMethod);\n        if (args.length !== inputsLength) {\n            throw Error(`Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`);\n        }\n        validateFields(abiMethod, args, this.structs, this.enums);\n    }\n    /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param argsCalldata RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */ compile(method, argsCalldata) {\n        const abiMethod = this.abi.find((abiFunction)=>abiFunction.name === method);\n        if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n            return [];\n        }\n        let args;\n        if (Array.isArray(argsCalldata)) {\n            args = argsCalldata;\n        } else {\n            const orderedObject = orderPropsByAbi(argsCalldata, abiMethod.inputs, this.structs, this.enums);\n            args = Object.values(orderedObject);\n            validateFields(abiMethod, args, this.structs, this.enums);\n        }\n        const argsIterator = args[Symbol.iterator]();\n        const callArray = abiMethod.inputs.reduce((acc, input)=>isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)), []);\n        Object.defineProperty(callArray, \"__compiled__\", {\n            enumerable: false,\n            writable: false,\n            value: true\n        });\n        return callArray;\n    }\n    /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */ static compile(rawArgs) {\n        const createTree = (obj)=>{\n            const getEntries = (o, prefix = \".\")=>{\n                const oe = Array.isArray(o) ? [\n                    o.length.toString(),\n                    ...o\n                ] : o;\n                return Object.entries(oe).flatMap(([k, v])=>{\n                    let value = v;\n                    if (k === \"entrypoint\") value = getSelectorFromName(value);\n                    else if (isLongText(value)) value = byteArrayFromString(value);\n                    const kk = Array.isArray(oe) && k === \"0\" ? \"$$len\" : k;\n                    if (isBigInt(value)) return [\n                        [\n                            `${prefix}${kk}`,\n                            felt(value)\n                        ]\n                    ];\n                    if (Object(value) === value) {\n                        const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n                        const keys = [\n                            ...Object.getOwnPropertyNames(value),\n                            ...methodsKeys\n                        ];\n                        if (keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n                            const myOption = value;\n                            const variantNb = myOption.isSome() ? 0 /* Some */  : 1 /* None */ ;\n                            if (myOption.isSome()) return getEntries({\n                                0: variantNb,\n                                1: myOption.unwrap()\n                            }, `${prefix}${kk}.`);\n                            return [\n                                [\n                                    `${prefix}${kk}`,\n                                    felt(variantNb)\n                                ]\n                            ];\n                        }\n                        if (keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n                            const myResult = value;\n                            const variantNb = myResult.isOk() ? 0 /* Ok */  : 1 /* Err */ ;\n                            return getEntries({\n                                0: variantNb,\n                                1: myResult.unwrap()\n                            }, `${prefix}${kk}.`);\n                        }\n                        if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n                            const myEnum = value;\n                            const activeVariant = myEnum.activeVariant();\n                            const listVariants = Object.keys(myEnum.variant);\n                            const activeVariantNb = listVariants.findIndex((variant)=>variant === activeVariant);\n                            if (typeof myEnum.unwrap() === \"object\" && Object.keys(myEnum.unwrap()).length === 0) {\n                                return [\n                                    [\n                                        `${prefix}${kk}`,\n                                        felt(activeVariantNb)\n                                    ]\n                                ];\n                            }\n                            return getEntries({\n                                0: activeVariantNb,\n                                1: myEnum.unwrap()\n                            }, `${prefix}${kk}.`);\n                        }\n                        return getEntries(value, `${prefix}${kk}.`);\n                    }\n                    return [\n                        [\n                            `${prefix}${kk}`,\n                            felt(value)\n                        ]\n                    ];\n                });\n            };\n            const result = Object.fromEntries(getEntries(obj));\n            return result;\n        };\n        let callTreeArray;\n        if (!Array.isArray(rawArgs)) {\n            const callTree = createTree(rawArgs);\n            callTreeArray = Object.values(callTree);\n        } else {\n            const callObj = {\n                ...rawArgs\n            };\n            const callTree = createTree(callObj);\n            callTreeArray = Object.values(callTree);\n        }\n        Object.defineProperty(callTreeArray, \"__compiled__\", {\n            enumerable: false,\n            writable: false,\n            value: true\n        });\n        return callTreeArray;\n    }\n    /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */ parse(method, response) {\n        const { outputs } = this.abi.find((abi)=>abi.name === method);\n        const responseIterator = response.flat()[Symbol.iterator]();\n        const parsed = outputs.flat().reduce((acc, output, idx)=>{\n            const propName = output.name ?? idx;\n            acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n            if (acc[propName] && acc[`${propName}_len`]) {\n                delete acc[`${propName}_len`];\n            }\n            return acc;\n        }, {});\n        return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;\n    }\n    /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */ format(method, response, format) {\n        const parsed = this.parse(method, response);\n        return formatter(parsed, format);\n    }\n    /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */ static getAbiStruct(abi) {\n        return abi.filter((abiEntry)=>abiEntry.type === \"struct\").reduce((acc, abiEntry)=>({\n                ...acc,\n                [abiEntry.name]: abiEntry\n            }), {});\n    }\n    /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */ static getAbiEnum(abi) {\n        const fullEnumList = abi.filter((abiEntry)=>abiEntry.type === \"enum\").reduce((acc, abiEntry)=>({\n                ...acc,\n                [abiEntry.name]: abiEntry\n            }), {});\n        delete fullEnumList[\"core::bool\"];\n        return fullEnumList;\n    }\n    /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */ static toCalldata(rawCalldata = []) {\n        return _CallData.compile(rawCalldata);\n    }\n    /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */ static toHex(raw = []) {\n        const calldata = _CallData.compile(raw);\n        return calldata.map((it)=>toHex(it));\n    }\n    /**\n   * Parse the elements of a contract response and structure them into one or several Result.\n   * In Cairo 0, arrays are not supported.\n   * @param typeCairo string or string[] - Cairo type name, ex : \"hello::hello::UserData\"\n   * @param response string[] - serialized data corresponding to typeCairo.\n   * @return Result or Result[] - parsed response corresponding to typeData.\n   * @example\n   * const res2=helloCallData.decodeParameters(\"hello::hello::UserData\",[\"0x123456\",\"0x1\"]);\n   * result = { address: 1193046n, is_claimed: true }\n   */ decodeParameters(typeCairo, response) {\n        const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [\n            typeCairo\n        ];\n        const responseIterator = response.flat()[Symbol.iterator]();\n        const decodedArray = typeCairoArray.map((typeParam)=>responseParser(responseIterator, {\n                name: \"\",\n                type: typeParam\n            }, this.structs, this.enums));\n        return decodedArray.length === 1 ? decodedArray[0] : decodedArray;\n    }\n};\n// src/utils/hash/index.ts\nvar hash_exports = {};\n__export(hash_exports, {\n    calculateContractAddressFromHash: ()=>calculateContractAddressFromHash,\n    calculateDeclareTransactionHash: ()=>calculateDeclareTransactionHash3,\n    calculateDeployAccountTransactionHash: ()=>calculateDeployAccountTransactionHash3,\n    calculateInvokeTransactionHash: ()=>calculateInvokeTransactionHash2,\n    computeCompiledClassHash: ()=>computeCompiledClassHash,\n    computeContractClassHash: ()=>computeContractClassHash,\n    computeHashOnElements: ()=>computeHashOnElements2,\n    computeHintedClassHash: ()=>computeHintedClassHash,\n    computeLegacyContractClassHash: ()=>computeLegacyContractClassHash,\n    computePedersenHash: ()=>computePedersenHash,\n    computePedersenHashOnElements: ()=>computePedersenHashOnElements,\n    computePoseidonHash: ()=>computePoseidonHash,\n    computePoseidonHashOnElements: ()=>computePoseidonHashOnElements,\n    computeSierraContractClassHash: ()=>computeSierraContractClassHash,\n    formatSpaces: ()=>formatSpaces,\n    getSelector: ()=>getSelector,\n    getSelectorFromName: ()=>getSelectorFromName,\n    hashByteCodeSegments: ()=>hashByteCodeSegments,\n    keccakBn: ()=>keccakBn,\n    poseidon: ()=>_noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_5__,\n    starknetKeccak: ()=>starknetKeccak\n});\n\n// src/utils/hash/transactionHash/v2.ts\nvar v2_exports = {};\n__export(v2_exports, {\n    calculateDeclareTransactionHash: ()=>calculateDeclareTransactionHash,\n    calculateDeployAccountTransactionHash: ()=>calculateDeployAccountTransactionHash,\n    calculateTransactionHash: ()=>calculateTransactionHash,\n    calculateTransactionHashCommon: ()=>calculateTransactionHashCommon,\n    computeHashOnElements: ()=>computeHashOnElements\n});\n// src/utils/ec.ts\nvar ec_exports = {};\n__export(ec_exports, {\n    starkCurve: ()=>_scure_starknet__WEBPACK_IMPORTED_MODULE_4__,\n    weierstrass: ()=>_noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_6__\n});\n\n\n// src/utils/hash/transactionHash/v2.ts\nfunction computeHashOnElements(data) {\n    return [\n        ...data,\n        data.length\n    ].reduce((x, y)=>_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.pedersen(toBigInt(x), toBigInt(y)), 0).toString();\n}\nfunction calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {\n    const calldataHash = computeHashOnElements(calldata);\n    const dataToHash = [\n        txHashPrefix,\n        version,\n        contractAddress,\n        entryPointSelector,\n        calldataHash,\n        maxFee,\n        chainId,\n        ...additionalData\n    ];\n    return computeHashOnElements(dataToHash);\n}\nfunction calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {\n    return calculateTransactionHashCommon(\"0x6465636c617265\" /* DECLARE */ , version, senderAddress, 0, [\n        classHash\n    ], maxFee, chainId, [\n        nonce,\n        ...compiledClassHash ? [\n            compiledClassHash\n        ] : []\n    ]);\n}\nfunction calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {\n    const calldata = [\n        classHash,\n        salt,\n        ...constructorCalldata\n    ];\n    return calculateTransactionHashCommon(\"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */ , version, contractAddress, 0, calldata, maxFee, chainId, [\n        nonce\n    ]);\n}\nfunction calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {\n    return calculateTransactionHashCommon(\"0x696e766f6b65\" /* INVOKE */ , version, contractAddress, 0, calldata, maxFee, chainId, [\n        nonce\n    ]);\n}\n// src/utils/hash/transactionHash/v3.ts\nvar v3_exports = {};\n__export(v3_exports, {\n    calculateDeclareTransactionHash: ()=>calculateDeclareTransactionHash2,\n    calculateDeployAccountTransactionHash: ()=>calculateDeployAccountTransactionHash2,\n    calculateInvokeTransactionHash: ()=>calculateInvokeTransactionHash,\n    calculateTransactionHashCommon: ()=>calculateTransactionHashCommon2,\n    hashDAMode: ()=>hashDAMode,\n    hashFeeField: ()=>hashFeeField\n});\n\nvar AToBI = (array)=>array.map((it)=>BigInt(it));\nvar DATA_AVAILABILITY_MODE_BITS = 32n;\nvar MAX_AMOUNT_BITS = 64n;\nvar MAX_PRICE_PER_UNIT_BITS = 128n;\nvar RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;\nvar L1_GAS_NAME = BigInt(encodeShortString(\"L1_GAS\"));\nvar L2_GAS_NAME = BigInt(encodeShortString(\"L2_GAS\"));\nfunction hashDAMode(nonceDAMode, feeDAMode) {\n    return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);\n}\nfunction hashFeeField(tip, bounds) {\n    const L1Bound = (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l1_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l1_gas.max_price_per_unit);\n    const L2Bound = (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l2_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l2_gas.max_price_per_unit);\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)([\n        BigInt(tip),\n        L1Bound,\n        L2Bound\n    ]);\n}\nfunction calculateTransactionHashCommon2(txHashPrefix, version, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, additionalData = []) {\n    const feeFieldHash = hashFeeField(tip, resourceBounds);\n    const dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);\n    const dataToHash = AToBI([\n        txHashPrefix,\n        version,\n        senderAddress,\n        feeFieldHash,\n        (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(paymasterData)),\n        chainId,\n        nonce,\n        dAModeHash,\n        ...AToBI(additionalData)\n    ]);\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(dataToHash));\n}\nfunction calculateDeployAccountTransactionHash2(contractAddress, classHash, compiledConstructorCalldata, salt, version, chainId, nonce, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n    return calculateTransactionHashCommon2(\"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */ , version, contractAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, [\n        (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(compiledConstructorCalldata)),\n        classHash,\n        salt\n    ]);\n}\nfunction calculateDeclareTransactionHash2(classHash, compiledClassHash, senderAddress, version, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n    return calculateTransactionHashCommon2(\"0x6465636c617265\" /* DECLARE */ , version, senderAddress, chainId, nonce, tip, AToBI(paymasterData), nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, [\n        (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(accountDeploymentData)),\n        classHash,\n        compiledClassHash\n    ]);\n}\nfunction calculateInvokeTransactionHash(senderAddress, version, compiledCalldata, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n    return calculateTransactionHashCommon2(\"0x696e766f6b65\" /* INVOKE */ , version, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, [\n        (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(accountDeploymentData)),\n        (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(AToBI(compiledCalldata))\n    ]);\n}\n// src/utils/hash/transactionHash/index.ts\nfunction isV3InvokeTx(args) {\n    return [\n        api_exports.ETransactionVersion.V3,\n        api_exports.ETransactionVersion.F3\n    ].includes(args.version);\n}\nfunction calculateInvokeTransactionHash2(args) {\n    if (isV3InvokeTx(args)) {\n        return calculateInvokeTransactionHash(args.senderAddress, args.version, args.compiledCalldata, args.chainId, args.nonce, args.accountDeploymentData, args.nonceDataAvailabilityMode, args.feeDataAvailabilityMode, args.resourceBounds, args.tip, args.paymasterData);\n    }\n    return calculateTransactionHash(args.senderAddress, args.version, args.compiledCalldata, args.maxFee, args.chainId, args.nonce);\n}\nfunction isV3DeclareTx(args) {\n    return [\n        api_exports.ETransactionVersion.V3,\n        api_exports.ETransactionVersion.F3\n    ].includes(args.version);\n}\nfunction calculateDeclareTransactionHash3(args) {\n    if (isV3DeclareTx(args)) {\n        return calculateDeclareTransactionHash2(args.classHash, args.compiledClassHash, args.senderAddress, args.version, args.chainId, args.nonce, args.accountDeploymentData, args.nonceDataAvailabilityMode, args.feeDataAvailabilityMode, args.resourceBounds, args.tip, args.paymasterData);\n    }\n    return calculateDeclareTransactionHash(args.classHash, args.senderAddress, args.version, args.maxFee, args.chainId, args.nonce, args.compiledClassHash);\n}\nfunction isV3DeployAccountTx(args) {\n    return [\n        api_exports.ETransactionVersion.V3,\n        api_exports.ETransactionVersion.F3\n    ].includes(args.version);\n}\nfunction calculateDeployAccountTransactionHash3(args) {\n    if (isV3DeployAccountTx(args)) {\n        return calculateDeployAccountTransactionHash2(args.contractAddress, args.classHash, args.compiledConstructorCalldata, args.salt, args.version, args.chainId, args.nonce, args.nonceDataAvailabilityMode, args.feeDataAvailabilityMode, args.resourceBounds, args.tip, args.paymasterData);\n    }\n    return calculateDeployAccountTransactionHash(args.contractAddress, args.classHash, args.constructorCalldata, args.salt, args.version, args.maxFee, args.chainId, args.nonce);\n}\n// src/utils/hash/classHash.ts\n\n// src/utils/json.ts\nvar json_exports = {};\n__export(json_exports, {\n    parse: ()=>parse2,\n    parseAlwaysAsBig: ()=>parseAlwaysAsBig,\n    stringify: ()=>stringify2,\n    stringifyAlwaysAsBig: ()=>stringifyAlwaysAsBig\n});\n\nvar parseIntAsNumberOrBigInt = (str)=>{\n    if (!lossless_json__WEBPACK_IMPORTED_MODULE_7__.isInteger(str)) return parseFloat(str);\n    const num = parseInt(str, 10);\n    return Number.isSafeInteger(num) ? num : BigInt(str);\n};\nvar parse2 = (str)=>lossless_json__WEBPACK_IMPORTED_MODULE_7__.parse(String(str), void 0, parseIntAsNumberOrBigInt);\nvar parseAlwaysAsBig = (str)=>lossless_json__WEBPACK_IMPORTED_MODULE_7__.parse(String(str), void 0, lossless_json__WEBPACK_IMPORTED_MODULE_7__.parseNumberAndBigInt);\nvar stringify2 = (value, replacer, space, numberStringifiers)=>lossless_json__WEBPACK_IMPORTED_MODULE_7__.stringify(value, replacer, space, numberStringifiers);\nvar stringifyAlwaysAsBig = stringify2;\n// src/utils/hash/classHash.ts\nfunction computePedersenHash(a, b) {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.pedersen(BigInt(a), BigInt(b));\n}\nfunction computePoseidonHash(a, b) {\n    return toHex(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHash(BigInt(a), BigInt(b)));\n}\nfunction computeHashOnElements2(data) {\n    return [\n        ...data,\n        data.length\n    ].reduce((x, y)=>_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.pedersen(BigInt(x), BigInt(y)), 0).toString();\n}\nvar computePedersenHashOnElements = computeHashOnElements2;\nfunction computePoseidonHashOnElements(data) {\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(data.map((x)=>BigInt(x))));\n}\nfunction calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const constructorCalldataHash = computeHashOnElements2(compiledCalldata);\n    const CONTRACT_ADDRESS_PREFIX = felt(\"0x535441524b4e45545f434f4e54524143545f41444452455353\");\n    const hash = computeHashOnElements2([\n        CONTRACT_ADDRESS_PREFIX,\n        deployerAddress,\n        salt,\n        classHash,\n        constructorCalldataHash\n    ]);\n    return toHex(BigInt(hash) % ADDR_BOUND);\n}\nfunction nullSkipReplacer(key, value) {\n    if (key === \"attributes\" || key === \"accessible_scopes\") {\n        return Array.isArray(value) && value.length === 0 ? void 0 : value;\n    }\n    if (key === \"debug_info\") {\n        return null;\n    }\n    return value === null ? void 0 : value;\n}\nfunction formatSpaces(json2) {\n    let insideQuotes = false;\n    const newString = [];\n    for (const char of json2){\n        if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === \"\\\\\") === false) {\n            insideQuotes = !insideQuotes;\n        }\n        if (insideQuotes) {\n            newString.push(char);\n        } else {\n            newString.push(char === \":\" ? \": \" : char === \",\" ? \", \" : char);\n        }\n    }\n    return newString.join(\"\");\n}\nfunction computeHintedClassHash(compiledContract) {\n    const { abi, program } = compiledContract;\n    const contractClass = {\n        abi,\n        program\n    };\n    const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));\n    return addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(serializedJson)).toString(16));\n}\nfunction computeLegacyContractClassHash(contract) {\n    const compiledContract = isString(contract) ? parse2(contract) : contract;\n    const apiVersion = toHex(API_VERSION);\n    const externalEntryPointsHash = computeHashOnElements2(compiledContract.entry_points_by_type.EXTERNAL.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const l1HandlerEntryPointsHash = computeHashOnElements2(compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const constructorEntryPointHash = computeHashOnElements2(compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const builtinsHash = computeHashOnElements2(compiledContract.program.builtins.map((s)=>encodeShortString(s)));\n    const hintedClassHash = computeHintedClassHash(compiledContract);\n    const dataHash = computeHashOnElements2(compiledContract.program.data);\n    return computeHashOnElements2([\n        apiVersion,\n        externalEntryPointsHash,\n        l1HandlerEntryPointsHash,\n        constructorEntryPointHash,\n        builtinsHash,\n        hintedClassHash,\n        dataHash\n    ]);\n}\nfunction hashBuiltins(builtins) {\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(builtins.flatMap((it)=>{\n        return BigInt(encodeShortString(it));\n    }));\n}\nfunction hashEntryPoint(data) {\n    const base = data.flatMap((it)=>{\n        return [\n            BigInt(it.selector),\n            BigInt(it.offset),\n            hashBuiltins(it.builtins)\n        ];\n    });\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(base);\n}\nfunction hashByteCodeSegments(casm) {\n    const byteCode = casm.bytecode.map((n)=>BigInt(n));\n    const bytecodeSegmentLengths = casm.bytecode_segment_lengths ?? [];\n    let segmentStart = 0;\n    const hashLeaves = bytecodeSegmentLengths.flatMap((len)=>{\n        const segment = byteCode.slice(segmentStart, segmentStart += len);\n        return [\n            BigInt(len),\n            (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(segment)\n        ];\n    });\n    return 1n + (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(hashLeaves);\n}\nfunction computeCompiledClassHash(casm) {\n    const COMPILED_CLASS_VERSION = \"COMPILED_CLASS_V1\";\n    const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n    const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n    const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n    const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n    const bytecode = casm.bytecode_segment_lengths ? hashByteCodeSegments(casm) : (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(casm.bytecode.map((it)=>BigInt(it)));\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)([\n        compiledClassVersion,\n        externalEntryPointsHash,\n        l1Handlers,\n        constructor,\n        bytecode\n    ]));\n}\nfunction hashEntryPointSierra(data) {\n    const base = data.flatMap((it)=>{\n        return [\n            BigInt(it.selector),\n            BigInt(it.function_idx)\n        ];\n    });\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(base);\n}\nfunction hashAbi(sierra) {\n    const indentString = formatSpaces(stringify2(sierra.abi, null));\n    return BigInt(addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(indentString)).toString(16)));\n}\nfunction computeSierraContractClassHash(sierra) {\n    const CONTRACT_CLASS_VERSION = \"CONTRACT_CLASS_V0.1.0\";\n    const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n    const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n    const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n    const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n    const abiHash = hashAbi(sierra);\n    const sierraProgram = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)(sierra.sierra_program.map((it)=>BigInt(it)));\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.poseidonHashMany)([\n        compiledClassVersion,\n        externalEntryPointsHash,\n        l1Handlers,\n        constructor,\n        abiHash,\n        sierraProgram\n    ]));\n}\nfunction computeContractClassHash(contract) {\n    const compiledContract = isString(contract) ? parse2(contract) : contract;\n    if (\"sierra_program\" in compiledContract) {\n        return computeSierraContractClassHash(compiledContract);\n    }\n    return computeLegacyContractClassHash(compiledContract);\n}\n// src/utils/stark.ts\nvar stark_exports = {};\n__export(stark_exports, {\n    compressProgram: ()=>compressProgram,\n    decompressProgram: ()=>decompressProgram,\n    estimateFeeToBounds: ()=>estimateFeeToBounds,\n    estimatedFeeToMaxFee: ()=>estimatedFeeToMaxFee,\n    formatSignature: ()=>formatSignature,\n    intDAM: ()=>intDAM,\n    makeAddress: ()=>makeAddress,\n    randomAddress: ()=>randomAddress,\n    reduceV2: ()=>reduceV2,\n    signatureToDecimalArray: ()=>signatureToDecimalArray,\n    signatureToHexArray: ()=>signatureToHexArray,\n    toFeeVersion: ()=>toFeeVersion,\n    toTransactionVersion: ()=>toTransactionVersion,\n    v3Details: ()=>v3Details\n});\n\n\nfunction compressProgram(jsonProgram) {\n    const stringified = isString(jsonProgram) ? jsonProgram : stringify2(jsonProgram);\n    const compressedProgram = (0,pako__WEBPACK_IMPORTED_MODULE_8__.gzip)(stringified);\n    return btoaUniversal(compressedProgram);\n}\nfunction decompressProgram(base642) {\n    if (Array.isArray(base642)) return base642;\n    const decompressed = arrayBufferToString((0,pako__WEBPACK_IMPORTED_MODULE_8__.ungzip)(atobUniversal(base642)));\n    return parse2(decompressed);\n}\nfunction randomAddress() {\n    const randomKeyPair = _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.utils.randomPrivateKey();\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.getStarkKey)(randomKeyPair);\n}\nfunction makeAddress(input) {\n    return addHexPrefix(input).toLowerCase();\n}\nfunction formatSignature(sig) {\n    if (!sig) throw Error(\"formatSignature: provided signature is undefined\");\n    if (Array.isArray(sig)) {\n        return sig.map((it)=>toHex(it));\n    }\n    try {\n        const { r, s } = sig;\n        return [\n            toHex(r),\n            toHex(s)\n        ];\n    } catch (e) {\n        throw new Error(\"Signature need to be weierstrass.SignatureType or an array for custom\");\n    }\n}\nfunction signatureToDecimalArray(sig) {\n    return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\nfunction signatureToHexArray(sig) {\n    return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\nfunction estimatedFeeToMaxFee(estimatedFee, overhead = 50 /* MAX_FEE */ ) {\n    return addPercent(estimatedFee, overhead);\n}\nfunction estimateFeeToBounds(estimate, amountOverhead = 50 /* L1_BOUND_MAX_AMOUNT */ , priceOverhead = 50 /* L1_BOUND_MAX_PRICE_PER_UNIT */ ) {\n    if (isBigInt(estimate)) {\n        return {\n            l2_gas: {\n                max_amount: \"0x0\",\n                max_price_per_unit: \"0x0\"\n            },\n            l1_gas: {\n                max_amount: \"0x0\",\n                max_price_per_unit: \"0x0\"\n            }\n        };\n    }\n    if (typeof estimate.gas_consumed === \"undefined\" || typeof estimate.gas_price === \"undefined\") {\n        throw Error(\"estimateFeeToBounds: estimate is undefined\");\n    }\n    const maxUnits = estimate.data_gas_consumed !== void 0 && estimate.data_gas_price !== void 0 ? toHex(addPercent(BigInt(estimate.overall_fee) / BigInt(estimate.gas_price), amountOverhead)) : toHex(addPercent(estimate.gas_consumed, amountOverhead));\n    const maxUnitPrice = toHex(addPercent(estimate.gas_price, priceOverhead));\n    return {\n        l2_gas: {\n            max_amount: \"0x0\",\n            max_price_per_unit: \"0x0\"\n        },\n        l1_gas: {\n            max_amount: maxUnits,\n            max_price_per_unit: maxUnitPrice\n        }\n    };\n}\nfunction intDAM(dam) {\n    if (dam === api_exports.EDataAvailabilityMode.L1) return api_exports.EDAMode.L1;\n    if (dam === api_exports.EDataAvailabilityMode.L2) return api_exports.EDAMode.L2;\n    throw Error(\"EDAM conversion\");\n}\nfunction toTransactionVersion(defaultVersion, providedVersion) {\n    const providedVersion0xs = providedVersion ? toHex(providedVersion) : void 0;\n    const defaultVersion0xs = toHex(defaultVersion);\n    if (providedVersion && !Object.values(api_exports.ETransactionVersion).includes(providedVersion0xs)) {\n        throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);\n    }\n    if (!Object.values(api_exports.ETransactionVersion).includes(defaultVersion0xs)) {\n        throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);\n    }\n    return providedVersion ? providedVersion0xs : defaultVersion0xs;\n}\nfunction toFeeVersion(providedVersion) {\n    if (!providedVersion) return void 0;\n    const version = toHex(providedVersion);\n    if (version === api_exports.ETransactionVersion.V0) return api_exports.ETransactionVersion.F0;\n    if (version === api_exports.ETransactionVersion.V1) return api_exports.ETransactionVersion.F1;\n    if (version === api_exports.ETransactionVersion.V2) return api_exports.ETransactionVersion.F2;\n    if (version === api_exports.ETransactionVersion.V3) return api_exports.ETransactionVersion.F3;\n    throw Error(`toFeeVersion: ${version} is not supported`);\n}\nfunction v3Details(details) {\n    return {\n        tip: details.tip || 0,\n        paymasterData: details.paymasterData || [],\n        accountDeploymentData: details.accountDeploymentData || [],\n        nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,\n        feeDataAvailabilityMode: details.feeDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,\n        resourceBounds: details.resourceBounds ?? estimateFeeToBounds(ZERO)\n    };\n}\nfunction reduceV2(providedVersion) {\n    if (providedVersion === api_exports.ETransactionVersion.F2) return api_exports.ETransactionVersion.F1;\n    if (providedVersion === api_exports.ETransactionVersion.V2) return api_exports.ETransactionVersion.V1;\n    return providedVersion;\n}\n// src/utils/contract.ts\nfunction isSierra(contract) {\n    const compiledContract = isString(contract) ? parse2(contract) : contract;\n    return \"sierra_program\" in compiledContract;\n}\nfunction extractContractHashes(payload) {\n    const response = {\n        ...payload\n    };\n    if (isSierra(payload.contract)) {\n        if (!payload.compiledClassHash && payload.casm) {\n            response.compiledClassHash = computeCompiledClassHash(payload.casm);\n        }\n        if (!response.compiledClassHash) throw new Error(\"Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash\");\n    }\n    response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n    if (!response.classHash) throw new Error(\"Extract classHash failed, provide (CompiledContract).json file or classHash\");\n    return response;\n}\nfunction contractClassResponseToLegacyCompiledContract(ccr) {\n    if (isSierra(ccr)) {\n        throw Error(\"ContractClassResponse need to be LegacyContractClass (cairo0 response class)\");\n    }\n    const contract = ccr;\n    return {\n        ...contract,\n        program: decompressProgram(contract.program)\n    };\n}\n// src/utils/eth.ts\nvar eth_exports = {};\n__export(eth_exports, {\n    ethRandomPrivateKey: ()=>ethRandomPrivateKey,\n    validateAndParseEthAddress: ()=>validateAndParseEthAddress\n});\n\nfunction ethRandomPrivateKey() {\n    return sanitizeHex(buf2hex(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.utils.randomPrivateKey()));\n}\nfunction validateAndParseEthAddress(address) {\n    assertInRange(address, ZERO, 2n ** 160n - 1n, \"Ethereum Address \");\n    const result = addHexPrefix(removeHexPrefix(toHex(address)).padStart(40, \"0\"));\n    assert(Boolean(result.match(/^(0x)?[0-9a-f]{40}$/)), \"Invalid Ethereum Address Format\");\n    return result;\n}\n// src/utils/fetchPonyfill.ts\n\n\nvar fetchPonyfill_default =  false || // use buildin fetch in browser if available\ntypeof global !== \"undefined\" && (0,fetch_cookie__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(global.fetch) || // use buildin fetch in node, react-native and service worker if available\nisomorphic_fetch__WEBPACK_IMPORTED_MODULE_11__;\n// src/utils/provider.ts\nvar provider_exports = {};\n__export(provider_exports, {\n    Block: ()=>Block,\n    createSierraContractClass: ()=>createSierraContractClass,\n    getDefaultNodeUrl: ()=>getDefaultNodeUrl,\n    isPendingBlock: ()=>isPendingBlock,\n    isPendingStateUpdate: ()=>isPendingStateUpdate,\n    isPendingTransaction: ()=>isPendingTransaction,\n    isV3Tx: ()=>isV3Tx,\n    isVersion: ()=>isVersion,\n    parseContract: ()=>parseContract,\n    validBlockTags: ()=>validBlockTags,\n    wait: ()=>wait\n});\nfunction wait(delay) {\n    return new Promise((res)=>{\n        setTimeout(res, delay);\n    });\n}\nfunction createSierraContractClass(contract) {\n    const result = {\n        ...contract\n    };\n    delete result.sierra_program_debug_info;\n    result.abi = formatSpaces(stringify2(contract.abi));\n    result.sierra_program = formatSpaces(stringify2(contract.sierra_program));\n    result.sierra_program = compressProgram(result.sierra_program);\n    return result;\n}\nfunction parseContract(contract) {\n    const parsedContract = isString(contract) ? parse2(contract) : contract;\n    if (!isSierra(contract)) {\n        return {\n            ...parsedContract,\n            ...\"program\" in parsedContract && {\n                program: compressProgram(parsedContract.program)\n            }\n        };\n    }\n    return createSierraContractClass(parsedContract);\n}\nvar getDefaultNodeUrl = (networkName, mute = false)=>{\n    if (!mute) {\n        console.warn(\"Using default public node url, please provide nodeUrl in provider options!\");\n    }\n    const nodes = RPC_NODES[networkName ?? \"SN_SEPOLIA\" /* SN_SEPOLIA */ ];\n    const randIdx = Math.floor(Math.random() * nodes.length);\n    return nodes[randIdx];\n};\nvar validBlockTags = Object.values(BlockTag);\nvar Block = class {\n    setIdentifier(__identifier) {\n        if (isString(__identifier)) {\n            if (isDecimalString(__identifier)) {\n                this.number = parseInt(__identifier, 10);\n            } else if (isHex(__identifier)) {\n                this.hash = __identifier;\n            } else if (validBlockTags.includes(__identifier)) {\n                this.tag = __identifier;\n            } else {\n                throw TypeError(`Block identifier unmanaged: ${__identifier}`);\n            }\n        } else if (isBigInt(__identifier)) {\n            this.hash = toHex(__identifier);\n        } else if (isNumber(__identifier)) {\n            this.number = __identifier;\n        } else {\n            this.tag = \"pending\" /* PENDING */ ;\n        }\n        if (isNumber(this.number) && this.number < 0) {\n            throw TypeError(`Block number (${this.number}) can't be negative`);\n        }\n    }\n    /**\n   * Create a Block instance\n   * @param {BlockIdentifier} _identifier  hex string and BigInt are detected as block hashes.\n   * decimal string and number are detected as block numbers.\n   * text string are detected as block tag.\n   * null is considered as a 'pending' block tag.\n   */ constructor(_identifier){\n        /**\n   * @param {BlockIdentifier} hash if not null, contains the block hash\n   */ this.hash = null;\n        /**\n   * @param {BlockIdentifier} number if not null, contains the block number\n   */ this.number = null;\n        /**\n   * @param {BlockIdentifier} tag if not null, contains \"pending\" or \"latest\"\n   */ this.tag = null;\n        this.valueOf = ()=>this.number;\n        this.toString = ()=>this.hash;\n        this.setIdentifier(_identifier);\n    }\n    // TODO: fix any\n    /**\n   * @returns {any} the identifier as a string\n   * @example\n   * ```typescript\n   * const result = new provider.Block(123456n).queryIdentifier;\n   * // result = \"blockHash=0x1e240\"\n   * ```\n   */ get queryIdentifier() {\n        if (this.number !== null) {\n            return `blockNumber=${this.number}`;\n        }\n        if (this.hash !== null) {\n            return `blockHash=${this.hash}`;\n        }\n        return `blockNumber=${this.tag}`;\n    }\n    // TODO: fix any\n    /**\n   * @returns {any} the identifier as an object\n   * @example\n   * ```typescript\n   * const result = new provider.Block(56789).identifier;\n   * // result = { block_number: 56789 }\n   * ```\n   */ get identifier() {\n        if (this.number !== null) {\n            return {\n                block_number: this.number\n            };\n        }\n        if (this.hash !== null) {\n            return {\n                block_hash: this.hash\n            };\n        }\n        return this.tag;\n    }\n    /**\n   * change the identifier of an existing Block instance\n   * @example\n   * ```typescript\n   * const myBlock = new provider.Block(\"latest\");\n   * myBlock.identifier =\"0x3456789abc\";\n   * const result = myBlock.identifier;\n   * // result = { block_hash: '0x3456789abc' }\n   * ```\n   */ set identifier(_identifier) {\n        this.setIdentifier(_identifier);\n    }\n};\nfunction isV3Tx(details) {\n    const version = details.version ? toHex(details.version) : api_exports.ETransactionVersion.V3;\n    return version === api_exports.ETransactionVersion.V3 || version === api_exports.ETransactionVersion.F3;\n}\nfunction isVersion(version, response) {\n    const [majorS, minorS] = version.split(\".\");\n    const [majorR, minorR] = response.split(\".\");\n    return majorS === majorR && minorS === minorR;\n}\nfunction isPendingBlock(response) {\n    return response.status === \"PENDING\";\n}\nfunction isPendingTransaction(response) {\n    return !(\"block_hash\" in response);\n}\nfunction isPendingStateUpdate(response) {\n    return !(\"block_hash\" in response);\n}\n// src/utils/transaction.ts\nvar transaction_exports = {};\n__export(transaction_exports, {\n    buildUDCCall: ()=>buildUDCCall,\n    fromCallsToExecuteCalldata: ()=>fromCallsToExecuteCalldata,\n    fromCallsToExecuteCalldataWithNonce: ()=>fromCallsToExecuteCalldataWithNonce,\n    fromCallsToExecuteCalldata_cairo1: ()=>fromCallsToExecuteCalldata_cairo1,\n    getExecuteCalldata: ()=>getExecuteCalldata,\n    getVersionsByType: ()=>getVersionsByType,\n    transformCallsToMulticallArrays: ()=>transformCallsToMulticallArrays,\n    transformCallsToMulticallArrays_cairo1: ()=>transformCallsToMulticallArrays_cairo1\n});\nvar transformCallsToMulticallArrays = (calls)=>{\n    const callArray = [];\n    const calldata = [];\n    calls.forEach((call)=>{\n        const data = CallData.compile(call.calldata || []);\n        callArray.push({\n            to: toBigInt(call.contractAddress).toString(10),\n            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n            data_offset: calldata.length.toString(),\n            data_len: data.length.toString()\n        });\n        calldata.push(...data);\n    });\n    return {\n        callArray,\n        calldata: CallData.compile({\n            calldata\n        })\n    };\n};\nvar fromCallsToExecuteCalldata = (calls)=>{\n    const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n    const compiledCalls = CallData.compile({\n        callArray\n    });\n    return [\n        ...compiledCalls,\n        ...calldata\n    ];\n};\nvar fromCallsToExecuteCalldataWithNonce = (calls, nonce)=>{\n    return [\n        ...fromCallsToExecuteCalldata(calls),\n        toBigInt(nonce).toString()\n    ];\n};\nvar transformCallsToMulticallArrays_cairo1 = (calls)=>{\n    const callArray = calls.map((call)=>({\n            to: toBigInt(call.contractAddress).toString(10),\n            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n            calldata: CallData.compile(call.calldata || [])\n        }));\n    return callArray;\n};\nvar fromCallsToExecuteCalldata_cairo1 = (calls)=>{\n    const orderCalls = calls.map((call)=>({\n            contractAddress: call.contractAddress,\n            entrypoint: call.entrypoint,\n            calldata: Array.isArray(call.calldata) && \"__compiled__\" in call.calldata ? call.calldata : CallData.compile(call.calldata)\n        }));\n    return CallData.compile({\n        orderCalls\n    });\n};\nvar getExecuteCalldata = (calls, cairoVersion = \"0\")=>{\n    if (cairoVersion === \"1\") {\n        return fromCallsToExecuteCalldata_cairo1(calls);\n    }\n    return fromCallsToExecuteCalldata(calls);\n};\nfunction buildUDCCall(payload, address) {\n    const params = [].concat(payload).map((it)=>{\n        const { classHash, salt, unique = true, constructorCalldata = [] } = it;\n        const compiledConstructorCallData = CallData.compile(constructorCalldata);\n        const deploySalt = salt ?? randomAddress();\n        return {\n            call: {\n                contractAddress: UDC.ADDRESS,\n                entrypoint: UDC.ENTRYPOINT,\n                calldata: [\n                    classHash,\n                    deploySalt,\n                    toCairoBool(unique),\n                    compiledConstructorCallData.length,\n                    ...compiledConstructorCallData\n                ]\n            },\n            address: calculateContractAddressFromHash(unique ? _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.pedersen(address, deploySalt) : deploySalt, classHash, compiledConstructorCallData, unique ? UDC.ADDRESS : 0)\n        };\n    });\n    return {\n        calls: params.map((it)=>it.call),\n        addresses: params.map((it)=>it.address)\n    };\n}\nfunction getVersionsByType(versionType) {\n    return versionType === \"fee\" ? {\n        v1: api_exports.ETransactionVersion.F1,\n        v2: api_exports.ETransactionVersion.F2,\n        v3: api_exports.ETransactionVersion.F3\n    } : {\n        v1: api_exports.ETransactionVersion.V1,\n        v2: api_exports.ETransactionVersion.V2,\n        v3: api_exports.ETransactionVersion.V3\n    };\n}\n// src/channel/rpc_0_6.ts\nvar defaultOptions = {\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    blockIdentifier: \"pending\" /* PENDING */ ,\n    retries: 200\n};\nvar RpcChannel = class {\n    // behave like web2 rpc and return when tx is processed\n    constructor(optionsOrProvider){\n        const { nodeUrl, retries, headers, blockIdentifier, chainId, specVersion, waitMode } = optionsOrProvider || {};\n        if (Object.values(NetworkName).includes(nodeUrl)) {\n            this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n        } else if (nodeUrl) {\n            this.nodeUrl = nodeUrl;\n        } else {\n            this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n        }\n        this.retries = retries || defaultOptions.retries;\n        this.headers = {\n            ...defaultOptions.headers,\n            ...headers\n        };\n        this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n        this.chainId = chainId;\n        this.specVersion = specVersion;\n        this.waitMode = waitMode || false;\n        this.requestId = 0;\n    }\n    setChainId(chainId) {\n        this.chainId = chainId;\n    }\n    fetch(method, params, id = 0) {\n        const rpcRequestBody = {\n            id,\n            jsonrpc: \"2.0\",\n            method,\n            ...params && {\n                params\n            }\n        };\n        return fetchPonyfill_default(this.nodeUrl, {\n            method: \"POST\",\n            body: stringify2(rpcRequestBody),\n            headers: this.headers\n        });\n    }\n    errorHandler(method, params, rpcError, otherError) {\n        if (rpcError) {\n            const { code, message, data } = rpcError;\n            throw new LibraryError(`RPC: ${method} with params ${stringify2(params, null, 2)}\n\n        ${code}: ${message}: ${stringify2(data)}`);\n        }\n        if (otherError instanceof LibraryError) {\n            throw otherError;\n        }\n        if (otherError) {\n            throw Error(otherError.message);\n        }\n    }\n    async fetchEndpoint(method, params) {\n        try {\n            const rawResult = await this.fetch(method, params, this.requestId += 1);\n            const { error, result } = await rawResult.json();\n            this.errorHandler(method, params, error);\n            return result;\n        } catch (error) {\n            this.errorHandler(method, params, error?.response?.data, error);\n            throw error;\n        }\n    }\n    async getChainId() {\n        this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n        return this.chainId;\n    }\n    async getSpecVersion() {\n        this.specVersion ??= await this.fetchEndpoint(\"starknet_specVersion\");\n        return this.specVersion;\n    }\n    getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getNonce\", {\n            contract_address,\n            block_id\n        });\n    }\n    /**\n   * Get the most recent accepted block hash and number\n   */ getBlockLatestAccepted() {\n        return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n    }\n    /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */ getBlockNumber() {\n        return this.fetchEndpoint(\"starknet_blockNumber\");\n    }\n    getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", {\n            block_id\n        });\n    }\n    getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxs\", {\n            block_id\n        });\n    }\n    getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStateUpdate\", {\n            block_id\n        });\n    }\n    getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_traceBlockTransactions\", {\n            block_id\n        });\n    }\n    getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", {\n            block_id\n        });\n    }\n    getTransactionByHash(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n            transaction_hash\n        });\n    }\n    getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", {\n            block_id,\n            index\n        });\n    }\n    getTransactionReceipt(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionReceipt\", {\n            transaction_hash\n        });\n    }\n    getTransactionTrace(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_traceTransaction\", {\n            transaction_hash\n        });\n    }\n    /**\n   * Get the status of a transaction\n   */ getTransactionStatus(transactionHash) {\n        const transaction_hash = toHex(transactionHash);\n        return this.fetchEndpoint(\"starknet_getTransactionStatus\", {\n            transaction_hash\n        });\n    }\n    /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */ simulateTransaction(invocations, simulateTransactionOptions = {}) {\n        const { blockIdentifier = this.blockIdentifier, skipValidate = true, skipFeeCharge = true } = simulateTransactionOptions;\n        const block_id = new Block(blockIdentifier).identifier;\n        const simulationFlags = [];\n        if (skipValidate) simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE);\n        if (skipFeeCharge) simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_FEE_CHARGE);\n        return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n            block_id,\n            transactions: invocations.map((it)=>this.buildTransaction(it)),\n            simulation_flags: simulationFlags\n        });\n    }\n    async waitForTransaction(txHash, options) {\n        const transactionHash = toHex(txHash);\n        let { retries } = this;\n        let onchain = false;\n        let isErrorState = false;\n        const retryInterval = options?.retryInterval ?? 5e3;\n        const errorStates = options?.errorStates ?? [\n            rpcspec_0_6_exports.ETransactionStatus.REJECTED\n        ];\n        const successStates = options?.successStates ?? [\n            rpcspec_0_6_exports.ETransactionExecutionStatus.SUCCEEDED,\n            rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L2,\n            rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L1\n        ];\n        let txStatus;\n        while(!onchain){\n            await wait(retryInterval);\n            try {\n                txStatus = await this.getTransactionStatus(transactionHash);\n                const executionStatus = txStatus.execution_status;\n                const finalityStatus = txStatus.finality_status;\n                if (!finalityStatus) {\n                    const error = new Error(\"waiting for transaction status\");\n                    throw error;\n                }\n                if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n                    const message = `${executionStatus}: ${finalityStatus}`;\n                    const error = new Error(message);\n                    error.response = txStatus;\n                    isErrorState = true;\n                    throw error;\n                } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n                    onchain = true;\n                }\n            } catch (error) {\n                if (error instanceof Error && isErrorState) {\n                    throw error;\n                }\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n        }\n        let txReceipt = null;\n        while(txReceipt === null){\n            try {\n                txReceipt = await this.getTransactionReceipt(transactionHash);\n            } catch (error) {\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n            await wait(retryInterval);\n        }\n        return txReceipt;\n    }\n    getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const parsedKey = toStorageKey(key);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStorageAt\", {\n            contract_address,\n            key: parsedKey,\n            block_id\n        });\n    }\n    getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n            block_id,\n            contract_address\n        });\n    }\n    getClass(classHash, blockIdentifier = this.blockIdentifier) {\n        const class_hash = toHex(classHash);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClass\", {\n            class_hash,\n            block_id\n        });\n    }\n    getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassAt\", {\n            block_id,\n            contract_address\n        });\n    }\n    async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {\n        const block_id = new Block(blockIdentifier).identifier;\n        let flags = {};\n        if (!isVersion(\"0.5\", await this.getSpecVersion())) {\n            flags = {\n                simulation_flags: skipValidate ? [\n                    rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE\n                ] : []\n            };\n        }\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: invocations.map((it)=>this.buildTransaction(it, \"fee\")),\n            block_id,\n            ...flags\n        });\n    }\n    async invoke(functionInvocation, details) {\n        let promise;\n        if (!isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n                invoke_transaction: {\n                    sender_address: functionInvocation.contractAddress,\n                    calldata: CallData.toHex(functionInvocation.calldata),\n                    type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n                    max_fee: toHex(details.maxFee || 0),\n                    version: rpcspec_0_6_exports.ETransactionVersion.V1,\n                    signature: signatureToHexArray(functionInvocation.signature),\n                    nonce: toHex(details.nonce)\n                }\n            });\n        } else {\n            promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n                invoke_transaction: {\n                    type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n                    sender_address: functionInvocation.contractAddress,\n                    calldata: CallData.toHex(functionInvocation.calldata),\n                    version: rpcspec_0_6_exports.ETransactionVersion.V3,\n                    signature: signatureToHexArray(functionInvocation.signature),\n                    nonce: toHex(details.nonce),\n                    resource_bounds: details.resourceBounds,\n                    tip: toHex(details.tip),\n                    paymaster_data: details.paymasterData.map((it)=>toHex(it)),\n                    account_deployment_data: details.accountDeploymentData.map((it)=>toHex(it)),\n                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n                    fee_data_availability_mode: details.feeDataAvailabilityMode\n                }\n            });\n        }\n        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n    }\n    async declare({ contract, signature, senderAddress, compiledClassHash }, details) {\n        let promise;\n        if (!isSierra(contract) && !isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n                    contract_class: {\n                        program: contract.program,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    version: rpcspec_0_6_exports.ETransactionVersion.V1,\n                    max_fee: toHex(details.maxFee || 0),\n                    signature: signatureToHexArray(signature),\n                    sender_address: senderAddress,\n                    nonce: toHex(details.nonce)\n                }\n            });\n        } else if (isSierra(contract) && !isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n                    contract_class: {\n                        sierra_program: decompressProgram(contract.sierra_program),\n                        contract_class_version: contract.contract_class_version,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    compiled_class_hash: compiledClassHash || \"\",\n                    version: rpcspec_0_6_exports.ETransactionVersion.V2,\n                    max_fee: toHex(details.maxFee || 0),\n                    signature: signatureToHexArray(signature),\n                    sender_address: senderAddress,\n                    nonce: toHex(details.nonce)\n                }\n            });\n        } else if (isSierra(contract) && isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n                    sender_address: senderAddress,\n                    compiled_class_hash: compiledClassHash || \"\",\n                    version: rpcspec_0_6_exports.ETransactionVersion.V3,\n                    signature: signatureToHexArray(signature),\n                    nonce: toHex(details.nonce),\n                    contract_class: {\n                        sierra_program: decompressProgram(contract.sierra_program),\n                        contract_class_version: contract.contract_class_version,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    resource_bounds: details.resourceBounds,\n                    tip: toHex(details.tip),\n                    paymaster_data: details.paymasterData.map((it)=>toHex(it)),\n                    account_deployment_data: details.accountDeploymentData.map((it)=>toHex(it)),\n                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n                    fee_data_availability_mode: details.feeDataAvailabilityMode\n                }\n            });\n        } else {\n            throw Error(\"declare unspotted parameters\");\n        }\n        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n    }\n    async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {\n        let promise;\n        if (!isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n                deploy_account_transaction: {\n                    constructor_calldata: CallData.toHex(constructorCalldata || []),\n                    class_hash: toHex(classHash),\n                    contract_address_salt: toHex(addressSalt || 0),\n                    type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,\n                    max_fee: toHex(details.maxFee || 0),\n                    version: rpcspec_0_6_exports.ETransactionVersion.V1,\n                    signature: signatureToHexArray(signature),\n                    nonce: toHex(details.nonce)\n                }\n            });\n        } else {\n            promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n                deploy_account_transaction: {\n                    type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,\n                    version: rpcspec_0_6_exports.ETransactionVersion.V3,\n                    signature: signatureToHexArray(signature),\n                    nonce: toHex(details.nonce),\n                    contract_address_salt: toHex(addressSalt || 0),\n                    constructor_calldata: CallData.toHex(constructorCalldata || []),\n                    class_hash: toHex(classHash),\n                    resource_bounds: details.resourceBounds,\n                    tip: toHex(details.tip),\n                    paymaster_data: details.paymasterData.map((it)=>toHex(it)),\n                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n                    fee_data_availability_mode: details.feeDataAvailabilityMode\n                }\n            });\n        }\n        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n    }\n    callContract(call, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_call\", {\n            request: {\n                contract_address: call.contractAddress,\n                entry_point_selector: getSelectorFromName(call.entrypoint),\n                calldata: CallData.toHex(call.calldata)\n            },\n            block_id\n        });\n    }\n    /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */ estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n        const { from_address, to_address, entry_point_selector, payload } = message;\n        const formattedMessage = {\n            from_address: validateAndParseEthAddress(from_address),\n            to_address: toHex(to_address),\n            entry_point_selector: getSelector(entry_point_selector),\n            payload: getHexStringArray(payload)\n        };\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n            message: formattedMessage,\n            block_id\n        });\n    }\n    /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */ getSyncingStats() {\n        return this.fetchEndpoint(\"starknet_syncing\");\n    }\n    /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */ getEvents(eventFilter) {\n        return this.fetchEndpoint(\"starknet_getEvents\", {\n            filter: eventFilter\n        });\n    }\n    buildTransaction(invocation, versionType) {\n        const defaultVersions = getVersionsByType(versionType);\n        let details;\n        if (!isV3Tx(invocation)) {\n            details = {\n                signature: signatureToHexArray(invocation.signature),\n                nonce: toHex(invocation.nonce),\n                max_fee: toHex(invocation.maxFee || 0)\n            };\n        } else {\n            details = {\n                signature: signatureToHexArray(invocation.signature),\n                nonce: toHex(invocation.nonce),\n                resource_bounds: invocation.resourceBounds,\n                tip: toHex(invocation.tip),\n                paymaster_data: invocation.paymasterData.map((it)=>toHex(it)),\n                nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n                fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n                account_deployment_data: invocation.accountDeploymentData.map((it)=>toHex(it))\n            };\n        }\n        if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n            return {\n                // v0 v1 v3\n                type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n                sender_address: invocation.contractAddress,\n                calldata: CallData.toHex(invocation.calldata),\n                version: toHex(invocation.version || defaultVersions.v3),\n                ...details\n            };\n        }\n        if (invocation.type === \"DECLARE\" /* DECLARE */ ) {\n            if (!isSierra(invocation.contract)) {\n                return {\n                    type: invocation.type,\n                    contract_class: invocation.contract,\n                    sender_address: invocation.senderAddress,\n                    version: toHex(invocation.version || defaultVersions.v1),\n                    ...details\n                };\n            }\n            return {\n                // Cairo 1 - v2 v3\n                type: invocation.type,\n                contract_class: {\n                    ...invocation.contract,\n                    sierra_program: decompressProgram(invocation.contract.sierra_program)\n                },\n                compiled_class_hash: invocation.compiledClassHash || \"\",\n                sender_address: invocation.senderAddress,\n                version: toHex(invocation.version || defaultVersions.v3),\n                ...details\n            };\n        }\n        if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n            const { account_deployment_data, ...restDetails } = details;\n            return {\n                type: invocation.type,\n                constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n                class_hash: toHex(invocation.classHash),\n                contract_address_salt: toHex(invocation.addressSalt || 0),\n                version: toHex(invocation.version || defaultVersions.v3),\n                ...restDetails\n            };\n        }\n        throw Error(\"RPC buildTransaction received unknown TransactionType\");\n    }\n};\n// src/channel/rpc_0_7.ts\nvar rpc_0_7_exports = {};\n__export(rpc_0_7_exports, {\n    RpcChannel: ()=>RpcChannel2\n});\nvar defaultOptions2 = {\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    blockIdentifier: \"pending\" /* PENDING */ ,\n    retries: 200\n};\nvar RpcChannel2 = class {\n    // behave like web2 rpc and return when tx is processed\n    constructor(optionsOrProvider){\n        const { nodeUrl, retries, headers, blockIdentifier, chainId, specVersion, waitMode, transactionRetryIntervalFallback } = optionsOrProvider || {};\n        if (Object.values(NetworkName).includes(nodeUrl)) {\n            this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n        } else if (nodeUrl) {\n            this.nodeUrl = nodeUrl;\n        } else {\n            this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n        }\n        this.retries = retries || defaultOptions2.retries;\n        this.headers = {\n            ...defaultOptions2.headers,\n            ...headers\n        };\n        this.blockIdentifier = blockIdentifier || defaultOptions2.blockIdentifier;\n        this.chainId = chainId;\n        this.specVersion = specVersion;\n        this.waitMode = waitMode || false;\n        this.requestId = 0;\n        this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;\n    }\n    get transactionRetryIntervalDefault() {\n        return this.transactionRetryIntervalFallback ?? 5e3;\n    }\n    setChainId(chainId) {\n        this.chainId = chainId;\n    }\n    fetch(method, params, id = 0) {\n        const rpcRequestBody = {\n            id,\n            jsonrpc: \"2.0\",\n            method,\n            ...params && {\n                params\n            }\n        };\n        return fetchPonyfill_default(this.nodeUrl, {\n            method: \"POST\",\n            body: stringify2(rpcRequestBody),\n            headers: this.headers\n        });\n    }\n    errorHandler(method, params, rpcError, otherError) {\n        if (rpcError) {\n            const { code, message, data } = rpcError;\n            throw new LibraryError(`RPC: ${method} with params ${stringify2(params, null, 2)}\n \n        ${code}: ${message}: ${stringify2(data)}`);\n        }\n        if (otherError instanceof LibraryError) {\n            throw otherError;\n        }\n        if (otherError) {\n            throw Error(otherError.message);\n        }\n    }\n    async fetchEndpoint(method, params) {\n        try {\n            const rawResult = await this.fetch(method, params, this.requestId += 1);\n            const { error, result } = await rawResult.json();\n            this.errorHandler(method, params, error);\n            return result;\n        } catch (error) {\n            this.errorHandler(method, params, error?.response?.data, error);\n            throw error;\n        }\n    }\n    async getChainId() {\n        this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n        return this.chainId;\n    }\n    async getSpecVersion() {\n        this.specVersion ??= await this.fetchEndpoint(\"starknet_specVersion\");\n        return this.specVersion;\n    }\n    getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getNonce\", {\n            contract_address,\n            block_id\n        });\n    }\n    /**\n   * Get the most recent accepted block hash and number\n   */ getBlockLatestAccepted() {\n        return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n    }\n    /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */ getBlockNumber() {\n        return this.fetchEndpoint(\"starknet_blockNumber\");\n    }\n    getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", {\n            block_id\n        });\n    }\n    getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxs\", {\n            block_id\n        });\n    }\n    getBlockWithReceipts(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithReceipts\", {\n            block_id\n        });\n    }\n    getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStateUpdate\", {\n            block_id\n        });\n    }\n    getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_traceBlockTransactions\", {\n            block_id\n        });\n    }\n    getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", {\n            block_id\n        });\n    }\n    getTransactionByHash(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n            transaction_hash\n        });\n    }\n    getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", {\n            block_id,\n            index\n        });\n    }\n    getTransactionReceipt(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionReceipt\", {\n            transaction_hash\n        });\n    }\n    getTransactionTrace(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_traceTransaction\", {\n            transaction_hash\n        });\n    }\n    /**\n   * Get the status of a transaction\n   */ getTransactionStatus(transactionHash) {\n        const transaction_hash = toHex(transactionHash);\n        return this.fetchEndpoint(\"starknet_getTransactionStatus\", {\n            transaction_hash\n        });\n    }\n    /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */ simulateTransaction(invocations, simulateTransactionOptions = {}) {\n        const { blockIdentifier = this.blockIdentifier, skipValidate = true, skipFeeCharge = true } = simulateTransactionOptions;\n        const block_id = new Block(blockIdentifier).identifier;\n        const simulationFlags = [];\n        if (skipValidate) simulationFlags.push(starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ESimulationFlag.SKIP_VALIDATE);\n        if (skipFeeCharge) simulationFlags.push(starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ESimulationFlag.SKIP_FEE_CHARGE);\n        return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n            block_id,\n            transactions: invocations.map((it)=>this.buildTransaction(it)),\n            simulation_flags: simulationFlags\n        });\n    }\n    async waitForTransaction(txHash, options) {\n        const transactionHash = toHex(txHash);\n        let { retries } = this;\n        let onchain = false;\n        let isErrorState = false;\n        const retryInterval = options?.retryInterval ?? this.transactionRetryIntervalDefault;\n        const errorStates = options?.errorStates ?? [\n            starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionStatus.REJECTED\n        ];\n        const successStates = options?.successStates ?? [\n            starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionExecutionStatus.SUCCEEDED,\n            starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionStatus.ACCEPTED_ON_L2,\n            starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionStatus.ACCEPTED_ON_L1\n        ];\n        let txStatus;\n        while(!onchain){\n            await wait(retryInterval);\n            try {\n                txStatus = await this.getTransactionStatus(transactionHash);\n                const executionStatus = txStatus.execution_status;\n                const finalityStatus = txStatus.finality_status;\n                if (!finalityStatus) {\n                    const error = new Error(\"waiting for transaction status\");\n                    throw error;\n                }\n                if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n                    const message = `${executionStatus}: ${finalityStatus}`;\n                    const error = new Error(message);\n                    error.response = txStatus;\n                    isErrorState = true;\n                    throw error;\n                } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n                    onchain = true;\n                }\n            } catch (error) {\n                if (error instanceof Error && isErrorState) {\n                    throw error;\n                }\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n        }\n        let txReceipt = null;\n        while(txReceipt === null){\n            try {\n                txReceipt = await this.getTransactionReceipt(transactionHash);\n            } catch (error) {\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n            await wait(retryInterval);\n        }\n        return txReceipt;\n    }\n    getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const parsedKey = toStorageKey(key);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStorageAt\", {\n            contract_address,\n            key: parsedKey,\n            block_id\n        });\n    }\n    getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n            block_id,\n            contract_address\n        });\n    }\n    getClass(classHash, blockIdentifier = this.blockIdentifier) {\n        const class_hash = toHex(classHash);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClass\", {\n            class_hash,\n            block_id\n        });\n    }\n    getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassAt\", {\n            block_id,\n            contract_address\n        });\n    }\n    async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {\n        const block_id = new Block(blockIdentifier).identifier;\n        let flags = {};\n        if (!isVersion(\"0.5\", await this.getSpecVersion())) {\n            flags = {\n                simulation_flags: skipValidate ? [\n                    starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ESimulationFlag.SKIP_VALIDATE\n                ] : []\n            };\n        }\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: invocations.map((it)=>this.buildTransaction(it, \"fee\")),\n            block_id,\n            ...flags\n        });\n    }\n    async invoke(functionInvocation, details) {\n        let promise;\n        if (!isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n                invoke_transaction: {\n                    sender_address: functionInvocation.contractAddress,\n                    calldata: CallData.toHex(functionInvocation.calldata),\n                    type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.INVOKE,\n                    max_fee: toHex(details.maxFee || 0),\n                    version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V1,\n                    signature: signatureToHexArray(functionInvocation.signature),\n                    nonce: toHex(details.nonce)\n                }\n            });\n        } else {\n            promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n                invoke_transaction: {\n                    type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.INVOKE,\n                    sender_address: functionInvocation.contractAddress,\n                    calldata: CallData.toHex(functionInvocation.calldata),\n                    version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V3,\n                    signature: signatureToHexArray(functionInvocation.signature),\n                    nonce: toHex(details.nonce),\n                    resource_bounds: details.resourceBounds,\n                    tip: toHex(details.tip),\n                    paymaster_data: details.paymasterData.map((it)=>toHex(it)),\n                    account_deployment_data: details.accountDeploymentData.map((it)=>toHex(it)),\n                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n                    fee_data_availability_mode: details.feeDataAvailabilityMode\n                }\n            });\n        }\n        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n    }\n    async declare({ contract, signature, senderAddress, compiledClassHash }, details) {\n        let promise;\n        if (!isSierra(contract) && !isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DECLARE,\n                    contract_class: {\n                        program: contract.program,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V1,\n                    max_fee: toHex(details.maxFee || 0),\n                    signature: signatureToHexArray(signature),\n                    sender_address: senderAddress,\n                    nonce: toHex(details.nonce)\n                }\n            });\n        } else if (isSierra(contract) && !isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DECLARE,\n                    contract_class: {\n                        sierra_program: decompressProgram(contract.sierra_program),\n                        contract_class_version: contract.contract_class_version,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    compiled_class_hash: compiledClassHash || \"\",\n                    version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V2,\n                    max_fee: toHex(details.maxFee || 0),\n                    signature: signatureToHexArray(signature),\n                    sender_address: senderAddress,\n                    nonce: toHex(details.nonce)\n                }\n            });\n        } else if (isSierra(contract) && isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DECLARE,\n                    sender_address: senderAddress,\n                    compiled_class_hash: compiledClassHash || \"\",\n                    version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V3,\n                    signature: signatureToHexArray(signature),\n                    nonce: toHex(details.nonce),\n                    contract_class: {\n                        sierra_program: decompressProgram(contract.sierra_program),\n                        contract_class_version: contract.contract_class_version,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    resource_bounds: details.resourceBounds,\n                    tip: toHex(details.tip),\n                    paymaster_data: details.paymasterData.map((it)=>toHex(it)),\n                    account_deployment_data: details.accountDeploymentData.map((it)=>toHex(it)),\n                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n                    fee_data_availability_mode: details.feeDataAvailabilityMode\n                }\n            });\n        } else {\n            throw Error(\"declare unspotted parameters\");\n        }\n        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n    }\n    async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {\n        let promise;\n        if (!isV3Tx(details)) {\n            promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n                deploy_account_transaction: {\n                    constructor_calldata: CallData.toHex(constructorCalldata || []),\n                    class_hash: toHex(classHash),\n                    contract_address_salt: toHex(addressSalt || 0),\n                    type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DEPLOY_ACCOUNT,\n                    max_fee: toHex(details.maxFee || 0),\n                    version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V1,\n                    signature: signatureToHexArray(signature),\n                    nonce: toHex(details.nonce)\n                }\n            });\n        } else {\n            promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n                deploy_account_transaction: {\n                    type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.DEPLOY_ACCOUNT,\n                    version: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionVersion.V3,\n                    signature: signatureToHexArray(signature),\n                    nonce: toHex(details.nonce),\n                    contract_address_salt: toHex(addressSalt || 0),\n                    constructor_calldata: CallData.toHex(constructorCalldata || []),\n                    class_hash: toHex(classHash),\n                    resource_bounds: details.resourceBounds,\n                    tip: toHex(details.tip),\n                    paymaster_data: details.paymasterData.map((it)=>toHex(it)),\n                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n                    fee_data_availability_mode: details.feeDataAvailabilityMode\n                }\n            });\n        }\n        return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n    }\n    callContract(call, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_call\", {\n            request: {\n                contract_address: call.contractAddress,\n                entry_point_selector: getSelectorFromName(call.entrypoint),\n                calldata: CallData.toHex(call.calldata)\n            },\n            block_id\n        });\n    }\n    /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */ estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n        const { from_address, to_address, entry_point_selector, payload } = message;\n        const formattedMessage = {\n            from_address: validateAndParseEthAddress(from_address),\n            to_address: toHex(to_address),\n            entry_point_selector: getSelector(entry_point_selector),\n            payload: getHexStringArray(payload)\n        };\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n            message: formattedMessage,\n            block_id\n        });\n    }\n    /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */ getSyncingStats() {\n        return this.fetchEndpoint(\"starknet_syncing\");\n    }\n    /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */ getEvents(eventFilter) {\n        return this.fetchEndpoint(\"starknet_getEvents\", {\n            filter: eventFilter\n        });\n    }\n    buildTransaction(invocation, versionType) {\n        const defaultVersions = getVersionsByType(versionType);\n        let details;\n        if (!isV3Tx(invocation)) {\n            details = {\n                signature: signatureToHexArray(invocation.signature),\n                nonce: toHex(invocation.nonce),\n                max_fee: toHex(invocation.maxFee || 0)\n            };\n        } else {\n            details = {\n                signature: signatureToHexArray(invocation.signature),\n                nonce: toHex(invocation.nonce),\n                resource_bounds: invocation.resourceBounds,\n                tip: toHex(invocation.tip),\n                paymaster_data: invocation.paymasterData.map((it)=>toHex(it)),\n                nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n                fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n                account_deployment_data: invocation.accountDeploymentData.map((it)=>toHex(it))\n            };\n        }\n        if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n            return {\n                // v0 v1 v3\n                type: starknet_types_07__WEBPACK_IMPORTED_MODULE_12__.ETransactionType.INVOKE,\n                sender_address: invocation.contractAddress,\n                calldata: CallData.toHex(invocation.calldata),\n                version: toHex(invocation.version || defaultVersions.v3),\n                ...details\n            };\n        }\n        if (invocation.type === \"DECLARE\" /* DECLARE */ ) {\n            if (!isSierra(invocation.contract)) {\n                return {\n                    type: invocation.type,\n                    contract_class: invocation.contract,\n                    sender_address: invocation.senderAddress,\n                    version: toHex(invocation.version || defaultVersions.v1),\n                    ...details\n                };\n            }\n            return {\n                // Cairo 1 - v2 v3\n                type: invocation.type,\n                contract_class: {\n                    ...invocation.contract,\n                    sierra_program: decompressProgram(invocation.contract.sierra_program)\n                },\n                compiled_class_hash: invocation.compiledClassHash || \"\",\n                sender_address: invocation.senderAddress,\n                version: toHex(invocation.version || defaultVersions.v3),\n                ...details\n            };\n        }\n        if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n            const { account_deployment_data, ...restDetails } = details;\n            return {\n                type: invocation.type,\n                constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n                class_hash: toHex(invocation.classHash),\n                contract_address_salt: toHex(invocation.addressSalt || 0),\n                version: toHex(invocation.version || defaultVersions.v3),\n                ...restDetails\n            };\n        }\n        throw Error(\"RPC buildTransaction received unknown TransactionType\");\n    }\n};\n// src/utils/responseParser/rpc.ts\nvar RPCResponseParser = class {\n    constructor(margin){\n        this.margin = margin;\n    }\n    estimatedFeeToMaxFee(estimatedFee) {\n        return estimatedFeeToMaxFee(estimatedFee, this.margin?.maxFee);\n    }\n    estimateFeeToBounds(estimate) {\n        return estimateFeeToBounds(estimate, this.margin?.l1BoundMaxAmount, this.margin?.l1BoundMaxPricePerUnit);\n    }\n    parseGetBlockResponse(res) {\n        return {\n            status: \"PENDING\",\n            ...res\n        };\n    }\n    parseTransactionReceipt(res) {\n        if (\"actual_fee\" in res && isString(res.actual_fee)) {\n            return {\n                ...res,\n                actual_fee: {\n                    amount: res.actual_fee,\n                    unit: \"FRI\"\n                }\n            };\n        }\n        return res;\n    }\n    parseFeeEstimateResponse(res) {\n        const val = res[0];\n        return {\n            overall_fee: toBigInt(val.overall_fee),\n            gas_consumed: toBigInt(val.gas_consumed),\n            gas_price: toBigInt(val.gas_price),\n            unit: val.unit,\n            suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n            resourceBounds: this.estimateFeeToBounds(val),\n            data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n            data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n\n        };\n    }\n    parseFeeEstimateBulkResponse(res) {\n        return res.map((val)=>({\n                overall_fee: toBigInt(val.overall_fee),\n                gas_consumed: toBigInt(val.gas_consumed),\n                gas_price: toBigInt(val.gas_price),\n                unit: val.unit,\n                suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n                resourceBounds: this.estimateFeeToBounds(val),\n                data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n                data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n\n            }));\n    }\n    parseSimulateTransactionResponse(res) {\n        return res.map((it)=>{\n            return {\n                ...it,\n                suggestedMaxFee: this.estimatedFeeToMaxFee(it.fee_estimation.overall_fee),\n                resourceBounds: this.estimateFeeToBounds(it.fee_estimation)\n            };\n        });\n    }\n    parseContractClassResponse(res) {\n        return {\n            ...res,\n            abi: isString(res.abi) ? JSON.parse(res.abi) : res.abi\n        };\n    }\n    parseL1GasPriceResponse(res) {\n        return res.l1_gas_price.price_in_wei;\n    }\n};\n// src/utils/transactionReceipt.ts\nvar ReceiptTx = class _ReceiptTx {\n    constructor(receipt){\n        [this.statusReceipt, this.value] = _ReceiptTx.isSuccess(receipt) ? [\n            \"success\",\n            receipt\n        ] : _ReceiptTx.isReverted(receipt) ? [\n            \"reverted\",\n            receipt\n        ] : _ReceiptTx.isRejected(receipt) ? [\n            \"rejected\",\n            receipt\n        ] : [\n            \"error\",\n            new Error(\"Unknown response type\")\n        ];\n        for (const [key] of Object.entries(this)){\n            Object.defineProperty(this, key, {\n                enumerable: false\n            });\n        }\n        for (const [key, value] of Object.entries(receipt)){\n            Object.defineProperty(this, key, {\n                enumerable: true,\n                writable: false,\n                value\n            });\n        }\n    }\n    match(callbacks) {\n        if (this.statusReceipt in callbacks) {\n            return callbacks[this.statusReceipt](this.value);\n        }\n        return callbacks._();\n    }\n    isSuccess() {\n        return this.statusReceipt === \"success\";\n    }\n    isReverted() {\n        return this.statusReceipt === \"reverted\";\n    }\n    isRejected() {\n        return this.statusReceipt === \"rejected\";\n    }\n    isError() {\n        return this.statusReceipt === \"error\";\n    }\n    static isSuccess(transactionReceipt) {\n        return transactionReceipt.execution_status === \"SUCCEEDED\" /* SUCCEEDED */ ;\n    }\n    static isReverted(transactionReceipt) {\n        return transactionReceipt.execution_status === \"REVERTED\" /* REVERTED */ ;\n    }\n    static isRejected(transactionReceipt) {\n        return transactionReceipt.status === \"REJECTED\" /* REJECTED */ ;\n    }\n};\n// src/provider/rpc.ts\nvar RpcProvider = class {\n    constructor(optionsOrProvider){\n        this.getStateUpdate = this.getBlockStateUpdate;\n        if (optionsOrProvider && \"channel\" in optionsOrProvider) {\n            this.channel = optionsOrProvider.channel;\n            this.responseParser = \"responseParser\" in optionsOrProvider ? optionsOrProvider.responseParser : new RPCResponseParser();\n        } else {\n            this.channel = new RpcChannel2({\n                ...optionsOrProvider,\n                waitMode: false\n            });\n            this.responseParser = new RPCResponseParser(optionsOrProvider?.feeMarginPercentage);\n        }\n    }\n    fetch(method, params, id = 0) {\n        return this.channel.fetch(method, params, id);\n    }\n    async getChainId() {\n        return this.channel.getChainId();\n    }\n    async getSpecVersion() {\n        return this.channel.getSpecVersion();\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier) {\n        return this.channel.getNonceForAddress(contractAddress, blockIdentifier);\n    }\n    async getBlock(blockIdentifier) {\n        return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse);\n    }\n    /**\n   * Get the most recent accepted block hash and number\n   */ async getBlockLatestAccepted() {\n        return this.channel.getBlockLatestAccepted();\n    }\n    /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */ async getBlockNumber() {\n        return this.channel.getBlockNumber();\n    }\n    async getBlockWithTxHashes(blockIdentifier) {\n        return this.channel.getBlockWithTxHashes(blockIdentifier);\n    }\n    async getBlockWithTxs(blockIdentifier) {\n        return this.channel.getBlockWithTxs(blockIdentifier);\n    }\n    /**\n   * Pause the execution of the script until a specified block is created.\n   * @param {BlockIdentifier} blockIdentifier bloc number (BigNumberisk) or 'pending' or 'latest'.\n   * Use of 'latest\" or of a block already created will generate no pause.\n   * @param {number} [retryInterval] number of milliseconds between 2 requests to the node\n   * @example\n   * ```typescript\n   * await myProvider.waitForBlock();\n   * // wait the creation of the pending block\n   * ```\n   */ async waitForBlock(blockIdentifier = \"pending\", retryInterval = 5e3) {\n        if (blockIdentifier === \"latest\" /* LATEST */ ) return;\n        const currentBlock = await this.getBlockNumber();\n        const targetBlock = blockIdentifier === \"pending\" /* PENDING */  ? currentBlock + 1 : Number(toHex(blockIdentifier));\n        if (targetBlock <= currentBlock) return;\n        const { retries } = this.channel;\n        let retriesCount = retries;\n        let isTargetBlock = false;\n        while(!isTargetBlock){\n            const currBlock = await this.getBlockNumber();\n            if (currBlock === targetBlock) {\n                isTargetBlock = true;\n            } else {\n                await wait(retryInterval);\n            }\n            retriesCount -= 1;\n            if (retriesCount <= 0) {\n                throw new Error(`waitForBlock() timed-out after ${retries} tries.`);\n            }\n        }\n    }\n    async getL1GasPrice(blockIdentifier) {\n        return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseL1GasPriceResponse);\n    }\n    async getL1MessageHash(l2TxHash) {\n        const transaction = await this.channel.getTransactionByHash(l2TxHash);\n        assert(transaction.type === \"L1_HANDLER\", \"This L2 transaction is not a L1 message.\");\n        const { calldata, contract_address, entry_point_selector, nonce } = transaction;\n        const params = [\n            calldata[0],\n            contract_address,\n            nonce,\n            entry_point_selector,\n            calldata.length - 1,\n            ...calldata.slice(1)\n        ];\n        const myEncode = addHexPrefix(params.reduce((res, par)=>res + removeHexPrefix(toHex(par)).padStart(64, \"0\"), \"\"));\n        return addHexPrefix((0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_3__.bytesToHex)((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_13__.keccak_256)(hexToBytes(myEncode))));\n    }\n    async getBlockWithReceipts(blockIdentifier) {\n        if (this.channel instanceof rpc_0_6_exports.RpcChannel) throw new LibraryError(\"Unsupported method for RPC version\");\n        return this.channel.getBlockWithReceipts(blockIdentifier);\n    }\n    async getBlockStateUpdate(blockIdentifier) {\n        return this.channel.getBlockStateUpdate(blockIdentifier);\n    }\n    async getBlockTransactionsTraces(blockIdentifier) {\n        return this.channel.getBlockTransactionsTraces(blockIdentifier);\n    }\n    async getBlockTransactionCount(blockIdentifier) {\n        return this.channel.getBlockTransactionCount(blockIdentifier);\n    }\n    /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.PENDING); (will be removed in next minor version)\n   * Utility method, same result can be achieved using getBlockWithTxHashes(BlockTag.pending);\n   */ async getPendingTransactions() {\n        const { transactions } = await this.getBlockWithTxHashes(\"pending\" /* PENDING */ ).then(this.responseParser.parseGetBlockResponse);\n        return Promise.all(transactions.map((it)=>this.getTransactionByHash(it)));\n    }\n    async getTransaction(txHash) {\n        return this.channel.getTransactionByHash(txHash);\n    }\n    async getTransactionByHash(txHash) {\n        return this.channel.getTransactionByHash(txHash);\n    }\n    async getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n        return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index);\n    }\n    async getTransactionReceipt(txHash) {\n        const txReceiptWoHelper = await this.channel.getTransactionReceipt(txHash);\n        const txReceiptWoHelperModified = this.responseParser.parseTransactionReceipt(txReceiptWoHelper);\n        return new ReceiptTx(txReceiptWoHelperModified);\n    }\n    async getTransactionTrace(txHash) {\n        return this.channel.getTransactionTrace(txHash);\n    }\n    /**\n   * Get the status of a transaction\n   */ async getTransactionStatus(transactionHash) {\n        return this.channel.getTransactionStatus(transactionHash);\n    }\n    /**\n   * @param invocations AccountInvocations\n   * @param options blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */ async getSimulateTransaction(invocations, options) {\n        return this.channel.simulateTransaction(invocations, options).then((r)=>this.responseParser.parseSimulateTransactionResponse(r));\n    }\n    async waitForTransaction(txHash, options) {\n        const receiptWoHelper = await this.channel.waitForTransaction(txHash, options);\n        return new ReceiptTx(receiptWoHelper);\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier) {\n        return this.channel.getStorageAt(contractAddress, key, blockIdentifier);\n    }\n    async getClassHashAt(contractAddress, blockIdentifier) {\n        return this.channel.getClassHashAt(contractAddress, blockIdentifier);\n    }\n    async getClassByHash(classHash) {\n        return this.getClass(classHash);\n    }\n    async getClass(classHash, blockIdentifier) {\n        return this.channel.getClass(classHash, blockIdentifier).then(this.responseParser.parseContractClassResponse);\n    }\n    async getClassAt(contractAddress, blockIdentifier) {\n        return this.channel.getClassAt(contractAddress, blockIdentifier).then(this.responseParser.parseContractClassResponse);\n    }\n    async getContractVersion(contractAddress, classHash, { blockIdentifier = this.channel.blockIdentifier, compiler = true } = {}) {\n        let contractClass;\n        if (contractAddress) {\n            contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n        } else if (classHash) {\n            contractClass = await this.getClass(classHash, blockIdentifier);\n        } else {\n            throw Error(\"getContractVersion require contractAddress or classHash\");\n        }\n        if (isSierra(contractClass)) {\n            if (compiler) {\n                const abiTest = getAbiContractVersion(contractClass.abi);\n                return {\n                    cairo: \"1\",\n                    compiler: abiTest.compiler\n                };\n            }\n            return {\n                cairo: \"1\",\n                compiler: void 0\n            };\n        }\n        return {\n            cairo: \"0\",\n            compiler: \"0\"\n        };\n    }\n    /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */ async getEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {\n        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n    }\n    async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {\n        return this.channel.getEstimateFee([\n            {\n                type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n                ...invocation,\n                ...invocationDetails\n            }\n        ], {\n            blockIdentifier,\n            skipValidate\n        }).then((r)=>this.responseParser.parseFeeEstimateResponse(r));\n    }\n    async getDeclareEstimateFee(invocation, details, blockIdentifier, skipValidate) {\n        return this.channel.getEstimateFee([\n            {\n                type: \"DECLARE\" /* DECLARE */ ,\n                ...invocation,\n                ...details\n            }\n        ], {\n            blockIdentifier,\n            skipValidate\n        }).then((r)=>this.responseParser.parseFeeEstimateResponse(r));\n    }\n    async getDeployAccountEstimateFee(invocation, details, blockIdentifier, skipValidate) {\n        return this.channel.getEstimateFee([\n            {\n                type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n                ...invocation,\n                ...details\n            }\n        ], {\n            blockIdentifier,\n            skipValidate\n        }).then((r)=>this.responseParser.parseFeeEstimateResponse(r));\n    }\n    async getEstimateFeeBulk(invocations, options) {\n        return this.channel.getEstimateFee(invocations, options).then((r)=>this.responseParser.parseFeeEstimateBulkResponse(r));\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.channel.invoke(functionInvocation, details);\n    }\n    async declareContract(transaction, details) {\n        return this.channel.declare(transaction, details);\n    }\n    async deployAccountContract(transaction, details) {\n        return this.channel.deployAccount(transaction, details);\n    }\n    async callContract(call, blockIdentifier) {\n        return this.channel.callContract(call, blockIdentifier);\n    }\n    /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */ async estimateMessageFee(message, blockIdentifier) {\n        return this.channel.estimateMessageFee(message, blockIdentifier);\n    }\n    /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */ async getSyncingStats() {\n        return this.channel.getSyncingStats();\n    }\n    /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */ async getEvents(eventFilter) {\n        return this.channel.getEvents(eventFilter);\n    }\n};\n// src/provider/extensions/default.ts\n\n// src/utils/starknetId.ts\nvar starknetId_exports = {};\n__export(starknetId_exports, {\n    StarknetIdContract: ()=>StarknetIdContract,\n    StarknetIdIdentityContract: ()=>StarknetIdIdentityContract,\n    StarknetIdMulticallContract: ()=>StarknetIdMulticallContract,\n    StarknetIdPfpContract: ()=>StarknetIdPfpContract,\n    StarknetIdPopContract: ()=>StarknetIdPopContract,\n    StarknetIdVerifierContract: ()=>StarknetIdVerifierContract,\n    dynamicCallData: ()=>dynamicCallData,\n    dynamicFelt: ()=>dynamicFelt,\n    execution: ()=>execution,\n    getStarknetIdContract: ()=>getStarknetIdContract,\n    getStarknetIdIdentityContract: ()=>getStarknetIdIdentityContract,\n    getStarknetIdMulticallContract: ()=>getStarknetIdMulticallContract,\n    getStarknetIdPfpContract: ()=>getStarknetIdPfpContract,\n    getStarknetIdPopContract: ()=>getStarknetIdPopContract,\n    getStarknetIdVerifierContract: ()=>getStarknetIdVerifierContract,\n    useDecoded: ()=>useDecoded,\n    useEncoded: ()=>useEncoded\n});\nvar basicAlphabet = \"abcdefghijklmnopqrstuvwxyz0123456789-\";\nvar basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nvar bigAlphabet = \"这来\";\nvar basicAlphabetSize = BigInt(basicAlphabet.length);\nvar bigAlphabetSize = BigInt(bigAlphabet.length);\nvar bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\nfunction extractStars(str) {\n    let k = 0;\n    while(str.endsWith(bigAlphabet[bigAlphabet.length - 1])){\n        str = str.substring(0, str.length - 1);\n        k += 1;\n    }\n    return [\n        str,\n        k\n    ];\n}\nfunction useDecoded(encoded) {\n    let decoded = \"\";\n    encoded.forEach((subdomain)=>{\n        while(subdomain !== ZERO){\n            const code = subdomain % basicSizePlusOne;\n            subdomain /= basicSizePlusOne;\n            if (code === BigInt(basicAlphabet.length)) {\n                const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n                if (nextSubdomain === ZERO) {\n                    const code2 = subdomain % bigAlphabetSizePlusOne;\n                    subdomain = nextSubdomain;\n                    if (code2 === ZERO) decoded += basicAlphabet[0];\n                    else decoded += bigAlphabet[Number(code2) - 1];\n                } else {\n                    const code2 = subdomain % bigAlphabetSize;\n                    decoded += bigAlphabet[Number(code2)];\n                    subdomain /= bigAlphabetSize;\n                }\n            } else decoded += basicAlphabet[Number(code)];\n        }\n        const [str, k] = extractStars(decoded);\n        if (k) decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n        decoded += \".\";\n    });\n    if (!decoded) {\n        return decoded;\n    }\n    return decoded.concat(\"stark\");\n}\nfunction useEncoded(decoded) {\n    let encoded = BigInt(0);\n    let multiplier = BigInt(1);\n    if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n        const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n        decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n    } else {\n        const [str, k] = extractStars(decoded);\n        if (k) decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n    }\n    for(let i = 0; i < decoded.length; i += 1){\n        const char = decoded[i];\n        const index = basicAlphabet.indexOf(char);\n        const bnIndex = BigInt(basicAlphabet.indexOf(char));\n        if (index !== -1) {\n            if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n                encoded += multiplier * basicAlphabetSize;\n                multiplier *= basicSizePlusOne;\n                multiplier *= basicSizePlusOne;\n            } else {\n                encoded += multiplier * bnIndex;\n                multiplier *= basicSizePlusOne;\n            }\n        } else if (bigAlphabet.indexOf(char) !== -1) {\n            encoded += multiplier * basicAlphabetSize;\n            multiplier *= basicSizePlusOne;\n            const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n            encoded += multiplier * BigInt(newid);\n            multiplier *= bigAlphabetSize;\n        }\n    }\n    return encoded;\n}\nvar StarknetIdContract = /* @__PURE__ */ ((StarknetIdContract2)=>{\n    StarknetIdContract2[\"MAINNET\"] = \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\";\n    StarknetIdContract2[\"TESTNET_SEPOLIA\"] = \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\";\n    return StarknetIdContract2;\n})(StarknetIdContract || {});\nfunction getStarknetIdContract(chainId) {\n    switch(chainId){\n        case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n            return \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\" /* MAINNET */ ;\n        case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */ :\n            return \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\" /* TESTNET_SEPOLIA */ ;\n        default:\n            throw new Error(\"Starknet.id is not yet deployed on this network\");\n    }\n}\nvar StarknetIdIdentityContract = /* @__PURE__ */ ((StarknetIdIdentityContract2)=>{\n    StarknetIdIdentityContract2[\"MAINNET\"] = \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\";\n    StarknetIdIdentityContract2[\"TESTNET_SEPOLIA\"] = \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\";\n    return StarknetIdIdentityContract2;\n})(StarknetIdIdentityContract || {});\nfunction getStarknetIdIdentityContract(chainId) {\n    switch(chainId){\n        case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n            return \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\" /* MAINNET */ ;\n        case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */ :\n            return \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\" /* TESTNET_SEPOLIA */ ;\n        default:\n            throw new Error(\"Starknet.id verifier contract is not yet deployed on this network\");\n    }\n}\nvar StarknetIdMulticallContract = \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\";\nfunction getStarknetIdMulticallContract(chainId) {\n    switch(chainId){\n        case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n            return StarknetIdMulticallContract;\n        case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */ :\n            return StarknetIdMulticallContract;\n        default:\n            throw new Error(\"Starknet.id multicall contract is not yet deployed on this network\");\n    }\n}\nvar StarknetIdVerifierContract = /* @__PURE__ */ ((StarknetIdVerifierContract2)=>{\n    StarknetIdVerifierContract2[\"MAINNET\"] = \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\";\n    StarknetIdVerifierContract2[\"TESTNET_SEPOLIA\"] = \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\";\n    return StarknetIdVerifierContract2;\n})(StarknetIdVerifierContract || {});\nfunction getStarknetIdVerifierContract(chainId) {\n    switch(chainId){\n        case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n            return \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\" /* MAINNET */ ;\n        case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */ :\n            return \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\" /* TESTNET_SEPOLIA */ ;\n        default:\n            throw new Error(\"Starknet.id verifier contract is not yet deployed on this network\");\n    }\n}\nvar StarknetIdPfpContract = /* @__PURE__ */ ((StarknetIdPfpContract2)=>{\n    StarknetIdPfpContract2[\"MAINNET\"] = \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\";\n    StarknetIdPfpContract2[\"TESTNET_SEPOLIA\"] = \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\";\n    return StarknetIdPfpContract2;\n})(StarknetIdPfpContract || {});\nfunction getStarknetIdPfpContract(chainId) {\n    switch(chainId){\n        case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n            return \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\" /* MAINNET */ ;\n        case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */ :\n            return \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\" /* TESTNET_SEPOLIA */ ;\n        default:\n            throw new Error(\"Starknet.id profile picture verifier contract is not yet deployed on this network\");\n    }\n}\nvar StarknetIdPopContract = /* @__PURE__ */ ((StarknetIdPopContract2)=>{\n    StarknetIdPopContract2[\"MAINNET\"] = \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\";\n    StarknetIdPopContract2[\"TESTNET_SEPOLIA\"] = \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\";\n    return StarknetIdPopContract2;\n})(StarknetIdPopContract || {});\nfunction getStarknetIdPopContract(chainId) {\n    switch(chainId){\n        case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n            return \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\" /* MAINNET */ ;\n        case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */ :\n            return \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\" /* TESTNET_SEPOLIA */ ;\n        default:\n            throw new Error(\"Starknet.id proof of personhood verifier contract is not yet deployed on this network\");\n    }\n}\nfunction execution(staticEx, ifEqual = void 0, ifNotEqual = void 0) {\n    return new CairoCustomEnum({\n        Static: staticEx,\n        IfEqual: ifEqual ? tuple(ifEqual[0], ifEqual[1], ifEqual[2]) : void 0,\n        IfNotEqual: ifNotEqual ? tuple(ifNotEqual[0], ifNotEqual[1], ifNotEqual[2]) : void 0\n    });\n}\nfunction dynamicFelt(hardcoded, reference = void 0) {\n    return new CairoCustomEnum({\n        Hardcoded: hardcoded,\n        Reference: reference ? tuple(reference[0], reference[1]) : void 0\n    });\n}\nfunction dynamicCallData(hardcoded, reference = void 0, arrayReference = void 0) {\n    return new CairoCustomEnum({\n        Hardcoded: hardcoded,\n        Reference: reference ? tuple(reference[0], reference[1]) : void 0,\n        ArrayReference: arrayReference ? tuple(arrayReference[0], arrayReference[1]) : void 0\n    });\n}\n// src/provider/extensions/starknetId.ts\nvar StarknetId = class _StarknetId {\n    async getStarkName(address, StarknetIdContract2) {\n        return _StarknetId.getStarkName(// After Mixin, this is ProviderInterface\n        this, address, StarknetIdContract2);\n    }\n    async getAddressFromStarkName(name, StarknetIdContract2) {\n        return _StarknetId.getAddressFromStarkName(// After Mixin, this is ProviderInterface\n        this, name, StarknetIdContract2);\n    }\n    async getStarkProfile(address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {\n        return _StarknetId.getStarkProfile(// After Mixin, this is ProviderInterface\n        this, address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2);\n    }\n    static async getStarkName(provider, address, StarknetIdContract2) {\n        const chainId = await provider.getChainId();\n        const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n        try {\n            const hexDomain = await provider.callContract({\n                contractAddress: contract,\n                entrypoint: \"address_to_domain\",\n                calldata: CallData.compile({\n                    address,\n                    hint: []\n                })\n            });\n            const decimalDomain = hexDomain.map((element)=>BigInt(element)).slice(1);\n            const stringDomain = useDecoded(decimalDomain);\n            if (!stringDomain) {\n                throw Error(\"Starkname not found\");\n            }\n            return stringDomain;\n        } catch (e) {\n            if (e instanceof Error && e.message === \"Starkname not found\") {\n                throw e;\n            }\n            throw Error(\"Could not get stark name\");\n        }\n    }\n    static async getAddressFromStarkName(provider, name, StarknetIdContract2) {\n        const chainId = await provider.getChainId();\n        const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n        try {\n            const encodedDomain = name.replace(\".stark\", \"\").split(\".\").map((part)=>useEncoded(part).toString(10));\n            const addressData = await provider.callContract({\n                contractAddress: contract,\n                entrypoint: \"domain_to_address\",\n                calldata: CallData.compile({\n                    domain: encodedDomain,\n                    hint: []\n                })\n            });\n            return addressData[0];\n        } catch  {\n            throw Error(\"Could not get address from stark name\");\n        }\n    }\n    static async getStarkProfile(provider, address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {\n        const chainId = await provider.getChainId();\n        const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n        const identityContract = StarknetIdIdentityContract2 ?? getStarknetIdIdentityContract(chainId);\n        const verifierContract = StarknetIdVerifierContract2 ?? getStarknetIdVerifierContract(chainId);\n        const pfpContract = StarknetIdPfpContract2 ?? getStarknetIdPfpContract(chainId);\n        const popContract = StarknetIdPopContract2 ?? getStarknetIdPopContract(chainId);\n        const multicallAddress = StarknetIdMulticallContract2 ?? getStarknetIdMulticallContract(chainId);\n        try {\n            const calls = [\n                {\n                    execution: execution({}),\n                    to: dynamicCallData(contract),\n                    selector: dynamicCallData(getSelectorFromName(\"address_to_domain\")),\n                    calldata: [\n                        dynamicCallData(address),\n                        dynamicCallData(\"0\")\n                    ]\n                },\n                {\n                    execution: execution({}),\n                    to: dynamicFelt(contract),\n                    selector: dynamicFelt(getSelectorFromName(\"domain_to_id\")),\n                    calldata: [\n                        dynamicCallData(void 0, void 0, [\n                            0,\n                            0\n                        ])\n                    ]\n                },\n                {\n                    execution: execution({}),\n                    to: dynamicFelt(identityContract),\n                    selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n                    calldata: [\n                        dynamicCallData(void 0, [\n                            1,\n                            0\n                        ]),\n                        dynamicCallData(encodeShortString(\"twitter\")),\n                        dynamicCallData(verifierContract),\n                        dynamicCallData(\"0\")\n                    ]\n                },\n                {\n                    execution: execution({}),\n                    to: dynamicFelt(identityContract),\n                    selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n                    calldata: [\n                        dynamicCallData(void 0, [\n                            1,\n                            0\n                        ]),\n                        dynamicCallData(encodeShortString(\"github\")),\n                        dynamicCallData(verifierContract),\n                        dynamicCallData(\"0\")\n                    ]\n                },\n                {\n                    execution: execution({}),\n                    to: dynamicFelt(identityContract),\n                    selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n                    calldata: [\n                        dynamicCallData(void 0, [\n                            1,\n                            0\n                        ]),\n                        dynamicCallData(encodeShortString(\"discord\")),\n                        dynamicCallData(verifierContract),\n                        dynamicCallData(\"0\")\n                    ]\n                },\n                {\n                    execution: execution({}),\n                    to: dynamicFelt(identityContract),\n                    selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n                    calldata: [\n                        dynamicCallData(void 0, [\n                            1,\n                            0\n                        ]),\n                        dynamicCallData(encodeShortString(\"proof_of_personhood\")),\n                        dynamicCallData(popContract),\n                        dynamicCallData(\"0\")\n                    ]\n                },\n                // PFP\n                {\n                    execution: execution({}),\n                    to: dynamicFelt(identityContract),\n                    selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n                    calldata: [\n                        dynamicCallData(void 0, [\n                            1,\n                            0\n                        ]),\n                        dynamicCallData(encodeShortString(\"nft_pp_contract\")),\n                        dynamicCallData(pfpContract),\n                        dynamicCallData(\"0\")\n                    ]\n                },\n                {\n                    execution: execution({}),\n                    to: dynamicFelt(identityContract),\n                    selector: dynamicFelt(getSelectorFromName(\"get_extended_verifier_data\")),\n                    calldata: [\n                        dynamicCallData(void 0, [\n                            1,\n                            0\n                        ]),\n                        dynamicCallData(encodeShortString(\"nft_pp_id\")),\n                        dynamicCallData(\"2\"),\n                        dynamicCallData(pfpContract),\n                        dynamicCallData(\"0\")\n                    ]\n                },\n                {\n                    execution: execution(void 0, void 0, [\n                        6,\n                        0,\n                        0\n                    ]),\n                    to: dynamicFelt(void 0, [\n                        6,\n                        0\n                    ]),\n                    selector: dynamicFelt(getSelectorFromName(\"tokenURI\")),\n                    calldata: [\n                        dynamicCallData(void 0, [\n                            7,\n                            1\n                        ]),\n                        dynamicCallData(void 0, [\n                            7,\n                            2\n                        ])\n                    ]\n                }\n            ];\n            const data = await provider.callContract({\n                contractAddress: multicallAddress,\n                entrypoint: \"aggregate\",\n                calldata: CallData.compile({\n                    calls\n                })\n            });\n            if (Array.isArray(data)) {\n                const size = parseInt(data[0], 16);\n                const finalArray = [];\n                let index = 1;\n                for(let i = 0; i < size; i += 1){\n                    if (index < data.length) {\n                        const subArraySize = parseInt(data[index], 16);\n                        index += 1;\n                        const subArray = data.slice(index, index + subArraySize);\n                        finalArray.push(subArray);\n                        index += subArraySize;\n                    } else {\n                        break;\n                    }\n                }\n                const name = useDecoded(finalArray[0].slice(1).map((hexString)=>BigInt(hexString)));\n                const twitter = finalArray[2][0] !== \"0x0\" ? BigInt(finalArray[2][0]).toString() : void 0;\n                const github = finalArray[3][0] !== \"0x0\" ? BigInt(finalArray[3][0]).toString() : void 0;\n                const discord = finalArray[4][0] !== \"0x0\" ? BigInt(finalArray[4][0]).toString() : void 0;\n                const proofOfPersonhood = finalArray[5][0] === \"0x1\";\n                const profilePictureMetadata = data[0] === \"0x9\" ? finalArray[8].slice(1).map((val)=>decodeShortString(val)).join(\"\") : void 0;\n                const profilePicture = profilePictureMetadata || `https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`;\n                return {\n                    name,\n                    twitter,\n                    github,\n                    discord,\n                    proofOfPersonhood,\n                    profilePicture\n                };\n            }\n            throw Error(\"Error while calling aggregate function\");\n        } catch (e) {\n            if (e instanceof Error) {\n                throw e;\n            }\n            throw Error(\"Could not get user stark profile data from address\");\n        }\n    }\n};\n// src/provider/extensions/default.ts\nvar RpcProvider2 = class extends (0,ts_mixer__WEBPACK_IMPORTED_MODULE_14__.Mixin)(RpcProvider, StarknetId) {\n};\n// src/provider/interface.ts\nvar ProviderInterface = class {\n};\n// src/provider/index.ts\nvar defaultProvider = new RpcProvider({\n    default: true\n});\n// src/signer/interface.ts\nvar SignerInterface = class {\n};\n// src/utils/typedData.ts\nvar typedData_exports = {};\n__export(typedData_exports, {\n    TypedDataRevision: ()=>starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision,\n    encodeData: ()=>encodeData,\n    encodeType: ()=>encodeType,\n    encodeValue: ()=>encodeValue,\n    getDependencies: ()=>getDependencies,\n    getMessageHash: ()=>getMessageHash,\n    getStructHash: ()=>getStructHash,\n    getTypeHash: ()=>getTypeHash,\n    isMerkleTreeType: ()=>isMerkleTreeType,\n    prepareSelector: ()=>prepareSelector\n});\n// src/utils/merkle.ts\nvar merkle_exports = {};\n__export(merkle_exports, {\n    MerkleTree: ()=>MerkleTree,\n    proofMerklePath: ()=>proofMerklePath\n});\nvar MerkleTree = class _MerkleTree {\n    /**\n   * Create a Merkle tree\n   *\n   * @param leafHashes hex-string array\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns created Merkle tree\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * // tree = {\n   * //   branches: [['0x5bb9440e2...', '0x262697b88...', ...], ['0x38118a340...', ...], ...],\n   * //   leaves: ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'],\n   * //   root: '0x7f748c75e5bdb7ae28013f076b8ab650c4e01d3530c6e5ab665f9f1accbe7d4',\n   * //   hashMethod: [Function computePedersenHash],\n   * // }\n   * ```\n   */ constructor(leafHashes, hashMethod = computePedersenHash){\n        this.branches = [];\n        this.hashMethod = hashMethod;\n        this.leaves = leafHashes;\n        this.root = this.build(leafHashes);\n    }\n    /** @ignore */ build(leaves) {\n        if (leaves.length === 1) {\n            return leaves[0];\n        }\n        if (leaves.length !== this.leaves.length) {\n            this.branches.push(leaves);\n        }\n        const newLeaves = [];\n        for(let i = 0; i < leaves.length; i += 2){\n            if (i + 1 === leaves.length) {\n                newLeaves.push(_MerkleTree.hash(leaves[i], \"0x0\", this.hashMethod));\n            } else {\n                newLeaves.push(_MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));\n            }\n        }\n        return this.build(newLeaves);\n    }\n    /**\n   * Calculate hash from ordered a and b, Pedersen hash default\n   *\n   * @param a first value\n   * @param b second value\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns result of the hash function\n   * @example\n   * ```typescript\n   * const result1 = MerkleTree.hash('0xabc', '0xdef');\n   * // result1 = '0x484f029da7914ada038b1adf67fc83632364a3ebc2cd9349b41ab61626d9e82'\n   *\n   * const customHashMethod = (a, b) => `custom_${a}_${b}`;\n   * const result2 = MerkleTree.hash('0xabc', '0xdef', customHashMethod);\n   * // result2 = 'custom_2748_3567'\n   * ```\n   */ static hash(a, b, hashMethod = computePedersenHash) {\n        const [aSorted, bSorted] = [\n            BigInt(a),\n            BigInt(b)\n        ].sort((x, y)=>x >= y ? 1 : -1);\n        return hashMethod(aSorted, bSorted);\n    }\n    /**\n   * Calculates the merkle membership proof path\n   *\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns collection of merkle proof hex-string hashes\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * const result = tree.getProof('0x3');\n   * // result = [\n   * //   '0x4',\n   * //   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',\n   * //   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',\n   * // ]\n   * ```\n   */ getProof(leaf, branch = this.leaves, hashPath = []) {\n        const index = branch.indexOf(leaf);\n        if (index === -1) {\n            throw new Error(\"leaf not found\");\n        }\n        if (branch.length === 1) {\n            return hashPath;\n        }\n        const isLeft = index % 2 === 0;\n        const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? \"0x0\";\n        const newHashPath = [\n            ...hashPath,\n            neededBranch\n        ];\n        const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b)=>b.length === branch.length);\n        const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [\n            this.root\n        ];\n        return this.getProof(_MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod), nextBranch, newHashPath);\n    }\n};\nfunction proofMerklePath(root, leaf, path, hashMethod = computePedersenHash) {\n    if (path.length === 0) {\n        return root === leaf;\n    }\n    const [next, ...rest] = path;\n    return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);\n}\n// src/utils/typedData.ts\nvar presetTypes = {\n    u256: JSON.parse('[{ \"name\": \"low\", \"type\": \"u128\" }, { \"name\": \"high\", \"type\": \"u128\" }]'),\n    TokenAmount: JSON.parse('[{ \"name\": \"token_address\", \"type\": \"ContractAddress\" }, { \"name\": \"amount\", \"type\": \"u256\" }]'),\n    NftId: JSON.parse('[{ \"name\": \"collection_address\", \"type\": \"ContractAddress\" }, { \"name\": \"token_id\", \"type\": \"u256\" }]')\n};\nvar revisionConfiguration = {\n    [starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE]: {\n        domain: \"StarknetDomain\",\n        hashMethod: computePoseidonHashOnElements,\n        hashMerkleMethod: computePoseidonHash,\n        escapeTypeString: (s)=>`\"${s}\"`,\n        presetTypes\n    },\n    [starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY]: {\n        domain: \"StarkNetDomain\",\n        hashMethod: computePedersenHashOnElements,\n        hashMerkleMethod: computePedersenHash,\n        escapeTypeString: (s)=>s,\n        presetTypes: {}\n    }\n};\nfunction assertRange(data, type, { min, max }) {\n    const value = BigInt(data);\n    assert(value >= min && value <= max, `${value} (${type}) is out of bounds [${min}, ${max}]`);\n}\nfunction identifyRevision({ types, domain }) {\n    if (revisionConfiguration[starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE].domain in types && domain.revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) return starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE;\n    if (revisionConfiguration[starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY].domain in types && (domain.revision ?? starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) return starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY;\n    return void 0;\n}\nfunction getHex(value) {\n    try {\n        return toHex(value);\n    } catch (e) {\n        if (isString(value)) {\n            return toHex(encodeShortString(value));\n        }\n        throw new Error(`Invalid BigNumberish: ${value}`);\n    }\n}\nfunction validateTypedData(data) {\n    const typedData = data;\n    return Boolean(typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData));\n}\nfunction prepareSelector(selector) {\n    return isHex(selector) ? selector : getSelectorFromName(selector);\n}\nfunction isMerkleTreeType(type) {\n    return type.type === \"merkletree\";\n}\nfunction getDependencies(types, type, dependencies = [], contains = \"\", revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n    if (type[type.length - 1] === \"*\") {\n        type = type.slice(0, -1);\n    } else if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        if (type === \"enum\") {\n            type = contains;\n        } else if (type.match(/^\\(.*\\)$/)) {\n            type = type.slice(1, -1);\n        }\n    }\n    if (dependencies.includes(type) || !types[type]) {\n        return dependencies;\n    }\n    return [\n        type,\n        ...types[type].reduce((previous, t)=>[\n                ...previous,\n                ...getDependencies(types, t.type, previous, t.contains, revision).filter((dependency)=>!previous.includes(dependency))\n            ], [])\n    ];\n}\nfunction getMerkleTreeType(types, ctx) {\n    if (ctx.parent && ctx.key) {\n        const parentType = types[ctx.parent];\n        const merkleType = parentType.find((t)=>t.name === ctx.key);\n        const isMerkleTree = isMerkleTreeType(merkleType);\n        if (!isMerkleTree) {\n            throw new Error(`${ctx.key} is not a merkle tree`);\n        }\n        if (merkleType.contains.endsWith(\"*\")) {\n            throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n        }\n        return merkleType.contains;\n    }\n    return \"raw\";\n}\nfunction encodeType(types, type, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n    const allTypes = revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE ? {\n        ...types,\n        ...revisionConfiguration[revision].presetTypes\n    } : types;\n    const [primary, ...dependencies] = getDependencies(allTypes, type, void 0, void 0, revision);\n    const newTypes = !primary ? [] : [\n        primary,\n        ...dependencies.sort()\n    ];\n    const esc = revisionConfiguration[revision].escapeTypeString;\n    return newTypes.map((dependency)=>{\n        const dependencyElements = allTypes[dependency].map((t)=>{\n            const targetType = t.type === \"enum\" && revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE ? t.contains : t.type;\n            const typeString = targetType.match(/^\\(.*\\)$/) ? `(${targetType.slice(1, -1).split(\",\").map((e)=>e ? esc(e) : e).join(\",\")})` : esc(targetType);\n            return `${esc(t.name)}:${typeString}`;\n        });\n        return `${esc(dependency)}(${dependencyElements})`;\n    }).join(\"\");\n}\nfunction getTypeHash(types, type, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n    return getSelectorFromName(encodeType(types, type, revision));\n}\nfunction encodeValue(types, type, data, ctx = {}, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n    if (types[type]) {\n        return [\n            type,\n            getStructHash(types, type, data, revision)\n        ];\n    }\n    if (revisionConfiguration[revision].presetTypes[type]) {\n        return [\n            type,\n            getStructHash(revisionConfiguration[revision].presetTypes, type, data, revision)\n        ];\n    }\n    if (type.endsWith(\"*\")) {\n        const hashes = data.map((entry)=>encodeValue(types, type.slice(0, -1), entry, void 0, revision)[1]);\n        return [\n            type,\n            revisionConfiguration[revision].hashMethod(hashes)\n        ];\n    }\n    switch(type){\n        case \"enum\":\n            {\n                if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n                    const [variantKey, variantData] = Object.entries(data)[0];\n                    const parentType = types[ctx.parent][0];\n                    const enumType = types[parentType.contains];\n                    const variantType = enumType.find((t)=>t.name === variantKey);\n                    const variantIndex = enumType.indexOf(variantType);\n                    const encodedSubtypes = variantType.type.slice(1, -1).split(\",\").map((subtype, index)=>{\n                        if (!subtype) return subtype;\n                        const subtypeData = variantData[index];\n                        return encodeValue(types, subtype, subtypeData, void 0, revision)[1];\n                    });\n                    return [\n                        type,\n                        revisionConfiguration[revision].hashMethod([\n                            variantIndex,\n                            ...encodedSubtypes\n                        ])\n                    ];\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        case \"merkletree\":\n            {\n                const merkleTreeType = getMerkleTreeType(types, ctx);\n                const structHashes = data.map((struct)=>{\n                    return encodeValue(types, merkleTreeType, struct, void 0, revision)[1];\n                });\n                const { root } = new MerkleTree(structHashes, revisionConfiguration[revision].hashMerkleMethod);\n                return [\n                    \"felt\",\n                    root\n                ];\n            }\n        case \"selector\":\n            {\n                return [\n                    \"felt\",\n                    prepareSelector(data)\n                ];\n            }\n        case \"string\":\n            {\n                if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n                    const byteArray = byteArrayFromString(data);\n                    const elements = [\n                        byteArray.data.length,\n                        ...byteArray.data,\n                        byteArray.pending_word,\n                        byteArray.pending_word_len\n                    ];\n                    return [\n                        type,\n                        revisionConfiguration[revision].hashMethod(elements)\n                    ];\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        case \"i128\":\n            {\n                if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n                    const value = BigInt(data);\n                    assertRange(value, type, RANGE_I128);\n                    return [\n                        type,\n                        getHex(value < 0n ? PRIME + value : value)\n                    ];\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        case \"timestamp\":\n        case \"u128\":\n            {\n                if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n                    assertRange(data, type, RANGE_U128);\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        case \"felt\":\n        case \"shortstring\":\n            {\n                if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n                    assertRange(getHex(data), type, RANGE_FELT);\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        case \"ClassHash\":\n        case \"ContractAddress\":\n            {\n                if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n                    assertRange(data, type, RANGE_FELT);\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        case \"bool\":\n            {\n                if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n                    assert(typeof data === \"boolean\", `Type mismatch for ${type} ${data}`);\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        default:\n            {\n                if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n                    throw new Error(`Unsupported type: ${type}`);\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n    }\n}\nfunction encodeData(types, type, data, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n    const targetType = types[type] ?? revisionConfiguration[revision].presetTypes[type];\n    const [returnTypes, values] = targetType.reduce(([ts, vs], field)=>{\n        if (data[field.name] === void 0 || data[field.name] === null && field.type !== \"enum\") {\n            throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n        }\n        const value = data[field.name];\n        const ctx = {\n            parent: type,\n            key: field.name\n        };\n        const [t, encodedValue] = encodeValue(types, field.type, value, ctx, revision);\n        return [\n            [\n                ...ts,\n                t\n            ],\n            [\n                ...vs,\n                encodedValue\n            ]\n        ];\n    }, [\n        [\n            \"felt\"\n        ],\n        [\n            getTypeHash(types, type, revision)\n        ]\n    ]);\n    return [\n        returnTypes,\n        values\n    ];\n}\nfunction getStructHash(types, type, data, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n    return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);\n}\nfunction getMessageHash(typedData, account) {\n    if (!validateTypedData(typedData)) {\n        throw new Error(\"Typed data does not match JSON schema\");\n    }\n    const revision = identifyRevision(typedData);\n    const { domain, hashMethod } = revisionConfiguration[revision];\n    const message = [\n        encodeShortString(\"StarkNet Message\"),\n        getStructHash(typedData.types, domain, typedData.domain, revision),\n        account,\n        getStructHash(typedData.types, typedData.primaryType, typedData.message, revision)\n    ];\n    return hashMethod(message);\n}\n// src/signer/default.ts\nvar Signer = class {\n    constructor(pk = _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.utils.randomPrivateKey()){\n        this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n    }\n    async getPubKey() {\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.getStarkKey(this.pk);\n    }\n    async signMessage(typedData, accountAddress) {\n        const msgHash = getMessageHash(typedData, accountAddress);\n        return this.signRaw(msgHash);\n    }\n    async signTransaction(transactions, details) {\n        const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n        let msgHash;\n        if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n            const det = details;\n            msgHash = calculateInvokeTransactionHash2({\n                ...det,\n                senderAddress: det.walletAddress,\n                compiledCalldata,\n                version: det.version\n            });\n        } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n            const det = details;\n            msgHash = calculateInvokeTransactionHash2({\n                ...det,\n                senderAddress: det.walletAddress,\n                compiledCalldata,\n                version: det.version,\n                nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n                feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n            });\n        } else {\n            throw Error(\"unsupported signTransaction version\");\n        }\n        return this.signRaw(msgHash);\n    }\n    async signDeployAccountTransaction(details) {\n        const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n        let msgHash;\n        if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeployAccountTransactionHash3({\n                ...det,\n                salt: det.addressSalt,\n                constructorCalldata: compiledConstructorCalldata,\n                version: det.version\n            });\n        } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeployAccountTransactionHash3({\n                ...det,\n                salt: det.addressSalt,\n                compiledConstructorCalldata,\n                version: det.version,\n                nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n                feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n            });\n        } else {\n            throw Error(\"unsupported signDeployAccountTransaction version\");\n        }\n        return this.signRaw(msgHash);\n    }\n    async signDeclareTransaction(details) {\n        let msgHash;\n        if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeclareTransactionHash3({\n                ...det,\n                version: det.version\n            });\n        } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeclareTransactionHash3({\n                ...det,\n                version: det.version,\n                nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n                feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n            });\n        } else {\n            throw Error(\"unsupported signDeclareTransaction version\");\n        }\n        return this.signRaw(msgHash);\n    }\n    async signRaw(msgHash) {\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_4__.sign(msgHash, this.pk);\n    }\n};\n// src/signer/ethSigner.ts\n\n// src/utils/uint256.ts\nvar uint256_exports = {};\n__export(uint256_exports, {\n    UINT_128_MAX: ()=>UINT_128_MAX,\n    UINT_256_MAX: ()=>UINT_256_MAX,\n    bnToUint256: ()=>bnToUint256,\n    isUint256: ()=>isUint256,\n    uint256ToBN: ()=>uint256ToBN\n});\nfunction uint256ToBN(uint2562) {\n    return new CairoUint256(uint2562).toBigInt();\n}\nfunction isUint256(bn) {\n    return CairoUint256.is(bn);\n}\nfunction bnToUint256(bn) {\n    return new CairoUint256(bn).toUint256HexString();\n}\n// src/signer/ethSigner.ts\nvar EthSigner = class {\n    // hex string without 0x and with an odd number of characters\n    constructor(pk = ethRandomPrivateKey()){\n        this.pk = pk instanceof Uint8Array ? buf2hex(pk).padStart(64, \"0\") : removeHexPrefix(toHex(pk)).padStart(64, \"0\");\n    }\n    /**\n   * provides the Ethereum full public key (without parity prefix)\n   * @returns an hex string : 64 first characters are Point X coordinate. 64 last characters are Point Y coordinate.\n   */ async getPubKey() {\n        return addHexPrefix(buf2hex(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.getPublicKey(this.pk, false)).padStart(130, \"0\").slice(2));\n    }\n    async signMessage(typedData, accountAddress) {\n        const msgHash = getMessageHash(typedData, accountAddress);\n        const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);\n        return this.formatEthSignature(signature);\n    }\n    async signTransaction(transactions, details) {\n        const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n        let msgHash;\n        if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n            const det = details;\n            msgHash = calculateInvokeTransactionHash2({\n                ...det,\n                senderAddress: det.walletAddress,\n                compiledCalldata,\n                version: det.version\n            });\n        } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n            const det = details;\n            msgHash = calculateInvokeTransactionHash2({\n                ...det,\n                senderAddress: det.walletAddress,\n                compiledCalldata,\n                version: det.version,\n                nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n                feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n            });\n        } else {\n            throw Error(\"unsupported signTransaction version\");\n        }\n        const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);\n        return this.formatEthSignature(signature);\n    }\n    async signDeployAccountTransaction(details) {\n        const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n        let msgHash;\n        if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeployAccountTransactionHash3({\n                ...det,\n                salt: det.addressSalt,\n                constructorCalldata: compiledConstructorCalldata,\n                version: det.version\n            });\n        } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeployAccountTransactionHash3({\n                ...det,\n                salt: det.addressSalt,\n                compiledConstructorCalldata,\n                version: det.version,\n                nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n                feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n            });\n        } else {\n            throw Error(\"unsupported signDeployAccountTransaction version\");\n        }\n        const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);\n        return this.formatEthSignature(signature);\n    }\n    async signDeclareTransaction(details) {\n        let msgHash;\n        if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeclareTransactionHash3({\n                ...det,\n                version: det.version\n            });\n        } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n            const det = details;\n            msgHash = calculateDeclareTransactionHash3({\n                ...det,\n                version: det.version,\n                nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n                feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n            });\n        } else {\n            throw Error(\"unsupported signDeclareTransaction version\");\n        }\n        const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);\n        return this.formatEthSignature(signature);\n    }\n    /**\n   * Serialize the signature in conformity with starknet::eth_signature::Signature\n   * @param ethSignature secp256k1 signature from Noble curves library\n   * @return an array of felts, representing a Cairo Eth Signature.\n   */ formatEthSignature(ethSignature) {\n        const r = bnToUint256(ethSignature.r);\n        const s = bnToUint256(ethSignature.s);\n        return [\n            toHex(r.low),\n            toHex(r.high),\n            toHex(s.low),\n            toHex(s.high),\n            toHex(ethSignature.recovery)\n        ];\n    }\n};\n// src/utils/events/index.ts\nvar events_exports = {};\n__export(events_exports, {\n    getAbiEvents: ()=>getAbiEvents,\n    isAbiEvent: ()=>isAbiEvent,\n    isObject: ()=>isObject,\n    parseEvents: ()=>parseEvents,\n    parseUDCEvent: ()=>parseUDCEvent\n});\nfunction isAbiEvent(object) {\n    return object.type === \"event\";\n}\nfunction getCairo0AbiEvents(abi) {\n    return abi.filter((abiEntry)=>abiEntry.type === \"event\").reduce((acc, abiEntry)=>{\n        const entryName = abiEntry.name;\n        const abiEntryMod = {\n            ...abiEntry\n        };\n        abiEntryMod.name = entryName;\n        return {\n            ...acc,\n            [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod\n        };\n    }, {});\n}\nfunction getCairo1AbiEvents(abi) {\n    const abiEventsStructs = abi.filter((obj)=>isAbiEvent(obj) && obj.kind === \"struct\");\n    const abiEventsEnums = abi.filter((obj)=>isAbiEvent(obj) && obj.kind === \"enum\");\n    const abiEventsData = abiEventsStructs.reduce((acc, event)=>{\n        let nameList = [];\n        let { name } = event;\n        let flat = false;\n        const findName = (variant)=>variant.type === name;\n        while(true){\n            const eventEnum = abiEventsEnums.find((eventE)=>eventE.variants.some(findName));\n            if (typeof eventEnum === \"undefined\") break;\n            const variant = eventEnum.variants.find(findName);\n            nameList.unshift(variant.name);\n            if (variant.kind === \"flat\") flat = true;\n            name = eventEnum.name;\n        }\n        if (nameList.length === 0) {\n            throw new Error(\"inconsistency in ABI events definition.\");\n        }\n        if (flat) nameList = [\n            nameList[nameList.length - 1]\n        ];\n        const final = nameList.pop();\n        let result = {\n            [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(final)).toString(16))]: event\n        };\n        while(nameList.length > 0){\n            result = {\n                [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_4__.keccak(utf8ToArray(nameList.pop())).toString(16))]: result\n            };\n        }\n        result = {\n            ...result\n        };\n        return mergeAbiEvents(acc, result);\n    }, {});\n    return abiEventsData;\n}\nfunction getAbiEvents(abi) {\n    return isCairo1Abi(abi) ? getCairo1AbiEvents(abi) : getCairo0AbiEvents(abi);\n}\nfunction isObject(item) {\n    return item && typeof item === \"object\" && !Array.isArray(item);\n}\nfunction mergeAbiEvents(target, source) {\n    const output = {\n        ...target\n    };\n    if (isObject(target) && isObject(source)) {\n        Object.keys(source).forEach((key)=>{\n            if (isObject(source[key])) {\n                if (!(key in target)) Object.assign(output, {\n                    [key]: source[key]\n                });\n                else output[key] = mergeAbiEvents(target[key], source[key]);\n            } else {\n                Object.assign(output, {\n                    [key]: source[key]\n                });\n            }\n        });\n    }\n    return output;\n}\nfunction parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {\n    const ret = providerReceivedEvents.flat().reduce((acc, recEvent)=>{\n        let abiEvent = abiEvents[recEvent.keys.shift() ?? 0];\n        if (!abiEvent) {\n            return acc;\n        }\n        while(!abiEvent.name){\n            const hashName = recEvent.keys.shift();\n            assert(!!hashName, 'Not enough data in \"key\" property of this event.');\n            abiEvent = abiEvent[hashName];\n        }\n        const parsedEvent = {};\n        parsedEvent[abiEvent.name] = {};\n        const keysIter = recEvent.keys[Symbol.iterator]();\n        const dataIter = recEvent.data[Symbol.iterator]();\n        const abiEventKeys = abiEvent.members?.filter((it)=>it.kind === \"key\") || abiEvent.keys;\n        const abiEventData = abiEvent.members?.filter((it)=>it.kind === \"data\") || abiEvent.data;\n        abiEventKeys.forEach((key)=>{\n            parsedEvent[abiEvent.name][key.name] = responseParser(keysIter, key, abiStructs, abiEnums, parsedEvent[abiEvent.name]);\n        });\n        abiEventData.forEach((data)=>{\n            parsedEvent[abiEvent.name][data.name] = responseParser(dataIter, data, abiStructs, abiEnums, parsedEvent[abiEvent.name]);\n        });\n        acc.push(parsedEvent);\n        return acc;\n    }, []);\n    return ret;\n}\nfunction parseUDCEvent(txReceipt) {\n    if (!txReceipt.events) {\n        throw new Error(\"UDC emitted event is empty\");\n    }\n    const event = txReceipt.events.find((it)=>cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)) || {\n        data: []\n    };\n    return {\n        transaction_hash: txReceipt.transaction_hash,\n        contract_address: event.data[0],\n        address: event.data[0],\n        deployer: event.data[1],\n        unique: event.data[2],\n        classHash: event.data[3],\n        calldata_len: event.data[4],\n        calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n        salt: event.data[event.data.length - 1]\n    };\n}\n// src/account/default.ts\nvar Account = class extends RpcProvider2 {\n    constructor(providerOrOptions, address, pkOrSigner, cairoVersion, transactionVersion = api_exports.ETransactionVersion.V2){\n        super(providerOrOptions);\n        this.deploySelf = this.deployAccount;\n        this.address = address.toLowerCase();\n        this.signer = isString(pkOrSigner) || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;\n        if (cairoVersion) {\n            this.cairoVersion = cairoVersion.toString();\n        }\n        this.transactionVersion = transactionVersion;\n    }\n    // provided version or contract based preferred transactionVersion\n    getPreferredVersion(type12, type3) {\n        if (this.transactionVersion === api_exports.ETransactionVersion.V3) return type3;\n        if (this.transactionVersion === api_exports.ETransactionVersion.V2) return type12;\n        return api_exports.ETransactionVersion.V3;\n    }\n    async getNonce(blockIdentifier) {\n        return super.getNonceForAddress(this.address, blockIdentifier);\n    }\n    async getNonceSafe(nonce) {\n        try {\n            return toBigInt(nonce ?? await this.getNonce());\n        } catch (error) {\n            return 0n;\n        }\n    }\n    /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor.\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */ async getCairoVersion(classHash) {\n        if (!this.cairoVersion) {\n            const { cairo } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);\n            this.cairoVersion = cairo;\n        }\n        return this.cairoVersion;\n    }\n    async estimateFee(calls, estimateFeeDetails = {}) {\n        return this.estimateInvokeFee(calls, estimateFeeDetails);\n    }\n    async estimateInvokeFee(calls, details = {}) {\n        const { nonce: providedNonce, blockIdentifier, version: providedVersion, skipValidate = true } = details;\n        const transactions = Array.isArray(calls) ? calls : [\n            calls\n        ];\n        const nonce = toBigInt(providedNonce ?? await this.getNonce());\n        const version = toTransactionVersion(this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3), toFeeVersion(providedVersion));\n        const chainId = await this.getChainId();\n        const signerDetails = {\n            ...v3Details(details),\n            walletAddress: this.address,\n            nonce,\n            maxFee: ZERO,\n            version,\n            chainId,\n            cairoVersion: await this.getCairoVersion(),\n            skipValidate\n        };\n        const invocation = await this.buildInvocation(transactions, signerDetails);\n        return super.getInvokeEstimateFee({\n            ...invocation\n        }, {\n            ...v3Details(details),\n            version,\n            nonce\n        }, blockIdentifier, details.skipValidate);\n    }\n    async estimateDeclareFee(payload, details = {}) {\n        const { blockIdentifier, nonce: providedNonce, version: providedVersion, skipValidate = true } = details;\n        const nonce = toBigInt(providedNonce ?? await this.getNonce());\n        const version = toTransactionVersion(!isSierra(payload.contract) ? api_exports.ETransactionVersion.F1 : this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3), toFeeVersion(providedVersion));\n        const chainId = await this.getChainId();\n        const declareContractTransaction = await this.buildDeclarePayload(payload, {\n            ...v3Details(details),\n            nonce,\n            chainId,\n            version,\n            walletAddress: this.address,\n            maxFee: ZERO,\n            cairoVersion: void 0,\n            // unused parameter\n            skipValidate\n        });\n        return super.getDeclareEstimateFee(declareContractTransaction, {\n            ...v3Details(details),\n            version,\n            nonce\n        }, blockIdentifier, details.skipValidate);\n    }\n    async estimateAccountDeployFee({ classHash, addressSalt = 0, constructorCalldata = [], contractAddress }, details = {}) {\n        const { blockIdentifier, version: providedVersion, skipValidate = true } = details;\n        const version = toTransactionVersion(this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3), toFeeVersion(providedVersion));\n        const nonce = ZERO;\n        const chainId = await this.getChainId();\n        const payload = await this.buildAccountDeployPayload({\n            classHash,\n            addressSalt,\n            constructorCalldata,\n            contractAddress\n        }, {\n            ...v3Details(details),\n            nonce,\n            chainId,\n            version,\n            walletAddress: this.address,\n            // unused parameter\n            maxFee: ZERO,\n            cairoVersion: void 0,\n            // unused parameter,\n            skipValidate\n        });\n        return super.getDeployAccountEstimateFee({\n            ...payload\n        }, {\n            ...v3Details(details),\n            version,\n            nonce\n        }, blockIdentifier, details.skipValidate);\n    }\n    async estimateDeployFee(payload, details = {}) {\n        const calls = this.buildUDCContractPayload(payload);\n        return this.estimateInvokeFee(calls, details);\n    }\n    async estimateFeeBulk(invocations, details = {}) {\n        const { nonce, blockIdentifier, version, skipValidate } = details;\n        const accountInvocations = await this.accountInvocationsFactory(invocations, {\n            ...v3Details(details),\n            versions: [\n                api_exports.ETransactionVersion.F1,\n                // non-sierra\n                toTransactionVersion(this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3), version)\n            ],\n            nonce,\n            blockIdentifier,\n            skipValidate\n        });\n        return super.getEstimateFeeBulk(accountInvocations, {\n            blockIdentifier,\n            skipValidate\n        });\n    }\n    async simulateTransaction(invocations, details = {}) {\n        const { nonce, blockIdentifier, skipValidate = true, skipExecute, version } = details;\n        const accountInvocations = await this.accountInvocationsFactory(invocations, {\n            ...v3Details(details),\n            versions: [\n                api_exports.ETransactionVersion.V1,\n                // non-sierra\n                toTransactionVersion(this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3), version)\n            ],\n            nonce,\n            blockIdentifier,\n            skipValidate\n        });\n        return super.getSimulateTransaction(accountInvocations, {\n            blockIdentifier,\n            skipValidate,\n            skipExecute\n        });\n    }\n    async execute(transactions, arg2, transactionsDetail = {}) {\n        const details = arg2 === void 0 || Array.isArray(arg2) ? transactionsDetail : arg2;\n        const calls = Array.isArray(transactions) ? transactions : [\n            transactions\n        ];\n        const nonce = toBigInt(details.nonce ?? await this.getNonce());\n        const version = toTransactionVersion(this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3), // TODO: does this depend on cairo version ?\n        details.version);\n        const estimate = await this.getUniversalSuggestedFee(version, {\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            payload: transactions\n        }, {\n            ...details,\n            version\n        });\n        const chainId = await this.getChainId();\n        const signerDetails = {\n            ...v3Details(details),\n            resourceBounds: estimate.resourceBounds,\n            walletAddress: this.address,\n            nonce,\n            maxFee: estimate.maxFee,\n            version,\n            chainId,\n            cairoVersion: await this.getCairoVersion()\n        };\n        const signature = await this.signer.signTransaction(calls, signerDetails);\n        const calldata = getExecuteCalldata(calls, await this.getCairoVersion());\n        return this.invokeFunction({\n            contractAddress: this.address,\n            calldata,\n            signature\n        }, {\n            ...v3Details(details),\n            resourceBounds: estimate.resourceBounds,\n            nonce,\n            maxFee: estimate.maxFee,\n            version\n        });\n    }\n    /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */ async declareIfNot(payload, transactionsDetail = {}) {\n        const declareContractPayload = extractContractHashes(payload);\n        try {\n            await this.getClassByHash(declareContractPayload.classHash);\n        } catch (error) {\n            return this.declare(payload, transactionsDetail);\n        }\n        return {\n            transaction_hash: \"\",\n            class_hash: declareContractPayload.classHash\n        };\n    }\n    async declare(payload, details = {}) {\n        const declareContractPayload = extractContractHashes(payload);\n        const { nonce, version: providedVersion } = details;\n        const version = toTransactionVersion(!isSierra(payload.contract) ? api_exports.ETransactionVersion.V1 : this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3), providedVersion);\n        const estimate = await this.getUniversalSuggestedFee(version, {\n            type: \"DECLARE\" /* DECLARE */ ,\n            payload: declareContractPayload\n        }, {\n            ...details,\n            version\n        });\n        const declareDetails = {\n            ...v3Details(details),\n            resourceBounds: estimate.resourceBounds,\n            maxFee: estimate.maxFee,\n            nonce: toBigInt(nonce ?? await this.getNonce()),\n            version,\n            chainId: await this.getChainId(),\n            walletAddress: this.address,\n            cairoVersion: void 0\n        };\n        const declareContractTransaction = await this.buildDeclarePayload(declareContractPayload, declareDetails);\n        return this.declareContract(declareContractTransaction, declareDetails);\n    }\n    async deploy(payload, details = {}) {\n        const { calls, addresses } = buildUDCCall(payload, this.address);\n        const invokeResponse = await this.execute(calls, void 0, details);\n        return {\n            ...invokeResponse,\n            contract_address: addresses\n        };\n    }\n    async deployContract(payload, details = {}) {\n        const deployTx = await this.deploy(payload, details);\n        const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n        return parseUDCEvent(txReceipt);\n    }\n    async declareAndDeploy(payload, details = {}) {\n        const { constructorCalldata, salt, unique } = payload;\n        let declare = await this.declareIfNot(payload, details);\n        if (declare.transaction_hash !== \"\") {\n            const tx = await this.waitForTransaction(declare.transaction_hash);\n            declare = {\n                ...declare,\n                ...tx\n            };\n        }\n        const deploy = await this.deployContract({\n            classHash: declare.class_hash,\n            salt,\n            unique,\n            constructorCalldata\n        }, details);\n        return {\n            declare: {\n                ...declare\n            },\n            deploy\n        };\n    }\n    async deployAccount({ classHash, constructorCalldata = [], addressSalt = 0, contractAddress: providedContractAddress }, details = {}) {\n        const version = toTransactionVersion(this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3), details.version);\n        const nonce = ZERO;\n        const chainId = await this.getChainId();\n        const compiledCalldata = CallData.compile(constructorCalldata);\n        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n        const estimate = await this.getUniversalSuggestedFee(version, {\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            payload: {\n                classHash,\n                constructorCalldata: compiledCalldata,\n                addressSalt,\n                contractAddress\n            }\n        }, details);\n        const signature = await this.signer.signDeployAccountTransaction({\n            ...v3Details(details),\n            classHash,\n            constructorCalldata: compiledCalldata,\n            contractAddress,\n            addressSalt,\n            chainId,\n            resourceBounds: estimate.resourceBounds,\n            maxFee: estimate.maxFee,\n            version,\n            nonce\n        });\n        return this.deployAccountContract({\n            classHash,\n            addressSalt,\n            constructorCalldata,\n            signature\n        }, {\n            ...v3Details(details),\n            nonce,\n            resourceBounds: estimate.resourceBounds,\n            maxFee: estimate.maxFee,\n            version\n        });\n    }\n    async signMessage(typedData) {\n        return this.signer.signMessage(typedData, this.address);\n    }\n    async hashMessage(typedData) {\n        return getMessageHash(typedData, this.address);\n    }\n    async verifyMessageHash(hash, signature, signatureVerificationFunctionName, signatureVerificationResponse) {\n        const knownSigVerificationFName = signatureVerificationFunctionName ? [\n            signatureVerificationFunctionName\n        ] : [\n            \"isValidSignature\",\n            \"is_valid_signature\"\n        ];\n        const knownSignatureResponse = signatureVerificationResponse || {\n            okResponse: [],\n            nokResponse: [\n                \"0x0\",\n                // Devnet\n                \"0x00\"\n            ],\n            error: [\n                \"argent/invalid-signature\",\n                // ArgentX 0.3.0 to 0.3.1\n                \"is invalid, with respect to the public key\",\n                // OpenZeppelin until 0.6.1, Braavos 0.0.11\n                \"INVALID_SIG\"\n            ]\n        };\n        let error;\n        for (const SigVerificationFName of knownSigVerificationFName){\n            try {\n                const resp = await this.callContract({\n                    contractAddress: this.address,\n                    entrypoint: SigVerificationFName,\n                    calldata: CallData.compile({\n                        hash: toBigInt(hash).toString(),\n                        signature: formatSignature(signature)\n                    })\n                });\n                if (knownSignatureResponse.nokResponse.includes(resp[0].toString())) {\n                    return false;\n                }\n                if (knownSignatureResponse.okResponse.length === 0 || knownSignatureResponse.okResponse.includes(resp[0].toString())) {\n                    return true;\n                }\n                throw Error(\"signatureVerificationResponse Error: response is not part of known responses\");\n            } catch (err) {\n                if (knownSignatureResponse.error.some((errMessage)=>err.message.includes(errMessage))) {\n                    return false;\n                }\n                error = err;\n            }\n        }\n        throw Error(`Signature verification Error: ${error}`);\n    }\n    async verifyMessage(typedData, signature, signatureVerificationFunctionName, signatureVerificationResponse) {\n        const hash = await this.hashMessage(typedData);\n        return this.verifyMessageHash(hash, signature, signatureVerificationFunctionName, signatureVerificationResponse);\n    }\n    /*\n   * Support methods\n   */ async getUniversalSuggestedFee(version, { type, payload }, details) {\n        let maxFee = 0;\n        let resourceBounds = estimateFeeToBounds(ZERO);\n        if (version === api_exports.ETransactionVersion.V3) {\n            resourceBounds = details.resourceBounds ?? (await this.getSuggestedFee({\n                type,\n                payload\n            }, details)).resourceBounds;\n        } else {\n            maxFee = details.maxFee ?? (await this.getSuggestedFee({\n                type,\n                payload\n            }, details)).suggestedMaxFee;\n        }\n        return {\n            maxFee,\n            resourceBounds\n        };\n    }\n    async getSuggestedFee({ type, payload }, details) {\n        let feeEstimate;\n        switch(type){\n            case \"INVOKE_FUNCTION\" /* INVOKE */ :\n                feeEstimate = await this.estimateInvokeFee(payload, details);\n                break;\n            case \"DECLARE\" /* DECLARE */ :\n                feeEstimate = await this.estimateDeclareFee(payload, details);\n                break;\n            case \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ :\n                feeEstimate = await this.estimateAccountDeployFee(payload, details);\n                break;\n            case \"DEPLOY\" /* DEPLOY */ :\n                feeEstimate = await this.estimateDeployFee(payload, details);\n                break;\n            default:\n                feeEstimate = {\n                    gas_consumed: 0n,\n                    gas_price: 0n,\n                    overall_fee: ZERO,\n                    unit: \"FRI\",\n                    suggestedMaxFee: ZERO,\n                    resourceBounds: estimateFeeToBounds(ZERO),\n                    data_gas_consumed: 0n,\n                    data_gas_price: 0n\n                };\n                break;\n        }\n        return feeEstimate;\n    }\n    async buildInvocation(call, details) {\n        const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n        const signature = !details.skipValidate ? await this.signer.signTransaction(call, details) : [];\n        return {\n            ...v3Details(details),\n            contractAddress: this.address,\n            calldata,\n            signature\n        };\n    }\n    async buildDeclarePayload(payload, details) {\n        const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n        const compressedCompiledContract = parseContract(contract);\n        if (typeof compiledClassHash === \"undefined\" && (details.version === api_exports.ETransactionVersion3.F3 || details.version === api_exports.ETransactionVersion3.V3)) {\n            throw Error(\"V3 Transaction work with Cairo1 Contracts and require compiledClassHash\");\n        }\n        const signature = !details.skipValidate ? await this.signer.signDeclareTransaction({\n            ...details,\n            ...v3Details(details),\n            classHash,\n            compiledClassHash,\n            // TODO: TS, cast because optional for v2 and required for v3, thrown if not present\n            senderAddress: details.walletAddress\n        }) : [];\n        return {\n            senderAddress: details.walletAddress,\n            signature,\n            contract: compressedCompiledContract,\n            compiledClassHash\n        };\n    }\n    async buildAccountDeployPayload({ classHash, addressSalt = 0, constructorCalldata = [], contractAddress: providedContractAddress }, details) {\n        const compiledCalldata = CallData.compile(constructorCalldata);\n        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n        const signature = !details.skipValidate ? await this.signer.signDeployAccountTransaction({\n            ...details,\n            ...v3Details(details),\n            classHash,\n            contractAddress,\n            addressSalt,\n            constructorCalldata: compiledCalldata\n        }) : [];\n        return {\n            ...v3Details(details),\n            classHash,\n            addressSalt,\n            constructorCalldata: compiledCalldata,\n            signature\n        };\n    }\n    buildUDCContractPayload(payload) {\n        const calls = [].concat(payload).map((it)=>{\n            const { classHash, salt = \"0\", unique = true, constructorCalldata = [] } = it;\n            const compiledConstructorCallData = CallData.compile(constructorCalldata);\n            return {\n                contractAddress: UDC.ADDRESS,\n                entrypoint: UDC.ENTRYPOINT,\n                calldata: [\n                    classHash,\n                    salt,\n                    toCairoBool(unique),\n                    compiledConstructorCallData.length,\n                    ...compiledConstructorCallData\n                ]\n            };\n        });\n        return calls;\n    }\n    async accountInvocationsFactory(invocations, details) {\n        const { nonce, blockIdentifier, skipValidate = true } = details;\n        const safeNonce = await this.getNonceSafe(nonce);\n        const chainId = await this.getChainId();\n        const versions = details.versions.map((it)=>toTransactionVersion(it));\n        const tx0Payload = \"payload\" in invocations[0] ? invocations[0].payload : invocations[0];\n        const cairoVersion = invocations[0].type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */  ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();\n        return Promise.all([].concat(invocations).map(async (transaction, index)=>{\n            const txPayload = \"payload\" in transaction ? transaction.payload : transaction;\n            const signerDetails = {\n                ...v3Details(details),\n                walletAddress: this.address,\n                nonce: toBigInt(Number(safeNonce) + index),\n                maxFee: ZERO,\n                chainId,\n                cairoVersion,\n                version: \"\",\n                skipValidate\n            };\n            const common = {\n                type: transaction.type,\n                nonce: toBigInt(Number(safeNonce) + index),\n                blockIdentifier,\n                version: \"\"\n            };\n            if (transaction.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n                const versionX = reduceV2(versions[1]);\n                signerDetails.version = versionX;\n                common.version = versionX;\n                const payload = await this.buildInvocation([].concat(txPayload), signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            if (transaction.type === \"DEPLOY\" /* DEPLOY */ ) {\n                const versionX = reduceV2(versions[1]);\n                signerDetails.version = versionX;\n                common.version = versionX;\n                const calls = this.buildUDCContractPayload(txPayload);\n                const payload = await this.buildInvocation(calls, signerDetails);\n                return {\n                    ...common,\n                    ...payload,\n                    type: \"INVOKE_FUNCTION\" /* INVOKE */ \n                };\n            }\n            if (transaction.type === \"DECLARE\" /* DECLARE */ ) {\n                const versionX = !isSierra(txPayload.contract) ? versions[0] : versions[1];\n                signerDetails.version = versionX;\n                common.version = versionX;\n                const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            if (transaction.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n                const versionX = reduceV2(versions[1]);\n                signerDetails.version = versionX;\n                common.version = versionX;\n                const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n        }));\n    }\n    async getStarkName(address = this.address, StarknetIdContract2) {\n        return super.getStarkName(address, StarknetIdContract2);\n    }\n};\n// src/account/interface.ts\nvar AccountInterface = class extends ProviderInterface {\n};\n// src/wallet/connect.ts\nvar connect_exports = {};\n__export(connect_exports, {\n    addDeclareTransaction: ()=>addDeclareTransaction,\n    addInvokeTransaction: ()=>addInvokeTransaction,\n    addStarknetChain: ()=>addStarknetChain,\n    deploymentData: ()=>deploymentData,\n    getPermissions: ()=>getPermissions,\n    onAccountChange: ()=>onAccountChange,\n    onNetworkChanged: ()=>onNetworkChanged,\n    requestAccounts: ()=>requestAccounts,\n    requestChainId: ()=>requestChainId,\n    signMessage: ()=>signMessage,\n    supportedSpecs: ()=>supportedSpecs,\n    switchStarknetChain: ()=>switchStarknetChain,\n    watchAsset: ()=>watchAsset\n});\nfunction requestAccounts(swo, silent_mode = false) {\n    return swo.request({\n        type: \"wallet_requestAccounts\",\n        params: {\n            silent_mode\n        }\n    });\n}\nfunction getPermissions(swo) {\n    return swo.request({\n        type: \"wallet_getPermissions\"\n    });\n}\nfunction watchAsset(swo, asset) {\n    return swo.request({\n        type: \"wallet_watchAsset\",\n        params: asset\n    });\n}\nfunction addStarknetChain(swo, chain) {\n    return swo.request({\n        type: \"wallet_addStarknetChain\",\n        params: chain\n    });\n}\nfunction switchStarknetChain(swo, chainId) {\n    return swo.request({\n        type: \"wallet_switchStarknetChain\",\n        params: {\n            chainId\n        }\n    });\n}\nfunction requestChainId(swo) {\n    return swo.request({\n        type: \"wallet_requestChainId\"\n    });\n}\nfunction deploymentData(swo) {\n    return swo.request({\n        type: \"wallet_deploymentData\"\n    });\n}\nfunction addInvokeTransaction(swo, params) {\n    return swo.request({\n        type: \"wallet_addInvokeTransaction\",\n        params\n    });\n}\nfunction addDeclareTransaction(swo, params) {\n    return swo.request({\n        type: \"wallet_addDeclareTransaction\",\n        params\n    });\n}\nfunction signMessage(swo, typedData) {\n    return swo.request({\n        type: \"wallet_signTypedData\",\n        params: typedData\n    });\n}\nfunction supportedSpecs(swo) {\n    return swo.request({\n        type: \"wallet_supportedSpecs\"\n    });\n}\nfunction onAccountChange(swo, callback) {\n    swo.on(\"accountsChanged\", callback);\n}\nfunction onNetworkChanged(swo, callback) {\n    swo.on(\"networkChanged\", callback);\n}\n// src/wallet/account.ts\nvar WalletAccount = class extends Account {\n    constructor(providerOrOptions, walletProvider, cairoVersion){\n        super(providerOrOptions, \"\", \"\", cairoVersion);\n        this.address = \"\";\n        this.walletProvider = walletProvider;\n        this.walletProvider.on(\"accountsChanged\", (res)=>{\n            if (!res) return;\n            this.address = res[0].toLowerCase();\n        });\n        this.walletProvider.on(\"networkChanged\", (res)=>{\n            if (!res) return;\n            this.channel.setChainId(res);\n        });\n        walletProvider.request({\n            type: \"wallet_requestAccounts\",\n            params: {\n                silent_mode: false\n            }\n        }).then((res)=>{\n            this.address = res[0].toLowerCase();\n        });\n    }\n    /**\n   * WALLET EVENTS\n   */ onAccountChange(callback) {\n        onAccountChange(this.walletProvider, callback);\n    }\n    onNetworkChanged(callback) {\n        onNetworkChanged(this.walletProvider, callback);\n    }\n    /**\n   * WALLET SPECIFIC METHODS\n   */ requestAccounts(silentMode = false) {\n        return requestAccounts(this.walletProvider, silentMode);\n    }\n    getPermissions() {\n        return getPermissions(this.walletProvider);\n    }\n    switchStarknetChain(chainId) {\n        return switchStarknetChain(this.walletProvider, chainId);\n    }\n    watchAsset(asset) {\n        return watchAsset(this.walletProvider, asset);\n    }\n    addStarknetChain(chain) {\n        return addStarknetChain(this.walletProvider, chain);\n    }\n    /**\n   * ACCOUNT METHODS\n   */ execute(calls) {\n        const txCalls = [].concat(calls).map((it)=>{\n            const { contractAddress, entrypoint, calldata } = it;\n            return {\n                contract_address: contractAddress,\n                entry_point: entrypoint,\n                calldata\n            };\n        });\n        const params = {\n            calls: txCalls\n        };\n        return addInvokeTransaction(this.walletProvider, params);\n    }\n    declare(payload) {\n        const declareContractPayload = extractContractHashes(payload);\n        const pContract = payload.contract;\n        const cairo1Contract = {\n            ...pContract,\n            abi: stringify2(pContract.abi)\n        };\n        if (!declareContractPayload.compiledClassHash) {\n            throw Error(\"compiledClassHash is required\");\n        }\n        const params = {\n            compiled_class_hash: declareContractPayload.compiledClassHash,\n            contract_class: cairo1Contract\n        };\n        return addDeclareTransaction(this.walletProvider, params);\n    }\n    async deploy(payload) {\n        const { calls, addresses } = buildUDCCall(payload, this.address);\n        const invokeResponse = await this.execute(calls);\n        return {\n            ...invokeResponse,\n            contract_address: addresses\n        };\n    }\n    signMessage(typedData) {\n        return signMessage(this.walletProvider, typedData);\n    }\n};\n// src/contract/default.ts\nvar splitArgsAndOptions = (args)=>{\n    const options = [\n        \"blockIdentifier\",\n        \"parseRequest\",\n        \"parseResponse\",\n        \"formatResponse\",\n        \"maxFee\",\n        \"nonce\",\n        \"signature\",\n        \"addressSalt\"\n    ];\n    const lastArg = args[args.length - 1];\n    if (typeof lastArg === \"object\" && options.some((x)=>x in lastArg)) {\n        return {\n            args,\n            options: args.pop()\n        };\n    }\n    return {\n        args\n    };\n};\nfunction buildCall(contract, functionAbi) {\n    return async function(...args) {\n        const params = splitArgsAndOptions(args);\n        return contract.call(functionAbi.name, params.args, {\n            parseRequest: true,\n            parseResponse: true,\n            ...params.options\n        });\n    };\n}\nfunction buildInvoke(contract, functionAbi) {\n    return async function(...args) {\n        const params = splitArgsAndOptions(args);\n        return contract.invoke(functionAbi.name, params.args, {\n            parseRequest: true,\n            ...params.options\n        });\n    };\n}\nfunction buildDefault(contract, functionAbi) {\n    if (functionAbi.stateMutability === \"view\" || functionAbi.state_mutability === \"view\") {\n        return buildCall(contract, functionAbi);\n    }\n    return buildInvoke(contract, functionAbi);\n}\nfunction buildPopulate(contract, functionAbi) {\n    return function(...args) {\n        return contract.populate(functionAbi.name, args);\n    };\n}\nfunction buildEstimate(contract, functionAbi) {\n    return function(...args) {\n        return contract.estimate(functionAbi.name, args);\n    };\n}\nfunction getCalldata(args, callback) {\n    if (Array.isArray(args) && \"__compiled__\" in args) return args;\n    if (Array.isArray(args) && Array.isArray(args[0]) && \"__compiled__\" in args[0]) return args[0];\n    return callback();\n}\nvar Contract = class {\n    /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */ constructor(abi, address, providerOrAccount = defaultProvider){\n        this.address = address && address.toLowerCase();\n        this.providerOrAccount = providerOrAccount;\n        this.callData = new CallData(abi);\n        this.structs = CallData.getAbiStruct(abi);\n        this.events = getAbiEvents(abi);\n        const parser = createAbiParser(abi);\n        this.abi = parser.getLegacyFormat();\n        const options = {\n            enumerable: true,\n            value: {},\n            writable: false\n        };\n        Object.defineProperties(this, {\n            functions: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            callStatic: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            populateTransaction: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            estimateFee: {\n                enumerable: true,\n                value: {},\n                writable: false\n            }\n        });\n        this.abi.forEach((abiElement)=>{\n            if (abiElement.type !== \"function\") return;\n            const signature = abiElement.name;\n            if (!this[signature]) {\n                Object.defineProperty(this, signature, {\n                    ...options,\n                    value: buildDefault(this, abiElement)\n                });\n            }\n            if (!this.functions[signature]) {\n                Object.defineProperty(this.functions, signature, {\n                    ...options,\n                    value: buildDefault(this, abiElement)\n                });\n            }\n            if (!this.callStatic[signature]) {\n                Object.defineProperty(this.callStatic, signature, {\n                    ...options,\n                    value: buildCall(this, abiElement)\n                });\n            }\n            if (!this.populateTransaction[signature]) {\n                Object.defineProperty(this.populateTransaction, signature, {\n                    ...options,\n                    value: buildPopulate(this, abiElement)\n                });\n            }\n            if (!this.estimateFee[signature]) {\n                Object.defineProperty(this.estimateFee, signature, {\n                    ...options,\n                    value: buildEstimate(this, abiElement)\n                });\n            }\n        });\n    }\n    attach(address) {\n        this.address = address;\n    }\n    connect(providerOrAccount) {\n        this.providerOrAccount = providerOrAccount;\n    }\n    async deployed() {\n        if (this.deployTransactionHash) {\n            await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n            this.deployTransactionHash = void 0;\n        }\n        return this;\n    }\n    async call(method, args = [], { parseRequest = true, parseResponse = true, formatResponse = void 0, blockIdentifier = void 0 } = {}) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        const calldata = getCalldata(args, ()=>{\n            if (parseRequest) {\n                this.callData.validate(\"CALL\" /* CALL */ , method, args);\n                return this.callData.compile(method, args);\n            }\n            console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n            return args;\n        });\n        return this.providerOrAccount.callContract({\n            contractAddress: this.address,\n            calldata,\n            entrypoint: method\n        }, blockIdentifier).then((it)=>{\n            if (!parseResponse) {\n                return it;\n            }\n            if (formatResponse) {\n                return this.callData.format(method, it, formatResponse);\n            }\n            return this.callData.parse(method, it);\n        });\n    }\n    invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        const calldata = getCalldata(args, ()=>{\n            if (parseRequest) {\n                this.callData.validate(\"INVOKE\" /* INVOKE */ , method, args);\n                return this.callData.compile(method, args);\n            }\n            console.warn(\"Invoke skipped parsing but provided rawArgs, possible malfunction request\");\n            return args;\n        });\n        const invocation = {\n            contractAddress: this.address,\n            calldata,\n            entrypoint: method\n        };\n        if (\"execute\" in this.providerOrAccount) {\n            return this.providerOrAccount.execute(invocation, void 0, {\n                maxFee,\n                nonce\n            });\n        }\n        if (!nonce) throw new Error(`Nonce is required when invoking a function without an account`);\n        console.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n        return this.providerOrAccount.invokeFunction({\n            ...invocation,\n            signature\n        }, {\n            nonce\n        });\n    }\n    async estimate(method, args = []) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        if (!getCalldata(args, ()=>false)) {\n            this.callData.validate(\"INVOKE\" /* INVOKE */ , method, args);\n        }\n        const invocation = this.populate(method, args);\n        if (\"estimateInvokeFee\" in this.providerOrAccount) {\n            return this.providerOrAccount.estimateInvokeFee(invocation);\n        }\n        throw Error(\"Contract must be connected to the account contract to estimate\");\n    }\n    populate(method, args = []) {\n        const calldata = getCalldata(args, ()=>this.callData.compile(method, args));\n        return {\n            contractAddress: this.address,\n            entrypoint: method,\n            calldata\n        };\n    }\n    parseEvents(receipt) {\n        return parseEvents(receipt.events?.filter((event)=>cleanHex(event.from_address) === cleanHex(this.address), []) || [], this.events, this.structs, CallData.getAbiEnum(this.abi));\n    }\n    isCairo1() {\n        return cairo_exports.isCairo1Abi(this.abi);\n    }\n    async getVersion() {\n        return this.providerOrAccount.getContractVersion(this.address);\n    }\n    typedv2(tAbi) {\n        return this;\n    }\n};\n// src/contract/interface.ts\nvar ContractInterface = class {\n};\n// src/contract/contractFactory.ts\nvar ContractFactory = class {\n    /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */ constructor(params){\n        this.compiledContract = params.compiledContract;\n        this.account = params.account;\n        this.casm = params.casm;\n        this.abi = params.abi ?? params.compiledContract.abi;\n        this.classHash = params.classHash;\n        this.compiledClassHash = params.compiledClassHash;\n        this.CallData = new CallData(this.abi);\n    }\n    /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */ async deploy(...args) {\n        const { args: param, options = {\n            parseRequest: true\n        } } = splitArgsAndOptions(args);\n        const constructorCalldata = getCalldata(param, ()=>{\n            if (options.parseRequest) {\n                this.CallData.validate(\"DEPLOY\" /* DEPLOY */ , \"constructor\", param);\n                return this.CallData.compile(\"constructor\", param);\n            }\n            console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n            return param;\n        });\n        const { deploy: { contract_address, transaction_hash } } = await this.account.declareAndDeploy({\n            contract: this.compiledContract,\n            casm: this.casm,\n            classHash: this.classHash,\n            compiledClassHash: this.compiledClassHash,\n            constructorCalldata,\n            salt: options.addressSalt\n        });\n        assert(Boolean(contract_address), \"Deployment of the contract failed\");\n        const contractInstance = new Contract(this.compiledContract.abi, contract_address, this.account);\n        contractInstance.deployTransactionHash = transaction_hash;\n        return contractInstance;\n    }\n    /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */ connect(account) {\n        this.account = account;\n        return this;\n    }\n    /**\n   * Attaches current abi and account to the new address\n   */ attach(address) {\n        return new Contract(this.abi, address, this.account);\n    }\n};\n// src/utils/responseParser/interface.ts\nvar ResponseParser = class {\n};\n// src/utils/address.ts\n\nfunction addAddressPadding(address) {\n    const hex = toHex(addHexPrefix(address.toString()));\n    const padded = removeHexPrefix(hex).padStart(64, \"0\");\n    return addHexPrefix(padded);\n}\nfunction validateAndParseAddress(address) {\n    const result = addAddressPadding(address);\n    if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n        throw new Error(\"Invalid Address Format\");\n    }\n    assertInRange(result, ZERO, ADDR_BOUND - 1n, \"Starknet Address\");\n    return result;\n}\nfunction getChecksumAddress(address) {\n    const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split(\"\");\n    const hex = removeHexPrefix(keccakBn(address));\n    const hashed = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(hex.padStart(64, \"0\"));\n    for(let i = 0; i < chars.length; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 15) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return addHexPrefix(chars.join(\"\"));\n}\nfunction validateChecksumAddress(address) {\n    return getChecksumAddress(address) === address;\n}\n// src/utils/url.ts\n\nvar protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nvar localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nvar nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\nfunction isUrl(s) {\n    if (!s) {\n        return false;\n    }\n    if (typeof s !== \"string\") {\n        return false;\n    }\n    const match = s.match(protocolAndDomainRE);\n    if (!match) {\n        return false;\n    }\n    const everythingAfterProtocol = match[1];\n    if (!everythingAfterProtocol) {\n        return false;\n    }\n    if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {\n        return true;\n    }\n    return false;\n}\nfunction buildUrl(baseUrl, defaultPath, urlOrPath) {\n    return isUrl(urlOrPath) ? urlOrPath : url_join__WEBPACK_IMPORTED_MODULE_15__(baseUrl, urlOrPath ?? defaultPath);\n}\n// src/index.ts\nvar number = num_exports;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLG1CQUFtQkYsT0FBT0csd0JBQXdCO0FBQ3RELElBQUlDLG9CQUFvQkosT0FBT0ssbUJBQW1CO0FBQ2xELElBQUlDLGVBQWVOLE9BQU9PLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsUUFBUUQsSUFDZlosVUFBVVcsUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPaEIsa0JBQWtCYSxNQUNoQyxJQUFJLENBQUNYLGFBQWFlLElBQUksQ0FBQ0wsSUFBSUksUUFBUUEsUUFBUUYsUUFDekNuQixVQUFVaUIsSUFBSUksS0FBSztZQUFFUCxLQUFLLElBQU1JLElBQUksQ0FBQ0csSUFBSTtZQUFFTixZQUFZLENBQUVLLENBQUFBLE9BQU9qQixpQkFBaUJlLE1BQU1HLElBQUcsS0FBTUQsS0FBS0wsVUFBVTtRQUFDO0lBQ3RIO0lBQ0EsT0FBT0U7QUFDVDtBQUNBLElBQUlNLGFBQWEsQ0FBQ1osUUFBUWEsS0FBS0MsZUFBa0JULENBQUFBLFlBQVlMLFFBQVFhLEtBQUssWUFBWUMsZ0JBQWdCVCxZQUFZUyxjQUFjRCxLQUFLLFVBQVM7QUFFOUksbUJBQW1CO0FBQ25CLElBQUlFLG9C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QUFDekM7QUFFQSxtQkFBbUI7QUFDWTtBQUMvQixJQUFJMm5CLHNCQUFzQjtBQUMxQixJQUFJQyxvQkFBb0I7QUFDeEIsSUFBSUMsdUJBQXVCO0FBQzNCLFNBQVNDLE1BQU16Z0MsQ0FBQztJQUNkLElBQUksQ0FBQ0EsR0FBRztRQUNOLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0EsTUFBTSxVQUFVO1FBQ3pCLE9BQU87SUFDVDtJQUNBLE1BQU03SyxRQUFRNkssRUFBRTdLLEtBQUssQ0FBQ21yQztJQUN0QixJQUFJLENBQUNuckMsT0FBTztRQUNWLE9BQU87SUFDVDtJQUNBLE1BQU11ckMsMEJBQTBCdnJDLEtBQUssQ0FBQyxFQUFFO0lBQ3hDLElBQUksQ0FBQ3VyQyx5QkFBeUI7UUFDNUIsT0FBTztJQUNUO0lBQ0EsSUFBSUgsa0JBQWtCaHpDLElBQUksQ0FBQ216Qyw0QkFBNEJGLHFCQUFxQmp6QyxJQUFJLENBQUNtekMsMEJBQTBCO1FBQ3pHLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNDLFNBQVNDLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxTQUFTO0lBQy9DLE9BQU9MLE1BQU1LLGFBQWFBLFlBQVlULHNDQUFPQSxDQUFDTyxTQUFTRSxhQUFhRDtBQUN0RTtBQUVBLGVBQWU7QUFDZixJQUFJOWxCLFNBQVMzcEI7QUE2RlgsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1kYXBwLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L2Rpc3QvaW5kZXgubWpzP2NlOTciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZCwgc2Vjb25kVGFyZ2V0KSA9PiAoX19jb3B5UHJvcHModGFyZ2V0LCBtb2QsIFwiZGVmYXVsdFwiKSwgc2Vjb25kVGFyZ2V0ICYmIF9fY29weVByb3BzKHNlY29uZFRhcmdldCwgbW9kLCBcImRlZmF1bHRcIikpO1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgY29uc3RhbnRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbnN0YW50c19leHBvcnRzLCB7XG4gIEFERFJfQk9VTkQ6ICgpID0+IEFERFJfQk9VTkQsXG4gIEFQSV9WRVJTSU9OOiAoKSA9PiBBUElfVkVSU0lPTixcbiAgQmFzZVVybDogKCkgPT4gQmFzZVVybCxcbiAgRmVlTWFyZ2luUGVyY2VudGFnZTogKCkgPT4gRmVlTWFyZ2luUGVyY2VudGFnZSxcbiAgSVNfQlJPV1NFUjogKCkgPT4gSVNfQlJPV1NFUixcbiAgTUFTS18yNTA6ICgpID0+IE1BU0tfMjUwLFxuICBNQVhfU1RPUkFHRV9JVEVNX1NJWkU6ICgpID0+IE1BWF9TVE9SQUdFX0lURU1fU0laRSxcbiAgTmV0d29ya05hbWU6ICgpID0+IE5ldHdvcmtOYW1lLFxuICBQUklNRTogKCkgPT4gUFJJTUUsXG4gIFJBTkdFX0ZFTFQ6ICgpID0+IFJBTkdFX0ZFTFQsXG4gIFJBTkdFX0kxMjg6ICgpID0+IFJBTkdFX0kxMjgsXG4gIFJBTkdFX1UxMjg6ICgpID0+IFJBTkdFX1UxMjgsXG4gIFJQQ19ERUZBVUxUX1ZFUlNJT046ICgpID0+IFJQQ19ERUZBVUxUX1ZFUlNJT04sXG4gIFJQQ19OT0RFUzogKCkgPT4gUlBDX05PREVTLFxuICBTdGFya25ldENoYWluSWQ6ICgpID0+IFN0YXJrbmV0Q2hhaW5JZCxcbiAgVEVYVF9UT19GRUxUX01BWF9MRU46ICgpID0+IFRFWFRfVE9fRkVMVF9NQVhfTEVOLFxuICBUUkFOU0FDVElPTl9WRVJTSU9OOiAoKSA9PiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLFxuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXg6ICgpID0+IFRyYW5zYWN0aW9uSGFzaFByZWZpeCxcbiAgVURDOiAoKSA9PiBVREMsXG4gIFpFUk86ICgpID0+IFpFUk9cbn0pO1xuXG4vLyBzcmMvdHlwZXMvYXBpL2luZGV4LnRzXG52YXIgYXBpX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGFwaV9leHBvcnRzLCB7XG4gIEpSUEM6ICgpID0+IGpzb25ycGNfZXhwb3J0cyxcbiAgUlBDU1BFQzA2OiAoKSA9PiBycGNzcGVjXzBfNl9leHBvcnRzLFxuICBSUENTUEVDMDc6ICgpID0+IFJQQ1NQRUMwN1xufSk7XG5cbi8vIHNyYy90eXBlcy9hcGkvanNvbnJwYy9pbmRleC50c1xudmFyIGpzb25ycGNfZXhwb3J0cyA9IHt9O1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwY3NwZWNfMF82L2luZGV4LnRzXG52YXIgcnBjc3BlY18wXzZfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocnBjc3BlY18wXzZfZXhwb3J0cywge1xuICBFQmxvY2tUYWc6ICgpID0+IEVCbG9ja1RhZyxcbiAgRURBTW9kZTogKCkgPT4gRURBTW9kZSxcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlOiAoKSA9PiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gIEVTaW11bGF0aW9uRmxhZzogKCkgPT4gRVNpbXVsYXRpb25GbGFnLFxuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzLFxuICBFVHJhbnNhY3Rpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uVHlwZTogKCkgPT4gRVRyYW5zYWN0aW9uVHlwZSxcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjogKCkgPT4gRVRyYW5zYWN0aW9uVmVyc2lvbixcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI6ICgpID0+IEVUcmFuc2FjdGlvblZlcnNpb24yLFxuICBFVHJhbnNhY3Rpb25WZXJzaW9uMzogKCkgPT4gRVRyYW5zYWN0aW9uVmVyc2lvbjMsXG4gIEVycm9yczogKCkgPT4gZXJyb3JzX2V4cG9ydHMsXG4gIFNQRUM6ICgpID0+IGNvbXBvbmVudHNfZXhwb3J0c1xufSk7XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlY18wXzYvZXJyb3JzLnRzXG52YXIgZXJyb3JzX2V4cG9ydHMgPSB7fTtcblxuLy8gc3JjL3R5cGVzL2FwaS9ycGNzcGVjXzBfNi9jb21wb25lbnRzLnRzXG52YXIgY29tcG9uZW50c19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlY18wXzYvbm9uc3BlYy50c1xudmFyIEVUcmFuc2FjdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25UeXBlMikgPT4ge1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFQ0xBUkVcIl0gPSBcIkRFQ0xBUkVcIjtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCJERVBMT1lfQUNDT1VOVFwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIklOVk9LRVwiXSA9IFwiSU5WT0tFXCI7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiTDFfSEFORExFUlwiXSA9IFwiTDFfSEFORExFUlwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uVHlwZTI7XG59KShFVHJhbnNhY3Rpb25UeXBlIHx8IHt9KTtcbnZhciBFU2ltdWxhdGlvbkZsYWcgPSAvKiBAX19QVVJFX18gKi8gKChFU2ltdWxhdGlvbkZsYWcyKSA9PiB7XG4gIEVTaW11bGF0aW9uRmxhZzJbXCJTS0lQX1ZBTElEQVRFXCJdID0gXCJTS0lQX1ZBTElEQVRFXCI7XG4gIEVTaW11bGF0aW9uRmxhZzJbXCJTS0lQX0ZFRV9DSEFSR0VcIl0gPSBcIlNLSVBfRkVFX0NIQVJHRVwiO1xuICByZXR1cm4gRVNpbXVsYXRpb25GbGFnMjtcbn0pKEVTaW11bGF0aW9uRmxhZyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uU3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVDRUlWRURcIl0gPSBcIlJFQ0VJVkVEXCI7XG4gIEVUcmFuc2FjdGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgRVRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25TdGF0dXMyO1xufSkoRVRyYW5zYWN0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czI7XG59KShFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiU1VDQ0VFREVEXCJdID0gXCJTVUNDRUVERURcIjtcbiAgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlJFVkVSVEVEXCJdID0gXCJSRVZFUlRFRFwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMjtcbn0pKEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyB8fCB7fSk7XG52YXIgRUJsb2NrVGFnID0gLyogQF9fUFVSRV9fICovICgoRUJsb2NrVGFnMikgPT4ge1xuICBFQmxvY2tUYWcyW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ1wiO1xuICBFQmxvY2tUYWcyW1wiTEFURVNUXCJdID0gXCJsYXRlc3RcIjtcbiAgcmV0dXJuIEVCbG9ja1RhZzI7XG59KShFQmxvY2tUYWcgfHwge30pO1xudmFyIEVEYXRhQXZhaWxhYmlsaXR5TW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEVEYXRhQXZhaWxhYmlsaXR5TW9kZTMpID0+IHtcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlM1tcIkwxXCJdID0gXCJMMVwiO1xuICBFRGF0YUF2YWlsYWJpbGl0eU1vZGUzW1wiTDJcIl0gPSBcIkwyXCI7XG4gIHJldHVybiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUzO1xufSkoRURhdGFBdmFpbGFiaWxpdHlNb2RlIHx8IHt9KTtcbnZhciBFREFNb2RlID0gLyogQF9fUFVSRV9fICovICgoRURBTW9kZTQpID0+IHtcbiAgRURBTW9kZTRbRURBTW9kZTRbXCJMMVwiXSA9IDBdID0gXCJMMVwiO1xuICBFREFNb2RlNFtFREFNb2RlNFtcIkwyXCJdID0gMV0gPSBcIkwyXCI7XG4gIHJldHVybiBFREFNb2RlNDtcbn0pKEVEQU1vZGUgfHwge30pO1xudmFyIEVUcmFuc2FjdGlvblZlcnNpb24gPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25WZXJzaW9uMTApID0+IHtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjEwW1wiVjBcIl0gPSBcIjB4MFwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMTBbXCJWMVwiXSA9IFwiMHgxXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24xMFtcIlYyXCJdID0gXCIweDJcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjEwW1wiVjNcIl0gPSBcIjB4M1wiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMTBbXCJGMFwiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjEwW1wiRjFcIl0gPSBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24xMFtcIkYyXCJdID0gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMlwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMTBbXCJGM1wiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvblZlcnNpb24xMDtcbn0pKEVUcmFuc2FjdGlvblZlcnNpb24gfHwge30pO1xudmFyIEVUcmFuc2FjdGlvblZlcnNpb24yID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uVmVyc2lvbjI1KSA9PiB7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24yNVtcIlYwXCJdID0gXCIweDBcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI1W1wiVjFcIl0gPSBcIjB4MVwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMjVbXCJWMlwiXSA9IFwiMHgyXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24yNVtcIkYwXCJdID0gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMjVbXCJGMVwiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI1W1wiRjJcIl0gPSBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25WZXJzaW9uMjU7XG59KShFVHJhbnNhY3Rpb25WZXJzaW9uMiB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uVmVyc2lvbjMgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25WZXJzaW9uMzYpID0+IHtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjM2W1wiVjNcIl0gPSBcIjB4M1wiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMzZbXCJGM1wiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvblZlcnNpb24zNjtcbn0pKEVUcmFuc2FjdGlvblZlcnNpb24zIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2FwaS9pbmRleC50c1xuX19yZUV4cG9ydChhcGlfZXhwb3J0cywgc3RhcmtuZXRfdHlwZXNfMDdfc3Rhcik7XG5pbXBvcnQgKiBhcyBSUENTUEVDMDcgZnJvbSBcInN0YXJrbmV0LXR5cGVzLTA3XCI7XG5pbXBvcnQgKiBhcyBzdGFya25ldF90eXBlc18wN19zdGFyIGZyb20gXCJzdGFya25ldC10eXBlcy0wN1wiO1xuXG4vLyBzcmMvdXRpbHMvZW5jb2RlLnRzXG52YXIgZW5jb2RlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGVuY29kZV9leHBvcnRzLCB7XG4gIElTX0JST1dTRVI6ICgpID0+IElTX0JST1dTRVIsXG4gIGFkZEhleFByZWZpeDogKCkgPT4gYWRkSGV4UHJlZml4LFxuICBhcnJheUJ1ZmZlclRvU3RyaW5nOiAoKSA9PiBhcnJheUJ1ZmZlclRvU3RyaW5nLFxuICBhdG9iVW5pdmVyc2FsOiAoKSA9PiBhdG9iVW5pdmVyc2FsLFxuICBidG9hVW5pdmVyc2FsOiAoKSA9PiBidG9hVW5pdmVyc2FsLFxuICBidWYyaGV4OiAoKSA9PiBidWYyaGV4LFxuICBjYWxjQnl0ZUxlbmd0aDogKCkgPT4gY2FsY0J5dGVMZW5ndGgsXG4gIHBhZExlZnQ6ICgpID0+IHBhZExlZnQsXG4gIHBhc2NhbFRvU25ha2U6ICgpID0+IHBhc2NhbFRvU25ha2UsXG4gIHJlbW92ZUhleFByZWZpeDogKCkgPT4gcmVtb3ZlSGV4UHJlZml4LFxuICBzYW5pdGl6ZUJ5dGVzOiAoKSA9PiBzYW5pdGl6ZUJ5dGVzLFxuICBzYW5pdGl6ZUhleDogKCkgPT4gc2FuaXRpemVIZXgsXG4gIHN0cmluZ1RvQXJyYXlCdWZmZXI6ICgpID0+IHN0cmluZ1RvQXJyYXlCdWZmZXIsXG4gIHV0ZjhUb0FycmF5OiAoKSA9PiB1dGY4VG9BcnJheVxufSk7XG5pbXBvcnQgeyBiYXNlNjQgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBTVFJJTkdfWkVSTyA9IFwiMFwiO1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb1N0cmluZyhhcnJheSkge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpLnJlZHVjZSgoZGF0YSwgYnl0ZSkgPT4gZGF0YSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSksIFwiXCIpO1xufVxuZnVuY3Rpb24gdXRmOFRvQXJyYXkoc3RyKSB7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXlCdWZmZXIoc3RyKSB7XG4gIHJldHVybiB1dGY4VG9BcnJheShzdHIpO1xufVxuZnVuY3Rpb24gYXRvYlVuaXZlcnNhbChhKSB7XG4gIHJldHVybiBiYXNlNjQuZGVjb2RlKGEpO1xufVxuZnVuY3Rpb24gYnRvYVVuaXZlcnNhbChiKSB7XG4gIHJldHVybiBiYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGIpKTtcbn1cbmZ1bmN0aW9uIGJ1ZjJoZXgoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIucmVkdWNlKChyLCB4KSA9PiByICsgeC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUhleFByZWZpeChoZXgpIHtcbiAgcmV0dXJuIGhleC5yZXBsYWNlKC9eMHgvaSwgXCJcIik7XG59XG5mdW5jdGlvbiBhZGRIZXhQcmVmaXgoaGV4KSB7XG4gIHJldHVybiBgMHgke3JlbW92ZUhleFByZWZpeChoZXgpfWA7XG59XG5mdW5jdGlvbiBwYWRTdHJpbmcoc3RyLCBsZW5ndGgsIGxlZnQsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICBjb25zdCBkaWZmID0gbGVuZ3RoIC0gc3RyLmxlbmd0aDtcbiAgbGV0IHJlc3VsdCA9IHN0cjtcbiAgaWYgKGRpZmYgPiAwKSB7XG4gICAgY29uc3QgcGFkID0gcGFkZGluZy5yZXBlYXQoZGlmZik7XG4gICAgcmVzdWx0ID0gbGVmdCA/IHBhZCArIHN0ciA6IHN0ciArIHBhZDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFkTGVmdChzdHIsIGxlbmd0aCwgcGFkZGluZyA9IFNUUklOR19aRVJPKSB7XG4gIHJldHVybiBwYWRTdHJpbmcoc3RyLCBsZW5ndGgsIHRydWUsIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gY2FsY0J5dGVMZW5ndGgoc3RyLCBieXRlU2l6ZSA9IDgpIHtcbiAgY29uc3QgeyBsZW5ndGggfSA9IHN0cjtcbiAgY29uc3QgcmVtYWluZGVyID0gbGVuZ3RoICUgYnl0ZVNpemU7XG4gIHJldHVybiByZW1haW5kZXIgPyAobGVuZ3RoIC0gcmVtYWluZGVyKSAvIGJ5dGVTaXplICogYnl0ZVNpemUgKyBieXRlU2l6ZSA6IGxlbmd0aDtcbn1cbmZ1bmN0aW9uIHNhbml0aXplQnl0ZXMoc3RyLCBieXRlU2l6ZSA9IDgsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICByZXR1cm4gcGFkTGVmdChzdHIsIGNhbGNCeXRlTGVuZ3RoKHN0ciwgYnl0ZVNpemUpLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplSGV4KGhleCkge1xuICBoZXggPSByZW1vdmVIZXhQcmVmaXgoaGV4KTtcbiAgaGV4ID0gc2FuaXRpemVCeXRlcyhoZXgsIDIpO1xuICBpZiAoaGV4KSB7XG4gICAgaGV4ID0gYWRkSGV4UHJlZml4KGhleCk7XG4gIH1cbiAgcmV0dXJuIGhleDtcbn1cbnZhciBwYXNjYWxUb1NuYWtlID0gKHRleHQpID0+IC9bYS16XS8udGVzdCh0ZXh0KSA/IHRleHQuc3BsaXQoLyg/PVtBLVpdKS8pLmpvaW4oXCJfXCIpLnRvVXBwZXJDYXNlKCkgOiB0ZXh0O1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgVEVYVF9UT19GRUxUX01BWF9MRU4gPSAzMTtcbnZhciBaRVJPID0gMG47XG52YXIgTUFTS18yNTAgPSAybiAqKiAyNTBuIC0gMW47XG52YXIgQVBJX1ZFUlNJT04gPSBaRVJPO1xudmFyIFBSSU1FID0gMm4gKiogMjUxbiArIDE3biAqIDJuICoqIDE5Mm4gKyAxbjtcbnZhciBNQVhfU1RPUkFHRV9JVEVNX1NJWkUgPSAyNTZuO1xudmFyIEFERFJfQk9VTkQgPSAybiAqKiAyNTFuIC0gTUFYX1NUT1JBR0VfSVRFTV9TSVpFO1xudmFyIHJhbmdlID0gKG1pbiwgbWF4KSA9PiAoeyBtaW4sIG1heCB9KTtcbnZhciBSQU5HRV9GRUxUID0gcmFuZ2UoWkVSTywgUFJJTUUgLSAxbik7XG52YXIgUkFOR0VfSTEyOCA9IHJhbmdlKC0oMm4gKiogMTI3biksIDJuICoqIDEyN24gLSAxbik7XG52YXIgUkFOR0VfVTEyOCA9IHJhbmdlKFpFUk8sIDJuICoqIDEyOG4gLSAxbik7XG52YXIgQmFzZVVybCA9IC8qIEBfX1BVUkVfXyAqLyAoKEJhc2VVcmwyKSA9PiB7XG4gIEJhc2VVcmwyW1wiU05fTUFJTlwiXSA9IFwiaHR0cHM6Ly9hbHBoYS1tYWlubmV0LnN0YXJrbmV0LmlvXCI7XG4gIEJhc2VVcmwyW1wiU05fU0VQT0xJQVwiXSA9IFwiaHR0cHM6Ly9hbHBoYS1zZXBvbGlhLnN0YXJrbmV0LmlvXCI7XG4gIHJldHVybiBCYXNlVXJsMjtcbn0pKEJhc2VVcmwgfHwge30pO1xudmFyIE5ldHdvcmtOYW1lID0gLyogQF9fUFVSRV9fICovICgoTmV0d29ya05hbWUyKSA9PiB7XG4gIE5ldHdvcmtOYW1lMltcIlNOX01BSU5cIl0gPSBcIlNOX01BSU5cIjtcbiAgTmV0d29ya05hbWUyW1wiU05fU0VQT0xJQVwiXSA9IFwiU05fU0VQT0xJQVwiO1xuICByZXR1cm4gTmV0d29ya05hbWUyO1xufSkoTmV0d29ya05hbWUgfHwge30pO1xudmFyIFN0YXJrbmV0Q2hhaW5JZCA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXJrbmV0Q2hhaW5JZDYpID0+IHtcbiAgU3RhcmtuZXRDaGFpbklkNltcIlNOX01BSU5cIl0gPSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIjtcbiAgU3RhcmtuZXRDaGFpbklkNltcIlNOX1NFUE9MSUFcIl0gPSBcIjB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDFcIjtcbiAgcmV0dXJuIFN0YXJrbmV0Q2hhaW5JZDY7XG59KShTdGFya25ldENoYWluSWQgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uSGFzaFByZWZpeCA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uSGFzaFByZWZpeDIpID0+IHtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkRFQ0xBUkVcIl0gPSBcIjB4NjQ2NTYzNmM2MTcyNjVcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkRFUExPWVwiXSA9IFwiMHg2NDY1NzA2YzZmNzlcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCIweDY0NjU3MDZjNmY3OTVmNjE2MzYzNmY3NTZlNzRcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIklOVk9LRVwiXSA9IFwiMHg2OTZlNzY2ZjZiNjVcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkwxX0hBTkRMRVJcIl0gPSBcIjB4NmMzMTVmNjg2MTZlNjQ2YzY1NzJcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uSGFzaFByZWZpeDI7XG59KShUcmFuc2FjdGlvbkhhc2hQcmVmaXggfHwge30pO1xudmFyIEZlZU1hcmdpblBlcmNlbnRhZ2UgPSAvKiBAX19QVVJFX18gKi8gKChGZWVNYXJnaW5QZXJjZW50YWdlMikgPT4ge1xuICBGZWVNYXJnaW5QZXJjZW50YWdlMltGZWVNYXJnaW5QZXJjZW50YWdlMltcIkwxX0JPVU5EX01BWF9BTU9VTlRcIl0gPSA1MF0gPSBcIkwxX0JPVU5EX01BWF9BTU9VTlRcIjtcbiAgRmVlTWFyZ2luUGVyY2VudGFnZTJbRmVlTWFyZ2luUGVyY2VudGFnZTJbXCJMMV9CT1VORF9NQVhfUFJJQ0VfUEVSX1VOSVRcIl0gPSA1MF0gPSBcIkwxX0JPVU5EX01BWF9QUklDRV9QRVJfVU5JVFwiO1xuICBGZWVNYXJnaW5QZXJjZW50YWdlMltGZWVNYXJnaW5QZXJjZW50YWdlMltcIk1BWF9GRUVcIl0gPSA1MF0gPSBcIk1BWF9GRUVcIjtcbiAgcmV0dXJuIEZlZU1hcmdpblBlcmNlbnRhZ2UyO1xufSkoRmVlTWFyZ2luUGVyY2VudGFnZSB8fCB7fSk7XG52YXIgVURDID0ge1xuICBBRERSRVNTOiBcIjB4MDQxYTc4ZTc0MWU1YWYyZmVjMzRiNjk1Njc5YmM2ODkxNzQyNDM5ZjdhZmI4NDg0ZWNkNzc2NjY2MWFkMDJiZlwiLFxuICBFTlRSWVBPSU5UOiBcImRlcGxveUNvbnRyYWN0XCJcbn07XG52YXIgUlBDX0RFRkFVTFRfVkVSU0lPTiA9IFwidjBfN1wiO1xudmFyIFJQQ19OT0RFUyA9IHtcbiAgU05fTUFJTjogW1xuICAgIGBodHRwczovL3N0YXJrbmV0LW1haW5uZXQucHVibGljLmJsYXN0YXBpLmlvL3JwYy8ke1JQQ19ERUZBVUxUX1ZFUlNJT059YCxcbiAgICBgaHR0cHM6Ly9mcmVlLXJwYy5uZXRoZXJtaW5kLmlvL21haW5uZXQtanVuby8ke1JQQ19ERUZBVUxUX1ZFUlNJT059YFxuICBdLFxuICBTTl9TRVBPTElBOiBbXG4gICAgYGh0dHBzOi8vc3RhcmtuZXQtc2Vwb2xpYS5wdWJsaWMuYmxhc3RhcGkuaW8vcnBjLyR7UlBDX0RFRkFVTFRfVkVSU0lPTn1gLFxuICAgIGBodHRwczovL2ZyZWUtcnBjLm5ldGhlcm1pbmQuaW8vc2Vwb2xpYS1qdW5vLyR7UlBDX0RFRkFVTFRfVkVSU0lPTn1gXG4gIF1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9ycGMudHNcbmltcG9ydCB7IGJ5dGVzVG9IZXggfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiO1xuaW1wb3J0IHsga2VjY2FrXzI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTNcIjtcblxuLy8gc3JjL2NoYW5uZWwvcnBjXzBfNi50c1xudmFyIHJwY18wXzZfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocnBjXzBfNl9leHBvcnRzLCB7XG4gIFJwY0NoYW5uZWw6ICgpID0+IFJwY0NoYW5uZWxcbn0pO1xuXG4vLyBzcmMvcHJvdmlkZXIvZXJyb3JzLnRzXG5mdW5jdGlvbiBmaXhTdGFjayh0YXJnZXQsIGZuID0gdGFyZ2V0LmNvbnN0cnVjdG9yKSB7XG4gIGNvbnN0IHsgY2FwdHVyZVN0YWNrVHJhY2UgfSA9IEVycm9yO1xuICBjYXB0dXJlU3RhY2tUcmFjZSAmJiBjYXB0dXJlU3RhY2tUcmFjZSh0YXJnZXQsIGZuKTtcbn1cbmZ1bmN0aW9uIGZpeFByb3RvKHRhcmdldCwgcHJvdG90eXBlKSB7XG4gIGNvbnN0IHsgc2V0UHJvdG90eXBlT2YgfSA9IE9iamVjdDtcbiAgc2V0UHJvdG90eXBlT2YgPyBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvdHlwZSkgOiB0YXJnZXQuX19wcm90b19fID0gcHJvdG90eXBlO1xufVxudmFyIEN1c3RvbUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWU7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIHZhbHVlOiBuZXcudGFyZ2V0Lm5hbWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGZpeFByb3RvKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICBmaXhTdGFjayh0aGlzKTtcbiAgfVxufTtcbnZhciBMaWJyYXJ5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEN1c3RvbUVycm9yIHtcbn07XG52YXIgR2F0ZXdheUVycm9yID0gY2xhc3MgZXh0ZW5kcyBMaWJyYXJ5RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvckNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgfVxufTtcbnZhciBIdHRwRXJyb3IgPSBjbGFzcyBleHRlbmRzIExpYnJhcnlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yQ29kZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZXJyb3JDb2RlID0gZXJyb3JDb2RlO1xuICB9XG59O1xuXG4vLyBzcmMvdHlwZXMvaW5kZXgudHNcbnZhciB0eXBlc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh0eXBlc19leHBvcnRzLCB7XG4gIEJsb2NrU3RhdHVzOiAoKSA9PiBCbG9ja1N0YXR1cyxcbiAgQmxvY2tUYWc6ICgpID0+IEJsb2NrVGFnLFxuICBFbnRyeVBvaW50VHlwZTogKCkgPT4gRW50cnlQb2ludFR5cGUsXG4gIExpdGVyYWw6ICgpID0+IExpdGVyYWwsXG4gIFJQQzogKCkgPT4gYXBpX2V4cG9ydHMsXG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzOiAoKSA9PiBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czogKCkgPT4gVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyxcbiAgVHJhbnNhY3Rpb25TdGF0dXM6ICgpID0+IFRyYW5zYWN0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvblR5cGU6ICgpID0+IFRyYW5zYWN0aW9uVHlwZSxcbiAgVHlwZWREYXRhUmV2aXNpb246ICgpID0+IFR5cGVkRGF0YVJldmlzaW9uLFxuICBVaW50OiAoKSA9PiBVaW50LFxuICBWYWxpZGF0ZVR5cGU6ICgpID0+IFZhbGlkYXRlVHlwZVxufSk7XG5cbi8vIHNyYy90eXBlcy9jYWxsZGF0YS50c1xudmFyIFZhbGlkYXRlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFZhbGlkYXRlVHlwZTIpID0+IHtcbiAgVmFsaWRhdGVUeXBlMltcIkRFUExPWVwiXSA9IFwiREVQTE9ZXCI7XG4gIFZhbGlkYXRlVHlwZTJbXCJDQUxMXCJdID0gXCJDQUxMXCI7XG4gIFZhbGlkYXRlVHlwZTJbXCJJTlZPS0VcIl0gPSBcIklOVk9LRVwiO1xuICByZXR1cm4gVmFsaWRhdGVUeXBlMjtcbn0pKFZhbGlkYXRlVHlwZSB8fCB7fSk7XG52YXIgVWludCA9IC8qIEBfX1BVUkVfXyAqLyAoKFVpbnQyKSA9PiB7XG4gIFVpbnQyW1widThcIl0gPSBcImNvcmU6OmludGVnZXI6OnU4XCI7XG4gIFVpbnQyW1widTE2XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MTZcIjtcbiAgVWludDJbXCJ1MzJcIl0gPSBcImNvcmU6OmludGVnZXI6OnUzMlwiO1xuICBVaW50MltcInU2NFwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTY0XCI7XG4gIFVpbnQyW1widTEyOFwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTEyOFwiO1xuICBVaW50MltcInUyNTZcIl0gPSBcImNvcmU6OmludGVnZXI6OnUyNTZcIjtcbiAgVWludDJbXCJ1NTEyXCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1NTEyXCI7XG4gIHJldHVybiBVaW50Mjtcbn0pKFVpbnQgfHwge30pO1xudmFyIExpdGVyYWwgPSAvKiBAX19QVVJFX18gKi8gKChMaXRlcmFsMikgPT4ge1xuICBMaXRlcmFsMltcIkNsYXNzSGFzaFwiXSA9IFwiY29yZTo6c3RhcmtuZXQ6OmNsYXNzX2hhc2g6OkNsYXNzSGFzaFwiO1xuICBMaXRlcmFsMltcIkNvbnRyYWN0QWRkcmVzc1wiXSA9IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiO1xuICBMaXRlcmFsMltcIlNlY3AyNTZrMVBvaW50XCJdID0gXCJjb3JlOjpzdGFya25ldDo6c2VjcDI1NmsxOjpTZWNwMjU2azFQb2ludFwiO1xuICByZXR1cm4gTGl0ZXJhbDI7XG59KShMaXRlcmFsIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2xpYi9jb250cmFjdC9pbmRleC50c1xudmFyIEVudHJ5UG9pbnRUeXBlID0gLyogQF9fUFVSRV9fICovICgoRW50cnlQb2ludFR5cGUyKSA9PiB7XG4gIEVudHJ5UG9pbnRUeXBlMltcIkVYVEVSTkFMXCJdID0gXCJFWFRFUk5BTFwiO1xuICBFbnRyeVBvaW50VHlwZTJbXCJMMV9IQU5ETEVSXCJdID0gXCJMMV9IQU5ETEVSXCI7XG4gIEVudHJ5UG9pbnRUeXBlMltcIkNPTlNUUlVDVE9SXCJdID0gXCJDT05TVFJVQ1RPUlwiO1xuICByZXR1cm4gRW50cnlQb2ludFR5cGUyO1xufSkoRW50cnlQb2ludFR5cGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvbGliL2luZGV4LnRzXG52YXIgVHJhbnNhY3Rpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25UeXBlMikgPT4ge1xuICBUcmFuc2FjdGlvblR5cGUyW1wiREVDTEFSRVwiXSA9IFwiREVDTEFSRVwiO1xuICBUcmFuc2FjdGlvblR5cGUyW1wiREVQTE9ZXCJdID0gXCJERVBMT1lcIjtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCJERVBMT1lfQUNDT1VOVFwiO1xuICBUcmFuc2FjdGlvblR5cGUyW1wiSU5WT0tFXCJdID0gXCJJTlZPS0VfRlVOQ1RJT05cIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZTI7XG59KShUcmFuc2FjdGlvblR5cGUgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25TdGF0dXMyKSA9PiB7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIk5PVF9SRUNFSVZFRFwiXSA9IFwiTk9UX1JFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIlJFQ0VJVkVEXCJdID0gXCJSRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJSRVZFUlRFRFwiXSA9IFwiUkVWRVJURURcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uU3RhdHVzMjtcbn0pKFRyYW5zYWN0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czIpID0+IHtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJOT1RfUkVDRUlWRURcIl0gPSBcIk5PVF9SRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIlJFQ0VJVkVEXCJdID0gXCJSRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czI7XG59KShUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMikgPT4ge1xuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiUkVWRVJURURcIl0gPSBcIlJFVkVSVEVEXCI7XG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlNVQ0NFRURFRFwiXSA9IFwiU1VDQ0VFREVEXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czI7XG59KShUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyB8fCB7fSk7XG52YXIgQmxvY2tTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChCbG9ja1N0YXR1czIpID0+IHtcbiAgQmxvY2tTdGF0dXMyW1wiUEVORElOR1wiXSA9IFwiUEVORElOR1wiO1xuICBCbG9ja1N0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgQmxvY2tTdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIEJsb2NrU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICByZXR1cm4gQmxvY2tTdGF0dXMyO1xufSkoQmxvY2tTdGF0dXMgfHwge30pO1xudmFyIEJsb2NrVGFnID0gLyogQF9fUFVSRV9fICovICgoQmxvY2tUYWcyKSA9PiB7XG4gIEJsb2NrVGFnMltcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgQmxvY2tUYWcyW1wiTEFURVNUXCJdID0gXCJsYXRlc3RcIjtcbiAgcmV0dXJuIEJsb2NrVGFnMjtcbn0pKEJsb2NrVGFnIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL3R5cGVkRGF0YS50c1xuaW1wb3J0IHtcbiAgVHlwZWREYXRhUmV2aXNpb25cbn0gZnJvbSBcInN0YXJrbmV0LXR5cGVzLTA3XCI7XG5cbi8vIHNyYy91dGlscy9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCBcIkFzc2VydGlvbiBmYWlsdXJlXCIpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9udW0udHNcbnZhciBudW1fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobnVtX2V4cG9ydHMsIHtcbiAgYWRkUGVyY2VudDogKCkgPT4gYWRkUGVyY2VudCxcbiAgYXNzZXJ0SW5SYW5nZTogKCkgPT4gYXNzZXJ0SW5SYW5nZSxcbiAgYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheTogKCkgPT4gYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheSxcbiAgYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXk6ICgpID0+IGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5LFxuICBjbGVhbkhleDogKCkgPT4gY2xlYW5IZXgsXG4gIGdldERlY2ltYWxTdHJpbmc6ICgpID0+IGdldERlY2ltYWxTdHJpbmcsXG4gIGdldEhleFN0cmluZzogKCkgPT4gZ2V0SGV4U3RyaW5nLFxuICBnZXRIZXhTdHJpbmdBcnJheTogKCkgPT4gZ2V0SGV4U3RyaW5nQXJyYXksXG4gIGhleFRvQnl0ZXM6ICgpID0+IGhleFRvQnl0ZXMsXG4gIGhleFRvRGVjaW1hbFN0cmluZzogKCkgPT4gaGV4VG9EZWNpbWFsU3RyaW5nLFxuICBpc0JpZ0ludDogKCkgPT4gaXNCaWdJbnQsXG4gIGlzQm9vbGVhbjogKCkgPT4gaXNCb29sZWFuLFxuICBpc0hleDogKCkgPT4gaXNIZXgsXG4gIGlzTnVtYmVyOiAoKSA9PiBpc051bWJlcixcbiAgaXNTdHJpbmdXaG9sZU51bWJlcjogKCkgPT4gaXNTdHJpbmdXaG9sZU51bWJlcixcbiAgdG9CaWdJbnQ6ICgpID0+IHRvQmlnSW50LFxuICB0b0NhaXJvQm9vbDogKCkgPT4gdG9DYWlyb0Jvb2wsXG4gIHRvSGV4OiAoKSA9PiB0b0hleCxcbiAgdG9IZXhTdHJpbmc6ICgpID0+IHRvSGV4U3RyaW5nLFxuICB0b1N0b3JhZ2VLZXk6ICgpID0+IHRvU3RvcmFnZUtleVxufSk7XG5pbXBvcnQgeyBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXNOb2JsZSB9IGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCI7XG5mdW5jdGlvbiBpc0hleChoZXgpIHtcbiAgcmV0dXJuIC9eMHhbMC05YS1mXSokL2kudGVzdChoZXgpO1xufVxuZnVuY3Rpb24gdG9CaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0JpZ0ludCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiO1xufVxuZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeCh0b0JpZ0ludCh2YWx1ZSkudG9TdHJpbmcoMTYpKTtcbn1cbnZhciB0b0hleFN0cmluZyA9IHRvSGV4O1xuZnVuY3Rpb24gdG9TdG9yYWdlS2V5KG51bWJlcjIpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeCh0b0JpZ0ludChudW1iZXIyKS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsIFwiMFwiKSk7XG59XG5mdW5jdGlvbiBoZXhUb0RlY2ltYWxTdHJpbmcoaGV4KSB7XG4gIHJldHVybiBCaWdJbnQoYWRkSGV4UHJlZml4KGhleCkpLnRvU3RyaW5nKDEwKTtcbn1cbmZ1bmN0aW9uIGNsZWFuSGV4KGhleCkge1xuICByZXR1cm4gaGV4LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXigweCkwKy8sIFwiJDFcIik7XG59XG5mdW5jdGlvbiBhc3NlcnRJblJhbmdlKGlucHV0LCBsb3dlckJvdW5kLCB1cHBlckJvdW5kLCBpbnB1dE5hbWUgPSBcIlwiKSB7XG4gIGNvbnN0IG1lc3NhZ2VTdWZmaXggPSBpbnB1dE5hbWUgPT09IFwiXCIgPyBcImludmFsaWQgbGVuZ3RoXCIgOiBgaW52YWxpZCAke2lucHV0TmFtZX0gbGVuZ3RoYDtcbiAgY29uc3QgaW5wdXRCaWdJbnQgPSBCaWdJbnQoaW5wdXQpO1xuICBjb25zdCBsb3dlckJvdW5kQmlnSW50ID0gQmlnSW50KGxvd2VyQm91bmQpO1xuICBjb25zdCB1cHBlckJvdW5kQmlnSW50ID0gQmlnSW50KHVwcGVyQm91bmQpO1xuICBhc3NlcnQoXG4gICAgaW5wdXRCaWdJbnQgPj0gbG93ZXJCb3VuZEJpZ0ludCAmJiBpbnB1dEJpZ0ludCA8PSB1cHBlckJvdW5kQmlnSW50LFxuICAgIGBNZXNzYWdlIG5vdCBzaWduYWJsZSwgJHttZXNzYWdlU3VmZml4fS5gXG4gICk7XG59XG5mdW5jdGlvbiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5KGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEubWFwKCh4KSA9PiB0b0JpZ0ludCh4KS50b1N0cmluZygxMCkpO1xufVxuZnVuY3Rpb24gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXkoZGF0YSkge1xuICByZXR1cm4gZGF0YS5tYXAoKHgpID0+IHRvSGV4KHgpKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nV2hvbGVOdW1iZXIoc3RyKSB7XG4gIHJldHVybiAvXlxcZCskLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBnZXREZWNpbWFsU3RyaW5nKHN0cikge1xuICBpZiAoaXNIZXgoc3RyKSkge1xuICAgIHJldHVybiBoZXhUb0RlY2ltYWxTdHJpbmcoc3RyKTtcbiAgfVxuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcihzdHIpKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBuZWVkcyB0byBiZSBhIGhleC1zdHJpbmcgb3Igd2hvbGUtbnVtYmVyLXN0cmluZ2ApO1xufVxuZnVuY3Rpb24gZ2V0SGV4U3RyaW5nKHN0cikge1xuICBpZiAoaXNIZXgoc3RyKSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgaWYgKGlzU3RyaW5nV2hvbGVOdW1iZXIoc3RyKSkge1xuICAgIHJldHVybiB0b0hleFN0cmluZyhzdHIpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IG5lZWRzIHRvIGJlIGEgaGV4LXN0cmluZyBvciB3aG9sZS1udW1iZXItc3RyaW5nYCk7XG59XG5mdW5jdGlvbiBnZXRIZXhTdHJpbmdBcnJheShhcnJheSkge1xuICByZXR1cm4gYXJyYXkubWFwKGdldEhleFN0cmluZyk7XG59XG5mdW5jdGlvbiB0b0NhaXJvQm9vbCh2YWx1ZSkge1xuICByZXR1cm4gKCt2YWx1ZSkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoc3RyKSB7XG4gIGlmICghaXNIZXgoc3RyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBuZWVkcyB0byBiZSBhIGhleC1zdHJpbmdgKTtcbiAgbGV0IGFkYXB0ZWRWYWx1ZSA9IHJlbW92ZUhleFByZWZpeChzdHIpO1xuICBpZiAoYWRhcHRlZFZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICBhZGFwdGVkVmFsdWUgPSBgMCR7YWRhcHRlZFZhbHVlfWA7XG4gIH1cbiAgcmV0dXJuIGhleFRvQnl0ZXNOb2JsZShhZGFwdGVkVmFsdWUpO1xufVxuZnVuY3Rpb24gYWRkUGVyY2VudChudW1iZXIyLCBwZXJjZW50KSB7XG4gIGNvbnN0IGJpZ0ludE51bSA9IEJpZ0ludChudW1iZXIyKTtcbiAgcmV0dXJuIGJpZ0ludE51bSArIGJpZ0ludE51bSAqIEJpZ0ludChwZXJjZW50KSAvIDEwMG47XG59XG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiO1xufVxuXG4vLyBzcmMvdXRpbHMvaGFzaC9zZWxlY3Rvci50c1xudmFyIHNlbGVjdG9yX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNlbGVjdG9yX2V4cG9ydHMsIHtcbiAgZ2V0U2VsZWN0b3I6ICgpID0+IGdldFNlbGVjdG9yLFxuICBnZXRTZWxlY3RvckZyb21OYW1lOiAoKSA9PiBnZXRTZWxlY3RvckZyb21OYW1lLFxuICBrZWNjYWtCbjogKCkgPT4ga2VjY2FrQm4sXG4gIHN0YXJrbmV0S2VjY2FrOiAoKSA9PiBzdGFya25ldEtlY2Nha1xufSk7XG5pbXBvcnQgeyBrZWNjYWsgfSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG5mdW5jdGlvbiBrZWNjYWtCbih2YWx1ZSkge1xuICBjb25zdCBoZXhXaXRob3V0UHJlZml4ID0gcmVtb3ZlSGV4UHJlZml4KHRvSGV4KEJpZ0ludCh2YWx1ZSkpKTtcbiAgY29uc3QgZXZlbkhleCA9IGhleFdpdGhvdXRQcmVmaXgubGVuZ3RoICUgMiA9PT0gMCA/IGhleFdpdGhvdXRQcmVmaXggOiBgMCR7aGV4V2l0aG91dFByZWZpeH1gO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGtlY2NhayhoZXhUb0J5dGVzKGFkZEhleFByZWZpeChldmVuSGV4KSkpLnRvU3RyaW5nKDE2KSk7XG59XG5mdW5jdGlvbiBrZWNjYWtIZXgoc3RyKSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoa2VjY2FrKHV0ZjhUb0FycmF5KHN0cikpLnRvU3RyaW5nKDE2KSk7XG59XG5mdW5jdGlvbiBzdGFya25ldEtlY2NhayhzdHIpIHtcbiAgY29uc3QgaGFzaCA9IEJpZ0ludChrZWNjYWtIZXgoc3RyKSk7XG4gIHJldHVybiBoYXNoICYgTUFTS18yNTA7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3RvckZyb21OYW1lKGZ1bmNOYW1lKSB7XG4gIHJldHVybiB0b0hleChzdGFya25ldEtlY2NhayhmdW5jTmFtZSkpO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0b3IodmFsdWUpIHtcbiAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdG9IZXhTdHJpbmcodmFsdWUpO1xuICB9XG4gIHJldHVybiBnZXRTZWxlY3RvckZyb21OYW1lKHZhbHVlKTtcbn1cblxuLy8gc3JjL3V0aWxzL3Nob3J0U3RyaW5nLnRzXG52YXIgc2hvcnRTdHJpbmdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc2hvcnRTdHJpbmdfZXhwb3J0cywge1xuICBkZWNvZGVTaG9ydFN0cmluZzogKCkgPT4gZGVjb2RlU2hvcnRTdHJpbmcsXG4gIGVuY29kZVNob3J0U3RyaW5nOiAoKSA9PiBlbmNvZGVTaG9ydFN0cmluZyxcbiAgaXNBU0NJSTogKCkgPT4gaXNBU0NJSSxcbiAgaXNEZWNpbWFsU3RyaW5nOiAoKSA9PiBpc0RlY2ltYWxTdHJpbmcsXG4gIGlzTG9uZ1RleHQ6ICgpID0+IGlzTG9uZ1RleHQsXG4gIGlzU2hvcnRTdHJpbmc6ICgpID0+IGlzU2hvcnRTdHJpbmcsXG4gIGlzU2hvcnRUZXh0OiAoKSA9PiBpc1Nob3J0VGV4dCxcbiAgaXNTdHJpbmc6ICgpID0+IGlzU3RyaW5nLFxuICBpc1RleHQ6ICgpID0+IGlzVGV4dCxcbiAgc3BsaXRMb25nU3RyaW5nOiAoKSA9PiBzcGxpdExvbmdTdHJpbmdcbn0pO1xuZnVuY3Rpb24gaXNBU0NJSShzdHIpIHtcbiAgcmV0dXJuIC9eW1xceDAwLVxceDdGXSokLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBpc1Nob3J0U3RyaW5nKHN0cikge1xuICByZXR1cm4gc3RyLmxlbmd0aCA8PSBURVhUX1RPX0ZFTFRfTUFYX0xFTjtcbn1cbmZ1bmN0aW9uIGlzRGVjaW1hbFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIC9eWzAtOV0qJC9pLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc1RleHQodmFsKSB7XG4gIHJldHVybiBpc1N0cmluZyh2YWwpICYmICFpc0hleCh2YWwpICYmICFpc1N0cmluZ1dob2xlTnVtYmVyKHZhbCk7XG59XG52YXIgaXNTaG9ydFRleHQgPSAodmFsKSA9PiBpc1RleHQodmFsKSAmJiBpc1Nob3J0U3RyaW5nKHZhbCk7XG52YXIgaXNMb25nVGV4dCA9ICh2YWwpID0+IGlzVGV4dCh2YWwpICYmICFpc1Nob3J0U3RyaW5nKHZhbCk7XG5mdW5jdGlvbiBzcGxpdExvbmdTdHJpbmcobG9uZ1N0cikge1xuICBjb25zdCByZWdleCA9IFJlZ0V4cChgW15dezEsJHtURVhUX1RPX0ZFTFRfTUFYX0xFTn19YCwgXCJnXCIpO1xuICByZXR1cm4gbG9uZ1N0ci5tYXRjaChyZWdleCkgfHwgW107XG59XG5mdW5jdGlvbiBlbmNvZGVTaG9ydFN0cmluZyhzdHIpIHtcbiAgaWYgKCFpc0FTQ0lJKHN0cikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgbm90IGFuIEFTQ0lJIHN0cmluZ2ApO1xuICBpZiAoIWlzU2hvcnRTdHJpbmcoc3RyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyB0b28gbG9uZ2ApO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KHN0ci5yZXBsYWNlKC8uL2csIChjaGFyKSA9PiBjaGFyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKSk7XG59XG5mdW5jdGlvbiBkZWNvZGVTaG9ydFN0cmluZyhzdHIpIHtcbiAgaWYgKCFpc0FTQ0lJKHN0cikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgbm90IGFuIEFTQ0lJIHN0cmluZ2ApO1xuICBpZiAoaXNIZXgoc3RyKSkge1xuICAgIHJldHVybiByZW1vdmVIZXhQcmVmaXgoc3RyKS5yZXBsYWNlKC8uezJ9L2csIChoZXgpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpKTtcbiAgfVxuICBpZiAoaXNEZWNpbWFsU3RyaW5nKHN0cikpIHtcbiAgICByZXR1cm4gZGVjb2RlU2hvcnRTdHJpbmcoXCIwWFwiLmNvbmNhdChCaWdJbnQoc3RyKS50b1N0cmluZygxNikpKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyBub3QgSGV4IG9yIGRlY2ltYWxgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2J5dGVBcnJheS50c1xudmFyIGJ5dGVBcnJheV9leHBvcnRzID0ge307XG5fX2V4cG9ydChieXRlQXJyYXlfZXhwb3J0cywge1xuICBieXRlQXJyYXlGcm9tU3RyaW5nOiAoKSA9PiBieXRlQXJyYXlGcm9tU3RyaW5nLFxuICBzdHJpbmdGcm9tQnl0ZUFycmF5OiAoKSA9PiBzdHJpbmdGcm9tQnl0ZUFycmF5XG59KTtcbmZ1bmN0aW9uIHN0cmluZ0Zyb21CeXRlQXJyYXkobXlCeXRlQXJyYXkpIHtcbiAgY29uc3QgcGVuZGluZ193b3JkID0gQmlnSW50KG15Qnl0ZUFycmF5LnBlbmRpbmdfd29yZCkgPT09IDBuID8gXCJcIiA6IGRlY29kZVNob3J0U3RyaW5nKHRvSGV4KG15Qnl0ZUFycmF5LnBlbmRpbmdfd29yZCkpO1xuICByZXR1cm4gbXlCeXRlQXJyYXkuZGF0YS5yZWR1Y2UoKGN1bXVsZWRTdHJpbmcsIGVuY29kZWRTdHJpbmcpID0+IHtcbiAgICBjb25zdCBhZGQgPSBCaWdJbnQoZW5jb2RlZFN0cmluZykgPT09IDBuID8gXCJcIiA6IGRlY29kZVNob3J0U3RyaW5nKHRvSGV4KGVuY29kZWRTdHJpbmcpKTtcbiAgICByZXR1cm4gY3VtdWxlZFN0cmluZyArIGFkZDtcbiAgfSwgXCJcIikgKyBwZW5kaW5nX3dvcmQ7XG59XG5mdW5jdGlvbiBieXRlQXJyYXlGcm9tU3RyaW5nKHRhcmdldFN0cmluZykge1xuICBjb25zdCBzaG9ydFN0cmluZ3MgPSBzcGxpdExvbmdTdHJpbmcodGFyZ2V0U3RyaW5nKTtcbiAgY29uc3QgcmVtYWluZGVyID0gc2hvcnRTdHJpbmdzW3Nob3J0U3RyaW5ncy5sZW5ndGggLSAxXTtcbiAgY29uc3Qgc2hvcnRTdHJpbmdzRW5jb2RlZCA9IHNob3J0U3RyaW5ncy5tYXAoZW5jb2RlU2hvcnRTdHJpbmcpO1xuICBjb25zdCBbcGVuZGluZ1dvcmQsIHBlbmRpbmdXb3JkTGVuZ3RoXSA9IHJlbWFpbmRlciA9PT0gdm9pZCAwIHx8IHJlbWFpbmRlci5sZW5ndGggPT09IDMxID8gW1wiMHgwMFwiLCAwXSA6IFtzaG9ydFN0cmluZ3NFbmNvZGVkLnBvcCgpLCByZW1haW5kZXIubGVuZ3RoXTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBzaG9ydFN0cmluZ3NFbmNvZGVkLmxlbmd0aCA9PT0gMCA/IFtdIDogc2hvcnRTdHJpbmdzRW5jb2RlZCxcbiAgICBwZW5kaW5nX3dvcmQ6IHBlbmRpbmdXb3JkLFxuICAgIHBlbmRpbmdfd29yZF9sZW46IHBlbmRpbmdXb3JkTGVuZ3RoXG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9jYWlyby50c1xudmFyIGNhaXJvX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNhaXJvX2V4cG9ydHMsIHtcbiAgZmVsdDogKCkgPT4gZmVsdCxcbiAgZ2V0QWJpQ29udHJhY3RWZXJzaW9uOiAoKSA9PiBnZXRBYmlDb250cmFjdFZlcnNpb24sXG4gIGdldEFycmF5VHlwZTogKCkgPT4gZ2V0QXJyYXlUeXBlLFxuICBpc0NhaXJvMUFiaTogKCkgPT4gaXNDYWlybzFBYmksXG4gIGlzQ2Fpcm8xVHlwZTogKCkgPT4gaXNDYWlybzFUeXBlLFxuICBpc0xlbjogKCkgPT4gaXNMZW4sXG4gIGlzVHlwZUFycmF5OiAoKSA9PiBpc1R5cGVBcnJheSxcbiAgaXNUeXBlQm9vbDogKCkgPT4gaXNUeXBlQm9vbCxcbiAgaXNUeXBlQnl0ZUFycmF5OiAoKSA9PiBpc1R5cGVCeXRlQXJyYXksXG4gIGlzVHlwZUJ5dGVzMzE6ICgpID0+IGlzVHlwZUJ5dGVzMzEsXG4gIGlzVHlwZUNvbnRyYWN0QWRkcmVzczogKCkgPT4gaXNUeXBlQ29udHJhY3RBZGRyZXNzLFxuICBpc1R5cGVFbnVtOiAoKSA9PiBpc1R5cGVFbnVtLFxuICBpc1R5cGVFdGhBZGRyZXNzOiAoKSA9PiBpc1R5cGVFdGhBZGRyZXNzLFxuICBpc1R5cGVGZWx0OiAoKSA9PiBpc1R5cGVGZWx0LFxuICBpc1R5cGVMaXRlcmFsOiAoKSA9PiBpc1R5cGVMaXRlcmFsLFxuICBpc1R5cGVOYW1lZFR1cGxlOiAoKSA9PiBpc1R5cGVOYW1lZFR1cGxlLFxuICBpc1R5cGVOb25aZXJvOiAoKSA9PiBpc1R5cGVOb25aZXJvLFxuICBpc1R5cGVPcHRpb246ICgpID0+IGlzVHlwZU9wdGlvbixcbiAgaXNUeXBlUmVzdWx0OiAoKSA9PiBpc1R5cGVSZXN1bHQsXG4gIGlzVHlwZVNlY3AyNTZrMVBvaW50OiAoKSA9PiBpc1R5cGVTZWNwMjU2azFQb2ludCxcbiAgaXNUeXBlU3RydWN0OiAoKSA9PiBpc1R5cGVTdHJ1Y3QsXG4gIGlzVHlwZVR1cGxlOiAoKSA9PiBpc1R5cGVUdXBsZSxcbiAgaXNUeXBlVWludDogKCkgPT4gaXNUeXBlVWludCxcbiAgaXNUeXBlVWludDI1NjogKCkgPT4gaXNUeXBlVWludDI1NixcbiAgdHVwbGU6ICgpID0+IHR1cGxlLFxuICB1aW50MjU2OiAoKSA9PiB1aW50MjU2LFxuICB1aW50NTEyOiAoKSA9PiB1aW50NTEyXG59KTtcblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL2ZlbHQudHNcbmZ1bmN0aW9uIENhaXJvRmVsdChpdCkge1xuICBpZiAoaXNCaWdJbnQoaXQpIHx8IE51bWJlci5pc0ludGVnZXIoaXQpKSB7XG4gICAgcmV0dXJuIGl0LnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKGlzU3RyaW5nKGl0KSkge1xuICAgIGlmIChpc0hleChpdCkpIHtcbiAgICAgIHJldHVybiBCaWdJbnQoaXQpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc1RleHQoaXQpKSB7XG4gICAgICBpZiAoIWlzU2hvcnRTdHJpbmcoaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtpdH0gaXMgYSBsb25nIHN0cmluZyA+IDMxIGNoYXJzLiBQbGVhc2Ugc3BsaXQgaXQgaW50byBhbiBhcnJheSBvZiBzaG9ydCBzdHJpbmdzLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoaXQpKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcihpdCkpIHtcbiAgICAgIHJldHVybiBpdDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQm9vbGVhbihpdCkpIHtcbiAgICByZXR1cm4gYCR7K2l0fWA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke2l0fSBjYW4ndCBiZSBjb21wdXRlZCBieSBmZWx0KClgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL3VpbnQyNTYudHNcbnZhciBVSU5UXzEyOF9NQVggPSAoMW4gPDwgMTI4bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NQVggPSAoMW4gPDwgMjU2bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NSU4gPSAwbjtcbnZhciBVSU5UXzI1Nl9MT1dfTUFYID0gMzQwMjgyMzY2OTIwOTM4NDYzNDYzMzc0NjA3NDMxNzY4MjExNDU1bjtcbnZhciBVSU5UXzI1Nl9ISUdIX01BWCA9IDM0MDI4MjM2NjkyMDkzODQ2MzQ2MzM3NDYwNzQzMTc2ODIxMTQ1NW47XG52YXIgVUlOVF8yNTZfTE9XX01JTiA9IDBuO1xudmFyIFVJTlRfMjU2X0hJR0hfTUlOID0gMG47XG52YXIgQ2Fpcm9VaW50MjU2ID0gY2xhc3MgX0NhaXJvVWludDI1NiB7XG4gIGxvdztcbiAgaGlnaDtcbiAgc3RhdGljIGFiaVNlbGVjdG9yID0gXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCI7XG4gIGNvbnN0cnVjdG9yKC4uLmFycikge1xuICAgIGlmICh0eXBlb2YgYXJyWzBdID09PSBcIm9iamVjdFwiICYmIGFyci5sZW5ndGggPT09IDEgJiYgXCJsb3dcIiBpbiBhcnJbMF0gJiYgXCJoaWdoXCIgaW4gYXJyWzBdKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IF9DYWlyb1VpbnQyNTYudmFsaWRhdGVQcm9wcyhhcnJbMF0ubG93LCBhcnJbMF0uaGlnaCk7XG4gICAgICB0aGlzLmxvdyA9IHByb3BzLmxvdztcbiAgICAgIHRoaXMuaGlnaCA9IHByb3BzLmhpZ2g7XG4gICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBiaWdJbnQgPSBfQ2Fpcm9VaW50MjU2LnZhbGlkYXRlKGFyclswXSk7XG4gICAgICB0aGlzLmxvdyA9IGJpZ0ludCAmIFVJTlRfMTI4X01BWDtcbiAgICAgIHRoaXMuaGlnaCA9IGJpZ0ludCA+PiAxMjhuO1xuICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgcHJvcHMgPSBfQ2Fpcm9VaW50MjU2LnZhbGlkYXRlUHJvcHMoYXJyWzBdLCBhcnJbMV0pO1xuICAgICAgdGhpcy5sb3cgPSBwcm9wcy5sb3c7XG4gICAgICB0aGlzLmhpZ2ggPSBwcm9wcy5oaWdoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkluY29ycmVjdCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgaWYgQmlnTnVtYmVyaXNoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVbml0MjU2XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGUoYmlnTnVtYmVyaXNoKSB7XG4gICAgY29uc3QgYmlnSW50ID0gQmlnSW50KGJpZ051bWJlcmlzaCk7XG4gICAgaWYgKGJpZ0ludCA8IFVJTlRfMjU2X01JTilcbiAgICAgIHRocm93IEVycm9yKFwiYmlnTnVtYmVyaXNoIGlzIHNtYWxsZXIgdGhhbiBVSU5UXzI1Nl9NSU5cIik7XG4gICAgaWYgKGJpZ0ludCA+IFVJTlRfMjU2X01BWClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJpZ051bWJlcmlzaCBpcyBiaWdnZXIgdGhhbiBVSU5UXzI1Nl9NQVhcIik7XG4gICAgcmV0dXJuIGJpZ0ludDtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgaWYgbG93IGFuZCBoaWdoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVbml0MjU2XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVQcm9wcyhsb3csIGhpZ2gpIHtcbiAgICBjb25zdCBiaWdJbnRMb3cgPSBCaWdJbnQobG93KTtcbiAgICBjb25zdCBiaWdJbnRIaWdoID0gQmlnSW50KGhpZ2gpO1xuICAgIGlmIChiaWdJbnRMb3cgPCBVSU5UXzI1Nl9MT1dfTUlOIHx8IGJpZ0ludExvdyA+IFVJTlRfMjU2X0xPV19NQVgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxvdyBpcyBvdXQgb2YgcmFuZ2UgVUlOVF8yNTZfTE9XX01JTiAtIFVJTlRfMjU2X0xPV19NQVhcIik7XG4gICAgfVxuICAgIGlmIChiaWdJbnRIaWdoIDwgVUlOVF8yNTZfSElHSF9NSU4gfHwgYmlnSW50SGlnaCA+IFVJTlRfMjU2X0hJR0hfTUFYKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoaWdoIGlzIG91dCBvZiByYW5nZSBVSU5UXzI1Nl9ISUdIX01JTiAtIFVJTlRfMjU2X0hJR0hfTUFYXCIpO1xuICAgIH1cbiAgICByZXR1cm4geyBsb3c6IGJpZ0ludExvdywgaGlnaDogYmlnSW50SGlnaCB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBCaWdOdW1iZXJpc2ggY2FuIGJlIHJlcHJlc2VudGVkIGFzIFVuaXQyNTZcbiAgICovXG4gIHN0YXRpYyBpcyhiaWdOdW1iZXJpc2gpIHtcbiAgICB0cnkge1xuICAgICAgX0NhaXJvVWludDI1Ni52YWxpZGF0ZShiaWdOdW1iZXJpc2gpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwcm92aWRlZCBhYmkgdHlwZSBpcyB0aGlzIGRhdGEgdHlwZVxuICAgKi9cbiAgc3RhdGljIGlzQWJpVHlwZShhYmlUeXBlKSB7XG4gICAgcmV0dXJuIGFiaVR5cGUgPT09IF9DYWlyb1VpbnQyNTYuYWJpU2VsZWN0b3I7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBiaWdpbnQgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIHRvQmlnSW50KCkge1xuICAgIHJldHVybiAodGhpcy5oaWdoIDw8IDEyOG4pICsgdGhpcy5sb3c7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBVaW50MjU2IHN0cnVjdHVyZSB3aXRoIEhleFN0cmluZyBwcm9wc1xuICAgKiB7bG93OiBIZXhTdHJpbmcsIGhpZ2g6IEhleFN0cmluZ31cbiAgICovXG4gIHRvVWludDI1NkhleFN0cmluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG93OiBhZGRIZXhQcmVmaXgodGhpcy5sb3cudG9TdHJpbmcoMTYpKSxcbiAgICAgIGhpZ2g6IGFkZEhleFByZWZpeCh0aGlzLmhpZ2gudG9TdHJpbmcoMTYpKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBVaW50MjU2IHN0cnVjdHVyZSB3aXRoIERlY2ltYWxTdHJpbmcgcHJvcHNcbiAgICoge2xvdzogRGVjU3RyaW5nLCBoaWdoOiBEZWNTdHJpbmd9XG4gICAqL1xuICB0b1VpbnQyNTZEZWNpbWFsU3RyaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb3c6IHRoaXMubG93LnRvU3RyaW5nKDEwKSxcbiAgICAgIGhpZ2g6IHRoaXMuaGlnaC50b1N0cmluZygxMClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYXBpIHJlcXVlc3RzIHJlcHJlc2VudGF0aW9uIHdpdGNoIGlzIGZlbHQgYXJyYXlcbiAgICovXG4gIHRvQXBpUmVxdWVzdCgpIHtcbiAgICByZXR1cm4gW0NhaXJvRmVsdCh0aGlzLmxvdyksIENhaXJvRmVsdCh0aGlzLmhpZ2gpXTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL3VpbnQ1MTIudHNcbnZhciBVSU5UXzUxMl9NQVggPSAoMW4gPDwgNTEybikgLSAxbjtcbnZhciBVSU5UXzUxMl9NSU4gPSAwbjtcbnZhciBVSU5UXzEyOF9NSU4gPSAwbjtcbnZhciBDYWlyb1VpbnQ1MTIgPSBjbGFzcyBfQ2Fpcm9VaW50NTEyIHtcbiAgbGltYjA7XG4gIGxpbWIxO1xuICBsaW1iMjtcbiAgbGltYjM7XG4gIHN0YXRpYyBhYmlTZWxlY3RvciA9IFwiY29yZTo6aW50ZWdlcjo6dTUxMlwiO1xuICBjb25zdHJ1Y3RvciguLi5hcnIpIHtcbiAgICBpZiAodHlwZW9mIGFyclswXSA9PT0gXCJvYmplY3RcIiAmJiBhcnIubGVuZ3RoID09PSAxICYmIFwibGltYjBcIiBpbiBhcnJbMF0gJiYgXCJsaW1iMVwiIGluIGFyclswXSAmJiBcImxpbWIyXCIgaW4gYXJyWzBdICYmIFwibGltYjNcIiBpbiBhcnJbMF0pIHtcbiAgICAgIGNvbnN0IHByb3BzID0gX0NhaXJvVWludDUxMi52YWxpZGF0ZVByb3BzKFxuICAgICAgICBhcnJbMF0ubGltYjAsXG4gICAgICAgIGFyclswXS5saW1iMSxcbiAgICAgICAgYXJyWzBdLmxpbWIyLFxuICAgICAgICBhcnJbMF0ubGltYjNcbiAgICAgICk7XG4gICAgICB0aGlzLmxpbWIwID0gcHJvcHMubGltYjA7XG4gICAgICB0aGlzLmxpbWIxID0gcHJvcHMubGltYjE7XG4gICAgICB0aGlzLmxpbWIyID0gcHJvcHMubGltYjI7XG4gICAgICB0aGlzLmxpbWIzID0gcHJvcHMubGltYjM7XG4gICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBiaWdJbnQgPSBfQ2Fpcm9VaW50NTEyLnZhbGlkYXRlKGFyclswXSk7XG4gICAgICB0aGlzLmxpbWIwID0gYmlnSW50ICYgVUlOVF8xMjhfTUFYO1xuICAgICAgdGhpcy5saW1iMSA9IChiaWdJbnQgJiBVSU5UXzEyOF9NQVggPDwgMTI4bikgPj4gMTI4bjtcbiAgICAgIHRoaXMubGltYjIgPSAoYmlnSW50ICYgVUlOVF8xMjhfTUFYIDw8IDI1Nm4pID4+IDI1Nm47XG4gICAgICB0aGlzLmxpbWIzID0gYmlnSW50ID4+IDM4NG47XG4gICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoID09PSA0KSB7XG4gICAgICBjb25zdCBwcm9wcyA9IF9DYWlyb1VpbnQ1MTIudmFsaWRhdGVQcm9wcyhhcnJbMF0sIGFyclsxXSwgYXJyWzJdLCBhcnJbM10pO1xuICAgICAgdGhpcy5saW1iMCA9IHByb3BzLmxpbWIwO1xuICAgICAgdGhpcy5saW1iMSA9IHByb3BzLmxpbWIxO1xuICAgICAgdGhpcy5saW1iMiA9IHByb3BzLmxpbWIyO1xuICAgICAgdGhpcy5saW1iMyA9IHByb3BzLmxpbWIzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkluY29ycmVjdCBVaW50NTEyIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnNcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBpZiBCaWdOdW1iZXJpc2ggY2FuIGJlIHJlcHJlc2VudGVkIGFzIFVpbnQ1MTJcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZShiaWdOdW1iZXJpc2gpIHtcbiAgICBjb25zdCBiaWdJbnQgPSBCaWdJbnQoYmlnTnVtYmVyaXNoKTtcbiAgICBpZiAoYmlnSW50IDwgVUlOVF81MTJfTUlOKVxuICAgICAgdGhyb3cgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgc21hbGxlciB0aGFuIFVJTlRfNTEyX01JTi5cIik7XG4gICAgaWYgKGJpZ0ludCA+IFVJTlRfNTEyX01BWClcbiAgICAgIHRocm93IEVycm9yKFwiYmlnTnVtYmVyaXNoIGlzIGJpZ2dlciB0aGFuIFVJTlRfNTEyX01BWC5cIik7XG4gICAgcmV0dXJuIGJpZ0ludDtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgaWYgbGltYnMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIFVpbnQ1MTJcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZVByb3BzKGxpbWIwLCBsaW1iMSwgbGltYjIsIGxpbWIzKSB7XG4gICAgY29uc3QgbDAgPSBCaWdJbnQobGltYjApO1xuICAgIGNvbnN0IGwxID0gQmlnSW50KGxpbWIxKTtcbiAgICBjb25zdCBsMiA9IEJpZ0ludChsaW1iMik7XG4gICAgY29uc3QgbDMgPSBCaWdJbnQobGltYjMpO1xuICAgIFtsMCwgbDEsIGwyLCBsM10uZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICBpZiAodmFsdWUgPCBVSU5UXzEyOF9NSU4gfHwgdmFsdWUgPiBVSU5UXzEyOF9NQVgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYGxpbWIke2luZGV4fSBpcyBub3QgaW4gdGhlIHJhbmdlIG9mIGEgdTEyOCBudW1iZXJgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyBsaW1iMDogbDAsIGxpbWIxOiBsMSwgbGltYjI6IGwyLCBsaW1iMzogbDMgfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgQmlnTnVtYmVyaXNoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVaW50NTEyXG4gICAqL1xuICBzdGF0aWMgaXMoYmlnTnVtYmVyaXNoKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9DYWlyb1VpbnQ1MTIudmFsaWRhdGUoYmlnTnVtYmVyaXNoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcHJvdmlkZWQgYWJpIHR5cGUgaXMgdGhpcyBkYXRhIHR5cGVcbiAgICovXG4gIHN0YXRpYyBpc0FiaVR5cGUoYWJpVHlwZSkge1xuICAgIHJldHVybiBhYmlUeXBlID09PSBfQ2Fpcm9VaW50NTEyLmFiaVNlbGVjdG9yO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYmlnaW50IHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICB0b0JpZ0ludCgpIHtcbiAgICByZXR1cm4gKHRoaXMubGltYjMgPDwgMzg0bikgKyAodGhpcy5saW1iMiA8PCAyNTZuKSArICh0aGlzLmxpbWIxIDw8IDEyOG4pICsgdGhpcy5saW1iMDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFVpbnQ1MTIgc3RydWN0dXJlIHdpdGggSGV4U3RyaW5nIHByb3BzXG4gICAqIGxpbWJ4OiBIZXhTdHJpbmdcbiAgICovXG4gIHRvVWludDUxMkhleFN0cmluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGltYjA6IGFkZEhleFByZWZpeCh0aGlzLmxpbWIwLnRvU3RyaW5nKDE2KSksXG4gICAgICBsaW1iMTogYWRkSGV4UHJlZml4KHRoaXMubGltYjEudG9TdHJpbmcoMTYpKSxcbiAgICAgIGxpbWIyOiBhZGRIZXhQcmVmaXgodGhpcy5saW1iMi50b1N0cmluZygxNikpLFxuICAgICAgbGltYjM6IGFkZEhleFByZWZpeCh0aGlzLmxpbWIzLnRvU3RyaW5nKDE2KSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVWludDUxMiBzdHJ1Y3R1cmUgd2l0aCBEZWNpbWFsU3RyaW5nIHByb3BzXG4gICAqIGxpbWJ4IERlY1N0cmluZ1xuICAgKi9cbiAgdG9VaW50NTEyRGVjaW1hbFN0cmluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGltYjA6IHRoaXMubGltYjAudG9TdHJpbmcoMTApLFxuICAgICAgbGltYjE6IHRoaXMubGltYjEudG9TdHJpbmcoMTApLFxuICAgICAgbGltYjI6IHRoaXMubGltYjIudG9TdHJpbmcoMTApLFxuICAgICAgbGltYjM6IHRoaXMubGltYjMudG9TdHJpbmcoMTApXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFwaSByZXF1ZXN0cyByZXByZXNlbnRhdGlvbiB3aXRjaCBpcyBmZWx0IGFycmF5XG4gICAqL1xuICB0b0FwaVJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIENhaXJvRmVsdCh0aGlzLmxpbWIwKSxcbiAgICAgIENhaXJvRmVsdCh0aGlzLmxpbWIxKSxcbiAgICAgIENhaXJvRmVsdCh0aGlzLmxpbWIyKSxcbiAgICAgIENhaXJvRmVsdCh0aGlzLmxpbWIzKVxuICAgIF07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9jYWlyby50c1xudmFyIGlzTGVuID0gKG5hbWUpID0+IC9fbGVuJC8udGVzdChuYW1lKTtcbnZhciBpc1R5cGVGZWx0ID0gKHR5cGUpID0+IHR5cGUgPT09IFwiZmVsdFwiIHx8IHR5cGUgPT09IFwiY29yZTo6ZmVsdDI1MlwiO1xudmFyIGlzVHlwZUFycmF5ID0gKHR5cGUpID0+IC9cXCovLnRlc3QodHlwZSkgfHwgdHlwZS5zdGFydHNXaXRoKFwiY29yZTo6YXJyYXk6OkFycmF5OjpcIikgfHwgdHlwZS5zdGFydHNXaXRoKFwiY29yZTo6YXJyYXk6OlNwYW46OlwiKTtcbnZhciBpc1R5cGVUdXBsZSA9ICh0eXBlKSA9PiAvXlxcKC4qXFwpJC9pLnRlc3QodHlwZSk7XG52YXIgaXNUeXBlTmFtZWRUdXBsZSA9ICh0eXBlKSA9PiAvXFwoLipcXCkvaS50ZXN0KHR5cGUpICYmIHR5cGUuaW5jbHVkZXMoXCI6XCIpO1xudmFyIGlzVHlwZVN0cnVjdCA9ICh0eXBlLCBzdHJ1Y3RzKSA9PiB0eXBlIGluIHN0cnVjdHM7XG52YXIgaXNUeXBlRW51bSA9ICh0eXBlLCBlbnVtcykgPT4gdHlwZSBpbiBlbnVtcztcbnZhciBpc1R5cGVPcHRpb24gPSAodHlwZSkgPT4gdHlwZS5zdGFydHNXaXRoKFwiY29yZTo6b3B0aW9uOjpPcHRpb246OlwiKTtcbnZhciBpc1R5cGVSZXN1bHQgPSAodHlwZSkgPT4gdHlwZS5zdGFydHNXaXRoKFwiY29yZTo6cmVzdWx0OjpSZXN1bHQ6OlwiKTtcbnZhciBpc1R5cGVVaW50ID0gKHR5cGUpID0+IE9iamVjdC52YWx1ZXMoVWludCkuaW5jbHVkZXModHlwZSk7XG52YXIgaXNUeXBlVWludDI1NiA9ICh0eXBlKSA9PiBDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpO1xudmFyIGlzVHlwZUxpdGVyYWwgPSAodHlwZSkgPT4gT2JqZWN0LnZhbHVlcyhMaXRlcmFsKS5pbmNsdWRlcyh0eXBlKTtcbnZhciBpc1R5cGVCb29sID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6Ym9vbFwiO1xudmFyIGlzVHlwZUNvbnRyYWN0QWRkcmVzcyA9ICh0eXBlKSA9PiB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIjtcbnZhciBpc1R5cGVFdGhBZGRyZXNzID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCI7XG52YXIgaXNUeXBlQnl0ZXMzMSA9ICh0eXBlKSA9PiB0eXBlID09PSBcImNvcmU6OmJ5dGVzXzMxOjpieXRlczMxXCI7XG52YXIgaXNUeXBlQnl0ZUFycmF5ID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6Ynl0ZV9hcnJheTo6Qnl0ZUFycmF5XCI7XG52YXIgaXNUeXBlU2VjcDI1NmsxUG9pbnQgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6c2VjcDI1NmsxOjpTZWNwMjU2azFQb2ludFwiO1xudmFyIGlzQ2Fpcm8xVHlwZSA9ICh0eXBlKSA9PiB0eXBlLmluY2x1ZGVzKFwiOjpcIik7XG52YXIgZ2V0QXJyYXlUeXBlID0gKHR5cGUpID0+IHtcbiAgaWYgKGlzQ2Fpcm8xVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiB0eXBlLnN1YnN0cmluZyh0eXBlLmluZGV4T2YoXCI8XCIpICsgMSwgdHlwZS5sYXN0SW5kZXhPZihcIj5cIikpO1xuICB9XG4gIHJldHVybiB0eXBlLnJlcGxhY2UoXCIqXCIsIFwiXCIpO1xufTtcbmZ1bmN0aW9uIGlzQ2Fpcm8xQWJpKGFiaSkge1xuICBjb25zdCB7IGNhaXJvIH0gPSBnZXRBYmlDb250cmFjdFZlcnNpb24oYWJpKTtcbiAgaWYgKGNhaXJvID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBFcnJvcihcIlVuYWJsZSB0byBkZXRlcm1pbmUgQ2Fpcm8gdmVyc2lvblwiKTtcbiAgfVxuICByZXR1cm4gY2Fpcm8gPT09IFwiMVwiO1xufVxuZnVuY3Rpb24gaXNUeXBlTm9uWmVybyh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjp6ZXJvYWJsZTo6Tm9uWmVybzo6XCIpO1xufVxuZnVuY3Rpb24gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGFiaSkge1xuICBpZiAoYWJpLmZpbmQoKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiKSkge1xuICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IFwiMlwiIH07XG4gIH1cbiAgY29uc3QgdGVzdEZ1bmN0aW9uID0gYWJpLmZpbmQoXG4gICAgKGl0KSA9PiBpdC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgKGl0LmlucHV0cy5sZW5ndGggfHwgaXQub3V0cHV0cy5sZW5ndGgpXG4gICk7XG4gIGlmICghdGVzdEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHsgY2Fpcm86IHZvaWQgMCwgY29tcGlsZXI6IHZvaWQgMCB9O1xuICB9XG4gIGNvbnN0IGlvID0gdGVzdEZ1bmN0aW9uLmlucHV0cy5sZW5ndGggPyB0ZXN0RnVuY3Rpb24uaW5wdXRzIDogdGVzdEZ1bmN0aW9uLm91dHB1dHM7XG4gIGlmIChpc0NhaXJvMVR5cGUoaW9bMF0udHlwZSkpIHtcbiAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiBcIjFcIiB9O1xuICB9XG4gIHJldHVybiB7IGNhaXJvOiBcIjBcIiwgY29tcGlsZXI6IFwiMFwiIH07XG59XG52YXIgdWludDI1NiA9IChpdCkgPT4ge1xuICByZXR1cm4gbmV3IENhaXJvVWludDI1NihpdCkudG9VaW50MjU2RGVjaW1hbFN0cmluZygpO1xufTtcbnZhciB1aW50NTEyID0gKGl0KSA9PiB7XG4gIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKGl0KS50b1VpbnQ1MTJEZWNpbWFsU3RyaW5nKCk7XG59O1xudmFyIHR1cGxlID0gKC4uLmFyZ3MpID0+ICh7IC4uLmFyZ3MgfSk7XG5mdW5jdGlvbiBmZWx0KGl0KSB7XG4gIHJldHVybiBDYWlyb0ZlbHQoaXQpO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZW51bS9DYWlyb0N1c3RvbUVudW0udHNcbnZhciBDYWlyb0N1c3RvbUVudW0gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBkaXJlY3QgcmVhZG9ubHkgYWNjZXNzIHRvIHZhcmlhbnRzIG9mIHRoZSBDYWlybyBDdXN0b20gRW51bS5cbiAgICogQHJldHVybnMgYSB2YWx1ZSBvZiB0eXBlIGFueVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHN1Y2Nlc3NWYWx1ZSA9IG15Q2Fpcm9FbnVtLnZhcmlhbnQuU3VjY2VzcztcbiAgICovXG4gIHZhcmlhbnQ7XG4gIC8qKlxuICAgKiBAcGFyYW0gZW51bUNvbnRlbnQgYW4gb2JqZWN0IHdpdGggdGhlIHZhcmlhbnRzIGFzIGtleXMgYW5kIHRoZSBjb250ZW50IGFzIHZhbHVlLiBPbmx5IG9uZSBjb250ZW50IHNoYWxsIGJlIGRlZmluZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnVtQ29udGVudCkge1xuICAgIGNvbnN0IHZhcmlhbnRzTGlzdCA9IE9iamVjdC52YWx1ZXMoZW51bUNvbnRlbnQpO1xuICAgIGlmICh2YXJpYW50c0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEVudW0gbXVzdCBoYXZlIGF0IGxlYXN0IDEgdmFyaWFudFwiKTtcbiAgICB9XG4gICAgY29uc3QgbmJBY3RpdmVWYXJpYW50cyA9IHZhcmlhbnRzTGlzdC5maWx0ZXIoXG4gICAgICAoY29udGVudCkgPT4gdHlwZW9mIGNvbnRlbnQgIT09IFwidW5kZWZpbmVkXCJcbiAgICApLmxlbmd0aDtcbiAgICBpZiAobmJBY3RpdmVWYXJpYW50cyAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBFbnVtIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBhY3RpdmUgdmFyaWFudFwiKTtcbiAgICB9XG4gICAgdGhpcy52YXJpYW50ID0gZW51bUNvbnRlbnQ7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSB2YWxpZCB2YXJpYW50IG9mIGEgQ2Fpcm8gY3VzdG9tIEVudW0uXG4gICAqL1xuICB1bndyYXAoKSB7XG4gICAgY29uc3QgdmFyaWFudHMgPSBPYmplY3QuZW50cmllcyh0aGlzLnZhcmlhbnQpO1xuICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKChpdGVtKSA9PiB0eXBlb2YgaXRlbVsxXSAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmVWYXJpYW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlVmFyaWFudFsxXTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICovXG4gIGFjdGl2ZVZhcmlhbnQoKSB7XG4gICAgY29uc3QgdmFyaWFudHMgPSBPYmplY3QuZW50cmllcyh0aGlzLnZhcmlhbnQpO1xuICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKChpdGVtKSA9PiB0eXBlb2YgaXRlbVsxXSAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmVWYXJpYW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZVZhcmlhbnRbMF07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9lbnVtL0NhaXJvT3B0aW9uLnRzXG52YXIgQ2Fpcm9PcHRpb25WYXJpYW50ID0gLyogQF9fUFVSRV9fICovICgoQ2Fpcm9PcHRpb25WYXJpYW50MikgPT4ge1xuICBDYWlyb09wdGlvblZhcmlhbnQyW0NhaXJvT3B0aW9uVmFyaWFudDJbXCJTb21lXCJdID0gMF0gPSBcIlNvbWVcIjtcbiAgQ2Fpcm9PcHRpb25WYXJpYW50MltDYWlyb09wdGlvblZhcmlhbnQyW1wiTm9uZVwiXSA9IDFdID0gXCJOb25lXCI7XG4gIHJldHVybiBDYWlyb09wdGlvblZhcmlhbnQyO1xufSkoQ2Fpcm9PcHRpb25WYXJpYW50IHx8IHt9KTtcbnZhciBDYWlyb09wdGlvbiA9IGNsYXNzIHtcbiAgU29tZTtcbiAgTm9uZTtcbiAgY29uc3RydWN0b3IodmFyaWFudCwgc29tZUNvbnRlbnQpIHtcbiAgICBpZiAoISh2YXJpYW50IGluIENhaXJvT3B0aW9uVmFyaWFudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIHZhcmlhbnQgOiBzaG91bGQgYmUgQ2Fpcm9PcHRpb25WYXJpYW50LlNvbWUgb3IgLk5vbmUuXCIpO1xuICAgIH1cbiAgICBpZiAodmFyaWFudCA9PT0gMCAvKiBTb21lICovKSB7XG4gICAgICBpZiAodHlwZW9mIHNvbWVDb250ZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIGNyZWF0aW9uIG9mIGEgQ2Fpcm8gT3B0aW9uIHdpdGggXCJTb21lXCIgdmFyaWFudCBuZWVkcyBhIGNvbnRlbnQgYXMgaW5wdXQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5Tb21lID0gc29tZUNvbnRlbnQ7XG4gICAgICB0aGlzLk5vbmUgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuU29tZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuTm9uZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIGN1c3RvbSBFbnVtLlxuICAgKiAgSWYgTm9uZSwgcmV0dXJucyAndW5kZWZpbmVkJy5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBpZiAodGhpcy5Ob25lKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5Tb21lO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdpc1NvbWUnLlxuICAgKi9cbiAgaXNTb21lKCkge1xuICAgIHJldHVybiAhKHR5cGVvZiB0aGlzLlNvbWUgPT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdpc05vbmUnLlxuICAgKi9cbiAgaXNOb25lKCkge1xuICAgIHJldHVybiB0aGlzLk5vbmUgPT09IHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9lbnVtL0NhaXJvUmVzdWx0LnRzXG52YXIgQ2Fpcm9SZXN1bHRWYXJpYW50ID0gLyogQF9fUFVSRV9fICovICgoQ2Fpcm9SZXN1bHRWYXJpYW50MikgPT4ge1xuICBDYWlyb1Jlc3VsdFZhcmlhbnQyW0NhaXJvUmVzdWx0VmFyaWFudDJbXCJPa1wiXSA9IDBdID0gXCJPa1wiO1xuICBDYWlyb1Jlc3VsdFZhcmlhbnQyW0NhaXJvUmVzdWx0VmFyaWFudDJbXCJFcnJcIl0gPSAxXSA9IFwiRXJyXCI7XG4gIHJldHVybiBDYWlyb1Jlc3VsdFZhcmlhbnQyO1xufSkoQ2Fpcm9SZXN1bHRWYXJpYW50IHx8IHt9KTtcbnZhciBDYWlyb1Jlc3VsdCA9IGNsYXNzIHtcbiAgT2s7XG4gIEVycjtcbiAgY29uc3RydWN0b3IodmFyaWFudCwgcmVzdWx0Q29udGVudCkge1xuICAgIGlmICghKHZhcmlhbnQgaW4gQ2Fpcm9SZXN1bHRWYXJpYW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgdmFyaWFudCA6IHNob3VsZCBiZSBDYWlyb1Jlc3VsdFZhcmlhbnQuT2sgb3IgLkVyci5cIik7XG4gICAgfVxuICAgIGlmICh2YXJpYW50ID09PSAwIC8qIE9rICovKSB7XG4gICAgICB0aGlzLk9rID0gcmVzdWx0Q29udGVudDtcbiAgICAgIHRoaXMuRXJyID0gdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLk9rID0gdm9pZCAwO1xuICAgICAgdGhpcy5FcnIgPSByZXN1bHRDb250ZW50O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBSZXN1bHQuXG4gICAqL1xuICB1bndyYXAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLk9rICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5PaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLkVyciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRoaXMuRXJyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIFJlc3VsdC5PayBhbmQgLkVyciBhcmUgdW5kZWZpbmVkLiBOb3QgYXV0aG9yaXplZC5cIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ09rJy5cbiAgICovXG4gIGlzT2soKSB7XG4gICAgcmV0dXJuICEodHlwZW9mIHRoaXMuT2sgPT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdpc0VycicuXG4gICAqL1xuICBpc0VycigpIHtcbiAgICByZXR1cm4gISh0eXBlb2YgdGhpcy5FcnIgPT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZm9ybWF0dGVyLnRzXG52YXIgZ3VhcmQgPSB7XG4gIGlzQk46IChkYXRhLCB0eXBlLCBrZXkpID0+IHtcbiAgICBpZiAoIWlzQmlnSW50KGRhdGFba2V5XSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBEYXRhIGFuZCBmb3JtYXR0ZXIgbWlzbWF0Y2ggb24gJHtrZXl9OiR7dHlwZVtrZXldfSwgZXhwZWN0ZWQgcmVzcG9uc2UgZGF0YSAke2tleX06JHtkYXRhW2tleV19IHRvIGJlIEJOIGluc3RlYWQgaXQgaXMgJHt0eXBlb2YgZGF0YVtrZXldfWBcbiAgICAgICk7XG4gIH0sXG4gIHVua25vd246IChkYXRhLCB0eXBlLCBrZXkpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBmb3JtYXR0ZXIgdHlwZSBvbiAke2tleX06JHt0eXBlW2tleV19IGZvciBkYXRhICR7a2V5fToke2RhdGFba2V5XX1gKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZvcm1hdHRlcihkYXRhLCB0eXBlLCBzYW1lVHlwZSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKFxuICAgIChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgY29uc3QgZWxUeXBlID0gc2FtZVR5cGUgPz8gdHlwZVtrZXldO1xuICAgICAgaWYgKCEoa2V5IGluIHR5cGUpICYmICFzYW1lVHlwZSkge1xuICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKGVsVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleV0pKSB7XG4gICAgICAgICAgY29uc3QgYXJyYXlTdHIgPSBmb3JtYXR0ZXIoXG4gICAgICAgICAgICBkYXRhW2tleV0sXG4gICAgICAgICAgICBkYXRhW2tleV0ubWFwKChfKSA9PiBlbFR5cGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhY2Nba2V5XSA9IE9iamVjdC52YWx1ZXMoYXJyYXlTdHIpLmpvaW4oXCJcIik7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfVxuICAgICAgICBndWFyZC5pc0JOKGRhdGEsIHR5cGUsIGtleSk7XG4gICAgICAgIGFjY1trZXldID0gZGVjb2RlU2hvcnRTdHJpbmcodmFsdWUpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKGVsVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBndWFyZC5pc0JOKGRhdGEsIHR5cGUsIGtleSk7XG4gICAgICAgIGFjY1trZXldID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZWxUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYWNjW2tleV0gPSBlbFR5cGUodmFsdWUpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxUeXBlKSkge1xuICAgICAgICBjb25zdCBhcnJheU9iaiA9IGZvcm1hdHRlcihkYXRhW2tleV0sIGVsVHlwZSwgZWxUeXBlWzBdKTtcbiAgICAgICAgYWNjW2tleV0gPSBPYmplY3QudmFsdWVzKGFycmF5T2JqKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZWxUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGFjY1trZXldID0gZm9ybWF0dGVyKGRhdGFba2V5XSwgZWxUeXBlKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGd1YXJkLnVua25vd24oZGF0YSwgdHlwZSwga2V5KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICB7fVxuICApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL3BhcnNlci0wLTEuMS4wLnRzXG52YXIgQWJpUGFyc2VyMSA9IGNsYXNzIHtcbiAgYWJpO1xuICBjb25zdHJ1Y3RvcihhYmkpIHtcbiAgICB0aGlzLmFiaSA9IGFiaTtcbiAgfVxuICAvKipcbiAgICogYWJpIG1ldGhvZCBpbnB1dHMgbGVuZ3RoIHdpdGhvdXQgJ19sZW4nIGlucHV0c1xuICAgKiBjYWlybyAwIHJlZHVjZXJcbiAgICogQHBhcmFtIGFiaU1ldGhvZCBGdW5jdGlvbkFiaVxuICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICovXG4gIG1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpIHtcbiAgICByZXR1cm4gYWJpTWV0aG9kLmlucHV0cy5yZWR1Y2UoKGFjYywgaW5wdXQpID0+ICFpc0xlbihpbnB1dC5uYW1lKSA/IGFjYyArIDEgOiBhY2MsIDApO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgbWV0aG9kIGRlZmluaXRpb24gZnJvbSBhYmlcbiAgICogQHBhcmFtIG5hbWUgc3RyaW5nXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uQWJpIHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRNZXRob2QobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFiaS5maW5kKChpdCkgPT4gaXQubmFtZSA9PT0gbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBBYmkgaW4gbGVnYWN5IGZvcm1hdFxuICAgKiBAcmV0dXJucyBBYmlcbiAgICovXG4gIGdldExlZ2FjeUZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYmk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvcGFyc2VyLTIuMC4wLnRzXG52YXIgQWJpUGFyc2VyMiA9IGNsYXNzIHtcbiAgYWJpO1xuICBjb25zdHJ1Y3RvcihhYmkpIHtcbiAgICB0aGlzLmFiaSA9IGFiaTtcbiAgfVxuICAvKipcbiAgICogYWJpIG1ldGhvZCBpbnB1dHMgbGVuZ3RoXG4gICAqIEBwYXJhbSBhYmlNZXRob2QgRnVuY3Rpb25BYmlcbiAgICogQHJldHVybnMgbnVtYmVyXG4gICAqL1xuICBtZXRob2RJbnB1dHNMZW5ndGgoYWJpTWV0aG9kKSB7XG4gICAgcmV0dXJuIGFiaU1ldGhvZC5pbnB1dHMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgbWV0aG9kIGRlZmluaXRpb24gZnJvbSBhYmlcbiAgICogQHBhcmFtIG5hbWUgc3RyaW5nXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uQWJpIHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRNZXRob2QobmFtZSkge1xuICAgIGNvbnN0IGludGYgPSB0aGlzLmFiaS5maW5kKFxuICAgICAgKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiXG4gICAgKTtcbiAgICByZXR1cm4gaW50Zi5pdGVtcy5maW5kKChpdCkgPT4gaXQubmFtZSA9PT0gbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBBYmkgaW4gbGVnYWN5IGZvcm1hdFxuICAgKiBAcmV0dXJucyBBYmlcbiAgICovXG4gIGdldExlZ2FjeUZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYmkuZmxhdE1hcCgoZSkgPT4ge1xuICAgICAgaWYgKGUudHlwZSA9PT0gXCJpbnRlcmZhY2VcIikge1xuICAgICAgICByZXR1cm4gZS5pdGVtcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL2luZGV4LnRzXG5mdW5jdGlvbiBjcmVhdGVBYmlQYXJzZXIoYWJpKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBnZXRBYmlWZXJzaW9uKGFiaSk7XG4gIGlmICh2ZXJzaW9uID09PSAwIHx8IHZlcnNpb24gPT09IDEpIHtcbiAgICByZXR1cm4gbmV3IEFiaVBhcnNlcjEoYWJpKTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMikge1xuICAgIHJldHVybiBuZXcgQWJpUGFyc2VyMihhYmkpO1xuICB9XG4gIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBBQkkgdmVyc2lvbiAke3ZlcnNpb259YCk7XG59XG5mdW5jdGlvbiBnZXRBYmlWZXJzaW9uKGFiaSkge1xuICBpZiAoYWJpLmZpbmQoKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiKSlcbiAgICByZXR1cm4gMjtcbiAgaWYgKGlzQ2Fpcm8xQWJpKGFiaSkpXG4gICAgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNOb0NvbnN0cnVjdG9yVmFsaWQobWV0aG9kLCBhcmdzQ2FsbGRhdGEsIGFiaU1ldGhvZCkge1xuICByZXR1cm4gbWV0aG9kID09PSBcImNvbnN0cnVjdG9yXCIgJiYgIWFiaU1ldGhvZCAmJiAhYXJnc0NhbGxkYXRhLmxlbmd0aDtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3R1cGxlLnRzXG5mdW5jdGlvbiBwYXJzZU5hbWVkVHVwbGUobmFtZWRUdXBsZSkge1xuICBjb25zdCBuYW1lID0gbmFtZWRUdXBsZS5zdWJzdHJpbmcoMCwgbmFtZWRUdXBsZS5pbmRleE9mKFwiOlwiKSk7XG4gIGNvbnN0IHR5cGUgPSBuYW1lZFR1cGxlLnN1YnN0cmluZyhuYW1lLmxlbmd0aCArIFwiOlwiLmxlbmd0aCk7XG4gIHJldHVybiB7IG5hbWUsIHR5cGUgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3ViVHVwbGUocykge1xuICBpZiAoIXMuaW5jbHVkZXMoXCIoXCIpKVxuICAgIHJldHVybiB7IHN1YlR1cGxlOiBbXSwgcmVzdWx0OiBzIH07XG4gIGNvbnN0IHN1YlR1cGxlID0gW107XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICBpZiAoc1tpXSA9PT0gXCIoXCIpIHtcbiAgICAgIGxldCBjb3VudGVyID0gMTtcbiAgICAgIGNvbnN0IGxCcmFja2V0ID0gaTtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjb3VudGVyKSB7XG4gICAgICAgIGlmIChzW2ldID09PSBcIilcIilcbiAgICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIGlmIChzW2ldID09PSBcIihcIilcbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHN1YlR1cGxlLnB1c2gocy5zdWJzdHJpbmcobEJyYWNrZXQsIGkpKTtcbiAgICAgIHJlc3VsdCArPSBcIiBcIjtcbiAgICAgIGktLTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHNbaV07XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICByZXR1cm4ge1xuICAgIHN1YlR1cGxlLFxuICAgIHJlc3VsdFxuICB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdENhaXJvMFR1cGxlKHR5cGUpIHtcbiAgY29uc3QgY2xlYW5UeXBlID0gdHlwZS5yZXBsYWNlKC9cXHMvZywgXCJcIikuc2xpY2UoMSwgLTEpO1xuICBjb25zdCB7IHN1YlR1cGxlLCByZXN1bHQgfSA9IHBhcnNlU3ViVHVwbGUoY2xlYW5UeXBlKTtcbiAgbGV0IHJlY29tcG9zZWQgPSByZXN1bHQuc3BsaXQoXCIsXCIpLm1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gc3ViVHVwbGUubGVuZ3RoID8gaXQucmVwbGFjZShcIiBcIiwgc3ViVHVwbGUuc2hpZnQoKSkgOiBpdDtcbiAgfSk7XG4gIGlmIChpc1R5cGVOYW1lZFR1cGxlKHR5cGUpKSB7XG4gICAgcmVjb21wb3NlZCA9IHJlY29tcG9zZWQucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZU5hbWVkVHVwbGUoaXQpKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgcmV0dXJuIHJlY29tcG9zZWQ7XG59XG5mdW5jdGlvbiBnZXRDbG9zdXJlT2Zmc2V0KGlucHV0LCBvcGVuLCBjbG9zZSkge1xuICBmb3IgKGxldCBpID0gMCwgY291bnRlciA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpbnB1dFtpXSA9PT0gb3Blbikge1xuICAgICAgY291bnRlcisrO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRbaV0gPT09IGNsb3NlICYmIC0tY291bnRlciA9PT0gMCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG59XG5mdW5jdGlvbiBleHRyYWN0Q2Fpcm8xVHVwbGUodHlwZSkge1xuICBjb25zdCBpbnB1dCA9IHR5cGUuc2xpY2UoMSwgLTEpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gIGxldCBsaW1pdEluZGV4O1xuICB3aGlsZSAoY3VycmVudEluZGV4IDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIGlucHV0W2N1cnJlbnRJbmRleF0gPT09IFwiKFwiOiB7XG4gICAgICAgIGxpbWl0SW5kZXggPSBjdXJyZW50SW5kZXggKyBnZXRDbG9zdXJlT2Zmc2V0KGlucHV0LnNsaWNlKGN1cnJlbnRJbmRleCksIFwiKFwiLCBcIilcIikgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgKGlucHV0LnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdDo6PFwiLCBjdXJyZW50SW5kZXgpIHx8IGlucHV0LnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6QXJyYXk6OjxcIiwgY3VycmVudEluZGV4KSB8fCBpbnB1dC5zdGFydHNXaXRoKFwiY29yZTo6b3B0aW9uOjpPcHRpb246OjxcIiwgY3VycmVudEluZGV4KSk6IHtcbiAgICAgICAgbGltaXRJbmRleCA9IGN1cnJlbnRJbmRleCArIGdldENsb3N1cmVPZmZzZXQoaW5wdXQuc2xpY2UoY3VycmVudEluZGV4KSwgXCI8XCIsIFwiPlwiKSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBjb21tYUluZGV4ID0gaW5wdXQuaW5kZXhPZihcIixcIiwgY3VycmVudEluZGV4KTtcbiAgICAgICAgbGltaXRJbmRleCA9IGNvbW1hSW5kZXggIT09IC0xID8gY29tbWFJbmRleCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2goaW5wdXQuc2xpY2UoY3VycmVudEluZGV4LCBsaW1pdEluZGV4KSk7XG4gICAgY3VycmVudEluZGV4ID0gbGltaXRJbmRleCArIDI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKHR5cGUpIHtcbiAgaWYgKGlzQ2Fpcm8xVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBleHRyYWN0Q2Fpcm8xVHVwbGUodHlwZSk7XG4gIH1cbiAgcmV0dXJuIGV4dHJhY3RDYWlybzBUdXBsZSh0eXBlKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3Byb3BlcnR5T3JkZXIudHNcbmZ1bmN0aW9uIGVycm9yVTI1NihrZXkpIHtcbiAgcmV0dXJuIEVycm9yKFxuICAgIGBZb3VyIG9iamVjdCBpbmNsdWRlcyB0aGUgcHJvcGVydHkgOiAke2tleX0sIGNvbnRhaW5pbmcgYW4gVWludDI1NiBvYmplY3Qgd2l0aG91dCB0aGUgJ2xvdycgYW5kICdoaWdoJyBrZXlzLmBcbiAgKTtcbn1cbmZ1bmN0aW9uIGVycm9yVTUxMihrZXkpIHtcbiAgcmV0dXJuIEVycm9yKFxuICAgIGBZb3VyIG9iamVjdCBpbmNsdWRlcyB0aGUgcHJvcGVydHkgOiAke2tleX0sIGNvbnRhaW5pbmcgYW4gVWludDUxMiBvYmplY3Qgd2l0aG91dCB0aGUgJ2xpbWIwJyB0byAnbGltYjMnIGtleXMuYFxuICApO1xufVxuZnVuY3Rpb24gb3JkZXJQcm9wc0J5QWJpKHVub3JkZXJlZE9iamVjdCwgYWJpT2ZPYmplY3QsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGNvbnN0IG9yZGVySW5wdXQgPSAodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSkgPT4ge1xuICAgIGlmIChpc1R5cGVBcnJheShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyQXJyYXkodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVFbnVtKGFiaVR5cGUsIGVudW1zKSkge1xuICAgICAgY29uc3QgYWJpT2JqID0gZW51bXNbYWJpVHlwZV07XG4gICAgICByZXR1cm4gb3JkZXJFbnVtKHVub3JkZXJlZEl0ZW0sIGFiaU9iaik7XG4gICAgfVxuICAgIGlmIChpc1R5cGVUdXBsZShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyVHVwbGUodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVFdGhBZGRyZXNzKGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZU5vblplcm8oYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiB1bm9yZGVyZWRJdGVtO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlQnl0ZUFycmF5KGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVNlY3AyNTZrMVBvaW50KGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgICB9XG4gICAgaWYgKENhaXJvVWludDI1Ni5pc0FiaVR5cGUoYWJpVHlwZSkpIHtcbiAgICAgIGNvbnN0IHUyNTYgPSB1bm9yZGVyZWRJdGVtO1xuICAgICAgaWYgKHR5cGVvZiB1MjU2ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB1MjU2O1xuICAgICAgfVxuICAgICAgaWYgKCEoXCJsb3dcIiBpbiB1MjU2ICYmIFwiaGlnaFwiIGluIHUyNTYpKSB7XG4gICAgICAgIHRocm93IGVycm9yVTI1NihhYmlUeXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGxvdzogdTI1Ni5sb3csIGhpZ2g6IHUyNTYuaGlnaCB9O1xuICAgIH1cbiAgICBpZiAoQ2Fpcm9VaW50NTEyLmlzQWJpVHlwZShhYmlUeXBlKSkge1xuICAgICAgY29uc3QgdTUxMiA9IHVub3JkZXJlZEl0ZW07XG4gICAgICBpZiAodHlwZW9mIHU1MTIgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHU1MTI7XG4gICAgICB9XG4gICAgICBpZiAoIVtcImxpbWIwXCIsIFwibGltYjFcIiwgXCJsaW1iMlwiLCBcImxpbWIzXCJdLmV2ZXJ5KChrZXkpID0+IGtleSBpbiB1NTEyKSkge1xuICAgICAgICB0aHJvdyBlcnJvclU1MTIoYWJpVHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBsaW1iMDogdTUxMi5saW1iMCwgbGltYjE6IHU1MTIubGltYjEsIGxpbWIyOiB1NTEyLmxpbWIyLCBsaW1iMzogdTUxMi5saW1iMyB9O1xuICAgIH1cbiAgICBpZiAoaXNUeXBlU3RydWN0KGFiaVR5cGUsIHN0cnVjdHMpKSB7XG4gICAgICBjb25zdCBhYmlPZlN0cnVjdCA9IHN0cnVjdHNbYWJpVHlwZV0ubWVtYmVycztcbiAgICAgIHJldHVybiBvcmRlclN0cnVjdCh1bm9yZGVyZWRJdGVtLCBhYmlPZlN0cnVjdCk7XG4gICAgfVxuICAgIHJldHVybiB1bm9yZGVyZWRJdGVtO1xuICB9O1xuICBjb25zdCBvcmRlclN0cnVjdCA9ICh1bm9yZGVyZWRPYmplY3QyLCBhYmlPYmplY3QpID0+IHtcbiAgICBjb25zdCBvcmRlcmVkT2JqZWN0MiA9IGFiaU9iamVjdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtKSA9PiB7XG4gICAgICBjb25zdCBzZXRQcm9wZXJ0eSA9ICh2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtLm5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlID8/IHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV1cbiAgICAgIH0pO1xuICAgICAgaWYgKHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGlzQ2Fpcm8xVHlwZShhYmlQYXJhbS50eXBlKSB8fCAhaXNMZW4oYWJpUGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgWW91ciBvYmplY3QgbmVlZHMgYSBwcm9wZXJ0eSB3aXRoIGtleSA6ICR7YWJpUGFyYW0ubmFtZX0gLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRQcm9wZXJ0eShvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV0sIGFiaVBhcmFtLnR5cGUpKTtcbiAgICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gb3JkZXJlZE9iamVjdDI7XG4gIH07XG4gIGZ1bmN0aW9uIG9yZGVyQXJyYXkobXlBcnJheSwgYWJpUGFyYW0pIHtcbiAgICBjb25zdCB0eXBlSW5BcnJheSA9IGdldEFycmF5VHlwZShhYmlQYXJhbSk7XG4gICAgaWYgKGlzU3RyaW5nKG15QXJyYXkpKSB7XG4gICAgICByZXR1cm4gbXlBcnJheTtcbiAgICB9XG4gICAgcmV0dXJuIG15QXJyYXkubWFwKChteUVsZW0pID0+IG9yZGVySW5wdXQobXlFbGVtLCB0eXBlSW5BcnJheSkpO1xuICB9XG4gIGZ1bmN0aW9uIG9yZGVyVHVwbGUodW5vcmRlcmVkT2JqZWN0MiwgYWJpUGFyYW0pIHtcbiAgICBjb25zdCB0eXBlTGlzdCA9IGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKGFiaVBhcmFtKTtcbiAgICBjb25zdCBvcmRlcmVkT2JqZWN0MiA9IHR5cGVMaXN0LnJlZHVjZSgob3JkZXJlZE9iamVjdCwgYWJpVHlwZUNhaXJvWCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IG15T2JqS2V5cyA9IE9iamVjdC5rZXlzKHVub3JkZXJlZE9iamVjdDIpO1xuICAgICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBpbmRleC50b1N0cmluZygpLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSA/PyB1bm9yZGVyZWRPYmplY3QyW215T2JqS2V5c1tpbmRleF1dXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFiaVR5cGUgPSBhYmlUeXBlQ2Fpcm9YPy50eXBlID8gYWJpVHlwZUNhaXJvWC50eXBlIDogYWJpVHlwZUNhaXJvWDtcbiAgICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0MltteU9iaktleXNbaW5kZXhdXSwgYWJpVHlwZSkpO1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBvcmRlcmVkT2JqZWN0MjtcbiAgfVxuICBjb25zdCBvcmRlckVudW0gPSAodW5vcmRlcmVkT2JqZWN0MiwgYWJpT2JqZWN0KSA9PiB7XG4gICAgaWYgKGlzVHlwZVJlc3VsdChhYmlPYmplY3QubmFtZSkpIHtcbiAgICAgIGNvbnN0IHVub3JkZXJlZFJlc3VsdCA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgICBjb25zdCByZXN1bHRPa1R5cGUgPSBhYmlPYmplY3QubmFtZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUubGFzdEluZGV4T2YoXCIsXCIpXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzdWx0RXJyVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIixcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodW5vcmRlcmVkUmVzdWx0LmlzT2soKSkge1xuICAgICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KFxuICAgICAgICAgIDAgLyogT2sgKi8sXG4gICAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyLnVud3JhcCgpLCByZXN1bHRPa1R5cGUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KFxuICAgICAgICAxIC8qIEVyciAqLyxcbiAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyLnVud3JhcCgpLCByZXN1bHRFcnJUeXBlKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZU9wdGlvbihhYmlPYmplY3QubmFtZSkpIHtcbiAgICAgIGNvbnN0IHVub3JkZXJlZE9wdGlvbiA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgICBjb25zdCByZXN1bHRTb21lVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIjxcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodW5vcmRlcmVkT3B0aW9uLmlzU29tZSgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2Fpcm9PcHRpb24oXG4gICAgICAgICAgMCAvKiBTb21lICovLFxuICAgICAgICAgIG9yZGVySW5wdXQodW5vcmRlcmVkT3B0aW9uLnVud3JhcCgpLCByZXN1bHRTb21lVHlwZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9PcHRpb24oMSAvKiBOb25lICovLCB7fSk7XG4gICAgfVxuICAgIGNvbnN0IHVub3JkZXJlZEN1c3RvbUVudW0gPSB1bm9yZGVyZWRPYmplY3QyO1xuICAgIGNvbnN0IHZhcmlhbnRzID0gT2JqZWN0LmVudHJpZXModW5vcmRlcmVkQ3VzdG9tRW51bS52YXJpYW50KTtcbiAgICBjb25zdCBuZXdFbnRyaWVzID0gdmFyaWFudHMubWFwKCh2YXJpYW50KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhcmlhbnRbMV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCB2YXJpYW50VHlwZSA9IGFiaU9iamVjdC50eXBlLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0LnR5cGUubGFzdEluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0LnR5cGUubGFzdEluZGV4T2YoXCI+XCIpXG4gICAgICApO1xuICAgICAgaWYgKHZhcmlhbnRUeXBlID09PSBcIigpXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3ZhcmlhbnRbMF0sIG9yZGVySW5wdXQodW5vcmRlcmVkQ3VzdG9tRW51bS51bndyYXAoKSwgdmFyaWFudFR5cGUpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bShPYmplY3QuZnJvbUVudHJpZXMobmV3RW50cmllcykpO1xuICB9O1xuICBjb25zdCBmaW5hbE9yZGVyZWRPYmplY3QgPSBhYmlPZk9iamVjdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtKSA9PiB7XG4gICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbS5uYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICBpZiAoaXNMZW4oYWJpUGFyYW0ubmFtZSkgJiYgIWlzQ2Fpcm8xVHlwZShhYmlQYXJhbS50eXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfVxuICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0W2FiaVBhcmFtLm5hbWVdLCBhYmlQYXJhbS50eXBlKSk7XG4gICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGZpbmFsT3JkZXJlZE9iamVjdDtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3JlcXVlc3RQYXJzZXIudHNcbmZ1bmN0aW9uIHBhcnNlQmFzZVR5cGVzKHR5cGUsIHZhbCkge1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSk6XG4gICAgICByZXR1cm4gbmV3IENhaXJvVWludDI1Nih2YWwpLnRvQXBpUmVxdWVzdCgpO1xuICAgIGNhc2UgQ2Fpcm9VaW50NTEyLmlzQWJpVHlwZSh0eXBlKTpcbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKHZhbCkudG9BcGlSZXF1ZXN0KCk7XG4gICAgY2FzZSBpc1R5cGVCeXRlczMxKHR5cGUpOlxuICAgICAgcmV0dXJuIGVuY29kZVNob3J0U3RyaW5nKHZhbC50b1N0cmluZygpKTtcbiAgICBjYXNlIGlzVHlwZVNlY3AyNTZrMVBvaW50KHR5cGUpOiB7XG4gICAgICBjb25zdCBwdWJLZXlFVEggPSByZW1vdmVIZXhQcmVmaXgodG9IZXgodmFsKSkucGFkU3RhcnQoMTI4LCBcIjBcIik7XG4gICAgICBjb25zdCBwdWJLZXlFVEh5ID0gdWludDI1NihhZGRIZXhQcmVmaXgocHViS2V5RVRILnNsaWNlKC02NCkpKTtcbiAgICAgIGNvbnN0IHB1YktleUVUSHggPSB1aW50MjU2KGFkZEhleFByZWZpeChwdWJLZXlFVEguc2xpY2UoMCwgLTY0KSkpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgZmVsdChwdWJLZXlFVEh4LmxvdyksXG4gICAgICAgIGZlbHQocHViS2V5RVRIeC5oaWdoKSxcbiAgICAgICAgZmVsdChwdWJLZXlFVEh5LmxvdyksXG4gICAgICAgIGZlbHQocHViS2V5RVRIeS5oaWdoKVxuICAgICAgXTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmZWx0KHZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVHVwbGUoZWxlbWVudCwgdHlwZVN0cikge1xuICBjb25zdCBtZW1iZXJUeXBlcyA9IGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKHR5cGVTdHIpO1xuICBjb25zdCBlbGVtZW50cyA9IE9iamVjdC52YWx1ZXMoZWxlbWVudCk7XG4gIGlmIChlbGVtZW50cy5sZW5ndGggIT09IG1lbWJlclR5cGVzLmxlbmd0aCkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgYFBhcnNlVHVwbGU6IHByb3ZpZGVkIGFuZCBleHBlY3RlZCBhYmkgdHVwbGUgc2l6ZSBkbyBub3QgbWF0Y2guXG4gICAgICBwcm92aWRlZDogJHtlbGVtZW50c30gXG4gICAgICBleHBlY3RlZDogJHttZW1iZXJUeXBlc31gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWVtYmVyVHlwZXMubWFwKChpdCwgZHgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudDogZWxlbWVudHNbZHhdLFxuICAgICAgdHlwZTogaXQudHlwZSA/PyBpdFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VCeXRlQXJyYXkoZWxlbWVudCkge1xuICBjb25zdCBteUJ5dGVBcnJheSA9IGJ5dGVBcnJheUZyb21TdHJpbmcoZWxlbWVudCk7XG4gIHJldHVybiBbXG4gICAgbXlCeXRlQXJyYXkuZGF0YS5sZW5ndGgudG9TdHJpbmcoKSxcbiAgICAuLi5teUJ5dGVBcnJheS5kYXRhLm1hcCgoYm4pID0+IGJuLnRvU3RyaW5nKCkpLFxuICAgIG15Qnl0ZUFycmF5LnBlbmRpbmdfd29yZC50b1N0cmluZygpLFxuICAgIG15Qnl0ZUFycmF5LnBlbmRpbmdfd29yZF9sZW4udG9TdHJpbmcoKVxuICBdO1xufVxuZnVuY3Rpb24gcGFyc2VDYWxsZGF0YVZhbHVlKGVsZW1lbnQsIHR5cGUsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGlmIChlbGVtZW50ID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBFcnJvcihgTWlzc2luZyBwYXJhbWV0ZXIgZm9yIHR5cGUgJHt0eXBlfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0LnB1c2goZmVsdChlbGVtZW50Lmxlbmd0aCkpO1xuICAgIGNvbnN0IGFycmF5VHlwZSA9IGdldEFycmF5VHlwZSh0eXBlKTtcbiAgICByZXR1cm4gZWxlbWVudC5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlQ2FsbGRhdGFWYWx1ZShpdCwgYXJyYXlUeXBlLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH0sIHJlc3VsdCk7XG4gIH1cbiAgaWYgKHN0cnVjdHNbdHlwZV0gJiYgc3RydWN0c1t0eXBlXS5tZW1iZXJzLmxlbmd0aCkge1xuICAgIGlmIChDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gbmV3IENhaXJvVWludDI1NihlbGVtZW50KS50b0FwaVJlcXVlc3QoKTtcbiAgICB9XG4gICAgaWYgKENhaXJvVWludDUxMi5pc0FiaVR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKGVsZW1lbnQpLnRvQXBpUmVxdWVzdCgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIilcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCBlbGVtZW50KTtcbiAgICBpZiAodHlwZSA9PT0gXCJjb3JlOjpieXRlX2FycmF5OjpCeXRlQXJyYXlcIilcbiAgICAgIHJldHVybiBwYXJzZUJ5dGVBcnJheShlbGVtZW50KTtcbiAgICBjb25zdCB7IG1lbWJlcnMgfSA9IHN0cnVjdHNbdHlwZV07XG4gICAgY29uc3Qgc3ViRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgcmV0dXJuIG1lbWJlcnMucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZUNhbGxkYXRhVmFsdWUoc3ViRWxlbWVudFtpdC5uYW1lXSwgaXQudHlwZSwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgaWYgKGlzVHlwZVR1cGxlKHR5cGUpKSB7XG4gICAgY29uc3QgdHVwbGVkID0gcGFyc2VUdXBsZShlbGVtZW50LCB0eXBlKTtcbiAgICByZXR1cm4gdHVwbGVkLnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShpdC5lbGVtZW50LCBpdC50eXBlLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZWREYXRhKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgaWYgKENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gbmV3IENhaXJvVWludDI1NihlbGVtZW50KS50b0FwaVJlcXVlc3QoKTtcbiAgfVxuICBpZiAoQ2Fpcm9VaW50NTEyLmlzQWJpVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKGVsZW1lbnQpLnRvQXBpUmVxdWVzdCgpO1xuICB9XG4gIGlmIChpc1R5cGVFbnVtKHR5cGUsIGVudW1zKSkge1xuICAgIGNvbnN0IHsgdmFyaWFudHMgfSA9IGVudW1zW3R5cGVdO1xuICAgIGlmIChpc1R5cGVPcHRpb24odHlwZSkpIHtcbiAgICAgIGNvbnN0IG15T3B0aW9uID0gZWxlbWVudDtcbiAgICAgIGlmIChteU9wdGlvbi5pc1NvbWUoKSkge1xuICAgICAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQyID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBcIlNvbWVcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50MiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFcnJvciBpbiBhYmkgOiBPcHRpb24gaGFzIG5vICdTb21lJyB2YXJpYW50LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVWYXJpYW50U29tZSA9IGxpc3RUeXBlVmFyaWFudDIudHlwZTtcbiAgICAgICAgaWYgKHR5cGVWYXJpYW50U29tZSA9PT0gXCIoKVwiKSB7XG4gICAgICAgICAgcmV0dXJuIDAgLyogU29tZSAqLy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlcjIgPSBwYXJzZUNhbGxkYXRhVmFsdWUoXG4gICAgICAgICAgbXlPcHRpb24udW53cmFwKCksXG4gICAgICAgICAgdHlwZVZhcmlhbnRTb21lLFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMikpIHtcbiAgICAgICAgICByZXR1cm4gWzAgLyogU29tZSAqLy50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAgLyogU29tZSAqLy50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxIC8qIE5vbmUgKi8udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVJlc3VsdCh0eXBlKSkge1xuICAgICAgY29uc3QgbXlSZXN1bHQgPSBlbGVtZW50O1xuICAgICAgaWYgKG15UmVzdWx0LmlzT2soKSkge1xuICAgICAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQzID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBcIk9rXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudDMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3IgaW4gYWJpIDogUmVzdWx0IGhhcyBubyAnT2snIHZhcmlhbnQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZVZhcmlhbnRPayA9IGxpc3RUeXBlVmFyaWFudDMudHlwZTtcbiAgICAgICAgaWYgKHR5cGVWYXJpYW50T2sgPT09IFwiKClcIikge1xuICAgICAgICAgIHJldHVybiAwIC8qIE9rICovLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyMyA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgICBteVJlc3VsdC51bndyYXAoKSxcbiAgICAgICAgICB0eXBlVmFyaWFudE9rLFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMykpIHtcbiAgICAgICAgICByZXR1cm4gWzAgLyogT2sgKi8udG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswIC8qIE9rICovLnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcjNdO1xuICAgICAgfVxuICAgICAgY29uc3QgbGlzdFR5cGVWYXJpYW50MiA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gXCJFcnJcIik7XG4gICAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudDIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIGluIGFiaSA6IFJlc3VsdCBoYXMgbm8gJ0VycicgdmFyaWFudC5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGVWYXJpYW50RXJyID0gbGlzdFR5cGVWYXJpYW50Mi50eXBlO1xuICAgICAgaWYgKHR5cGVWYXJpYW50RXJyID09PSBcIigpXCIpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogRXJyICovLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIyID0gcGFyc2VDYWxsZGF0YVZhbHVlKG15UmVzdWx0LnVud3JhcCgpLCB0eXBlVmFyaWFudEVyciwgc3RydWN0cywgZW51bXMpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMikpIHtcbiAgICAgICAgcmV0dXJuIFsxIC8qIEVyciAqLy50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbMSAvKiBFcnIgKi8udG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyMl07XG4gICAgfVxuICAgIGNvbnN0IG15RW51bSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IG15RW51bS5hY3RpdmVWYXJpYW50KCk7XG4gICAgY29uc3QgbGlzdFR5cGVWYXJpYW50ID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBhY3RpdmVWYXJpYW50KTtcbiAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgRXJyb3IoYE5vdCBmaW5kIGluIGFiaSA6IEVudW0gaGFzIG5vICcke2FjdGl2ZVZhcmlhbnR9JyB2YXJpYW50LmApO1xuICAgIH1cbiAgICBjb25zdCB0eXBlQWN0aXZlVmFyaWFudCA9IGxpc3RUeXBlVmFyaWFudC50eXBlO1xuICAgIGNvbnN0IG51bUFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kSW5kZXgoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gYWN0aXZlVmFyaWFudCk7XG4gICAgaWYgKHR5cGVBY3RpdmVWYXJpYW50ID09PSBcIigpXCIpIHtcbiAgICAgIHJldHVybiBudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlciA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShteUVudW0udW53cmFwKCksIHR5cGVBY3RpdmVWYXJpYW50LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyKSkge1xuICAgICAgcmV0dXJuIFtudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcl07XG4gICAgfVxuICAgIHJldHVybiBbbnVtQWN0aXZlVmFyaWFudC50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXJdO1xuICB9XG4gIGlmIChpc1R5cGVOb25aZXJvKHR5cGUpKSB7XG4gICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKGdldEFycmF5VHlwZSh0eXBlKSwgZWxlbWVudCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgRXJyb3IoYFBhcmFtZXRlciAke2VsZW1lbnR9IGRvIG5vdCBhbGlnbiB3aXRoIGFiaSBwYXJhbWV0ZXIgJHt0eXBlfWApO1xuICB9XG4gIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FsbGRhdGFGaWVsZChhcmdzSXRlcmF0b3IsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IGlucHV0O1xuICBsZXQgeyB2YWx1ZSB9ID0gYXJnc0l0ZXJhdG9yLm5leHQoKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVBcnJheSh0eXBlKTpcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIWlzVGV4dCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEFCSSBleHBlY3RlZCBwYXJhbWV0ZXIgJHtuYW1lfSB0byBiZSBhcnJheSBvciBsb25nIHN0cmluZywgZ290ICR7dmFsdWV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gc3BsaXRMb25nU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUodmFsdWUsIGlucHV0LnR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIGlzVHlwZU5vblplcm8odHlwZSk6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXMoZ2V0QXJyYXlUeXBlKHR5cGUpLCB2YWx1ZSk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiOlxuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKHR5cGUsIHZhbHVlKTtcbiAgICBjYXNlIChpc1R5cGVTdHJ1Y3QodHlwZSwgc3RydWN0cykgfHwgaXNUeXBlVHVwbGUodHlwZSkgfHwgQ2Fpcm9VaW50MjU2LmlzQWJpVHlwZSh0eXBlKSB8fCBDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpKTpcbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUodmFsdWUsIHR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIGlzVHlwZUVudW0odHlwZSwgZW51bXMpOlxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHN0cnVjdHMsXG4gICAgICAgIGVudW1zXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgdmFsdWUpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9yZXNwb25zZVBhcnNlci50c1xuZnVuY3Rpb24gcGFyc2VCYXNlVHlwZXMyKHR5cGUsIGl0KSB7XG4gIGxldCB0ZW1wO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUJvb2wodHlwZSk6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oQmlnSW50KHRlbXApKTtcbiAgICBjYXNlIENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSk6XG4gICAgICBjb25zdCBsb3cgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCBoaWdoID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYobG93LCBoaWdoKS50b0JpZ0ludCgpO1xuICAgIGNhc2UgQ2Fpcm9VaW50NTEyLmlzQWJpVHlwZSh0eXBlKTpcbiAgICAgIGNvbnN0IGxpbWIwID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgbGltYjEgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCBsaW1iMiA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IGxpbWIzID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQ1MTIobGltYjAsIGxpbWIxLCBsaW1iMiwgbGltYjMpLnRvQmlnSW50KCk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiOlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OmJ5dGVzXzMxOjpieXRlczMxXCI6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIGRlY29kZVNob3J0U3RyaW5nKHRlbXApO1xuICAgIGNhc2UgaXNUeXBlU2VjcDI1NmsxUG9pbnQodHlwZSk6XG4gICAgICBjb25zdCB4TG93ID0gcmVtb3ZlSGV4UHJlZml4KGl0Lm5leHQoKS52YWx1ZSkucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICAgIGNvbnN0IHhIaWdoID0gcmVtb3ZlSGV4UHJlZml4KGl0Lm5leHQoKS52YWx1ZSkucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICAgIGNvbnN0IHlMb3cgPSByZW1vdmVIZXhQcmVmaXgoaXQubmV4dCgpLnZhbHVlKS5wYWRTdGFydCgzMiwgXCIwXCIpO1xuICAgICAgY29uc3QgeUhpZ2ggPSByZW1vdmVIZXhQcmVmaXgoaXQubmV4dCgpLnZhbHVlKS5wYWRTdGFydCgzMiwgXCIwXCIpO1xuICAgICAgY29uc3QgcHViSyA9IEJpZ0ludChhZGRIZXhQcmVmaXgoeEhpZ2ggKyB4TG93ICsgeUhpZ2ggKyB5TG93KSk7XG4gICAgICByZXR1cm4gcHViSztcbiAgICBkZWZhdWx0OlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbGVtZW50LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBpZiAoZWxlbWVudC50eXBlID09PSBcIigpXCIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgaWYgKENhaXJvVWludDI1Ni5pc0FiaVR5cGUoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IGxvdyA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIGNvbnN0IGhpZ2ggPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICByZXR1cm4gbmV3IENhaXJvVWludDI1Nihsb3csIGhpZ2gpLnRvQmlnSW50KCk7XG4gIH1cbiAgaWYgKENhaXJvVWludDUxMi5pc0FiaVR5cGUoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IGxpbWIwID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgY29uc3QgbGltYjEgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICBjb25zdCBsaW1iMiA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIGNvbnN0IGxpbWIzID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQ1MTIobGltYjAsIGxpbWIxLCBsaW1iMiwgbGltYjMpLnRvQmlnSW50KCk7XG4gIH1cbiAgaWYgKGlzVHlwZUJ5dGVBcnJheShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgcGFyc2VkQnl0ZXMzMUFyciA9IFtdO1xuICAgIGNvbnN0IGJ5dGVzMzFBcnJMZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHdoaWxlIChwYXJzZWRCeXRlczMxQXJyLmxlbmd0aCA8IGJ5dGVzMzFBcnJMZW4pIHtcbiAgICAgIHBhcnNlZEJ5dGVzMzFBcnIucHVzaCh0b0hleChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSkpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nX3dvcmQgPSB0b0hleChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgY29uc3QgcGVuZGluZ193b3JkX2xlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgY29uc3QgbXlCeXRlQXJyYXkgPSB7XG4gICAgICBkYXRhOiBwYXJzZWRCeXRlczMxQXJyLFxuICAgICAgcGVuZGluZ193b3JkLFxuICAgICAgcGVuZGluZ193b3JkX2xlblxuICAgIH07XG4gICAgcmV0dXJuIHN0cmluZ0Zyb21CeXRlQXJyYXkobXlCeXRlQXJyYXkpO1xuICB9XG4gIGlmIChpc1R5cGVBcnJheShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgcGFyc2VkRGF0YUFyciA9IFtdO1xuICAgIGNvbnN0IGVsID0geyBuYW1lOiBcIlwiLCB0eXBlOiBnZXRBcnJheVR5cGUoZWxlbWVudC50eXBlKSB9O1xuICAgIGNvbnN0IGxlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgbGVuKSB7XG4gICAgICBwYXJzZWREYXRhQXJyLnB1c2gocGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkRGF0YUFycjtcbiAgfVxuICBpZiAoaXNUeXBlTm9uWmVybyhlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgZWwgPSB7IG5hbWU6IFwiXCIsIHR5cGU6IGdldEFycmF5VHlwZShlbGVtZW50LnR5cGUpIH07XG4gICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpO1xuICB9XG4gIGlmIChzdHJ1Y3RzICYmIGVsZW1lbnQudHlwZSBpbiBzdHJ1Y3RzICYmIHN0cnVjdHNbZWxlbWVudC50eXBlXSkge1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCIpIHtcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIoZWxlbWVudC50eXBlLCByZXNwb25zZUl0ZXJhdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHNbZWxlbWVudC50eXBlXS5tZW1iZXJzLnJlZHVjZSgoYWNjLCBlbCkgPT4ge1xuICAgICAgYWNjW2VsLm5hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuICBpZiAoZW51bXMgJiYgZWxlbWVudC50eXBlIGluIGVudW1zICYmIGVudW1zW2VsZW1lbnQudHlwZV0pIHtcbiAgICBjb25zdCB2YXJpYW50TnVtID0gTnVtYmVyKHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICBjb25zdCByYXdFbnVtID0gZW51bXNbZWxlbWVudC50eXBlXS52YXJpYW50cy5yZWR1Y2UoKGFjYywgdmFyaWFudCwgbnVtKSA9PiB7XG4gICAgICBpZiAobnVtID09PSB2YXJpYW50TnVtKSB7XG4gICAgICAgIGFjY1t2YXJpYW50Lm5hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKFxuICAgICAgICAgIHJlc3BvbnNlSXRlcmF0b3IsXG4gICAgICAgICAgeyBuYW1lOiBcIlwiLCB0eXBlOiB2YXJpYW50LnR5cGUgfSxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIGVudW1zXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBhY2NbdmFyaWFudC5uYW1lXSA9IHZvaWQgMDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGlmIChlbGVtZW50LnR5cGUuc3RhcnRzV2l0aChcImNvcmU6Om9wdGlvbjo6T3B0aW9uXCIpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdmFyaWFudE51bSA9PT0gMCAvKiBTb21lICovID8gcmF3RW51bS5Tb21lIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb09wdGlvbih2YXJpYW50TnVtLCBjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKFwiY29yZTo6cmVzdWx0OjpSZXN1bHRcIikpIHtcbiAgICAgIGxldCBjb250ZW50O1xuICAgICAgaWYgKHZhcmlhbnROdW0gPT09IDAgLyogT2sgKi8pIHtcbiAgICAgICAgY29udGVudCA9IHJhd0VudW0uT2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gcmF3RW51bS5FcnI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KHZhcmlhbnROdW0sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBjdXN0b21FbnVtID0gbmV3IENhaXJvQ3VzdG9tRW51bShyYXdFbnVtKTtcbiAgICByZXR1cm4gY3VzdG9tRW51bTtcbiAgfVxuICBpZiAoaXNUeXBlVHVwbGUoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IG1lbWJlclR5cGVzID0gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXMoZWxlbWVudC50eXBlKTtcbiAgICByZXR1cm4gbWVtYmVyVHlwZXMucmVkdWNlKChhY2MsIGl0LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBpdD8ubmFtZSA/IGl0Lm5hbWUgOiBpZHg7XG4gICAgICBjb25zdCB0eXBlID0gaXQ/LnR5cGUgPyBpdC50eXBlIDogaXQ7XG4gICAgICBjb25zdCBlbCA9IHsgbmFtZSwgdHlwZSB9O1xuICAgICAgYWNjW25hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuICBpZiAoaXNUeXBlQXJyYXkoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICBjb25zdCBlbCA9IHsgbmFtZTogXCJcIiwgdHlwZTogZ2V0QXJyYXlUeXBlKGVsZW1lbnQudHlwZSkgfTtcbiAgICBjb25zdCBsZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGxlbikge1xuICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gIH1cbiAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzMihlbGVtZW50LnR5cGUsIHJlc3BvbnNlSXRlcmF0b3IpO1xufVxuZnVuY3Rpb24gcmVzcG9uc2VQYXJzZXIocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcywgcGFyc2VkUmVzdWx0KSB7XG4gIGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gb3V0cHV0O1xuICBsZXQgdGVtcDtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc0xlbihuYW1lKTpcbiAgICAgIHRlbXAgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gICAgY2FzZSAoc3RydWN0cyAmJiB0eXBlIGluIHN0cnVjdHMgfHwgaXNUeXBlVHVwbGUodHlwZSkpOlxuICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIChlbnVtcyAmJiBpc1R5cGVFbnVtKHR5cGUsIGVudW1zKSk6XG4gICAgICByZXR1cm4gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgaXNUeXBlQXJyYXkodHlwZSk6XG4gICAgICBpZiAoaXNDYWlybzFUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWREYXRhQXJyID0gW107XG4gICAgICBpZiAocGFyc2VkUmVzdWx0ICYmIHBhcnNlZFJlc3VsdFtgJHtuYW1lfV9sZW5gXSkge1xuICAgICAgICBjb25zdCBhcnJMZW4gPSBwYXJzZWRSZXN1bHRbYCR7bmFtZX1fbGVuYF07XG4gICAgICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGFyckxlbikge1xuICAgICAgICAgIHBhcnNlZERhdGFBcnIucHVzaChcbiAgICAgICAgICAgIHBhcnNlUmVzcG9uc2VWYWx1ZShcbiAgICAgICAgICAgICAgcmVzcG9uc2VJdGVyYXRvcixcbiAgICAgICAgICAgICAgeyBuYW1lLCB0eXBlOiBvdXRwdXQudHlwZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSB9LFxuICAgICAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgICAgICBlbnVtc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWREYXRhQXJyO1xuICAgIGNhc2UgaXNUeXBlTm9uWmVybyh0eXBlKTpcbiAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIodHlwZSwgcmVzcG9uc2VJdGVyYXRvcik7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3ZhbGlkYXRlLnRzXG52YXIgdmFsaWRhdGVGZWx0ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIGlzU3RyaW5nKHBhcmFtZXRlcikgfHwgaXNOdW1iZXIocGFyYW1ldGVyKSB8fCBpc0JpZ0ludChwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgZmVsdCB0eXBlZCBhcyAoU3RyaW5nLCBOdW1iZXIgb3IgQmlnSW50KWBcbiAgKTtcbiAgaWYgKGlzU3RyaW5nKHBhcmFtZXRlcikgJiYgIWlzSGV4KHBhcmFtZXRlcikpXG4gICAgcmV0dXJuO1xuICBjb25zdCBwYXJhbSA9IEJpZ0ludChwYXJhbWV0ZXIudG9TdHJpbmcoMTApKTtcbiAgYXNzZXJ0KFxuICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjY2XG4gICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZUJ5dGVzMzEgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoaXNTdHJpbmcocGFyYW1ldGVyKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgYmUgYSBzdHJpbmcuYCk7XG4gIGFzc2VydChcbiAgICBwYXJhbWV0ZXIubGVuZ3RoIDwgMzIsXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBhIHN0cmluZyBvZiBsZXNzIHRoYW4gMzIgY2hhcmFjdGVycy5gXG4gICk7XG59O1xudmFyIHZhbGlkYXRlQnl0ZUFycmF5ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KGlzU3RyaW5nKHBhcmFtZXRlciksIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgc3RyaW5nLmApO1xufTtcbnZhciB2YWxpZGF0ZVVpbnQgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBpZiAoaXNOdW1iZXIocGFyYW1ldGVyKSkge1xuICAgIGFzc2VydChcbiAgICAgIHBhcmFtZXRlciA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgIGBWYWxpZGF0aW9uOiBQYXJhbWV0ZXIgaXMgdG8gbGFyZ2UgdG8gYmUgdHlwZWQgYXMgTnVtYmVyIHVzZSAoQmlnSW50IG9yIFN0cmluZylgXG4gICAgKTtcbiAgfVxuICBhc3NlcnQoXG4gICAgaXNTdHJpbmcocGFyYW1ldGVyKSB8fCBpc051bWJlcihwYXJhbWV0ZXIpIHx8IGlzQmlnSW50KHBhcmFtZXRlcikgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiBcImxvd1wiIGluIHBhcmFtZXRlciAmJiBcImhpZ2hcIiBpbiBwYXJhbWV0ZXIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiBbXCJsaW1iMFwiLCBcImxpbWIxXCIsIFwibGltYjJcIiwgXCJsaW1iM1wiXS5ldmVyeSgoa2V5KSA9PiBrZXkgaW4gcGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IG9mIGNhaXJvIHR5cGUgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgdHlwZSAoU3RyaW5nLCBOdW1iZXIgb3IgQmlnSW50KSwgYnV0IGlzICR7dHlwZW9mIHBhcmFtZXRlcn0gJHtwYXJhbWV0ZXJ9LmBcbiAgKTtcbiAgbGV0IHBhcmFtO1xuICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiIC8qIHUyNTYgKi86XG4gICAgICBwYXJhbSA9IG5ldyBDYWlyb1VpbnQyNTYocGFyYW1ldGVyKS50b0JpZ0ludCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnU1MTJcIiAvKiB1NTEyICovOlxuICAgICAgcGFyYW0gPSBuZXcgQ2Fpcm9VaW50NTEyKHBhcmFtZXRlcikudG9CaWdJbnQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwYXJhbSA9IHRvQmlnSW50KHBhcmFtZXRlcik7XG4gIH1cbiAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnU4XCIgLyogdTggKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDI1NW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAgLSAyNTVdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MTZcIiAvKiB1MTYgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDY1NTM1bixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgNjU1MzVdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MzJcIiAvKiB1MzIgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDQyOTQ5NjcyOTVuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCA0Mjk0OTY3Mjk1XWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTY0XCIgLyogdTY0ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiA2NG4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl42NC0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTEyOFwiIC8qIHUxMjggKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDEyOG4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4xMjgtMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUyNTZcIiAvKiB1MjU2ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTZuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgJHtpbnB1dC50eXBlfSAwIC0gMl4yNTYtMWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTUxMlwiIC8qIHU1MTIgKi86XG4gICAgICBhc3NlcnQoQ2Fpcm9VaW50NTEyLmlzKHBhcmFtKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBpcyAke2lucHV0LnR5cGV9IDAgLSAyXjUxMi0xYCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6c3RhcmtuZXQ6OmNsYXNzX2hhc2g6OkNsYXNzSGFzaFwiIC8qIENsYXNzSGFzaCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgLy8gZnJvbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGFya3dhcmUtbGlicy9zdGFya25ldC1zcGVjcy9ibG9iLzI5YmFiNjUwYmU2YjE4NDdjOTJkNDQ2MWQ0YzMzMDA4YjVlNTBiMWEvYXBpL3N0YXJrbmV0X2FwaV9vcGVucnBjLmpzb24jTDE2NzBcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjI1Mi0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiIC8qIENvbnRyYWN0QWRkcmVzcyAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgLy8gZnJvbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGFya3dhcmUtbGlicy9zdGFya25ldC1zcGVjcy9ibG9iLzI5YmFiNjUwYmU2YjE4NDdjOTJkNDQ2MWQ0YzMzMDA4YjVlNTBiMWEvYXBpL3N0YXJrbmV0X2FwaV9vcGVucnBjLmpzb24jTDEyNDVcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjI1Mi0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6c3RhcmtuZXQ6OnNlY3AyNTZrMTo6U2VjcDI1NmsxUG9pbnRcIiAvKiBTZWNwMjU2azFQb2ludCAqLzoge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiA1MTJuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gbXVzdCBiZSAke2lucHV0LnR5cGV9IDogYSA1MTIgYml0cyBudW1iZXIuYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVCb29sID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIGlzQm9vbGVhbihwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gb2YgY2Fpcm8gdHlwZSAke2lucHV0LnR5cGV9IHNob3VsZCBiZSB0eXBlIChCb29sZWFuKWBcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVTdHJ1Y3QgPSAocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cykgPT4ge1xuICBpZiAoaW5wdXQudHlwZSA9PT0gXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCIgLyogdTI1NiAqLyB8fCBpbnB1dC50eXBlID09PSBcImNvcmU6OmludGVnZXI6OnU1MTJcIiAvKiB1NTEyICovKSB7XG4gICAgdmFsaWRhdGVVaW50KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5wdXQudHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIikge1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiBwYXJhbWV0ZXIgIT09IFwib2JqZWN0XCIsXG4gICAgICBgRXRoQWRkcmVzcyB0eXBlIGlzIHdhaXRpbmcgYSBCaWdOdW1iZXJpc2guIEdvdCAke3BhcmFtZXRlcn1gXG4gICAgKTtcbiAgICBjb25zdCBwYXJhbSA9IEJpZ0ludChwYXJhbWV0ZXIudG9TdHJpbmcoMTApKTtcbiAgICBhc3NlcnQoXG4gICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTI1OVxuICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMTYwbiAtIDFuLFxuICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4xNjAtMV1gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGlzIGNhaXJvIHR5cGUgc3RydWN0ICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGpzIG9iamVjdCAobm90IGFycmF5KWBcbiAgKTtcbiAgc3RydWN0c1tpbnB1dC50eXBlXS5tZW1iZXJzLmZvckVhY2goKHsgbmFtZSB9KSA9PiB7XG4gICAgYXNzZXJ0KFxuICAgICAgT2JqZWN0LmtleXMocGFyYW1ldGVyKS5pbmNsdWRlcyhuYW1lKSxcbiAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGhhdmUgYSBwcm9wZXJ0eSAke25hbWV9YFxuICAgICk7XG4gIH0pO1xufTtcbnZhciB2YWxpZGF0ZUVudW0gPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgY2Fpcm8gdHlwZSBFbnVtICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGpzIG9iamVjdCAobm90IGFycmF5KWBcbiAgKTtcbiAgY29uc3QgbWV0aG9kc0tleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyYW1ldGVyKSk7XG4gIGNvbnN0IGtleXMgPSBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyYW1ldGVyKSwgLi4ubWV0aG9kc0tleXNdO1xuICBpZiAoaXNUeXBlT3B0aW9uKGlucHV0LnR5cGUpICYmIGtleXMuaW5jbHVkZXMoXCJpc1NvbWVcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzTm9uZVwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNUeXBlUmVzdWx0KGlucHV0LnR5cGUpICYmIGtleXMuaW5jbHVkZXMoXCJpc09rXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc0VyclwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoa2V5cy5pbmNsdWRlcyhcInZhcmlhbnRcIikgJiYga2V5cy5pbmNsdWRlcyhcImFjdGl2ZVZhcmlhbnRcIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBWYWxpZGF0ZSBFbnVtOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlIHJlY2VpdmVkICR7cGFyYW1ldGVyfSwgaXMgbm90IGFuIEVudW0uYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVR1cGxlID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhIHR1cGxlIChkZWZpbmVkIGFzIG9iamVjdClgXG4gICk7XG59O1xudmFyIHZhbGlkYXRlQXJyYXkgPSAocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cywgZW51bXMpID0+IHtcbiAgY29uc3QgYmFzZVR5cGUgPSBnZXRBcnJheVR5cGUoaW5wdXQudHlwZSk7XG4gIGlmIChpc1R5cGVGZWx0KGJhc2VUeXBlKSAmJiBpc0xvbmdUZXh0KHBhcmFtZXRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgYmUgYW4gQXJyYXlgKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVGZWx0KGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChwYXJhbSkgPT4gdmFsaWRhdGVGZWx0KHBhcmFtLCBpbnB1dCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVUdXBsZShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlVHVwbGUoaXQsIHsgbmFtZTogaW5wdXQubmFtZSwgdHlwZTogYmFzZVR5cGUgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVBcnJheShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaChcbiAgICAgICAgKHBhcmFtKSA9PiB2YWxpZGF0ZUFycmF5KHBhcmFtLCB7IG5hbWU6IFwiXCIsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMsIGVudW1zKVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlU3RydWN0KGJhc2VUeXBlLCBzdHJ1Y3RzKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKFxuICAgICAgICAoaXQpID0+IHZhbGlkYXRlU3RydWN0KGl0LCB7IG5hbWU6IGlucHV0Lm5hbWUsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVFbnVtKGJhc2VUeXBlLCBlbnVtcyk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlRW51bShpdCwgeyBuYW1lOiBpbnB1dC5uYW1lLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIChpc1R5cGVVaW50KGJhc2VUeXBlKSB8fCBpc1R5cGVMaXRlcmFsKGJhc2VUeXBlKSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgocGFyYW0pID0+IHZhbGlkYXRlVWludChwYXJhbSwgeyBuYW1lOiBcIlwiLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZUJvb2woYmFzZVR5cGUpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKHBhcmFtKSA9PiB2YWxpZGF0ZUJvb2wocGFyYW0sIGlucHV0KSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVOb25aZXJvID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgY29uc3QgYmFzZVR5cGUgPSBnZXRBcnJheVR5cGUoaW5wdXQudHlwZSk7XG4gIGFzc2VydChcbiAgICBpc1R5cGVVaW50KGJhc2VUeXBlKSAmJiBiYXNlVHlwZSAhPT0gQ2Fpcm9VaW50NTEyLmFiaVNlbGVjdG9yIHx8IGlzVHlwZUZlbHQoYmFzZVR5cGUpLFxuICAgIGBWYWxpZGF0ZTogJHtpbnB1dC5uYW1lfSB0eXBlIGlzIG5vdCBhdXRob3JpemVkIGZvciBOb25aZXJvIHR5cGUuYFxuICApO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUZlbHQoYmFzZVR5cGUpOlxuICAgICAgdmFsaWRhdGVGZWx0KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBCaWdJbnQocGFyYW1ldGVyLnRvU3RyaW5nKDEwKSkgPiAwLFxuICAgICAgICBcIlZhbGlkYXRlOiB2YWx1ZSAwIGlzIG5vdCBhdXRob3JpemVkIGluIE5vblplcm8gZmVsdDI1MiB0eXBlLlwiXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVVaW50KGJhc2VUeXBlKTpcbiAgICAgIHZhbGlkYXRlVWludChwYXJhbWV0ZXIsIHsgbmFtZTogXCJcIiwgdHlwZTogYmFzZVR5cGUgfSk7XG4gICAgICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUyNTZcIiAvKiB1MjU2ICovOlxuICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgIG5ldyBDYWlyb1VpbnQyNTYocGFyYW1ldGVyKS50b0JpZ0ludCgpID4gMCxcbiAgICAgICAgICAgIFwiVmFsaWRhdGU6IHZhbHVlIDAgaXMgbm90IGF1dGhvcml6ZWQgaW4gTm9uWmVybyB1aW50MjU2IHR5cGUuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgIHRvQmlnSW50KHBhcmFtZXRlcikgPiAwLFxuICAgICAgICAgICAgXCJWYWxpZGF0ZTogdmFsdWUgMCBpcyBub3QgYXV0aG9yaXplZCBpbiBOb25aZXJvIHVpbnQgdHlwZS5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkcyhhYmlNZXRob2QsIGFyZ3MsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGFiaU1ldGhvZC5pbnB1dHMucmVkdWNlKChhY2MsIGlucHV0KSA9PiB7XG4gICAgY29uc3QgcGFyYW1ldGVyID0gYXJnc1thY2NdO1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBpc0xlbihpbnB1dC5uYW1lKTpcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIGNhc2UgaXNUeXBlRmVsdChpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVGZWx0KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlQnl0ZXMzMShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVCeXRlczMxKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgKGlzVHlwZVVpbnQoaW5wdXQudHlwZSkgfHwgaXNUeXBlTGl0ZXJhbChpbnB1dC50eXBlKSk6XG4gICAgICAgIHZhbGlkYXRlVWludChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUJvb2woaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQm9vbChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUJ5dGVBcnJheShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVCeXRlQXJyYXkocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVBcnJheShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVBcnJheShwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVTdHJ1Y3QoaW5wdXQudHlwZSwgc3RydWN0cyk6XG4gICAgICAgIHZhbGlkYXRlU3RydWN0KHBhcmFtZXRlciwgaW5wdXQsIHN0cnVjdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlRW51bShpbnB1dC50eXBlLCBlbnVtcyk6XG4gICAgICAgIHZhbGlkYXRlRW51bShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZVR1cGxlKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZVR1cGxlKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlTm9uWmVybyhpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVOb25aZXJvKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYyArIDE7XG4gIH0sIDApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvaW5kZXgudHNcbnZhciBDYWxsRGF0YSA9IGNsYXNzIF9DYWxsRGF0YSB7XG4gIGFiaTtcbiAgcGFyc2VyO1xuICBzdHJ1Y3RzO1xuICBlbnVtcztcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5zdHJ1Y3RzID0gX0NhbGxEYXRhLmdldEFiaVN0cnVjdChhYmkpO1xuICAgIHRoaXMuZW51bXMgPSBfQ2FsbERhdGEuZ2V0QWJpRW51bShhYmkpO1xuICAgIHRoaXMucGFyc2VyID0gY3JlYXRlQWJpUGFyc2VyKGFiaSk7XG4gICAgdGhpcy5hYmkgPSB0aGlzLnBhcnNlci5nZXRMZWdhY3lGb3JtYXQoKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kIGFzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9uZXMgaW4gdGhlIGFiaVxuICAgKiBAcGFyYW0gdHlwZSBWYWxpZGF0ZVR5cGUgLSB0eXBlIG9mIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBuYW1lIG9mIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIGFyZ3MgQXJnc09yQ2FsbGRhdGEgLSBhcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICovXG4gIHZhbGlkYXRlKHR5cGUsIG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgaWYgKHR5cGUgIT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovKSB7XG4gICAgICBjb25zdCBpbnZvY2FibGVGdW5jdGlvbk5hbWVzID0gdGhpcy5hYmkuZmlsdGVyKChhYmkpID0+IHtcbiAgICAgICAgaWYgKGFiaS50eXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpc1ZpZXcgPSBhYmkuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBhYmkuc3RhdGVfbXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCI7XG4gICAgICAgIHJldHVybiB0eXBlID09PSBcIklOVk9LRVwiIC8qIElOVk9LRSAqLyA/ICFpc1ZpZXcgOiBpc1ZpZXc7XG4gICAgICB9KS5tYXAoKGFiaSkgPT4gYWJpLm5hbWUpO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBpbnZvY2FibGVGdW5jdGlvbk5hbWVzLmluY2x1ZGVzKG1ldGhvZCksXG4gICAgICAgIGAke3R5cGUgPT09IFwiSU5WT0tFXCIgLyogSU5WT0tFICovID8gXCJpbnZvY2FibGVcIiA6IFwidmlld2FibGVcIn0gbWV0aG9kIG5vdCBmb3VuZCBpbiBhYmlgXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBhYmlNZXRob2QgPSB0aGlzLmFiaS5maW5kKFxuICAgICAgKGFiaSkgPT4gdHlwZSA9PT0gXCJERVBMT1lcIiAvKiBERVBMT1kgKi8gPyBhYmkubmFtZSA9PT0gbWV0aG9kICYmIGFiaS50eXBlID09PSBcImNvbnN0cnVjdG9yXCIgOiBhYmkubmFtZSA9PT0gbWV0aG9kICYmIGFiaS50eXBlID09PSBcImZ1bmN0aW9uXCJcbiAgICApO1xuICAgIGlmIChpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3MsIGFiaU1ldGhvZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRzTGVuZ3RoID0gdGhpcy5wYXJzZXIubWV0aG9kSW5wdXRzTGVuZ3RoKGFiaU1ldGhvZCk7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSBpbnB1dHNMZW5ndGgpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzLCBleHBlY3RlZCAke2lucHV0c0xlbmd0aH0gYXJndW1lbnRzLCBidXQgZ290ICR7YXJncy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpO1xuICB9XG4gIC8qKlxuICAgKiBDb21waWxlIGNvbnRyYWN0IGNhbGxEYXRhIHdpdGggYWJpXG4gICAqIFBhcnNlIHRoZSBjYWxsZGF0YSBieSB1c2luZyBpbnB1dCBmaWVsZHMgZnJvbSB0aGUgYWJpIGZvciB0aGF0IG1ldGhvZFxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSBhcmdzQ2FsbGRhdGEgUmF3QXJncyAtIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1ldGhvZC4gQ2FuIGJlIGFuIGFycmF5IG9mIGFyZ3VtZW50cyAoaW4gdGhlIG9yZGVyIG9mIGFiaSBkZWZpbml0aW9uKSwgb3IgYW4gb2JqZWN0IGNvbnN0cnVjdGVkIGluIGNvbmZvcm1pdHkgd2l0aCBhYmkgKGluIHRoaXMgY2FzZSwgdGhlIHBhcmFtZXRlciBjYW4gYmUgaW4gYSB3cm9uZyBvcmRlcikuXG4gICAqIEByZXR1cm4gQ2FsbGRhdGEgLSBwYXJzZWQgYXJndW1lbnRzIGluIGZvcm1hdCB0aGF0IGNvbnRyYWN0IGlzIGV4cGVjdGluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGNhbGxkYXRhID0gbXlDYWxsRGF0YS5jb21waWxlKFwiY29uc3RydWN0b3JcIiwgW1wiMHgzNGFcIiwgWzEsIDNuXV0pO1xuICAgKiBgYGBcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBjYWxsZGF0YTIgPSBteUNhbGxEYXRhLmNvbXBpbGUoXCJjb25zdHJ1Y3RvclwiLCB7bGlzdDpbMSwgM25dLCBiYWxhbmNlOlwiMHgzNFwifSk7IC8vIHdyb25nIG9yZGVyIGlzIHZhbGlkXG4gICAqIGBgYFxuICAgKi9cbiAgY29tcGlsZShtZXRob2QsIGFyZ3NDYWxsZGF0YSkge1xuICAgIGNvbnN0IGFiaU1ldGhvZCA9IHRoaXMuYWJpLmZpbmQoKGFiaUZ1bmN0aW9uKSA9PiBhYmlGdW5jdGlvbi5uYW1lID09PSBtZXRob2QpO1xuICAgIGlmIChpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3NDYWxsZGF0YSwgYWJpTWV0aG9kKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgYXJncztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzQ2FsbGRhdGEpKSB7XG4gICAgICBhcmdzID0gYXJnc0NhbGxkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcmRlcmVkT2JqZWN0ID0gb3JkZXJQcm9wc0J5QWJpKFxuICAgICAgICBhcmdzQ2FsbGRhdGEsXG4gICAgICAgIGFiaU1ldGhvZC5pbnB1dHMsXG4gICAgICAgIHRoaXMuc3RydWN0cyxcbiAgICAgICAgdGhpcy5lbnVtc1xuICAgICAgKTtcbiAgICAgIGFyZ3MgPSBPYmplY3QudmFsdWVzKG9yZGVyZWRPYmplY3QpO1xuICAgICAgdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpO1xuICAgIH1cbiAgICBjb25zdCBhcmdzSXRlcmF0b3IgPSBhcmdzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBjYWxsQXJyYXkgPSBhYmlNZXRob2QuaW5wdXRzLnJlZHVjZShcbiAgICAgIChhY2MsIGlucHV0KSA9PiBpc0xlbihpbnB1dC5uYW1lKSAmJiAhaXNDYWlybzFUeXBlKGlucHV0LnR5cGUpID8gYWNjIDogYWNjLmNvbmNhdChwYXJzZUNhbGxkYXRhRmllbGQoYXJnc0l0ZXJhdG9yLCBpbnB1dCwgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zKSksXG4gICAgICBbXVxuICAgICk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbGxBcnJheSwgXCJfX2NvbXBpbGVkX19cIiwge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBjYWxsQXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXBpbGUgY29udHJhY3QgY2FsbERhdGEgd2l0aG91dCBhYmlcbiAgICogQHBhcmFtIHJhd0FyZ3MgUmF3QXJncyByZXByZXNlbnRpbmcgY2Fpcm8gbWV0aG9kIGFyZ3VtZW50cyBvciBzdHJpbmcgYXJyYXkgb2YgY29tcGlsZWQgZGF0YVxuICAgKiBAcmV0dXJucyBDYWxsZGF0YVxuICAgKi9cbiAgc3RhdGljIGNvbXBpbGUocmF3QXJncykge1xuICAgIGNvbnN0IGNyZWF0ZVRyZWUgPSAob2JqKSA9PiB7XG4gICAgICBjb25zdCBnZXRFbnRyaWVzID0gKG8sIHByZWZpeCA9IFwiLlwiKSA9PiB7XG4gICAgICAgIGNvbnN0IG9lID0gQXJyYXkuaXNBcnJheShvKSA/IFtvLmxlbmd0aC50b1N0cmluZygpLCAuLi5vXSA6IG87XG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhvZSkuZmxhdE1hcCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gdjtcbiAgICAgICAgICBpZiAoayA9PT0gXCJlbnRyeXBvaW50XCIpXG4gICAgICAgICAgICB2YWx1ZSA9IGdldFNlbGVjdG9yRnJvbU5hbWUodmFsdWUpO1xuICAgICAgICAgIGVsc2UgaWYgKGlzTG9uZ1RleHQodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSBieXRlQXJyYXlGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICBjb25zdCBrayA9IEFycmF5LmlzQXJyYXkob2UpICYmIGsgPT09IFwiMFwiID8gXCIkJGxlblwiIDogaztcbiAgICAgICAgICBpZiAoaXNCaWdJbnQodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdCh2YWx1ZSldXTtcbiAgICAgICAgICBpZiAoT2JqZWN0KHZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZHNLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gWy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSwgLi4ubWV0aG9kc0tleXNdO1xuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJpc1NvbWVcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzTm9uZVwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBteU9wdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYW50TmIgPSBteU9wdGlvbi5pc1NvbWUoKSA/IDAgLyogU29tZSAqLyA6IDEgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgaWYgKG15T3B0aW9uLmlzU29tZSgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHsgMDogdmFyaWFudE5iLCAxOiBteU9wdGlvbi51bndyYXAoKSB9LCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQodmFyaWFudE5iKV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJpc09rXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc0VyclwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBteVJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYW50TmIgPSBteVJlc3VsdC5pc09rKCkgPyAwIC8qIE9rICovIDogMSAvKiBFcnIgKi87XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHsgMDogdmFyaWFudE5iLCAxOiBteVJlc3VsdC51bndyYXAoKSB9LCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5cy5pbmNsdWRlcyhcInZhcmlhbnRcIikgJiYga2V5cy5pbmNsdWRlcyhcImFjdGl2ZVZhcmlhbnRcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlFbnVtID0gdmFsdWU7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSBteUVudW0uYWN0aXZlVmFyaWFudCgpO1xuICAgICAgICAgICAgICBjb25zdCBsaXN0VmFyaWFudHMgPSBPYmplY3Qua2V5cyhteUVudW0udmFyaWFudCk7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnROYiA9IGxpc3RWYXJpYW50cy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgKHZhcmlhbnQpID0+IHZhcmlhbnQgPT09IGFjdGl2ZVZhcmlhbnRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBteUVudW0udW53cmFwKCkgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMobXlFbnVtLnVud3JhcCgpKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KGFjdGl2ZVZhcmlhbnROYildXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IGFjdGl2ZVZhcmlhbnROYiwgMTogbXlFbnVtLnVud3JhcCgpIH0sIGAke3ByZWZpeH0ke2trfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHZhbHVlLCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQodmFsdWUpXV07XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5mcm9tRW50cmllcyhnZXRFbnRyaWVzKG9iaikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGxldCBjYWxsVHJlZUFycmF5O1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyYXdBcmdzKSkge1xuICAgICAgY29uc3QgY2FsbFRyZWUgPSBjcmVhdGVUcmVlKHJhd0FyZ3MpO1xuICAgICAgY2FsbFRyZWVBcnJheSA9IE9iamVjdC52YWx1ZXMoY2FsbFRyZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjYWxsT2JqID0geyAuLi5yYXdBcmdzIH07XG4gICAgICBjb25zdCBjYWxsVHJlZSA9IGNyZWF0ZVRyZWUoY2FsbE9iaik7XG4gICAgICBjYWxsVHJlZUFycmF5ID0gT2JqZWN0LnZhbHVlcyhjYWxsVHJlZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWxsVHJlZUFycmF5LCBcIl9fY29tcGlsZWRfX1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxUcmVlQXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGVsZW1lbnRzIG9mIHRoZSByZXNwb25zZSBhcnJheSBhbmQgc3RydWN0dXJpbmcgdGhlbSBpbnRvIHJlc3BvbnNlIG9iamVjdFxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSByZXNwb25zZSBzdHJpbmdbXSAtIHJlc3BvbnNlIGZyb20gdGhlIG1ldGhvZFxuICAgKiBAcmV0dXJuIFJlc3VsdCAtIHBhcnNlZCByZXNwb25zZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBhYmlcbiAgICovXG4gIHBhcnNlKG1ldGhvZCwgcmVzcG9uc2UpIHtcbiAgICBjb25zdCB7IG91dHB1dHMgfSA9IHRoaXMuYWJpLmZpbmQoKGFiaSkgPT4gYWJpLm5hbWUgPT09IG1ldGhvZCk7XG4gICAgY29uc3QgcmVzcG9uc2VJdGVyYXRvciA9IHJlc3BvbnNlLmZsYXQoKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgcGFyc2VkID0gb3V0cHV0cy5mbGF0KCkucmVkdWNlKChhY2MsIG91dHB1dCwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBwcm9wTmFtZSA9IG91dHB1dC5uYW1lID8/IGlkeDtcbiAgICAgIGFjY1twcm9wTmFtZV0gPSByZXNwb25zZVBhcnNlcihyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcywgYWNjKTtcbiAgICAgIGlmIChhY2NbcHJvcE5hbWVdICYmIGFjY1tgJHtwcm9wTmFtZX1fbGVuYF0pIHtcbiAgICAgICAgZGVsZXRlIGFjY1tgJHtwcm9wTmFtZX1fbGVuYF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyc2VkKS5sZW5ndGggPT09IDEgJiYgMCBpbiBwYXJzZWQgPyBwYXJzZWRbMF0gOiBwYXJzZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEZvcm1hdCBjYWlybyBtZXRob2QgcmVzcG9uc2UgZGF0YSB0byBuYXRpdmUganMgdmFsdWVzIGJhc2VkIG9uIHByb3ZpZGVkIGZvcm1hdCBzY2hlbWFcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBjYWlybyBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0gcmVzcG9uc2Ugc3RyaW5nW10gLSBjYWlybyBtZXRob2QgcmVzcG9uc2VcbiAgICogQHBhcmFtIGZvcm1hdCBvYmplY3QgLSBmb3JtYXR0ZXIgb2JqZWN0IHNjaGVtYVxuICAgKiBAcmV0dXJucyBSZXN1bHQgLSBwYXJzZWQgYW5kIGZvcm1hdHRlZCByZXNwb25zZSBvYmplY3RcbiAgICovXG4gIGZvcm1hdChtZXRob2QsIHJlc3BvbnNlLCBmb3JtYXQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlKG1ldGhvZCwgcmVzcG9uc2UpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIocGFyc2VkLCBmb3JtYXQpO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBzdHJ1Y3RzIGZyb20gYWJpXG4gICAqIEBwYXJhbSBhYmkgQWJpXG4gICAqIEByZXR1cm5zIEFiaVN0cnVjdHMgLSBzdHJ1Y3RzIGZyb20gYWJpXG4gICAqL1xuICBzdGF0aWMgZ2V0QWJpU3RydWN0KGFiaSkge1xuICAgIHJldHVybiBhYmkuZmlsdGVyKChhYmlFbnRyeSkgPT4gYWJpRW50cnkudHlwZSA9PT0gXCJzdHJ1Y3RcIikucmVkdWNlKFxuICAgICAgKGFjYywgYWJpRW50cnkpID0+ICh7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2FiaUVudHJ5Lm5hbWVdOiBhYmlFbnRyeVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciB0byBleHRyYWN0IGVudW1zIGZyb20gYWJpXG4gICAqIEBwYXJhbSBhYmkgQWJpXG4gICAqIEByZXR1cm5zIEFiaUVudW1zIC0gZW51bXMgZnJvbSBhYmlcbiAgICovXG4gIHN0YXRpYyBnZXRBYmlFbnVtKGFiaSkge1xuICAgIGNvbnN0IGZ1bGxFbnVtTGlzdCA9IGFiaS5maWx0ZXIoKGFiaUVudHJ5KSA9PiBhYmlFbnRyeS50eXBlID09PSBcImVudW1cIikucmVkdWNlKFxuICAgICAgKGFjYywgYWJpRW50cnkpID0+ICh7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2FiaUVudHJ5Lm5hbWVdOiBhYmlFbnRyeVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gICAgZGVsZXRlIGZ1bGxFbnVtTGlzdFtcImNvcmU6OmJvb2xcIl07XG4gICAgcmV0dXJuIGZ1bGxFbnVtTGlzdDtcbiAgfVxuICAvKipcbiAgICogSGVscGVyOiBDb21waWxlIEhleENhbGxkYXRhIHwgUmF3Q2FsbGRhdGEgfCBSYXdBcmdzXG4gICAqIEBwYXJhbSByYXdDYWxsZGF0YSBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcmV0dXJucyBDYWxsZGF0YVxuICAgKi9cbiAgc3RhdGljIHRvQ2FsbGRhdGEocmF3Q2FsbGRhdGEgPSBbXSkge1xuICAgIHJldHVybiBfQ2FsbERhdGEuY29tcGlsZShyYXdDYWxsZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlcjogQ29udmVydCByYXcgdG8gSGV4Q2FsbGRhdGFcbiAgICogQHBhcmFtIHJhdyBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcmV0dXJucyBIZXhDYWxsZGF0YVxuICAgKi9cbiAgc3RhdGljIHRvSGV4KHJhdyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBfQ2FsbERhdGEuY29tcGlsZShyYXcpO1xuICAgIHJldHVybiBjYWxsZGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgZWxlbWVudHMgb2YgYSBjb250cmFjdCByZXNwb25zZSBhbmQgc3RydWN0dXJlIHRoZW0gaW50byBvbmUgb3Igc2V2ZXJhbCBSZXN1bHQuXG4gICAqIEluIENhaXJvIDAsIGFycmF5cyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICogQHBhcmFtIHR5cGVDYWlybyBzdHJpbmcgb3Igc3RyaW5nW10gLSBDYWlybyB0eXBlIG5hbWUsIGV4IDogXCJoZWxsbzo6aGVsbG86OlVzZXJEYXRhXCJcbiAgICogQHBhcmFtIHJlc3BvbnNlIHN0cmluZ1tdIC0gc2VyaWFsaXplZCBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gdHlwZUNhaXJvLlxuICAgKiBAcmV0dXJuIFJlc3VsdCBvciBSZXN1bHRbXSAtIHBhcnNlZCByZXNwb25zZSBjb3JyZXNwb25kaW5nIHRvIHR5cGVEYXRhLlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZXMyPWhlbGxvQ2FsbERhdGEuZGVjb2RlUGFyYW1ldGVycyhcImhlbGxvOjpoZWxsbzo6VXNlckRhdGFcIixbXCIweDEyMzQ1NlwiLFwiMHgxXCJdKTtcbiAgICogcmVzdWx0ID0geyBhZGRyZXNzOiAxMTkzMDQ2biwgaXNfY2xhaW1lZDogdHJ1ZSB9XG4gICAqL1xuICBkZWNvZGVQYXJhbWV0ZXJzKHR5cGVDYWlybywgcmVzcG9uc2UpIHtcbiAgICBjb25zdCB0eXBlQ2Fpcm9BcnJheSA9IEFycmF5LmlzQXJyYXkodHlwZUNhaXJvKSA/IHR5cGVDYWlybyA6IFt0eXBlQ2Fpcm9dO1xuICAgIGNvbnN0IHJlc3BvbnNlSXRlcmF0b3IgPSByZXNwb25zZS5mbGF0KClbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGRlY29kZWRBcnJheSA9IHR5cGVDYWlyb0FycmF5Lm1hcChcbiAgICAgICh0eXBlUGFyYW0pID0+IHJlc3BvbnNlUGFyc2VyKFxuICAgICAgICByZXNwb25zZUl0ZXJhdG9yLFxuICAgICAgICB7IG5hbWU6IFwiXCIsIHR5cGU6IHR5cGVQYXJhbSB9LFxuICAgICAgICB0aGlzLnN0cnVjdHMsXG4gICAgICAgIHRoaXMuZW51bXNcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBkZWNvZGVkQXJyYXkubGVuZ3RoID09PSAxID8gZGVjb2RlZEFycmF5WzBdIDogZGVjb2RlZEFycmF5O1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvaGFzaC9pbmRleC50c1xudmFyIGhhc2hfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaGFzaF9leHBvcnRzLCB7XG4gIGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoOiAoKSA9PiBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaCxcbiAgY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMsXG4gIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gzLFxuICBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIsXG4gIGNvbXB1dGVDb21waWxlZENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoLFxuICBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVDb250cmFjdENsYXNzSGFzaCxcbiAgY29tcHV0ZUhhc2hPbkVsZW1lbnRzOiAoKSA9PiBjb21wdXRlSGFzaE9uRWxlbWVudHMyLFxuICBjb21wdXRlSGludGVkQ2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlSGludGVkQ2xhc3NIYXNoLFxuICBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaCxcbiAgY29tcHV0ZVBlZGVyc2VuSGFzaDogKCkgPT4gY29tcHV0ZVBlZGVyc2VuSGFzaCxcbiAgY29tcHV0ZVBlZGVyc2VuSGFzaE9uRWxlbWVudHM6ICgpID0+IGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzLFxuICBjb21wdXRlUG9zZWlkb25IYXNoOiAoKSA9PiBjb21wdXRlUG9zZWlkb25IYXNoLFxuICBjb21wdXRlUG9zZWlkb25IYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHMsXG4gIGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoLFxuICBmb3JtYXRTcGFjZXM6ICgpID0+IGZvcm1hdFNwYWNlcyxcbiAgZ2V0U2VsZWN0b3I6ICgpID0+IGdldFNlbGVjdG9yLFxuICBnZXRTZWxlY3RvckZyb21OYW1lOiAoKSA9PiBnZXRTZWxlY3RvckZyb21OYW1lLFxuICBoYXNoQnl0ZUNvZGVTZWdtZW50czogKCkgPT4gaGFzaEJ5dGVDb2RlU2VnbWVudHMsXG4gIGtlY2Nha0JuOiAoKSA9PiBrZWNjYWtCbixcbiAgcG9zZWlkb246ICgpID0+IHBvc2VpZG9uLFxuICBzdGFya25ldEtlY2NhazogKCkgPT4gc3RhcmtuZXRLZWNjYWtcbn0pO1xuaW1wb3J0ICogYXMgcG9zZWlkb24gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvcG9zZWlkb25cIjtcblxuLy8gc3JjL3V0aWxzL2hhc2gvdHJhbnNhY3Rpb25IYXNoL3YyLnRzXG52YXIgdjJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodjJfZXhwb3J0cywge1xuICBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uOiAoKSA9PiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24sXG4gIGNvbXB1dGVIYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzXG59KTtcblxuLy8gc3JjL3V0aWxzL2VjLnRzXG52YXIgZWNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZWNfZXhwb3J0cywge1xuICBzdGFya0N1cnZlOiAoKSA9PiBzdGFya0N1cnZlLFxuICB3ZWllcnN0cmFzczogKCkgPT4gd2VpZXJzdHJhc3Ncbn0pO1xuaW1wb3J0ICogYXMgc3RhcmtDdXJ2ZSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG5pbXBvcnQgKiBhcyB3ZWllcnN0cmFzcyBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC93ZWllcnN0cmFzc1wiO1xuXG4vLyBzcmMvdXRpbHMvaGFzaC90cmFuc2FjdGlvbkhhc2gvdjIudHNcbmZ1bmN0aW9uIGNvbXB1dGVIYXNoT25FbGVtZW50cyhkYXRhKSB7XG4gIHJldHVybiBbLi4uZGF0YSwgZGF0YS5sZW5ndGhdLnJlZHVjZSgoeCwgeSkgPT4gc3RhcmtDdXJ2ZS5wZWRlcnNlbih0b0JpZ0ludCh4KSwgdG9CaWdJbnQoeSkpLCAwKS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKHR4SGFzaFByZWZpeCwgdmVyc2lvbiwgY29udHJhY3RBZGRyZXNzLCBlbnRyeVBvaW50U2VsZWN0b3IsIGNhbGxkYXRhLCBtYXhGZWUsIGNoYWluSWQsIGFkZGl0aW9uYWxEYXRhID0gW10pIHtcbiAgY29uc3QgY2FsbGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGNhbGxkYXRhKTtcbiAgY29uc3QgZGF0YVRvSGFzaCA9IFtcbiAgICB0eEhhc2hQcmVmaXgsXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgZW50cnlQb2ludFNlbGVjdG9yLFxuICAgIGNhbGxkYXRhSGFzaCxcbiAgICBtYXhGZWUsXG4gICAgY2hhaW5JZCxcbiAgICAuLi5hZGRpdGlvbmFsRGF0YVxuICBdO1xuICByZXR1cm4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGRhdGFUb0hhc2gpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaChjbGFzc0hhc2gsIHNlbmRlckFkZHJlc3MsIHZlcnNpb24sIG1heEZlZSwgY2hhaW5JZCwgbm9uY2UsIGNvbXBpbGVkQ2xhc3NIYXNoKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY0NjU2MzZjNjE3MjY1XCIgLyogREVDTEFSRSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIHNlbmRlckFkZHJlc3MsXG4gICAgMCxcbiAgICBbY2xhc3NIYXNoXSxcbiAgICBtYXhGZWUsXG4gICAgY2hhaW5JZCxcbiAgICBbbm9uY2UsIC4uLmNvbXBpbGVkQ2xhc3NIYXNoID8gW2NvbXBpbGVkQ2xhc3NIYXNoXSA6IFtdXVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaChjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgY29uc3RydWN0b3JDYWxsZGF0YSwgc2FsdCwgdmVyc2lvbiwgbWF4RmVlLCBjaGFpbklkLCBub25jZSkge1xuICBjb25zdCBjYWxsZGF0YSA9IFtjbGFzc0hhc2gsIHNhbHQsIC4uLmNvbnN0cnVjdG9yQ2FsbGRhdGFdO1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKFxuICAgIFwiMHg2NDY1NzA2YzZmNzk1ZjYxNjM2MzZmNzU2ZTc0XCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgMCxcbiAgICBjYWxsZGF0YSxcbiAgICBtYXhGZWUsXG4gICAgY2hhaW5JZCxcbiAgICBbbm9uY2VdXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2goY29udHJhY3RBZGRyZXNzLCB2ZXJzaW9uLCBjYWxsZGF0YSwgbWF4RmVlLCBjaGFpbklkLCBub25jZSkge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKFxuICAgIFwiMHg2OTZlNzY2ZjZiNjVcIiAvKiBJTlZPS0UgKi8sXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgMCxcbiAgICBjYWxsZGF0YSxcbiAgICBtYXhGZWUsXG4gICAgY2hhaW5JZCxcbiAgICBbbm9uY2VdXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC92My50c1xudmFyIHYzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHYzX2V4cG9ydHMsIHtcbiAgY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDIsXG4gIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gyLFxuICBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uOiAoKSA9PiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yLFxuICBoYXNoREFNb2RlOiAoKSA9PiBoYXNoREFNb2RlLFxuICBoYXNoRmVlRmllbGQ6ICgpID0+IGhhc2hGZWVGaWVsZFxufSk7XG5pbXBvcnQgeyBwb3NlaWRvbkhhc2hNYW55IH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xudmFyIEFUb0JJID0gKGFycmF5KSA9PiBhcnJheS5tYXAoKGl0KSA9PiBCaWdJbnQoaXQpKTtcbnZhciBEQVRBX0FWQUlMQUJJTElUWV9NT0RFX0JJVFMgPSAzMm47XG52YXIgTUFYX0FNT1VOVF9CSVRTID0gNjRuO1xudmFyIE1BWF9QUklDRV9QRVJfVU5JVF9CSVRTID0gMTI4bjtcbnZhciBSRVNPVVJDRV9WQUxVRV9PRkZTRVQgPSBNQVhfQU1PVU5UX0JJVFMgKyBNQVhfUFJJQ0VfUEVSX1VOSVRfQklUUztcbnZhciBMMV9HQVNfTkFNRSA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhcIkwxX0dBU1wiKSk7XG52YXIgTDJfR0FTX05BTUUgPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoXCJMMl9HQVNcIikpO1xuZnVuY3Rpb24gaGFzaERBTW9kZShub25jZURBTW9kZSwgZmVlREFNb2RlKSB7XG4gIHJldHVybiAoQmlnSW50KG5vbmNlREFNb2RlKSA8PCBEQVRBX0FWQUlMQUJJTElUWV9NT0RFX0JJVFMpICsgQmlnSW50KGZlZURBTW9kZSk7XG59XG5mdW5jdGlvbiBoYXNoRmVlRmllbGQodGlwLCBib3VuZHMpIHtcbiAgY29uc3QgTDFCb3VuZCA9IChMMV9HQVNfTkFNRSA8PCBSRVNPVVJDRV9WQUxVRV9PRkZTRVQpICsgKEJpZ0ludChib3VuZHMubDFfZ2FzLm1heF9hbW91bnQpIDw8IE1BWF9QUklDRV9QRVJfVU5JVF9CSVRTKSArIEJpZ0ludChib3VuZHMubDFfZ2FzLm1heF9wcmljZV9wZXJfdW5pdCk7XG4gIGNvbnN0IEwyQm91bmQgPSAoTDJfR0FTX05BTUUgPDwgUkVTT1VSQ0VfVkFMVUVfT0ZGU0VUKSArIChCaWdJbnQoYm91bmRzLmwyX2dhcy5tYXhfYW1vdW50KSA8PCBNQVhfUFJJQ0VfUEVSX1VOSVRfQklUUykgKyBCaWdJbnQoYm91bmRzLmwyX2dhcy5tYXhfcHJpY2VfcGVyX3VuaXQpO1xuICByZXR1cm4gcG9zZWlkb25IYXNoTWFueShbQmlnSW50KHRpcCksIEwxQm91bmQsIEwyQm91bmRdKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjIodHhIYXNoUHJlZml4LCB2ZXJzaW9uLCBzZW5kZXJBZGRyZXNzLCBjaGFpbklkLCBub25jZSwgdGlwLCBwYXltYXN0ZXJEYXRhLCBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSwgcmVzb3VyY2VCb3VuZHMsIGFkZGl0aW9uYWxEYXRhID0gW10pIHtcbiAgY29uc3QgZmVlRmllbGRIYXNoID0gaGFzaEZlZUZpZWxkKHRpcCwgcmVzb3VyY2VCb3VuZHMpO1xuICBjb25zdCBkQU1vZGVIYXNoID0gaGFzaERBTW9kZShub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSk7XG4gIGNvbnN0IGRhdGFUb0hhc2ggPSBBVG9CSShbXG4gICAgdHhIYXNoUHJlZml4LFxuICAgIHZlcnNpb24sXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICBmZWVGaWVsZEhhc2gsXG4gICAgcG9zZWlkb25IYXNoTWFueShBVG9CSShwYXltYXN0ZXJEYXRhKSksXG4gICAgY2hhaW5JZCxcbiAgICBub25jZSxcbiAgICBkQU1vZGVIYXNoLFxuICAgIC4uLkFUb0JJKGFkZGl0aW9uYWxEYXRhKVxuICBdKTtcbiAgcmV0dXJuIHRvSGV4KHBvc2VpZG9uSGFzaE1hbnkoZGF0YVRvSGFzaCkpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDIoY29udHJhY3RBZGRyZXNzLCBjbGFzc0hhc2gsIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSwgc2FsdCwgdmVyc2lvbiwgY2hhaW5JZCwgbm9uY2UsIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLCByZXNvdXJjZUJvdW5kcywgdGlwLCBwYXltYXN0ZXJEYXRhKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yKFxuICAgIFwiMHg2NDY1NzA2YzZmNzk1ZjYxNjM2MzZmNzU2ZTc0XCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgY2hhaW5JZCxcbiAgICBub25jZSxcbiAgICB0aXAsXG4gICAgcGF5bWFzdGVyRGF0YSxcbiAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIHJlc291cmNlQm91bmRzLFxuICAgIFtwb3NlaWRvbkhhc2hNYW55KEFUb0JJKGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSkpLCBjbGFzc0hhc2gsIHNhbHRdXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMihjbGFzc0hhc2gsIGNvbXBpbGVkQ2xhc3NIYXNoLCBzZW5kZXJBZGRyZXNzLCB2ZXJzaW9uLCBjaGFpbklkLCBub25jZSwgYWNjb3VudERlcGxveW1lbnREYXRhLCBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSwgcmVzb3VyY2VCb3VuZHMsIHRpcCwgcGF5bWFzdGVyRGF0YSkge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uMihcbiAgICBcIjB4NjQ2NTYzNmM2MTcyNjVcIiAvKiBERUNMQVJFICovLFxuICAgIHZlcnNpb24sXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICBjaGFpbklkLFxuICAgIG5vbmNlLFxuICAgIHRpcCxcbiAgICBBVG9CSShwYXltYXN0ZXJEYXRhKSxcbiAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIHJlc291cmNlQm91bmRzLFxuICAgIFtwb3NlaWRvbkhhc2hNYW55KEFUb0JJKGFjY291bnREZXBsb3ltZW50RGF0YSkpLCBjbGFzc0hhc2gsIGNvbXBpbGVkQ2xhc3NIYXNoXVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoKHNlbmRlckFkZHJlc3MsIHZlcnNpb24sIGNvbXBpbGVkQ2FsbGRhdGEsIGNoYWluSWQsIG5vbmNlLCBhY2NvdW50RGVwbG95bWVudERhdGEsIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLCByZXNvdXJjZUJvdW5kcywgdGlwLCBwYXltYXN0ZXJEYXRhKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yKFxuICAgIFwiMHg2OTZlNzY2ZjZiNjVcIiAvKiBJTlZPS0UgKi8sXG4gICAgdmVyc2lvbixcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIGNoYWluSWQsXG4gICAgbm9uY2UsXG4gICAgdGlwLFxuICAgIHBheW1hc3RlckRhdGEsXG4gICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICByZXNvdXJjZUJvdW5kcyxcbiAgICBbcG9zZWlkb25IYXNoTWFueShBVG9CSShhY2NvdW50RGVwbG95bWVudERhdGEpKSwgcG9zZWlkb25IYXNoTWFueShBVG9CSShjb21waWxlZENhbGxkYXRhKSldXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC9pbmRleC50c1xuZnVuY3Rpb24gaXNWM0ludm9rZVR4KGFyZ3MpIHtcbiAgcmV0dXJuIFthcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzXS5pbmNsdWRlcyhhcmdzLnZlcnNpb24pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMihhcmdzKSB7XG4gIGlmIChpc1YzSW52b2tlVHgoYXJncykpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoKFxuICAgICAgYXJncy5zZW5kZXJBZGRyZXNzLFxuICAgICAgYXJncy52ZXJzaW9uLFxuICAgICAgYXJncy5jb21waWxlZENhbGxkYXRhLFxuICAgICAgYXJncy5jaGFpbklkLFxuICAgICAgYXJncy5ub25jZSxcbiAgICAgIGFyZ3MuYWNjb3VudERlcGxveW1lbnREYXRhLFxuICAgICAgYXJncy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgIGFyZ3MucmVzb3VyY2VCb3VuZHMsXG4gICAgICBhcmdzLnRpcCxcbiAgICAgIGFyZ3MucGF5bWFzdGVyRGF0YVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaChcbiAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgYXJncy52ZXJzaW9uLFxuICAgIGFyZ3MuY29tcGlsZWRDYWxsZGF0YSxcbiAgICBhcmdzLm1heEZlZSxcbiAgICBhcmdzLmNoYWluSWQsXG4gICAgYXJncy5ub25jZVxuICApO1xufVxuZnVuY3Rpb24gaXNWM0RlY2xhcmVUeChhcmdzKSB7XG4gIHJldHVybiBbYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMywgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GM10uaW5jbHVkZXMoYXJncy52ZXJzaW9uKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzKGFyZ3MpIHtcbiAgaWYgKGlzVjNEZWNsYXJlVHgoYXJncykpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDIoXG4gICAgICBhcmdzLmNsYXNzSGFzaCxcbiAgICAgIGFyZ3MuY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgICBhcmdzLnZlcnNpb24sXG4gICAgICBhcmdzLmNoYWluSWQsXG4gICAgICBhcmdzLm5vbmNlLFxuICAgICAgYXJncy5hY2NvdW50RGVwbG95bWVudERhdGEsXG4gICAgICBhcmdzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIGFyZ3MudGlwLFxuICAgICAgYXJncy5wYXltYXN0ZXJEYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaChcbiAgICBhcmdzLmNsYXNzSGFzaCxcbiAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgYXJncy52ZXJzaW9uLFxuICAgIGFyZ3MubWF4RmVlLFxuICAgIGFyZ3MuY2hhaW5JZCxcbiAgICBhcmdzLm5vbmNlLFxuICAgIGFyZ3MuY29tcGlsZWRDbGFzc0hhc2hcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVjNEZXBsb3lBY2NvdW50VHgoYXJncykge1xuICByZXR1cm4gW2FwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjNdLmluY2x1ZGVzKGFyZ3MudmVyc2lvbik7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyhhcmdzKSB7XG4gIGlmIChpc1YzRGVwbG95QWNjb3VudFR4KGFyZ3MpKSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gyKFxuICAgICAgYXJncy5jb250cmFjdEFkZHJlc3MsXG4gICAgICBhcmdzLmNsYXNzSGFzaCxcbiAgICAgIGFyZ3MuY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgYXJncy5zYWx0LFxuICAgICAgYXJncy52ZXJzaW9uLFxuICAgICAgYXJncy5jaGFpbklkLFxuICAgICAgYXJncy5ub25jZSxcbiAgICAgIGFyZ3Mubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgIGFyZ3MuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLnJlc291cmNlQm91bmRzLFxuICAgICAgYXJncy50aXAsXG4gICAgICBhcmdzLnBheW1hc3RlckRhdGFcbiAgICApO1xuICB9XG4gIHJldHVybiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoKFxuICAgIGFyZ3MuY29udHJhY3RBZGRyZXNzLFxuICAgIGFyZ3MuY2xhc3NIYXNoLFxuICAgIGFyZ3MuY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICBhcmdzLnNhbHQsXG4gICAgYXJncy52ZXJzaW9uLFxuICAgIGFyZ3MubWF4RmVlLFxuICAgIGFyZ3MuY2hhaW5JZCxcbiAgICBhcmdzLm5vbmNlXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9oYXNoL2NsYXNzSGFzaC50c1xuaW1wb3J0IHsgcG9zZWlkb25IYXNoTWFueSBhcyBwb3NlaWRvbkhhc2hNYW55MiB9IGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcblxuLy8gc3JjL3V0aWxzL2pzb24udHNcbnZhciBqc29uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGpzb25fZXhwb3J0cywge1xuICBwYXJzZTogKCkgPT4gcGFyc2UyLFxuICBwYXJzZUFsd2F5c0FzQmlnOiAoKSA9PiBwYXJzZUFsd2F5c0FzQmlnLFxuICBzdHJpbmdpZnk6ICgpID0+IHN0cmluZ2lmeTIsXG4gIHN0cmluZ2lmeUFsd2F5c0FzQmlnOiAoKSA9PiBzdHJpbmdpZnlBbHdheXNBc0JpZ1xufSk7XG5pbXBvcnQgKiBhcyBqc29uIGZyb20gXCJsb3NzbGVzcy1qc29uXCI7XG52YXIgcGFyc2VJbnRBc051bWJlck9yQmlnSW50ID0gKHN0cikgPT4ge1xuICBpZiAoIWpzb24uaXNJbnRlZ2VyKHN0cikpXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbiAgY29uc3QgbnVtID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIHJldHVybiBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pID8gbnVtIDogQmlnSW50KHN0cik7XG59O1xudmFyIHBhcnNlMiA9IChzdHIpID0+IGpzb24ucGFyc2UoU3RyaW5nKHN0ciksIHZvaWQgMCwgcGFyc2VJbnRBc051bWJlck9yQmlnSW50KTtcbnZhciBwYXJzZUFsd2F5c0FzQmlnID0gKHN0cikgPT4ganNvbi5wYXJzZShTdHJpbmcoc3RyKSwgdm9pZCAwLCBqc29uLnBhcnNlTnVtYmVyQW5kQmlnSW50KTtcbnZhciBzdHJpbmdpZnkyID0gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UsIG51bWJlclN0cmluZ2lmaWVycykgPT4ganNvbi5zdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgbnVtYmVyU3RyaW5naWZpZXJzKTtcbnZhciBzdHJpbmdpZnlBbHdheXNBc0JpZyA9IHN0cmluZ2lmeTI7XG5cbi8vIHNyYy91dGlscy9oYXNoL2NsYXNzSGFzaC50c1xuZnVuY3Rpb24gY29tcHV0ZVBlZGVyc2VuSGFzaChhLCBiKSB7XG4gIHJldHVybiBzdGFya0N1cnZlLnBlZGVyc2VuKEJpZ0ludChhKSwgQmlnSW50KGIpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVQb3NlaWRvbkhhc2goYSwgYikge1xuICByZXR1cm4gdG9IZXgoc3RhcmtDdXJ2ZS5wb3NlaWRvbkhhc2goQmlnSW50KGEpLCBCaWdJbnQoYikpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIYXNoT25FbGVtZW50czIoZGF0YSkge1xuICByZXR1cm4gWy4uLmRhdGEsIGRhdGEubGVuZ3RoXS5yZWR1Y2UoKHgsIHkpID0+IHN0YXJrQ3VydmUucGVkZXJzZW4oQmlnSW50KHgpLCBCaWdJbnQoeSkpLCAwKS50b1N0cmluZygpO1xufVxudmFyIGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMjtcbmZ1bmN0aW9uIGNvbXB1dGVQb3NlaWRvbkhhc2hPbkVsZW1lbnRzKGRhdGEpIHtcbiAgcmV0dXJuIHRvSGV4KHBvc2VpZG9uSGFzaE1hbnkyKGRhdGEubWFwKCh4KSA9PiBCaWdJbnQoeCkpKSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaChzYWx0LCBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGRlcGxveWVyQWRkcmVzcykge1xuICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgY29uc3QgY29uc3RydWN0b3JDYWxsZGF0YUhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKGNvbXBpbGVkQ2FsbGRhdGEpO1xuICBjb25zdCBDT05UUkFDVF9BRERSRVNTX1BSRUZJWCA9IGZlbHQoXCIweDUzNTQ0MTUyNGI0ZTQ1NTQ1ZjQzNGY0ZTU0NTI0MTQzNTQ1ZjQxNDQ0NDUyNDU1MzUzXCIpO1xuICBjb25zdCBoYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihbXG4gICAgQ09OVFJBQ1RfQUREUkVTU19QUkVGSVgsXG4gICAgZGVwbG95ZXJBZGRyZXNzLFxuICAgIHNhbHQsXG4gICAgY2xhc3NIYXNoLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGFIYXNoXG4gIF0pO1xuICByZXR1cm4gdG9IZXgoQmlnSW50KGhhc2gpICUgQUREUl9CT1VORCk7XG59XG5mdW5jdGlvbiBudWxsU2tpcFJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PT0gXCJhdHRyaWJ1dGVzXCIgfHwga2V5ID09PSBcImFjY2Vzc2libGVfc2NvcGVzXCIpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwID8gdm9pZCAwIDogdmFsdWU7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJkZWJ1Z19pbmZvXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNwYWNlcyhqc29uMikge1xuICBsZXQgaW5zaWRlUXVvdGVzID0gZmFsc2U7XG4gIGNvbnN0IG5ld1N0cmluZyA9IFtdO1xuICBmb3IgKGNvbnN0IGNoYXIgb2YganNvbjIpIHtcbiAgICBpZiAoY2hhciA9PT0gJ1wiJyAmJiAobmV3U3RyaW5nLmxlbmd0aCA+IDAgJiYgbmV3U3RyaW5nLnNsaWNlKC0xKVswXSA9PT0gXCJcXFxcXCIpID09PSBmYWxzZSkge1xuICAgICAgaW5zaWRlUXVvdGVzID0gIWluc2lkZVF1b3RlcztcbiAgICB9XG4gICAgaWYgKGluc2lkZVF1b3Rlcykge1xuICAgICAgbmV3U3RyaW5nLnB1c2goY2hhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0cmluZy5wdXNoKGNoYXIgPT09IFwiOlwiID8gXCI6IFwiIDogY2hhciA9PT0gXCIsXCIgPyBcIiwgXCIgOiBjaGFyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1N0cmluZy5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUhpbnRlZENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KSB7XG4gIGNvbnN0IHsgYWJpLCBwcm9ncmFtIH0gPSBjb21waWxlZENvbnRyYWN0O1xuICBjb25zdCBjb250cmFjdENsYXNzID0geyBhYmksIHByb2dyYW0gfTtcbiAgY29uc3Qgc2VyaWFsaXplZEpzb24gPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5Mihjb250cmFjdENsYXNzLCBudWxsU2tpcFJlcGxhY2VyKSk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoc2VyaWFsaXplZEpzb24pKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSBpc1N0cmluZyhjb250cmFjdCkgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIGNvbnN0IGFwaVZlcnNpb24gPSB0b0hleChBUElfVkVSU0lPTik7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihcbiAgICBjb21waWxlZENvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMLmZsYXRNYXAoKGUpID0+IFtlLnNlbGVjdG9yLCBlLm9mZnNldF0pXG4gICk7XG4gIGNvbnN0IGwxSGFuZGxlckVudHJ5UG9pbnRzSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50czIoXG4gICAgY29tcGlsZWRDb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSLmZsYXRNYXAoKGUpID0+IFtlLnNlbGVjdG9yLCBlLm9mZnNldF0pXG4gICk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKFxuICAgIGNvbXBpbGVkQ29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IuZmxhdE1hcCgoZSkgPT4gW2Uuc2VsZWN0b3IsIGUub2Zmc2V0XSlcbiAgKTtcbiAgY29uc3QgYnVpbHRpbnNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihcbiAgICBjb21waWxlZENvbnRyYWN0LnByb2dyYW0uYnVpbHRpbnMubWFwKChzKSA9PiBlbmNvZGVTaG9ydFN0cmluZyhzKSlcbiAgKTtcbiAgY29uc3QgaGludGVkQ2xhc3NIYXNoID0gY29tcHV0ZUhpbnRlZENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbiAgY29uc3QgZGF0YUhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKGNvbXBpbGVkQ29udHJhY3QucHJvZ3JhbS5kYXRhKTtcbiAgcmV0dXJuIGNvbXB1dGVIYXNoT25FbGVtZW50czIoW1xuICAgIGFwaVZlcnNpb24sXG4gICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgbDFIYW5kbGVyRW50cnlQb2ludHNIYXNoLFxuICAgIGNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2gsXG4gICAgYnVpbHRpbnNIYXNoLFxuICAgIGhpbnRlZENsYXNzSGFzaCxcbiAgICBkYXRhSGFzaFxuICBdKTtcbn1cbmZ1bmN0aW9uIGhhc2hCdWlsdGlucyhidWlsdGlucykge1xuICByZXR1cm4gcG9zZWlkb25IYXNoTWFueTIoXG4gICAgYnVpbHRpbnMuZmxhdE1hcCgoaXQpID0+IHtcbiAgICAgIHJldHVybiBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoaXQpKTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gaGFzaEVudHJ5UG9pbnQoZGF0YSkge1xuICBjb25zdCBiYXNlID0gZGF0YS5mbGF0TWFwKChpdCkgPT4ge1xuICAgIHJldHVybiBbQmlnSW50KGl0LnNlbGVjdG9yKSwgQmlnSW50KGl0Lm9mZnNldCksIGhhc2hCdWlsdGlucyhpdC5idWlsdGlucyldO1xuICB9KTtcbiAgcmV0dXJuIHBvc2VpZG9uSGFzaE1hbnkyKGJhc2UpO1xufVxuZnVuY3Rpb24gaGFzaEJ5dGVDb2RlU2VnbWVudHMoY2FzbSkge1xuICBjb25zdCBieXRlQ29kZSA9IGNhc20uYnl0ZWNvZGUubWFwKChuKSA9PiBCaWdJbnQobikpO1xuICBjb25zdCBieXRlY29kZVNlZ21lbnRMZW5ndGhzID0gY2FzbS5ieXRlY29kZV9zZWdtZW50X2xlbmd0aHMgPz8gW107XG4gIGxldCBzZWdtZW50U3RhcnQgPSAwO1xuICBjb25zdCBoYXNoTGVhdmVzID0gYnl0ZWNvZGVTZWdtZW50TGVuZ3Rocy5mbGF0TWFwKChsZW4pID0+IHtcbiAgICBjb25zdCBzZWdtZW50ID0gYnl0ZUNvZGUuc2xpY2Uoc2VnbWVudFN0YXJ0LCBzZWdtZW50U3RhcnQgKz0gbGVuKTtcbiAgICByZXR1cm4gW0JpZ0ludChsZW4pLCBwb3NlaWRvbkhhc2hNYW55MihzZWdtZW50KV07XG4gIH0pO1xuICByZXR1cm4gMW4gKyBwb3NlaWRvbkhhc2hNYW55MihoYXNoTGVhdmVzKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb21waWxlZENsYXNzSGFzaChjYXNtKSB7XG4gIGNvbnN0IENPTVBJTEVEX0NMQVNTX1ZFUlNJT04gPSBcIkNPTVBJTEVEX0NMQVNTX1YxXCI7XG4gIGNvbnN0IGNvbXBpbGVkQ2xhc3NWZXJzaW9uID0gQmlnSW50KGVuY29kZVNob3J0U3RyaW5nKENPTVBJTEVEX0NMQVNTX1ZFUlNJT04pKTtcbiAgY29uc3QgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2ggPSBoYXNoRW50cnlQb2ludChjYXNtLmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMKTtcbiAgY29uc3QgbDFIYW5kbGVycyA9IGhhc2hFbnRyeVBvaW50KGNhc20uZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUik7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gaGFzaEVudHJ5UG9pbnQoY2FzbS5lbnRyeV9wb2ludHNfYnlfdHlwZS5DT05TVFJVQ1RPUik7XG4gIGNvbnN0IGJ5dGVjb2RlID0gY2FzbS5ieXRlY29kZV9zZWdtZW50X2xlbmd0aHMgPyBoYXNoQnl0ZUNvZGVTZWdtZW50cyhjYXNtKSA6IHBvc2VpZG9uSGFzaE1hbnkyKGNhc20uYnl0ZWNvZGUubWFwKChpdCkgPT4gQmlnSW50KGl0KSkpO1xuICByZXR1cm4gdG9IZXgoXG4gICAgcG9zZWlkb25IYXNoTWFueTIoW1xuICAgICAgY29tcGlsZWRDbGFzc1ZlcnNpb24sXG4gICAgICBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCxcbiAgICAgIGwxSGFuZGxlcnMsXG4gICAgICBjb25zdHJ1Y3RvcixcbiAgICAgIGJ5dGVjb2RlXG4gICAgXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhc2hFbnRyeVBvaW50U2llcnJhKGRhdGEpIHtcbiAgY29uc3QgYmFzZSA9IGRhdGEuZmxhdE1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gW0JpZ0ludChpdC5zZWxlY3RvciksIEJpZ0ludChpdC5mdW5jdGlvbl9pZHgpXTtcbiAgfSk7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55MihiYXNlKTtcbn1cbmZ1bmN0aW9uIGhhc2hBYmkoc2llcnJhKSB7XG4gIGNvbnN0IGluZGVudFN0cmluZyA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKHNpZXJyYS5hYmksIG51bGwpKTtcbiAgcmV0dXJuIEJpZ0ludChhZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoaW5kZW50U3RyaW5nKSkudG9TdHJpbmcoMTYpKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2goc2llcnJhKSB7XG4gIGNvbnN0IENPTlRSQUNUX0NMQVNTX1ZFUlNJT04gPSBcIkNPTlRSQUNUX0NMQVNTX1YwLjEuMFwiO1xuICBjb25zdCBjb21waWxlZENsYXNzVmVyc2lvbiA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhDT05UUkFDVF9DTEFTU19WRVJTSU9OKSk7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gaGFzaEVudHJ5UG9pbnRTaWVycmEoc2llcnJhLmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMKTtcbiAgY29uc3QgbDFIYW5kbGVycyA9IGhhc2hFbnRyeVBvaW50U2llcnJhKHNpZXJyYS5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSKTtcbiAgY29uc3QgY29uc3RydWN0b3IgPSBoYXNoRW50cnlQb2ludFNpZXJyYShzaWVycmEuZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IpO1xuICBjb25zdCBhYmlIYXNoID0gaGFzaEFiaShzaWVycmEpO1xuICBjb25zdCBzaWVycmFQcm9ncmFtID0gcG9zZWlkb25IYXNoTWFueTIoc2llcnJhLnNpZXJyYV9wcm9ncmFtLm1hcCgoaXQpID0+IEJpZ0ludChpdCkpKTtcbiAgcmV0dXJuIHRvSGV4KFxuICAgIHBvc2VpZG9uSGFzaE1hbnkyKFtcbiAgICAgIGNvbXBpbGVkQ2xhc3NWZXJzaW9uLFxuICAgICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgICBsMUhhbmRsZXJzLFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBhYmlIYXNoLFxuICAgICAgc2llcnJhUHJvZ3JhbVxuICAgIF0pXG4gICk7XG59XG5mdW5jdGlvbiBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2goY29udHJhY3QpIHtcbiAgY29uc3QgY29tcGlsZWRDb250cmFjdCA9IGlzU3RyaW5nKGNvbnRyYWN0KSA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgaWYgKFwic2llcnJhX3Byb2dyYW1cIiBpbiBjb21waWxlZENvbnRyYWN0KSB7XG4gICAgcmV0dXJuIGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpO1xufVxuXG4vLyBzcmMvdXRpbHMvc3RhcmsudHNcbnZhciBzdGFya19leHBvcnRzID0ge307XG5fX2V4cG9ydChzdGFya19leHBvcnRzLCB7XG4gIGNvbXByZXNzUHJvZ3JhbTogKCkgPT4gY29tcHJlc3NQcm9ncmFtLFxuICBkZWNvbXByZXNzUHJvZ3JhbTogKCkgPT4gZGVjb21wcmVzc1Byb2dyYW0sXG4gIGVzdGltYXRlRmVlVG9Cb3VuZHM6ICgpID0+IGVzdGltYXRlRmVlVG9Cb3VuZHMsXG4gIGVzdGltYXRlZEZlZVRvTWF4RmVlOiAoKSA9PiBlc3RpbWF0ZWRGZWVUb01heEZlZSxcbiAgZm9ybWF0U2lnbmF0dXJlOiAoKSA9PiBmb3JtYXRTaWduYXR1cmUsXG4gIGludERBTTogKCkgPT4gaW50REFNLFxuICBtYWtlQWRkcmVzczogKCkgPT4gbWFrZUFkZHJlc3MsXG4gIHJhbmRvbUFkZHJlc3M6ICgpID0+IHJhbmRvbUFkZHJlc3MsXG4gIHJlZHVjZVYyOiAoKSA9PiByZWR1Y2VWMixcbiAgc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXk6ICgpID0+IHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5LFxuICBzaWduYXR1cmVUb0hleEFycmF5OiAoKSA9PiBzaWduYXR1cmVUb0hleEFycmF5LFxuICB0b0ZlZVZlcnNpb246ICgpID0+IHRvRmVlVmVyc2lvbixcbiAgdG9UcmFuc2FjdGlvblZlcnNpb246ICgpID0+IHRvVHJhbnNhY3Rpb25WZXJzaW9uLFxuICB2M0RldGFpbHM6ICgpID0+IHYzRGV0YWlsc1xufSk7XG5pbXBvcnQgeyBnZXRTdGFya0tleSwgdXRpbHMgfSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG5pbXBvcnQgeyBnemlwLCB1bmd6aXAgfSBmcm9tIFwicGFrb1wiO1xuZnVuY3Rpb24gY29tcHJlc3NQcm9ncmFtKGpzb25Qcm9ncmFtKSB7XG4gIGNvbnN0IHN0cmluZ2lmaWVkID0gaXNTdHJpbmcoanNvblByb2dyYW0pID8ganNvblByb2dyYW0gOiBzdHJpbmdpZnkyKGpzb25Qcm9ncmFtKTtcbiAgY29uc3QgY29tcHJlc3NlZFByb2dyYW0gPSBnemlwKHN0cmluZ2lmaWVkKTtcbiAgcmV0dXJuIGJ0b2FVbml2ZXJzYWwoY29tcHJlc3NlZFByb2dyYW0pO1xufVxuZnVuY3Rpb24gZGVjb21wcmVzc1Byb2dyYW0oYmFzZTY0Mikge1xuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlNjQyKSlcbiAgICByZXR1cm4gYmFzZTY0MjtcbiAgY29uc3QgZGVjb21wcmVzc2VkID0gYXJyYXlCdWZmZXJUb1N0cmluZyh1bmd6aXAoYXRvYlVuaXZlcnNhbChiYXNlNjQyKSkpO1xuICByZXR1cm4gcGFyc2UyKGRlY29tcHJlc3NlZCk7XG59XG5mdW5jdGlvbiByYW5kb21BZGRyZXNzKCkge1xuICBjb25zdCByYW5kb21LZXlQYWlyID0gdXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICByZXR1cm4gZ2V0U3RhcmtLZXkocmFuZG9tS2V5UGFpcik7XG59XG5mdW5jdGlvbiBtYWtlQWRkcmVzcyhpbnB1dCkge1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGlucHV0KS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gZm9ybWF0U2lnbmF0dXJlKHNpZykge1xuICBpZiAoIXNpZylcbiAgICB0aHJvdyBFcnJvcihcImZvcm1hdFNpZ25hdHVyZTogcHJvdmlkZWQgc2lnbmF0dXJlIGlzIHVuZGVmaW5lZFwiKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2lnKSkge1xuICAgIHJldHVybiBzaWcubWFwKChpdCkgPT4gdG9IZXgoaXQpKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnO1xuICAgIHJldHVybiBbdG9IZXgociksIHRvSGV4KHMpXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ25hdHVyZSBuZWVkIHRvIGJlIHdlaWVyc3RyYXNzLlNpZ25hdHVyZVR5cGUgb3IgYW4gYXJyYXkgZm9yIGN1c3RvbVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkoc2lnKSB7XG4gIHJldHVybiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5KGZvcm1hdFNpZ25hdHVyZShzaWcpKTtcbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnKSB7XG4gIHJldHVybiBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheShmb3JtYXRTaWduYXR1cmUoc2lnKSk7XG59XG5mdW5jdGlvbiBlc3RpbWF0ZWRGZWVUb01heEZlZShlc3RpbWF0ZWRGZWUsIG92ZXJoZWFkID0gNTAgLyogTUFYX0ZFRSAqLykge1xuICByZXR1cm4gYWRkUGVyY2VudChlc3RpbWF0ZWRGZWUsIG92ZXJoZWFkKTtcbn1cbmZ1bmN0aW9uIGVzdGltYXRlRmVlVG9Cb3VuZHMoZXN0aW1hdGUsIGFtb3VudE92ZXJoZWFkID0gNTAgLyogTDFfQk9VTkRfTUFYX0FNT1VOVCAqLywgcHJpY2VPdmVyaGVhZCA9IDUwIC8qIEwxX0JPVU5EX01BWF9QUklDRV9QRVJfVU5JVCAqLykge1xuICBpZiAoaXNCaWdJbnQoZXN0aW1hdGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGwyX2dhczogeyBtYXhfYW1vdW50OiBcIjB4MFwiLCBtYXhfcHJpY2VfcGVyX3VuaXQ6IFwiMHgwXCIgfSxcbiAgICAgIGwxX2dhczogeyBtYXhfYW1vdW50OiBcIjB4MFwiLCBtYXhfcHJpY2VfcGVyX3VuaXQ6IFwiMHgwXCIgfVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBlc3RpbWF0ZS5nYXNfY29uc3VtZWQgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGVzdGltYXRlLmdhc19wcmljZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IEVycm9yKFwiZXN0aW1hdGVGZWVUb0JvdW5kczogZXN0aW1hdGUgaXMgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGNvbnN0IG1heFVuaXRzID0gZXN0aW1hdGUuZGF0YV9nYXNfY29uc3VtZWQgIT09IHZvaWQgMCAmJiBlc3RpbWF0ZS5kYXRhX2dhc19wcmljZSAhPT0gdm9pZCAwID8gdG9IZXgoYWRkUGVyY2VudChCaWdJbnQoZXN0aW1hdGUub3ZlcmFsbF9mZWUpIC8gQmlnSW50KGVzdGltYXRlLmdhc19wcmljZSksIGFtb3VudE92ZXJoZWFkKSkgOiB0b0hleChhZGRQZXJjZW50KGVzdGltYXRlLmdhc19jb25zdW1lZCwgYW1vdW50T3ZlcmhlYWQpKTtcbiAgY29uc3QgbWF4VW5pdFByaWNlID0gdG9IZXgoYWRkUGVyY2VudChlc3RpbWF0ZS5nYXNfcHJpY2UsIHByaWNlT3ZlcmhlYWQpKTtcbiAgcmV0dXJuIHtcbiAgICBsMl9nYXM6IHsgbWF4X2Ftb3VudDogXCIweDBcIiwgbWF4X3ByaWNlX3Blcl91bml0OiBcIjB4MFwiIH0sXG4gICAgbDFfZ2FzOiB7IG1heF9hbW91bnQ6IG1heFVuaXRzLCBtYXhfcHJpY2VfcGVyX3VuaXQ6IG1heFVuaXRQcmljZSB9XG4gIH07XG59XG5mdW5jdGlvbiBpbnREQU0oZGFtKSB7XG4gIGlmIChkYW0gPT09IGFwaV9leHBvcnRzLkVEYXRhQXZhaWxhYmlsaXR5TW9kZS5MMSlcbiAgICByZXR1cm4gYXBpX2V4cG9ydHMuRURBTW9kZS5MMTtcbiAgaWYgKGRhbSA9PT0gYXBpX2V4cG9ydHMuRURhdGFBdmFpbGFiaWxpdHlNb2RlLkwyKVxuICAgIHJldHVybiBhcGlfZXhwb3J0cy5FREFNb2RlLkwyO1xuICB0aHJvdyBFcnJvcihcIkVEQU0gY29udmVyc2lvblwiKTtcbn1cbmZ1bmN0aW9uIHRvVHJhbnNhY3Rpb25WZXJzaW9uKGRlZmF1bHRWZXJzaW9uLCBwcm92aWRlZFZlcnNpb24pIHtcbiAgY29uc3QgcHJvdmlkZWRWZXJzaW9uMHhzID0gcHJvdmlkZWRWZXJzaW9uID8gdG9IZXgocHJvdmlkZWRWZXJzaW9uKSA6IHZvaWQgMDtcbiAgY29uc3QgZGVmYXVsdFZlcnNpb24weHMgPSB0b0hleChkZWZhdWx0VmVyc2lvbik7XG4gIGlmIChwcm92aWRlZFZlcnNpb24gJiYgIU9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbikuaW5jbHVkZXMocHJvdmlkZWRWZXJzaW9uMHhzKSkge1xuICAgIHRocm93IEVycm9yKGBwcm92aWRlZFZlcnNpb24gJHtwcm92aWRlZFZlcnNpb259IGlzIG5vdCBFVHJhbnNhY3Rpb25WZXJzaW9uYCk7XG4gIH1cbiAgaWYgKCFPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24pLmluY2x1ZGVzKGRlZmF1bHRWZXJzaW9uMHhzKSkge1xuICAgIHRocm93IEVycm9yKGBkZWZhdWx0VmVyc2lvbiAke2RlZmF1bHRWZXJzaW9ufSBpcyBub3QgRVRyYW5zYWN0aW9uVmVyc2lvbmApO1xuICB9XG4gIHJldHVybiBwcm92aWRlZFZlcnNpb24gPyBwcm92aWRlZFZlcnNpb24weHMgOiBkZWZhdWx0VmVyc2lvbjB4cztcbn1cbmZ1bmN0aW9uIHRvRmVlVmVyc2lvbihwcm92aWRlZFZlcnNpb24pIHtcbiAgaWYgKCFwcm92aWRlZFZlcnNpb24pXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgdmVyc2lvbiA9IHRvSGV4KHByb3ZpZGVkVmVyc2lvbik7XG4gIGlmICh2ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYwKVxuICAgIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYwO1xuICBpZiAodmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSlcbiAgICByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMTtcbiAgaWYgKHZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIpXG4gICAgcmV0dXJuIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjI7XG4gIGlmICh2ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzKVxuICAgIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzO1xuICB0aHJvdyBFcnJvcihgdG9GZWVWZXJzaW9uOiAke3ZlcnNpb259IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbn1cbmZ1bmN0aW9uIHYzRGV0YWlscyhkZXRhaWxzKSB7XG4gIHJldHVybiB7XG4gICAgdGlwOiBkZXRhaWxzLnRpcCB8fCAwLFxuICAgIHBheW1hc3RlckRhdGE6IGRldGFpbHMucGF5bWFzdGVyRGF0YSB8fCBbXSxcbiAgICBhY2NvdW50RGVwbG95bWVudERhdGE6IGRldGFpbHMuYWNjb3VudERlcGxveW1lbnREYXRhIHx8IFtdLFxuICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGRldGFpbHMubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSB8fCBhcGlfZXhwb3J0cy5FRGF0YUF2YWlsYWJpbGl0eU1vZGUuTDEsXG4gICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUgfHwgYXBpX2V4cG9ydHMuRURhdGFBdmFpbGFiaWxpdHlNb2RlLkwxLFxuICAgIHJlc291cmNlQm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzID8/IGVzdGltYXRlRmVlVG9Cb3VuZHMoWkVSTylcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlZHVjZVYyKHByb3ZpZGVkVmVyc2lvbikge1xuICBpZiAocHJvdmlkZWRWZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYyKVxuICAgIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxO1xuICBpZiAocHJvdmlkZWRWZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyKVxuICAgIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxO1xuICByZXR1cm4gcHJvdmlkZWRWZXJzaW9uO1xufVxuXG4vLyBzcmMvdXRpbHMvY29udHJhY3QudHNcbmZ1bmN0aW9uIGlzU2llcnJhKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSBpc1N0cmluZyhjb250cmFjdCkgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIHJldHVybiBcInNpZXJyYV9wcm9ncmFtXCIgaW4gY29tcGlsZWRDb250cmFjdDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0geyAuLi5wYXlsb2FkIH07XG4gIGlmIChpc1NpZXJyYShwYXlsb2FkLmNvbnRyYWN0KSkge1xuICAgIGlmICghcGF5bG9hZC5jb21waWxlZENsYXNzSGFzaCAmJiBwYXlsb2FkLmNhc20pIHtcbiAgICAgIHJlc3BvbnNlLmNvbXBpbGVkQ2xhc3NIYXNoID0gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoKHBheWxvYWQuY2FzbSk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuY29tcGlsZWRDbGFzc0hhc2gpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXh0cmFjdCBjb21waWxlZENsYXNzSGFzaCBmYWlsZWQsIHByb3ZpZGUgKENhaXJvQXNzZW1ibHkpLmNhc20gZmlsZSBvciBjb21waWxlZENsYXNzSGFzaFwiXG4gICAgICApO1xuICB9XG4gIHJlc3BvbnNlLmNsYXNzSGFzaCA9IHBheWxvYWQuY2xhc3NIYXNoID8/IGNvbXB1dGVDb250cmFjdENsYXNzSGFzaChwYXlsb2FkLmNvbnRyYWN0KTtcbiAgaWYgKCFyZXNwb25zZS5jbGFzc0hhc2gpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0cmFjdCBjbGFzc0hhc2ggZmFpbGVkLCBwcm92aWRlIChDb21waWxlZENvbnRyYWN0KS5qc29uIGZpbGUgb3IgY2xhc3NIYXNoXCIpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG5mdW5jdGlvbiBjb250cmFjdENsYXNzUmVzcG9uc2VUb0xlZ2FjeUNvbXBpbGVkQ29udHJhY3QoY2NyKSB7XG4gIGlmIChpc1NpZXJyYShjY3IpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDb250cmFjdENsYXNzUmVzcG9uc2UgbmVlZCB0byBiZSBMZWdhY3lDb250cmFjdENsYXNzIChjYWlybzAgcmVzcG9uc2UgY2xhc3MpXCIpO1xuICB9XG4gIGNvbnN0IGNvbnRyYWN0ID0gY2NyO1xuICByZXR1cm4geyAuLi5jb250cmFjdCwgcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oY29udHJhY3QucHJvZ3JhbSkgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2V0aC50c1xudmFyIGV0aF9leHBvcnRzID0ge307XG5fX2V4cG9ydChldGhfZXhwb3J0cywge1xuICBldGhSYW5kb21Qcml2YXRlS2V5OiAoKSA9PiBldGhSYW5kb21Qcml2YXRlS2V5LFxuICB2YWxpZGF0ZUFuZFBhcnNlRXRoQWRkcmVzczogKCkgPT4gdmFsaWRhdGVBbmRQYXJzZUV0aEFkZHJlc3Ncbn0pO1xuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5mdW5jdGlvbiBldGhSYW5kb21Qcml2YXRlS2V5KCkge1xuICByZXR1cm4gc2FuaXRpemVIZXgoYnVmMmhleChzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFBhcnNlRXRoQWRkcmVzcyhhZGRyZXNzKSB7XG4gIGFzc2VydEluUmFuZ2UoYWRkcmVzcywgWkVSTywgMm4gKiogMTYwbiAtIDFuLCBcIkV0aGVyZXVtIEFkZHJlc3MgXCIpO1xuICBjb25zdCByZXN1bHQgPSBhZGRIZXhQcmVmaXgocmVtb3ZlSGV4UHJlZml4KHRvSGV4KGFkZHJlc3MpKS5wYWRTdGFydCg0MCwgXCIwXCIpKTtcbiAgYXNzZXJ0KEJvb2xlYW4ocmVzdWx0Lm1hdGNoKC9eKDB4KT9bMC05YS1mXXs0MH0kLykpLCBcIkludmFsaWQgRXRoZXJldW0gQWRkcmVzcyBGb3JtYXRcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy91dGlscy9mZXRjaFBvbnlmaWxsLnRzXG5pbXBvcnQgbWFrZUZldGNoQ29va2llIGZyb20gXCJmZXRjaC1jb29raWVcIjtcbmltcG9ydCBpc29tb3JwaGljRmV0Y2ggZnJvbSBcImlzb21vcnBoaWMtZmV0Y2hcIjtcbnZhciBmZXRjaFBvbnlmaWxsX2RlZmF1bHQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5mZXRjaCB8fCAvLyB1c2UgYnVpbGRpbiBmZXRjaCBpbiBicm93c2VyIGlmIGF2YWlsYWJsZVxudHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtYWtlRmV0Y2hDb29raWUoZ2xvYmFsLmZldGNoKSB8fCAvLyB1c2UgYnVpbGRpbiBmZXRjaCBpbiBub2RlLCByZWFjdC1uYXRpdmUgYW5kIHNlcnZpY2Ugd29ya2VyIGlmIGF2YWlsYWJsZVxuaXNvbW9ycGhpY0ZldGNoO1xuXG4vLyBzcmMvdXRpbHMvcHJvdmlkZXIudHNcbnZhciBwcm92aWRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChwcm92aWRlcl9leHBvcnRzLCB7XG4gIEJsb2NrOiAoKSA9PiBCbG9jayxcbiAgY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzczogKCkgPT4gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyxcbiAgZ2V0RGVmYXVsdE5vZGVVcmw6ICgpID0+IGdldERlZmF1bHROb2RlVXJsLFxuICBpc1BlbmRpbmdCbG9jazogKCkgPT4gaXNQZW5kaW5nQmxvY2ssXG4gIGlzUGVuZGluZ1N0YXRlVXBkYXRlOiAoKSA9PiBpc1BlbmRpbmdTdGF0ZVVwZGF0ZSxcbiAgaXNQZW5kaW5nVHJhbnNhY3Rpb246ICgpID0+IGlzUGVuZGluZ1RyYW5zYWN0aW9uLFxuICBpc1YzVHg6ICgpID0+IGlzVjNUeCxcbiAgaXNWZXJzaW9uOiAoKSA9PiBpc1ZlcnNpb24sXG4gIHBhcnNlQ29udHJhY3Q6ICgpID0+IHBhcnNlQ29udHJhY3QsXG4gIHZhbGlkQmxvY2tUYWdzOiAoKSA9PiB2YWxpZEJsb2NrVGFncyxcbiAgd2FpdDogKCkgPT4gd2FpdFxufSk7XG5mdW5jdGlvbiB3YWl0KGRlbGF5KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgc2V0VGltZW91dChyZXMsIGRlbGF5KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTaWVycmFDb250cmFjdENsYXNzKGNvbnRyYWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4uY29udHJhY3QgfTtcbiAgZGVsZXRlIHJlc3VsdC5zaWVycmFfcHJvZ3JhbV9kZWJ1Z19pbmZvO1xuICByZXN1bHQuYWJpID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoY29udHJhY3QuYWJpKSk7XG4gIHJlc3VsdC5zaWVycmFfcHJvZ3JhbSA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSk7XG4gIHJlc3VsdC5zaWVycmFfcHJvZ3JhbSA9IGNvbXByZXNzUHJvZ3JhbShyZXN1bHQuc2llcnJhX3Byb2dyYW0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VDb250cmFjdChjb250cmFjdCkge1xuICBjb25zdCBwYXJzZWRDb250cmFjdCA9IGlzU3RyaW5nKGNvbnRyYWN0KSA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgaWYgKCFpc1NpZXJyYShjb250cmFjdCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFyc2VkQ29udHJhY3QsXG4gICAgICAuLi5cInByb2dyYW1cIiBpbiBwYXJzZWRDb250cmFjdCAmJiB7IHByb2dyYW06IGNvbXByZXNzUHJvZ3JhbShwYXJzZWRDb250cmFjdC5wcm9ncmFtKSB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyhwYXJzZWRDb250cmFjdCk7XG59XG52YXIgZ2V0RGVmYXVsdE5vZGVVcmwgPSAobmV0d29ya05hbWUsIG11dGUgPSBmYWxzZSkgPT4ge1xuICBpZiAoIW11dGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJVc2luZyBkZWZhdWx0IHB1YmxpYyBub2RlIHVybCwgcGxlYXNlIHByb3ZpZGUgbm9kZVVybCBpbiBwcm92aWRlciBvcHRpb25zIVwiKTtcbiAgfVxuICBjb25zdCBub2RlcyA9IFJQQ19OT0RFU1tuZXR3b3JrTmFtZSA/PyBcIlNOX1NFUE9MSUFcIiAvKiBTTl9TRVBPTElBICovXTtcbiAgY29uc3QgcmFuZElkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCk7XG4gIHJldHVybiBub2Rlc1tyYW5kSWR4XTtcbn07XG52YXIgdmFsaWRCbG9ja1RhZ3MgPSBPYmplY3QudmFsdWVzKEJsb2NrVGFnKTtcbnZhciBCbG9jayA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmxvY2tJZGVudGlmaWVyfSBoYXNoIGlmIG5vdCBudWxsLCBjb250YWlucyB0aGUgYmxvY2sgaGFzaFxuICAgKi9cbiAgaGFzaCA9IG51bGw7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jsb2NrSWRlbnRpZmllcn0gbnVtYmVyIGlmIG5vdCBudWxsLCBjb250YWlucyB0aGUgYmxvY2sgbnVtYmVyXG4gICAqL1xuICBudW1iZXIgPSBudWxsO1xuICAvKipcbiAgICogQHBhcmFtIHtCbG9ja0lkZW50aWZpZXJ9IHRhZyBpZiBub3QgbnVsbCwgY29udGFpbnMgXCJwZW5kaW5nXCIgb3IgXCJsYXRlc3RcIlxuICAgKi9cbiAgdGFnID0gbnVsbDtcbiAgc2V0SWRlbnRpZmllcihfX2lkZW50aWZpZXIpIHtcbiAgICBpZiAoaXNTdHJpbmcoX19pZGVudGlmaWVyKSkge1xuICAgICAgaWYgKGlzRGVjaW1hbFN0cmluZyhfX2lkZW50aWZpZXIpKSB7XG4gICAgICAgIHRoaXMubnVtYmVyID0gcGFyc2VJbnQoX19pZGVudGlmaWVyLCAxMCk7XG4gICAgICB9IGVsc2UgaWYgKGlzSGV4KF9faWRlbnRpZmllcikpIHtcbiAgICAgICAgdGhpcy5oYXNoID0gX19pZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIGlmICh2YWxpZEJsb2NrVGFncy5pbmNsdWRlcyhfX2lkZW50aWZpZXIpKSB7XG4gICAgICAgIHRoaXMudGFnID0gX19pZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKGBCbG9jayBpZGVudGlmaWVyIHVubWFuYWdlZDogJHtfX2lkZW50aWZpZXJ9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0JpZ0ludChfX2lkZW50aWZpZXIpKSB7XG4gICAgICB0aGlzLmhhc2ggPSB0b0hleChfX2lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoX19pZGVudGlmaWVyKSkge1xuICAgICAgdGhpcy5udW1iZXIgPSBfX2lkZW50aWZpZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFnID0gXCJwZW5kaW5nXCIgLyogUEVORElORyAqLztcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKHRoaXMubnVtYmVyKSAmJiB0aGlzLm51bWJlciA8IDApIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcihgQmxvY2sgbnVtYmVyICgke3RoaXMubnVtYmVyfSkgY2FuJ3QgYmUgbmVnYXRpdmVgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIEJsb2NrIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7QmxvY2tJZGVudGlmaWVyfSBfaWRlbnRpZmllciAgaGV4IHN0cmluZyBhbmQgQmlnSW50IGFyZSBkZXRlY3RlZCBhcyBibG9jayBoYXNoZXMuXG4gICAqIGRlY2ltYWwgc3RyaW5nIGFuZCBudW1iZXIgYXJlIGRldGVjdGVkIGFzIGJsb2NrIG51bWJlcnMuXG4gICAqIHRleHQgc3RyaW5nIGFyZSBkZXRlY3RlZCBhcyBibG9jayB0YWcuXG4gICAqIG51bGwgaXMgY29uc2lkZXJlZCBhcyBhICdwZW5kaW5nJyBibG9jayB0YWcuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihfaWRlbnRpZmllcikge1xuICAgIHRoaXMuc2V0SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gIH1cbiAgLy8gVE9ETzogZml4IGFueVxuICAvKipcbiAgICogQHJldHVybnMge2FueX0gdGhlIGlkZW50aWZpZXIgYXMgYSBzdHJpbmdcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQgPSBuZXcgcHJvdmlkZXIuQmxvY2soMTIzNDU2bikucXVlcnlJZGVudGlmaWVyO1xuICAgKiAvLyByZXN1bHQgPSBcImJsb2NrSGFzaD0weDFlMjQwXCJcbiAgICogYGBgXG4gICAqL1xuICBnZXQgcXVlcnlJZGVudGlmaWVyKCkge1xuICAgIGlmICh0aGlzLm51bWJlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGBibG9ja051bWJlcj0ke3RoaXMubnVtYmVyfWA7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBgYmxvY2tIYXNoPSR7dGhpcy5oYXNofWA7XG4gICAgfVxuICAgIHJldHVybiBgYmxvY2tOdW1iZXI9JHt0aGlzLnRhZ31gO1xuICB9XG4gIC8vIFRPRE86IGZpeCBhbnlcbiAgLyoqXG4gICAqIEByZXR1cm5zIHthbnl9IHRoZSBpZGVudGlmaWVyIGFzIGFuIG9iamVjdFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3VsdCA9IG5ldyBwcm92aWRlci5CbG9jayg1Njc4OSkuaWRlbnRpZmllcjtcbiAgICogLy8gcmVzdWx0ID0geyBibG9ja19udW1iZXI6IDU2Nzg5IH1cbiAgICogYGBgXG4gICAqL1xuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICBpZiAodGhpcy5udW1iZXIgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGJsb2NrX251bWJlcjogdGhpcy5udW1iZXIgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgYmxvY2tfaGFzaDogdGhpcy5oYXNoIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhZztcbiAgfVxuICAvKipcbiAgICogY2hhbmdlIHRoZSBpZGVudGlmaWVyIG9mIGFuIGV4aXN0aW5nIEJsb2NrIGluc3RhbmNlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbXlCbG9jayA9IG5ldyBwcm92aWRlci5CbG9jayhcImxhdGVzdFwiKTtcbiAgICogbXlCbG9jay5pZGVudGlmaWVyID1cIjB4MzQ1Njc4OWFiY1wiO1xuICAgKiBjb25zdCByZXN1bHQgPSBteUJsb2NrLmlkZW50aWZpZXI7XG4gICAqIC8vIHJlc3VsdCA9IHsgYmxvY2tfaGFzaDogJzB4MzQ1Njc4OWFiYycgfVxuICAgKiBgYGBcbiAgICovXG4gIHNldCBpZGVudGlmaWVyKF9pZGVudGlmaWVyKSB7XG4gICAgdGhpcy5zZXRJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgfVxuICB2YWx1ZU9mID0gKCkgPT4gdGhpcy5udW1iZXI7XG4gIHRvU3RyaW5nID0gKCkgPT4gdGhpcy5oYXNoO1xufTtcbmZ1bmN0aW9uIGlzVjNUeChkZXRhaWxzKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBkZXRhaWxzLnZlcnNpb24gPyB0b0hleChkZXRhaWxzLnZlcnNpb24pIDogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMztcbiAgcmV0dXJuIHZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMgfHwgdmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMztcbn1cbmZ1bmN0aW9uIGlzVmVyc2lvbih2ZXJzaW9uLCByZXNwb25zZSkge1xuICBjb25zdCBbbWFqb3JTLCBtaW5vclNdID0gdmVyc2lvbi5zcGxpdChcIi5cIik7XG4gIGNvbnN0IFttYWpvclIsIG1pbm9yUl0gPSByZXNwb25zZS5zcGxpdChcIi5cIik7XG4gIHJldHVybiBtYWpvclMgPT09IG1ham9yUiAmJiBtaW5vclMgPT09IG1pbm9yUjtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZ0Jsb2NrKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZS5zdGF0dXMgPT09IFwiUEVORElOR1wiO1xufVxuZnVuY3Rpb24gaXNQZW5kaW5nVHJhbnNhY3Rpb24ocmVzcG9uc2UpIHtcbiAgcmV0dXJuICEoXCJibG9ja19oYXNoXCIgaW4gcmVzcG9uc2UpO1xufVxuZnVuY3Rpb24gaXNQZW5kaW5nU3RhdGVVcGRhdGUocmVzcG9uc2UpIHtcbiAgcmV0dXJuICEoXCJibG9ja19oYXNoXCIgaW4gcmVzcG9uc2UpO1xufVxuXG4vLyBzcmMvdXRpbHMvdHJhbnNhY3Rpb24udHNcbnZhciB0cmFuc2FjdGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydCh0cmFuc2FjdGlvbl9leHBvcnRzLCB7XG4gIGJ1aWxkVURDQ2FsbDogKCkgPT4gYnVpbGRVRENDYWxsLFxuICBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEsXG4gIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSxcbiAgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YV9jYWlybzEsXG4gIGdldEV4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZ2V0RXhlY3V0ZUNhbGxkYXRhLFxuICBnZXRWZXJzaW9uc0J5VHlwZTogKCkgPT4gZ2V0VmVyc2lvbnNCeVR5cGUsXG4gIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXM6ICgpID0+IHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMsXG4gIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXNfY2Fpcm8xOiAoKSA9PiB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMVxufSk7XG52YXIgdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5cyA9IChjYWxscykgPT4ge1xuICBjb25zdCBjYWxsQXJyYXkgPSBbXTtcbiAgY29uc3QgY2FsbGRhdGEgPSBbXTtcbiAgY2FsbHMuZm9yRWFjaCgoY2FsbCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEgfHwgW10pO1xuICAgIGNhbGxBcnJheS5wdXNoKHtcbiAgICAgIHRvOiB0b0JpZ0ludChjYWxsLmNvbnRyYWN0QWRkcmVzcykudG9TdHJpbmcoMTApLFxuICAgICAgc2VsZWN0b3I6IHRvQmlnSW50KGdldFNlbGVjdG9yRnJvbU5hbWUoY2FsbC5lbnRyeXBvaW50KSkudG9TdHJpbmcoMTApLFxuICAgICAgZGF0YV9vZmZzZXQ6IGNhbGxkYXRhLmxlbmd0aC50b1N0cmluZygpLFxuICAgICAgZGF0YV9sZW46IGRhdGEubGVuZ3RoLnRvU3RyaW5nKClcbiAgICB9KTtcbiAgICBjYWxsZGF0YS5wdXNoKC4uLmRhdGEpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjYWxsQXJyYXksXG4gICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoeyBjYWxsZGF0YSB9KVxuICB9O1xufTtcbnZhciBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YSA9IChjYWxscykgPT4ge1xuICBjb25zdCB7IGNhbGxBcnJheSwgY2FsbGRhdGEgfSA9IHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMoY2FsbHMpO1xuICBjb25zdCBjb21waWxlZENhbGxzID0gQ2FsbERhdGEuY29tcGlsZSh7IGNhbGxBcnJheSB9KTtcbiAgcmV0dXJuIFsuLi5jb21waWxlZENhbGxzLCAuLi5jYWxsZGF0YV07XG59O1xudmFyIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlID0gKGNhbGxzLCBub25jZSkgPT4ge1xuICByZXR1cm4gWy4uLmZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhKGNhbGxzKSwgdG9CaWdJbnQobm9uY2UpLnRvU3RyaW5nKCldO1xufTtcbnZhciB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMSA9IChjYWxscykgPT4ge1xuICBjb25zdCBjYWxsQXJyYXkgPSBjYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgdG86IHRvQmlnSW50KGNhbGwuY29udHJhY3RBZGRyZXNzKS50b1N0cmluZygxMCksXG4gICAgc2VsZWN0b3I6IHRvQmlnSW50KGdldFNlbGVjdG9yRnJvbU5hbWUoY2FsbC5lbnRyeXBvaW50KSkudG9TdHJpbmcoMTApLFxuICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEgfHwgW10pXG4gIH0pKTtcbiAgcmV0dXJuIGNhbGxBcnJheTtcbn07XG52YXIgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xID0gKGNhbGxzKSA9PiB7XG4gIGNvbnN0IG9yZGVyQ2FsbHMgPSBjYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgY29udHJhY3RBZGRyZXNzOiBjYWxsLmNvbnRyYWN0QWRkcmVzcyxcbiAgICBlbnRyeXBvaW50OiBjYWxsLmVudHJ5cG9pbnQsXG4gICAgY2FsbGRhdGE6IEFycmF5LmlzQXJyYXkoY2FsbC5jYWxsZGF0YSkgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBjYWxsLmNhbGxkYXRhID8gY2FsbC5jYWxsZGF0YSA6IENhbGxEYXRhLmNvbXBpbGUoY2FsbC5jYWxsZGF0YSlcbiAgICAvLyBSYXdBcmdzT2JqZWN0IHwgUmF3QXJnc0FycmF5IHR5cGVcbiAgfSkpO1xuICByZXR1cm4gQ2FsbERhdGEuY29tcGlsZSh7IG9yZGVyQ2FsbHMgfSk7XG59O1xudmFyIGdldEV4ZWN1dGVDYWxsZGF0YSA9IChjYWxscywgY2Fpcm9WZXJzaW9uID0gXCIwXCIpID0+IHtcbiAgaWYgKGNhaXJvVmVyc2lvbiA9PT0gXCIxXCIpIHtcbiAgICByZXR1cm4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xKGNhbGxzKTtcbiAgfVxuICByZXR1cm4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEoY2FsbHMpO1xufTtcbmZ1bmN0aW9uIGJ1aWxkVURDQ2FsbChwYXlsb2FkLCBhZGRyZXNzKSB7XG4gIGNvbnN0IHBhcmFtcyA9IFtdLmNvbmNhdChwYXlsb2FkKS5tYXAoKGl0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2xhc3NIYXNoLFxuICAgICAgc2FsdCxcbiAgICAgIHVuaXF1ZSA9IHRydWUsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW11cbiAgICB9ID0gaXQ7XG4gICAgY29uc3QgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBjb25zdCBkZXBsb3lTYWx0ID0gc2FsdCA/PyByYW5kb21BZGRyZXNzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbGw6IHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBVREMuQUREUkVTUyxcbiAgICAgICAgZW50cnlwb2ludDogVURDLkVOVFJZUE9JTlQsXG4gICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIGRlcGxveVNhbHQsXG4gICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgYWRkcmVzczogY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goXG4gICAgICAgIHVuaXF1ZSA/IHN0YXJrQ3VydmUucGVkZXJzZW4oYWRkcmVzcywgZGVwbG95U2FsdCkgOiBkZXBsb3lTYWx0LFxuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSxcbiAgICAgICAgdW5pcXVlID8gVURDLkFERFJFU1MgOiAwXG4gICAgICApXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsbHM6IHBhcmFtcy5tYXAoKGl0KSA9PiBpdC5jYWxsKSxcbiAgICBhZGRyZXNzZXM6IHBhcmFtcy5tYXAoKGl0KSA9PiBpdC5hZGRyZXNzKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpIHtcbiAgcmV0dXJuIHZlcnNpb25UeXBlID09PSBcImZlZVwiID8ge1xuICAgIHYxOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxLFxuICAgIHYyOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYyLFxuICAgIHYzOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzXG4gIH0gOiB7IHYxOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLCB2MjogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMiwgdjM6IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMgfTtcbn1cblxuLy8gc3JjL2NoYW5uZWwvcnBjXzBfNi50c1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gIGJsb2NrSWRlbnRpZmllcjogXCJwZW5kaW5nXCIgLyogUEVORElORyAqLyxcbiAgcmV0cmllczogMjAwXG59O1xudmFyIFJwY0NoYW5uZWwgPSBjbGFzcyB7XG4gIG5vZGVVcmw7XG4gIGhlYWRlcnM7XG4gIHJldHJpZXM7XG4gIHJlcXVlc3RJZDtcbiAgYmxvY2tJZGVudGlmaWVyO1xuICBjaGFpbklkO1xuICBzcGVjVmVyc2lvbjtcbiAgd2FpdE1vZGU7XG4gIC8vIGJlaGF2ZSBsaWtlIHdlYjIgcnBjIGFuZCByZXR1cm4gd2hlbiB0eCBpcyBwcm9jZXNzZWRcbiAgY29uc3RydWN0b3Iob3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICBjb25zdCB7IG5vZGVVcmwsIHJldHJpZXMsIGhlYWRlcnMsIGJsb2NrSWRlbnRpZmllciwgY2hhaW5JZCwgc3BlY1ZlcnNpb24sIHdhaXRNb2RlIH0gPSBvcHRpb25zT3JQcm92aWRlciB8fCB7fTtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhOZXR3b3JrTmFtZSkuaW5jbHVkZXMobm9kZVVybCkpIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IGdldERlZmF1bHROb2RlVXJsKG5vZGVVcmwsIG9wdGlvbnNPclByb3ZpZGVyPy5kZWZhdWx0KTtcbiAgICB9IGVsc2UgaWYgKG5vZGVVcmwpIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IG5vZGVVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IGdldERlZmF1bHROb2RlVXJsKHZvaWQgMCwgb3B0aW9uc09yUHJvdmlkZXI/LmRlZmF1bHQpO1xuICAgIH1cbiAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzIHx8IGRlZmF1bHRPcHRpb25zLnJldHJpZXM7XG4gICAgdGhpcy5oZWFkZXJzID0geyAuLi5kZWZhdWx0T3B0aW9ucy5oZWFkZXJzLCAuLi5oZWFkZXJzIH07XG4gICAgdGhpcy5ibG9ja0lkZW50aWZpZXIgPSBibG9ja0lkZW50aWZpZXIgfHwgZGVmYXVsdE9wdGlvbnMuYmxvY2tJZGVudGlmaWVyO1xuICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgdGhpcy5zcGVjVmVyc2lvbiA9IHNwZWNWZXJzaW9uO1xuICAgIHRoaXMud2FpdE1vZGUgPSB3YWl0TW9kZSB8fCBmYWxzZTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IDA7XG4gIH1cbiAgc2V0Q2hhaW5JZChjaGFpbklkKSB7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgfVxuICBmZXRjaChtZXRob2QsIHBhcmFtcywgaWQgPSAwKSB7XG4gICAgY29uc3QgcnBjUmVxdWVzdEJvZHkgPSB7XG4gICAgICBpZCxcbiAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICBtZXRob2QsXG4gICAgICAuLi5wYXJhbXMgJiYgeyBwYXJhbXMgfVxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoUG9ueWZpbGxfZGVmYXVsdCh0aGlzLm5vZGVVcmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBzdHJpbmdpZnkyKHJwY1JlcXVlc3RCb2R5KSxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgIH0pO1xuICB9XG4gIGVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgcnBjRXJyb3IsIG90aGVyRXJyb3IpIHtcbiAgICBpZiAocnBjRXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgY29kZSwgbWVzc2FnZSwgZGF0YSB9ID0gcnBjRXJyb3I7XG4gICAgICB0aHJvdyBuZXcgTGlicmFyeUVycm9yKFxuICAgICAgICBgUlBDOiAke21ldGhvZH0gd2l0aCBwYXJhbXMgJHtzdHJpbmdpZnkyKHBhcmFtcywgbnVsbCwgMil9XG5cbiAgICAgICAgJHtjb2RlfTogJHttZXNzYWdlfTogJHtzdHJpbmdpZnkyKGRhdGEpfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvdGhlckVycm9yIGluc3RhbmNlb2YgTGlicmFyeUVycm9yKSB7XG4gICAgICB0aHJvdyBvdGhlckVycm9yO1xuICAgIH1cbiAgICBpZiAob3RoZXJFcnJvcikge1xuICAgICAgdGhyb3cgRXJyb3Iob3RoZXJFcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZmV0Y2hFbmRwb2ludChtZXRob2QsIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByYXdSZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoKG1ldGhvZCwgcGFyYW1zLCB0aGlzLnJlcXVlc3RJZCArPSAxKTtcbiAgICAgIGNvbnN0IHsgZXJyb3IsIHJlc3VsdCB9ID0gYXdhaXQgcmF3UmVzdWx0Lmpzb24oKTtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgZXJyb3I/LnJlc3BvbnNlPy5kYXRhLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICB0aGlzLmNoYWluSWQgPz89IGF3YWl0IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2NoYWluSWRcIik7XG4gICAgcmV0dXJuIHRoaXMuY2hhaW5JZDtcbiAgfVxuICBhc3luYyBnZXRTcGVjVmVyc2lvbigpIHtcbiAgICB0aGlzLnNwZWNWZXJzaW9uID8/PSBhd2FpdCB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zcGVjVmVyc2lvblwiKTtcbiAgICByZXR1cm4gdGhpcy5zcGVjVmVyc2lvbjtcbiAgfVxuICBnZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Tm9uY2VcIiwge1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgaGFzaCBhbmQgbnVtYmVyXG4gICAqL1xuICBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9ibG9ja0hhc2hBbmROdW1iZXJcIik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgbnVtYmVyXG4gICAqIHJlZHVuZGFudCB1c2UgZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpO1xuICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgdGhlIGxhdGVzdCBibG9ja1xuICAgKi9cbiAgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrTnVtYmVyXCIpO1xuICB9XG4gIGdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeEhhc2hlc1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrV2l0aFR4cyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tXaXRoVHhzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0U3RhdGVVcGRhdGVcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VCbG9ja1RyYW5zYWN0aW9uc1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50XCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25CeUhhc2godHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2hcbiAgICB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4KGJsb2NrSWRlbnRpZmllciwgaW5kZXgpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXhcIiwgeyBibG9ja19pZCwgaW5kZXggfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgeyB0cmFuc2FjdGlvbl9oYXNoIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uVHJhY2UodHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3RyYWNlVHJhbnNhY3Rpb25cIiwgeyB0cmFuc2FjdGlvbl9oYXNoIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXR1cyBvZiBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHJhbnNhY3Rpb25IYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25TdGF0dXNcIiwgeyB0cmFuc2FjdGlvbl9oYXNoIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gaW52b2NhdGlvbnMgQWNjb3VudEludm9jYXRpb25zXG4gICAqIEBwYXJhbSBzaW11bGF0ZVRyYW5zYWN0aW9uT3B0aW9ucyBibG9ja0lkZW50aWZpZXIgYW5kIGZsYWdzIHRvIHNraXAgdmFsaWRhdGlvbiBhbmQgZmVlIGNoYXJnZTxici8+XG4gICAqIC0gYmxvY2tJZGVudGlmaWVyPGJyLz5cbiAgICogLSBza2lwVmFsaWRhdGUgKGRlZmF1bHQgZmFsc2UpPGJyLz5cbiAgICogLSBza2lwRmVlQ2hhcmdlIChkZWZhdWx0IHRydWUpPGJyLz5cbiAgICovXG4gIHNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZSA9IHRydWUsXG4gICAgICBza2lwRmVlQ2hhcmdlID0gdHJ1ZVxuICAgIH0gPSBzaW11bGF0ZVRyYW5zYWN0aW9uT3B0aW9ucztcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3Qgc2ltdWxhdGlvbkZsYWdzID0gW107XG4gICAgaWYgKHNraXBWYWxpZGF0ZSlcbiAgICAgIHNpbXVsYXRpb25GbGFncy5wdXNoKHJwY3NwZWNfMF82X2V4cG9ydHMuRVNpbXVsYXRpb25GbGFnLlNLSVBfVkFMSURBVEUpO1xuICAgIGlmIChza2lwRmVlQ2hhcmdlKVxuICAgICAgc2ltdWxhdGlvbkZsYWdzLnB1c2gocnBjc3BlY18wXzZfZXhwb3J0cy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9GRUVfQ0hBUkdFKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc2ltdWxhdGVUcmFuc2FjdGlvbnNcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICB0cmFuc2FjdGlvbnM6IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCkpLFxuICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2ltdWxhdGlvbkZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgbGV0IHsgcmV0cmllcyB9ID0gdGhpcztcbiAgICBsZXQgb25jaGFpbiA9IGZhbHNlO1xuICAgIGxldCBpc0Vycm9yU3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gb3B0aW9ucz8ucmV0cnlJbnRlcnZhbCA/PyA1ZTM7XG4gICAgY29uc3QgZXJyb3JTdGF0ZXMgPSBvcHRpb25zPy5lcnJvclN0YXRlcyA/PyBbXG4gICAgICBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5SRUpFQ1RFRFxuICAgICAgLy8gVE9ETzogY29tbWVudGVkIG91dCB0byBwcmVzZXJ2ZSB0aGUgbG9uZy1zdGFuZGluZyBiZWhhdmlvciBvZiBcInJldmVydGVkXCIgbm90IGJlaW5nIHRyZWF0ZWQgYXMgYW4gZXJyb3IgYnkgZGVmYXVsdFxuICAgICAgLy8gc2hvdWxkIGRlY2lkZSB3aGljaCBiZWhhdmlvciB0byBrZWVwIGluIHRoZSBmdXR1cmVcbiAgICAgIC8vIFJQQy5FVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMuUkVWRVJURUQsXG4gICAgXTtcbiAgICBjb25zdCBzdWNjZXNzU3RhdGVzID0gb3B0aW9ucz8uc3VjY2Vzc1N0YXRlcyA/PyBbXG4gICAgICBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5TVUNDRUVERUQsXG4gICAgICBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMixcbiAgICAgIHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uU3RhdHVzLkFDQ0VQVEVEX09OX0wxXG4gICAgXTtcbiAgICBsZXQgdHhTdGF0dXM7XG4gICAgd2hpbGUgKCFvbmNoYWluKSB7XG4gICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHhTdGF0dXMgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvblN0YXR1cyA9IHR4U3RhdHVzLmV4ZWN1dGlvbl9zdGF0dXM7XG4gICAgICAgIGNvbnN0IGZpbmFsaXR5U3RhdHVzID0gdHhTdGF0dXMuZmluYWxpdHlfc3RhdHVzO1xuICAgICAgICBpZiAoIWZpbmFsaXR5U3RhdHVzKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJ3YWl0aW5nIGZvciB0cmFuc2FjdGlvbiBzdGF0dXNcIik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yU3RhdGVzLmluY2x1ZGVzKGV4ZWN1dGlvblN0YXR1cykgfHwgZXJyb3JTdGF0ZXMuaW5jbHVkZXMoZmluYWxpdHlTdGF0dXMpKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke2V4ZWN1dGlvblN0YXR1c306ICR7ZmluYWxpdHlTdGF0dXN9YDtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHR4U3RhdHVzO1xuICAgICAgICAgIGlzRXJyb3JTdGF0ZSA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhleGVjdXRpb25TdGF0dXMpIHx8IHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMoZmluYWxpdHlTdGF0dXMpKSB7XG4gICAgICAgICAgb25jaGFpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGlzRXJyb3JTdGF0ZSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXRyaWVzIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JUcmFuc2FjdGlvbiB0aW1lZC1vdXQgd2l0aCByZXRyaWVzICR7dGhpcy5yZXRyaWVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXRyaWVzIC09IDE7XG4gICAgfVxuICAgIGxldCB0eFJlY2VpcHQgPSBudWxsO1xuICAgIHdoaWxlICh0eFJlY2VpcHQgPT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHR4UmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAocmV0cmllcyA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3YWl0Rm9yVHJhbnNhY3Rpb24gdGltZWQtb3V0IHdpdGggcmV0cmllcyAke3RoaXMucmV0cmllc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0cmllcyAtPSAxO1xuICAgICAgYXdhaXQgd2FpdChyZXRyeUludGVydmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4UmVjZWlwdDtcbiAgfVxuICBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gdG9TdG9yYWdlS2V5KGtleSk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdG9yYWdlQXRcIiwge1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIGtleTogcGFyc2VkS2V5LFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc0hhc2hBdFwiLCB7XG4gICAgICBibG9ja19pZCxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3NcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzcyhjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY2xhc3NfaGFzaCA9IHRvSGV4KGNsYXNzSGFzaCk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc1wiLCB7XG4gICAgICBjbGFzc19oYXNoLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbnMsIHsgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSA9IHRydWUgfSkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBsZXQgZmxhZ3MgPSB7fTtcbiAgICBpZiAoIWlzVmVyc2lvbihcIjAuNVwiLCBhd2FpdCB0aGlzLmdldFNwZWNWZXJzaW9uKCkpKSB7XG4gICAgICBmbGFncyA9IHtcbiAgICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2tpcFZhbGlkYXRlID8gW3JwY3NwZWNfMF82X2V4cG9ydHMuRVNpbXVsYXRpb25GbGFnLlNLSVBfVkFMSURBVEVdIDogW11cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9lc3RpbWF0ZUZlZVwiLCB7XG4gICAgICByZXF1ZXN0OiBpbnZvY2F0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaXQsIFwiZmVlXCIpKSxcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgLi4uZmxhZ3NcbiAgICB9KTtcbiAgfVxuICBhc3luYyBpbnZva2UoZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKSB7XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKCFpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGludm9rZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChmdW5jdGlvbkludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGludm9rZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGZ1bmN0aW9uSW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGZ1bmN0aW9uSW52b2NhdGlvbi5jYWxsZGF0YSksXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhaXRNb2RlID8gdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oKGF3YWl0IHByb21pc2UpLnRyYW5zYWN0aW9uX2hhc2gpIDogcHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZWNsYXJlKHsgY29udHJhY3QsIHNpZ25hdHVyZSwgc2VuZGVyQWRkcmVzcywgY29tcGlsZWRDbGFzc0hhc2ggfSwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNTaWVycmEoY29udHJhY3QpICYmICFpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZWNsYXJlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHByb2dyYW06IGNvbnRyYWN0LnByb2dyYW0sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzU2llcnJhKGNvbnRyYWN0KSAmJiAhaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgICBzaWVycmFfcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oY29udHJhY3Quc2llcnJhX3Byb2dyYW0pLFxuICAgICAgICAgICAgY29udHJhY3RfY2xhc3NfdmVyc2lvbjogY29udHJhY3QuY29udHJhY3RfY2xhc3NfdmVyc2lvbixcbiAgICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICAgIGFiaTogY29udHJhY3QuYWJpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBjb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICAgIHZlcnNpb246IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMixcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1NpZXJyYShjb250cmFjdCkgJiYgaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSxcbiAgICAgICAgICAgIGNvbnRyYWN0X2NsYXNzX3ZlcnNpb246IGNvbnRyYWN0LmNvbnRyYWN0X2NsYXNzX3ZlcnNpb24sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiZGVjbGFyZSB1bnNwb3R0ZWQgcGFyYW1ldGVyc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FpdE1vZGUgPyB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbigoYXdhaXQgcHJvbWlzZSkudHJhbnNhY3Rpb25faGFzaCkgOiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnQoeyBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGFkZHJlc3NTYWx0LCBzaWduYXR1cmUgfSwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVwbG95X2FjY291bnRfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoY2xhc3NIYXNoKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERVBMT1lfQUNDT1VOVCxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICB2ZXJzaW9uOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVwbG95X2FjY291bnRfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQsXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgICBjbGFzc19oYXNoOiB0b0hleChjbGFzc0hhc2gpLFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWl0TW9kZSA/IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKChhd2FpdCBwcm9taXNlKS50cmFuc2FjdGlvbl9oYXNoKSA6IHByb21pc2U7XG4gIH1cbiAgY2FsbENvbnRyYWN0KGNhbGwsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jYWxsXCIsIHtcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCksXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjYWxsLmNhbGxkYXRhKVxuICAgICAgfSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE5FVzogRXN0aW1hdGUgdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gTDFcbiAgICogQHBhcmFtIG1lc3NhZ2UgTWVzc2FnZSBGcm9tIEwxXG4gICAqL1xuICBlc3RpbWF0ZU1lc3NhZ2VGZWUobWVzc2FnZSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCB7IGZyb21fYWRkcmVzcywgdG9fYWRkcmVzcywgZW50cnlfcG9pbnRfc2VsZWN0b3IsIHBheWxvYWQgfSA9IG1lc3NhZ2U7XG4gICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IHtcbiAgICAgIGZyb21fYWRkcmVzczogdmFsaWRhdGVBbmRQYXJzZUV0aEFkZHJlc3MoZnJvbV9hZGRyZXNzKSxcbiAgICAgIHRvX2FkZHJlc3M6IHRvSGV4KHRvX2FkZHJlc3MpLFxuICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IGdldFNlbGVjdG9yKGVudHJ5X3BvaW50X3NlbGVjdG9yKSxcbiAgICAgIHBheWxvYWQ6IGdldEhleFN0cmluZ0FycmF5KHBheWxvYWQpXG4gICAgfTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlTWVzc2FnZUZlZVwiLCB7XG4gICAgICBtZXNzYWdlOiBmb3JtYXR0ZWRNZXNzYWdlLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYWJvdXQgdGhlIHN5bmMgc3RhdHVzLCBvciBmYWxzZSBpZiB0aGUgbm9kZSBpcyBub3Qgc3luY2hpbmdcbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGggdGhlIHN0YXRzIGRhdGFcbiAgICovXG4gIGdldFN5bmNpbmdTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc3luY2luZ1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGFuZCB0aGUgcGFnaW5hdGlvbiBvZiB0aGUgZXZlbnRzXG4gICAqL1xuICBnZXRFdmVudHMoZXZlbnRGaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0RXZlbnRzXCIsIHsgZmlsdGVyOiBldmVudEZpbHRlciB9KTtcbiAgfVxuICBidWlsZFRyYW5zYWN0aW9uKGludm9jYXRpb24sIHZlcnNpb25UeXBlKSB7XG4gICAgY29uc3QgZGVmYXVsdFZlcnNpb25zID0gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpO1xuICAgIGxldCBkZXRhaWxzO1xuICAgIGlmICghaXNWM1R4KGludm9jYXRpb24pKSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGludm9jYXRpb24ubWF4RmVlIHx8IDApXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIHJlc291cmNlX2JvdW5kczogaW52b2NhdGlvbi5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgdGlwOiB0b0hleChpbnZvY2F0aW9uLnRpcCksXG4gICAgICAgIHBheW1hc3Rlcl9kYXRhOiBpbnZvY2F0aW9uLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGludm9jYXRpb24uYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyB2MCB2MSB2M1xuICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChpbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MyksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8pIHtcbiAgICAgIGlmICghaXNTaWVycmEoaW52b2NhdGlvbi5jb250cmFjdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IGludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgICAuLi5kZXRhaWxzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBDYWlybyAxIC0gdjIgdjNcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgIC4uLmludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGludm9jYXRpb24uY29udHJhY3Quc2llcnJhX3Byb2dyYW0pXG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGludm9jYXRpb24uY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MyksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLykge1xuICAgICAgY29uc3QgeyBhY2NvdW50X2RlcGxveW1lbnRfZGF0YSwgLi4ucmVzdERldGFpbHMgfSA9IGRldGFpbHM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChpbnZvY2F0aW9uLmNvbnN0cnVjdG9yQ2FsbGRhdGEgfHwgW10pLFxuICAgICAgICBjbGFzc19oYXNoOiB0b0hleChpbnZvY2F0aW9uLmNsYXNzSGFzaCksXG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoaW52b2NhdGlvbi5hZGRyZXNzU2FsdCB8fCAwKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MyksXG4gICAgICAgIC4uLnJlc3REZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIlJQQyBidWlsZFRyYW5zYWN0aW9uIHJlY2VpdmVkIHVua25vd24gVHJhbnNhY3Rpb25UeXBlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvY2hhbm5lbC9ycGNfMF83LnRzXG52YXIgcnBjXzBfN19leHBvcnRzID0ge307XG5fX2V4cG9ydChycGNfMF83X2V4cG9ydHMsIHtcbiAgUnBjQ2hhbm5lbDogKCkgPT4gUnBjQ2hhbm5lbDJcbn0pO1xudmFyIGRlZmF1bHRPcHRpb25zMiA9IHtcbiAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICBibG9ja0lkZW50aWZpZXI6IFwicGVuZGluZ1wiIC8qIFBFTkRJTkcgKi8sXG4gIHJldHJpZXM6IDIwMFxufTtcbnZhciBScGNDaGFubmVsMiA9IGNsYXNzIHtcbiAgbm9kZVVybDtcbiAgaGVhZGVycztcbiAgcmV0cmllcztcbiAgcmVxdWVzdElkO1xuICBibG9ja0lkZW50aWZpZXI7XG4gIGNoYWluSWQ7XG4gIHNwZWNWZXJzaW9uO1xuICB0cmFuc2FjdGlvblJldHJ5SW50ZXJ2YWxGYWxsYmFjaztcbiAgd2FpdE1vZGU7XG4gIC8vIGJlaGF2ZSBsaWtlIHdlYjIgcnBjIGFuZCByZXR1cm4gd2hlbiB0eCBpcyBwcm9jZXNzZWRcbiAgY29uc3RydWN0b3Iob3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBub2RlVXJsLFxuICAgICAgcmV0cmllcyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBjaGFpbklkLFxuICAgICAgc3BlY1ZlcnNpb24sXG4gICAgICB3YWl0TW9kZSxcbiAgICAgIHRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbEZhbGxiYWNrXG4gICAgfSA9IG9wdGlvbnNPclByb3ZpZGVyIHx8IHt9O1xuICAgIGlmIChPYmplY3QudmFsdWVzKE5ldHdvcmtOYW1lKS5pbmNsdWRlcyhub2RlVXJsKSkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwobm9kZVVybCwgb3B0aW9uc09yUHJvdmlkZXI/LmRlZmF1bHQpO1xuICAgIH0gZWxzZSBpZiAobm9kZVVybCkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gbm9kZVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwodm9pZCAwLCBvcHRpb25zT3JQcm92aWRlcj8uZGVmYXVsdCk7XG4gICAgfVxuICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXMgfHwgZGVmYXVsdE9wdGlvbnMyLnJldHJpZXM7XG4gICAgdGhpcy5oZWFkZXJzID0geyAuLi5kZWZhdWx0T3B0aW9uczIuaGVhZGVycywgLi4uaGVhZGVycyB9O1xuICAgIHRoaXMuYmxvY2tJZGVudGlmaWVyID0gYmxvY2tJZGVudGlmaWVyIHx8IGRlZmF1bHRPcHRpb25zMi5ibG9ja0lkZW50aWZpZXI7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB0aGlzLnNwZWNWZXJzaW9uID0gc3BlY1ZlcnNpb247XG4gICAgdGhpcy53YWl0TW9kZSA9IHdhaXRNb2RlIHx8IGZhbHNlO1xuICAgIHRoaXMucmVxdWVzdElkID0gMDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbEZhbGxiYWNrID0gdHJhbnNhY3Rpb25SZXRyeUludGVydmFsRmFsbGJhY2s7XG4gIH1cbiAgZ2V0IHRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25SZXRyeUludGVydmFsRmFsbGJhY2sgPz8gNWUzO1xuICB9XG4gIHNldENoYWluSWQoY2hhaW5JZCkge1xuICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gIH1cbiAgZmV0Y2gobWV0aG9kLCBwYXJhbXMsIGlkID0gMCkge1xuICAgIGNvbnN0IHJwY1JlcXVlc3RCb2R5ID0ge1xuICAgICAgaWQsXG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgbWV0aG9kLFxuICAgICAgLi4ucGFyYW1zICYmIHsgcGFyYW1zIH1cbiAgICB9O1xuICAgIHJldHVybiBmZXRjaFBvbnlmaWxsX2RlZmF1bHQodGhpcy5ub2RlVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogc3RyaW5naWZ5MihycGNSZXF1ZXN0Qm9keSksXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICB9KTtcbiAgfVxuICBlcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIHJwY0Vycm9yLCBvdGhlckVycm9yKSB7XG4gICAgaWYgKHJwY0Vycm9yKSB7XG4gICAgICBjb25zdCB7IGNvZGUsIG1lc3NhZ2UsIGRhdGEgfSA9IHJwY0Vycm9yO1xuICAgICAgdGhyb3cgbmV3IExpYnJhcnlFcnJvcihcbiAgICAgICAgYFJQQzogJHttZXRob2R9IHdpdGggcGFyYW1zICR7c3RyaW5naWZ5MihwYXJhbXMsIG51bGwsIDIpfVxuIFxuICAgICAgICAke2NvZGV9OiAke21lc3NhZ2V9OiAke3N0cmluZ2lmeTIoZGF0YSl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG90aGVyRXJyb3IgaW5zdGFuY2VvZiBMaWJyYXJ5RXJyb3IpIHtcbiAgICAgIHRocm93IG90aGVyRXJyb3I7XG4gICAgfVxuICAgIGlmIChvdGhlckVycm9yKSB7XG4gICAgICB0aHJvdyBFcnJvcihvdGhlckVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmZXRjaEVuZHBvaW50KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhd1Jlc3VsdCA9IGF3YWl0IHRoaXMuZmV0Y2gobWV0aG9kLCBwYXJhbXMsIHRoaXMucmVxdWVzdElkICs9IDEpO1xuICAgICAgY29uc3QgeyBlcnJvciwgcmVzdWx0IH0gPSBhd2FpdCByYXdSZXN1bHQuanNvbigpO1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIGVycm9yKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcj8ucmVzcG9uc2U/LmRhdGEsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHRoaXMuY2hhaW5JZCA/Pz0gYXdhaXQgdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfY2hhaW5JZFwiKTtcbiAgICByZXR1cm4gdGhpcy5jaGFpbklkO1xuICB9XG4gIGFzeW5jIGdldFNwZWNWZXJzaW9uKCkge1xuICAgIHRoaXMuc3BlY1ZlcnNpb24gPz89IGF3YWl0IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3NwZWNWZXJzaW9uXCIpO1xuICAgIHJldHVybiB0aGlzLnNwZWNWZXJzaW9uO1xuICB9XG4gIGdldE5vbmNlRm9yQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXROb25jZVwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBoYXNoIGFuZCBudW1iZXJcbiAgICovXG4gIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrSGFzaEFuZE51bWJlclwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBudW1iZXJcbiAgICogcmVkdW5kYW50IHVzZSBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7XG4gICAqIEByZXR1cm5zIE51bWJlciBvZiB0aGUgbGF0ZXN0IGJsb2NrXG4gICAqL1xuICBnZXRCbG9ja051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYmxvY2tOdW1iZXJcIik7XG4gIH1cbiAgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrV2l0aFR4SGFzaGVzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeHNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1dpdGhSZWNlaXB0cyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tXaXRoUmVjZWlwdHNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1N0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdGF0ZVVwZGF0ZVwiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF90cmFjZUJsb2NrVHJhbnNhY3Rpb25zXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaFxuICAgIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgoYmxvY2tJZGVudGlmaWVyLCBpbmRleCkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleFwiLCB7IGJsb2NrX2lkLCBpbmRleCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VUcmFuc2FjdGlvblwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdHVzIG9mIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvblN0YXR1c1wiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9ucyBBY2NvdW50SW52b2NhdGlvbnNcbiAgICogQHBhcmFtIHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zIGJsb2NrSWRlbnRpZmllciBhbmQgZmxhZ3MgdG8gc2tpcCB2YWxpZGF0aW9uIGFuZCBmZWUgY2hhcmdlPGJyLz5cbiAgICogLSBibG9ja0lkZW50aWZpZXI8YnIvPlxuICAgKiAtIHNraXBWYWxpZGF0ZSAoZGVmYXVsdCBmYWxzZSk8YnIvPlxuICAgKiAtIHNraXBGZWVDaGFyZ2UgKGRlZmF1bHQgdHJ1ZSk8YnIvPlxuICAgKi9cbiAgc2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywgc2ltdWxhdGVUcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlID0gdHJ1ZSxcbiAgICAgIHNraXBGZWVDaGFyZ2UgPSB0cnVlXG4gICAgfSA9IHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBjb25zdCBzaW11bGF0aW9uRmxhZ3MgPSBbXTtcbiAgICBpZiAoc2tpcFZhbGlkYXRlKVxuICAgICAgc2ltdWxhdGlvbkZsYWdzLnB1c2goUlBDU1BFQzA3LkVTaW11bGF0aW9uRmxhZy5TS0lQX1ZBTElEQVRFKTtcbiAgICBpZiAoc2tpcEZlZUNoYXJnZSlcbiAgICAgIHNpbXVsYXRpb25GbGFncy5wdXNoKFJQQ1NQRUMwNy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9GRUVfQ0hBUkdFKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc2ltdWxhdGVUcmFuc2FjdGlvbnNcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICB0cmFuc2FjdGlvbnM6IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCkpLFxuICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2ltdWxhdGlvbkZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgbGV0IHsgcmV0cmllcyB9ID0gdGhpcztcbiAgICBsZXQgb25jaGFpbiA9IGZhbHNlO1xuICAgIGxldCBpc0Vycm9yU3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gb3B0aW9ucz8ucmV0cnlJbnRlcnZhbCA/PyB0aGlzLnRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbERlZmF1bHQ7XG4gICAgY29uc3QgZXJyb3JTdGF0ZXMgPSBvcHRpb25zPy5lcnJvclN0YXRlcyA/PyBbXG4gICAgICBSUENTUEVDMDcuRVRyYW5zYWN0aW9uU3RhdHVzLlJFSkVDVEVEXG4gICAgICAvLyBUT0RPOiBjb21tZW50ZWQgb3V0IHRvIHByZXNlcnZlIHRoZSBsb25nLXN0YW5kaW5nIGJlaGF2aW9yIG9mIFwicmV2ZXJ0ZWRcIiBub3QgYmVpbmcgdHJlYXRlZCBhcyBhbiBlcnJvciBieSBkZWZhdWx0XG4gICAgICAvLyBzaG91bGQgZGVjaWRlIHdoaWNoIGJlaGF2aW9yIHRvIGtlZXAgaW4gdGhlIGZ1dHVyZVxuICAgICAgLy8gUlBDLkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5SRVZFUlRFRCxcbiAgICBdO1xuICAgIGNvbnN0IHN1Y2Nlc3NTdGF0ZXMgPSBvcHRpb25zPy5zdWNjZXNzU3RhdGVzID8/IFtcbiAgICAgIFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMuU1VDQ0VFREVELFxuICAgICAgUlBDU1BFQzA3LkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMixcbiAgICAgIFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDFcbiAgICBdO1xuICAgIGxldCB0eFN0YXR1cztcbiAgICB3aGlsZSAoIW9uY2hhaW4pIHtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICB0cnkge1xuICAgICAgICB0eFN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uU3RhdHVzID0gdHhTdGF0dXMuZXhlY3V0aW9uX3N0YXR1cztcbiAgICAgICAgY29uc3QgZmluYWxpdHlTdGF0dXMgPSB0eFN0YXR1cy5maW5hbGl0eV9zdGF0dXM7XG4gICAgICAgIGlmICghZmluYWxpdHlTdGF0dXMpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIndhaXRpbmcgZm9yIHRyYW5zYWN0aW9uIHN0YXR1c1wiKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JTdGF0ZXMuaW5jbHVkZXMoZXhlY3V0aW9uU3RhdHVzKSB8fCBlcnJvclN0YXRlcy5pbmNsdWRlcyhmaW5hbGl0eVN0YXR1cykpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7ZXhlY3V0aW9uU3RhdHVzfTogJHtmaW5hbGl0eVN0YXR1c31gO1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0gdHhTdGF0dXM7XG4gICAgICAgICAgaXNFcnJvclN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBlbHNlIGlmIChzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKGV4ZWN1dGlvblN0YXR1cykgfHwgc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhmaW5hbGl0eVN0YXR1cykpIHtcbiAgICAgICAgICBvbmNoYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgaXNFcnJvclN0YXRlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldHJpZXMgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FpdEZvclRyYW5zYWN0aW9uIHRpbWVkLW91dCB3aXRoIHJldHJpZXMgJHt0aGlzLnJldHJpZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHJpZXMgLT0gMTtcbiAgICB9XG4gICAgbGV0IHR4UmVjZWlwdCA9IG51bGw7XG4gICAgd2hpbGUgKHR4UmVjZWlwdCA9PT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHhSZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChyZXRyaWVzIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JUcmFuc2FjdGlvbiB0aW1lZC1vdXQgd2l0aCByZXRyaWVzICR7dGhpcy5yZXRyaWVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXRyaWVzIC09IDE7XG4gICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdHhSZWNlaXB0O1xuICB9XG4gIGdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBwYXJzZWRLZXkgPSB0b1N0b3JhZ2VLZXkoa2V5KTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFN0b3JhZ2VBdFwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAga2V5OiBwYXJzZWRLZXksXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIGdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzSGFzaEF0XCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgY29udHJhY3RfYWRkcmVzc1xuICAgIH0pO1xuICB9XG4gIGdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjbGFzc19oYXNoID0gdG9IZXgoY2xhc3NIYXNoKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzXCIsIHtcbiAgICAgIGNsYXNzX2hhc2gsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NBdFwiLCB7XG4gICAgICBibG9ja19pZCxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3NcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRFc3RpbWF0ZUZlZShpbnZvY2F0aW9ucywgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gdHJ1ZSB9KSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGxldCBmbGFncyA9IHt9O1xuICAgIGlmICghaXNWZXJzaW9uKFwiMC41XCIsIGF3YWl0IHRoaXMuZ2V0U3BlY1ZlcnNpb24oKSkpIHtcbiAgICAgIGZsYWdzID0ge1xuICAgICAgICBzaW11bGF0aW9uX2ZsYWdzOiBza2lwVmFsaWRhdGUgPyBbUlBDU1BFQzA3LkVTaW11bGF0aW9uRmxhZy5TS0lQX1ZBTElEQVRFXSA6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogaW52b2NhdGlvbnMubWFwKChpdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGl0LCBcImZlZVwiKSksXG4gICAgICBibG9ja19pZCxcbiAgICAgIC4uLmZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgaW52b2tlKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBpbnZva2VfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogZnVuY3Rpb25JbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KGZ1bmN0aW9uSW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZEludm9rZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgaW52b2tlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChmdW5jdGlvbkludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhaXRNb2RlID8gdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oKGF3YWl0IHByb21pc2UpLnRyYW5zYWN0aW9uX2hhc2gpIDogcHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZWNsYXJlKHsgY29udHJhY3QsIHNpZ25hdHVyZSwgc2VuZGVyQWRkcmVzcywgY29tcGlsZWRDbGFzc0hhc2ggfSwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNTaWVycmEoY29udHJhY3QpICYmICFpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZWNsYXJlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgcHJvZ3JhbTogY29udHJhY3QucHJvZ3JhbSxcbiAgICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICAgIGFiaTogY29udHJhY3QuYWJpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZXJzaW9uOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1NpZXJyYShjb250cmFjdCkgJiYgIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgICBzaWVycmFfcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oY29udHJhY3Quc2llcnJhX3Byb2dyYW0pLFxuICAgICAgICAgICAgY29udHJhY3RfY2xhc3NfdmVyc2lvbjogY29udHJhY3QuY29udHJhY3RfY2xhc3NfdmVyc2lvbixcbiAgICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICAgIGFiaTogY29udHJhY3QuYWJpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBjb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyLFxuICAgICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzU2llcnJhKGNvbnRyYWN0KSAmJiBpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZWNsYXJlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBjb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSxcbiAgICAgICAgICAgIGNvbnRyYWN0X2NsYXNzX3ZlcnNpb246IGNvbnRyYWN0LmNvbnRyYWN0X2NsYXNzX3ZlcnNpb24sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiZGVjbGFyZSB1bnNwb3R0ZWQgcGFyYW1ldGVyc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FpdE1vZGUgPyB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbigoYXdhaXQgcHJvbWlzZSkudHJhbnNhY3Rpb25faGFzaCkgOiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnQoeyBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGFkZHJlc3NTYWx0LCBzaWduYXR1cmUgfSwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVwbG95X2FjY291bnRfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoY2xhc3NIYXNoKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLkRFUExPWV9BQ0NPVU5ULFxuICAgICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlcGxveUFjY291bnRUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlcGxveV9hY2NvdW50X3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQsXG4gICAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjMsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGNvbnN0cnVjdG9yQ2FsbGRhdGEgfHwgW10pLFxuICAgICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGNsYXNzSGFzaCksXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhaXRNb2RlID8gdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oKGF3YWl0IHByb21pc2UpLnRyYW5zYWN0aW9uX2hhc2gpIDogcHJvbWlzZTtcbiAgfVxuICBjYWxsQ29udHJhY3QoY2FsbCwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2NhbGxcIiwge1xuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBjb250cmFjdF9hZGRyZXNzOiBjYWxsLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IGdldFNlbGVjdG9yRnJvbU5hbWUoY2FsbC5lbnRyeXBvaW50KSxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGNhbGwuY2FsbGRhdGEpXG4gICAgICB9LFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTkVXOiBFc3RpbWF0ZSB0aGUgZmVlIGZvciBhIG1lc3NhZ2UgZnJvbSBMMVxuICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIEZyb20gTDFcbiAgICovXG4gIGVzdGltYXRlTWVzc2FnZUZlZShtZXNzYWdlLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IHsgZnJvbV9hZGRyZXNzLCB0b19hZGRyZXNzLCBlbnRyeV9wb2ludF9zZWxlY3RvciwgcGF5bG9hZCB9ID0gbWVzc2FnZTtcbiAgICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlID0ge1xuICAgICAgZnJvbV9hZGRyZXNzOiB2YWxpZGF0ZUFuZFBhcnNlRXRoQWRkcmVzcyhmcm9tX2FkZHJlc3MpLFxuICAgICAgdG9fYWRkcmVzczogdG9IZXgodG9fYWRkcmVzcyksXG4gICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3IoZW50cnlfcG9pbnRfc2VsZWN0b3IpLFxuICAgICAgcGF5bG9hZDogZ2V0SGV4U3RyaW5nQXJyYXkocGF5bG9hZClcbiAgICB9O1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVNZXNzYWdlRmVlXCIsIHtcbiAgICAgIG1lc3NhZ2U6IGZvcm1hdHRlZE1lc3NhZ2UsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBhYm91dCB0aGUgc3luYyBzdGF0dXMsIG9yIGZhbHNlIGlmIHRoZSBub2RlIGlzIG5vdCBzeW5jaGluZ1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCB0aGUgc3RhdHMgZGF0YVxuICAgKi9cbiAgZ2V0U3luY2luZ1N0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zeW5jaW5nXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBldmVudHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGZpbHRlclxuICAgKiBAcmV0dXJucyBldmVudHMgYW5kIHRoZSBwYWdpbmF0aW9uIG9mIHRoZSBldmVudHNcbiAgICovXG4gIGdldEV2ZW50cyhldmVudEZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRFdmVudHNcIiwgeyBmaWx0ZXI6IGV2ZW50RmlsdGVyIH0pO1xuICB9XG4gIGJ1aWxkVHJhbnNhY3Rpb24oaW52b2NhdGlvbiwgdmVyc2lvblR5cGUpIHtcbiAgICBjb25zdCBkZWZhdWx0VmVyc2lvbnMgPSBnZXRWZXJzaW9uc0J5VHlwZSh2ZXJzaW9uVHlwZSk7XG4gICAgbGV0IGRldGFpbHM7XG4gICAgaWYgKCFpc1YzVHgoaW52b2NhdGlvbikpIHtcbiAgICAgIGRldGFpbHMgPSB7XG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShpbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgIG5vbmNlOiB0b0hleChpbnZvY2F0aW9uLm5vbmNlKSxcbiAgICAgICAgbWF4X2ZlZTogdG9IZXgoaW52b2NhdGlvbi5tYXhGZWUgfHwgMClcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFpbHMgPSB7XG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShpbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgIG5vbmNlOiB0b0hleChpbnZvY2F0aW9uLm5vbmNlKSxcbiAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBpbnZvY2F0aW9uLnJlc291cmNlQm91bmRzLFxuICAgICAgICB0aXA6IHRvSGV4KGludm9jYXRpb24udGlwKSxcbiAgICAgICAgcGF5bWFzdGVyX2RhdGE6IGludm9jYXRpb24ucGF5bWFzdGVyRGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpLFxuICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBpbnZvY2F0aW9uLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBpbnZvY2F0aW9uLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogaW52b2NhdGlvbi5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIHYwIHYxIHYzXG4gICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoaW52b2NhdGlvbi5jYWxsZGF0YSksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjMpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovKSB7XG4gICAgICBpZiAoIWlzU2llcnJhKGludm9jYXRpb24uY29udHJhY3QpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MSksXG4gICAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gQ2Fpcm8gMSAtIHYyIHYzXG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShpbnZvY2F0aW9uLmNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKVxuICAgICAgICB9LFxuICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBpbnZvY2F0aW9uLmNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjMpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8pIHtcbiAgICAgIGNvbnN0IHsgYWNjb3VudF9kZXBsb3ltZW50X2RhdGEsIC4uLnJlc3REZXRhaWxzIH0gPSBkZXRhaWxzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoaW52b2NhdGlvbi5jb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoaW52b2NhdGlvbi5jbGFzc0hhc2gpLFxuICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGludm9jYXRpb24uYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjMpLFxuICAgICAgICAuLi5yZXN0RGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJSUEMgYnVpbGRUcmFuc2FjdGlvbiByZWNlaXZlZCB1bmtub3duIFRyYW5zYWN0aW9uVHlwZVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3Jlc3BvbnNlUGFyc2VyL3JwYy50c1xudmFyIFJQQ1Jlc3BvbnNlUGFyc2VyID0gY2xhc3Mge1xuICBtYXJnaW47XG4gIGNvbnN0cnVjdG9yKG1hcmdpbikge1xuICAgIHRoaXMubWFyZ2luID0gbWFyZ2luO1xuICB9XG4gIGVzdGltYXRlZEZlZVRvTWF4RmVlKGVzdGltYXRlZEZlZSkge1xuICAgIHJldHVybiBlc3RpbWF0ZWRGZWVUb01heEZlZShlc3RpbWF0ZWRGZWUsIHRoaXMubWFyZ2luPy5tYXhGZWUpO1xuICB9XG4gIGVzdGltYXRlRmVlVG9Cb3VuZHMoZXN0aW1hdGUpIHtcbiAgICByZXR1cm4gZXN0aW1hdGVGZWVUb0JvdW5kcyhcbiAgICAgIGVzdGltYXRlLFxuICAgICAgdGhpcy5tYXJnaW4/LmwxQm91bmRNYXhBbW91bnQsXG4gICAgICB0aGlzLm1hcmdpbj8ubDFCb3VuZE1heFByaWNlUGVyVW5pdFxuICAgICk7XG4gIH1cbiAgcGFyc2VHZXRCbG9ja1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7IHN0YXR1czogXCJQRU5ESU5HXCIsIC4uLnJlcyB9O1xuICB9XG4gIHBhcnNlVHJhbnNhY3Rpb25SZWNlaXB0KHJlcykge1xuICAgIGlmIChcImFjdHVhbF9mZWVcIiBpbiByZXMgJiYgaXNTdHJpbmcocmVzLmFjdHVhbF9mZWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXMsXG4gICAgICAgIGFjdHVhbF9mZWU6IHtcbiAgICAgICAgICBhbW91bnQ6IHJlcy5hY3R1YWxfZmVlLFxuICAgICAgICAgIHVuaXQ6IFwiRlJJXCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3QgdmFsID0gcmVzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQodmFsLmdhc19jb25zdW1lZCksXG4gICAgICBnYXNfcHJpY2U6IHRvQmlnSW50KHZhbC5nYXNfcHJpY2UpLFxuICAgICAgdW5pdDogdmFsLnVuaXQsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWU6IHRoaXMuZXN0aW1hdGVkRmVlVG9NYXhGZWUodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIHJlc291cmNlQm91bmRzOiB0aGlzLmVzdGltYXRlRmVlVG9Cb3VuZHModmFsKSxcbiAgICAgIGRhdGFfZ2FzX2NvbnN1bWVkOiB2YWwuZGF0YV9nYXNfY29uc3VtZWQgPyB0b0JpZ0ludCh2YWwuZGF0YV9nYXNfY29uc3VtZWQpIDogMG4sXG4gICAgICBkYXRhX2dhc19wcmljZTogdmFsLmRhdGFfZ2FzX3ByaWNlID8gdG9CaWdJbnQodmFsLmRhdGFfZ2FzX3ByaWNlKSA6IDBuXG4gICAgfTtcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubWFwKCh2YWwpID0+ICh7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQodmFsLmdhc19jb25zdW1lZCksXG4gICAgICBnYXNfcHJpY2U6IHRvQmlnSW50KHZhbC5nYXNfcHJpY2UpLFxuICAgICAgdW5pdDogdmFsLnVuaXQsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWU6IHRoaXMuZXN0aW1hdGVkRmVlVG9NYXhGZWUodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIHJlc291cmNlQm91bmRzOiB0aGlzLmVzdGltYXRlRmVlVG9Cb3VuZHModmFsKSxcbiAgICAgIGRhdGFfZ2FzX2NvbnN1bWVkOiB2YWwuZGF0YV9nYXNfY29uc3VtZWQgPyB0b0JpZ0ludCh2YWwuZGF0YV9nYXNfY29uc3VtZWQpIDogMG4sXG4gICAgICBkYXRhX2dhc19wcmljZTogdmFsLmRhdGFfZ2FzX3ByaWNlID8gdG9CaWdJbnQodmFsLmRhdGFfZ2FzX3ByaWNlKSA6IDBuXG4gICAgfSkpO1xuICB9XG4gIHBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubWFwKChpdCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXQsXG4gICAgICAgIHN1Z2dlc3RlZE1heEZlZTogdGhpcy5lc3RpbWF0ZWRGZWVUb01heEZlZShpdC5mZWVfZXN0aW1hdGlvbi5vdmVyYWxsX2ZlZSksXG4gICAgICAgIHJlc291cmNlQm91bmRzOiB0aGlzLmVzdGltYXRlRmVlVG9Cb3VuZHMoaXQuZmVlX2VzdGltYXRpb24pXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXMsXG4gICAgICBhYmk6IGlzU3RyaW5nKHJlcy5hYmkpID8gSlNPTi5wYXJzZShyZXMuYWJpKSA6IHJlcy5hYmlcbiAgICB9O1xuICB9XG4gIHBhcnNlTDFHYXNQcmljZVJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubDFfZ2FzX3ByaWNlLnByaWNlX2luX3dlaTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3RyYW5zYWN0aW9uUmVjZWlwdC50c1xudmFyIFJlY2VpcHRUeCA9IGNsYXNzIF9SZWNlaXB0VHgge1xuICBzdGF0dXNSZWNlaXB0O1xuICB2YWx1ZTtcbiAgY29uc3RydWN0b3IocmVjZWlwdCkge1xuICAgIFt0aGlzLnN0YXR1c1JlY2VpcHQsIHRoaXMudmFsdWVdID0gX1JlY2VpcHRUeC5pc1N1Y2Nlc3MocmVjZWlwdCkgPyBbXCJzdWNjZXNzXCIsIHJlY2VpcHRdIDogX1JlY2VpcHRUeC5pc1JldmVydGVkKHJlY2VpcHQpID8gW1wicmV2ZXJ0ZWRcIiwgcmVjZWlwdF0gOiBfUmVjZWlwdFR4LmlzUmVqZWN0ZWQocmVjZWlwdCkgPyBbXCJyZWplY3RlZFwiLCByZWNlaXB0XSA6IFtcImVycm9yXCIsIG5ldyBFcnJvcihcIlVua25vd24gcmVzcG9uc2UgdHlwZVwiKV07XG4gICAgZm9yIChjb25zdCBba2V5XSBvZiBPYmplY3QuZW50cmllcyh0aGlzKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlY2VpcHQpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBtYXRjaChjYWxsYmFja3MpIHtcbiAgICBpZiAodGhpcy5zdGF0dXNSZWNlaXB0IGluIGNhbGxiYWNrcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrc1t0aGlzLnN0YXR1c1JlY2VpcHRdKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2tzLl8oKTtcbiAgfVxuICBpc1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzUmVjZWlwdCA9PT0gXCJzdWNjZXNzXCI7XG4gIH1cbiAgaXNSZXZlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXNSZWNlaXB0ID09PSBcInJldmVydGVkXCI7XG4gIH1cbiAgaXNSZWplY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXNSZWNlaXB0ID09PSBcInJlamVjdGVkXCI7XG4gIH1cbiAgaXNFcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXNSZWNlaXB0ID09PSBcImVycm9yXCI7XG4gIH1cbiAgc3RhdGljIGlzU3VjY2Vzcyh0cmFuc2FjdGlvblJlY2VpcHQpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25SZWNlaXB0LmV4ZWN1dGlvbl9zdGF0dXMgPT09IFwiU1VDQ0VFREVEXCIgLyogU1VDQ0VFREVEICovO1xuICB9XG4gIHN0YXRpYyBpc1JldmVydGVkKHRyYW5zYWN0aW9uUmVjZWlwdCkge1xuICAgIHJldHVybiB0cmFuc2FjdGlvblJlY2VpcHQuZXhlY3V0aW9uX3N0YXR1cyA9PT0gXCJSRVZFUlRFRFwiIC8qIFJFVkVSVEVEICovO1xuICB9XG4gIHN0YXRpYyBpc1JlamVjdGVkKHRyYW5zYWN0aW9uUmVjZWlwdCkge1xuICAgIHJldHVybiB0cmFuc2FjdGlvblJlY2VpcHQuc3RhdHVzID09PSBcIlJFSkVDVEVEXCIgLyogUkVKRUNURUQgKi87XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9ycGMudHNcbnZhciBScGNQcm92aWRlciA9IGNsYXNzIHtcbiAgcmVzcG9uc2VQYXJzZXI7XG4gIGNoYW5uZWw7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnNPclByb3ZpZGVyKSB7XG4gICAgaWYgKG9wdGlvbnNPclByb3ZpZGVyICYmIFwiY2hhbm5lbFwiIGluIG9wdGlvbnNPclByb3ZpZGVyKSB7XG4gICAgICB0aGlzLmNoYW5uZWwgPSBvcHRpb25zT3JQcm92aWRlci5jaGFubmVsO1xuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlciA9IFwicmVzcG9uc2VQYXJzZXJcIiBpbiBvcHRpb25zT3JQcm92aWRlciA/IG9wdGlvbnNPclByb3ZpZGVyLnJlc3BvbnNlUGFyc2VyIDogbmV3IFJQQ1Jlc3BvbnNlUGFyc2VyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IG5ldyBScGNDaGFubmVsMih7IC4uLm9wdGlvbnNPclByb3ZpZGVyLCB3YWl0TW9kZTogZmFsc2UgfSk7XG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyID0gbmV3IFJQQ1Jlc3BvbnNlUGFyc2VyKG9wdGlvbnNPclByb3ZpZGVyPy5mZWVNYXJnaW5QZXJjZW50YWdlKTtcbiAgICB9XG4gIH1cbiAgZmV0Y2gobWV0aG9kLCBwYXJhbXMsIGlkID0gMCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZmV0Y2gobWV0aG9kLCBwYXJhbXMsIGlkKTtcbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0Q2hhaW5JZCgpO1xuICB9XG4gIGFzeW5jIGdldFNwZWNWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0U3BlY1ZlcnNpb24oKTtcbiAgfVxuICBhc3luYyBnZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldE5vbmNlRm9yQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2soYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIpLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUdldEJsb2NrUmVzcG9uc2UpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGFjY2VwdGVkIGJsb2NrIGhhc2ggYW5kIG51bWJlclxuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBudW1iZXJcbiAgICogcmVkdW5kYW50IHVzZSBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7XG4gICAqIEByZXR1cm5zIE51bWJlciBvZiB0aGUgbGF0ZXN0IGJsb2NrXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrTnVtYmVyKCk7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrV2l0aFR4cyhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrV2l0aFR4cyhibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgZXhlY3V0aW9uIG9mIHRoZSBzY3JpcHQgdW50aWwgYSBzcGVjaWZpZWQgYmxvY2sgaXMgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtCbG9ja0lkZW50aWZpZXJ9IGJsb2NrSWRlbnRpZmllciBibG9jIG51bWJlciAoQmlnTnVtYmVyaXNrKSBvciAncGVuZGluZycgb3IgJ2xhdGVzdCcuXG4gICAqIFVzZSBvZiAnbGF0ZXN0XCIgb3Igb2YgYSBibG9jayBhbHJlYWR5IGNyZWF0ZWQgd2lsbCBnZW5lcmF0ZSBubyBwYXVzZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXRyeUludGVydmFsXSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJldHdlZW4gMiByZXF1ZXN0cyB0byB0aGUgbm9kZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGF3YWl0IG15UHJvdmlkZXIud2FpdEZvckJsb2NrKCk7XG4gICAqIC8vIHdhaXQgdGhlIGNyZWF0aW9uIG9mIHRoZSBwZW5kaW5nIGJsb2NrXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgd2FpdEZvckJsb2NrKGJsb2NrSWRlbnRpZmllciA9IFwicGVuZGluZ1wiLCByZXRyeUludGVydmFsID0gNWUzKSB7XG4gICAgaWYgKGJsb2NrSWRlbnRpZmllciA9PT0gXCJsYXRlc3RcIiAvKiBMQVRFU1QgKi8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY3VycmVudEJsb2NrID0gYXdhaXQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xuICAgIGNvbnN0IHRhcmdldEJsb2NrID0gYmxvY2tJZGVudGlmaWVyID09PSBcInBlbmRpbmdcIiAvKiBQRU5ESU5HICovID8gY3VycmVudEJsb2NrICsgMSA6IE51bWJlcih0b0hleChibG9ja0lkZW50aWZpZXIpKTtcbiAgICBpZiAodGFyZ2V0QmxvY2sgPD0gY3VycmVudEJsb2NrKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgcmV0cmllcyB9ID0gdGhpcy5jaGFubmVsO1xuICAgIGxldCByZXRyaWVzQ291bnQgPSByZXRyaWVzO1xuICAgIGxldCBpc1RhcmdldEJsb2NrID0gZmFsc2U7XG4gICAgd2hpbGUgKCFpc1RhcmdldEJsb2NrKSB7XG4gICAgICBjb25zdCBjdXJyQmxvY2sgPSBhd2FpdCB0aGlzLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICBpZiAoY3VyckJsb2NrID09PSB0YXJnZXRCbG9jaykge1xuICAgICAgICBpc1RhcmdldEJsb2NrID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgICByZXRyaWVzQ291bnQgLT0gMTtcbiAgICAgIGlmIChyZXRyaWVzQ291bnQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JCbG9jaygpIHRpbWVkLW91dCBhZnRlciAke3JldHJpZXN9IHRyaWVzLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBnZXRMMUdhc1ByaWNlKGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VMMUdhc1ByaWNlUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldEwxTWVzc2FnZUhhc2gobDJUeEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvbkJ5SGFzaChsMlR4SGFzaCk7XG4gICAgYXNzZXJ0KHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiTDFfSEFORExFUlwiLCBcIlRoaXMgTDIgdHJhbnNhY3Rpb24gaXMgbm90IGEgTDEgbWVzc2FnZS5cIik7XG4gICAgY29uc3QgeyBjYWxsZGF0YSwgY29udHJhY3RfYWRkcmVzcywgZW50cnlfcG9pbnRfc2VsZWN0b3IsIG5vbmNlIH0gPSB0cmFuc2FjdGlvbjtcbiAgICBjb25zdCBwYXJhbXMgPSBbXG4gICAgICBjYWxsZGF0YVswXSxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBub25jZSxcbiAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yLFxuICAgICAgY2FsbGRhdGEubGVuZ3RoIC0gMSxcbiAgICAgIC4uLmNhbGxkYXRhLnNsaWNlKDEpXG4gICAgXTtcbiAgICBjb25zdCBteUVuY29kZSA9IGFkZEhleFByZWZpeChcbiAgICAgIHBhcmFtcy5yZWR1Y2UoXG4gICAgICAgIChyZXMsIHBhcikgPT4gcmVzICsgcmVtb3ZlSGV4UHJlZml4KHRvSGV4KHBhcikpLnBhZFN0YXJ0KDY0LCBcIjBcIiksXG4gICAgICAgIFwiXCJcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBhZGRIZXhQcmVmaXgoYnl0ZXNUb0hleChrZWNjYWtfMjU2KGhleFRvQnl0ZXMobXlFbmNvZGUpKSkpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrV2l0aFJlY2VpcHRzKGJsb2NrSWRlbnRpZmllcikge1xuICAgIGlmICh0aGlzLmNoYW5uZWwgaW5zdGFuY2VvZiBycGNfMF82X2V4cG9ydHMuUnBjQ2hhbm5lbClcbiAgICAgIHRocm93IG5ldyBMaWJyYXJ5RXJyb3IoXCJVbnN1cHBvcnRlZCBtZXRob2QgZm9yIFJQQyB2ZXJzaW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tXaXRoUmVjZWlwdHMoYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBnZXRTdGF0ZVVwZGF0ZSA9IHRoaXMuZ2V0QmxvY2tTdGF0ZVVwZGF0ZTtcbiAgYXN5bmMgZ2V0QmxvY2tTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrU3RhdGVVcGRhdGUoYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcyhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0cmFuc2FjdGlvbnMgZnJvbSBwZW5kaW5nIGJsb2NrXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQgdXNlIGdldEJsb2NrKEJsb2NrVGFnLlBFTkRJTkcpOyAod2lsbCBiZSByZW1vdmVkIGluIG5leHQgbWlub3IgdmVyc2lvbilcbiAgICogVXRpbGl0eSBtZXRob2QsIHNhbWUgcmVzdWx0IGNhbiBiZSBhY2hpZXZlZCB1c2luZyBnZXRCbG9ja1dpdGhUeEhhc2hlcyhCbG9ja1RhZy5wZW5kaW5nKTtcbiAgICovXG4gIGFzeW5jIGdldFBlbmRpbmdUcmFuc2FjdGlvbnMoKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IGF3YWl0IHRoaXMuZ2V0QmxvY2tXaXRoVHhIYXNoZXMoXCJwZW5kaW5nXCIgLyogUEVORElORyAqLykudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRCbG9ja1Jlc3BvbnNlXG4gICAgKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zLm1hcCgoaXQpID0+IHRoaXMuZ2V0VHJhbnNhY3Rpb25CeUhhc2goaXQpKSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uQnlIYXNoKHR4SGFzaCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0VHJhbnNhY3Rpb25CeUhhc2godHhIYXNoKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4KGJsb2NrSWRlbnRpZmllciwgaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgoYmxvY2tJZGVudGlmaWVyLCBpbmRleCk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCkge1xuICAgIGNvbnN0IHR4UmVjZWlwdFdvSGVscGVyID0gYXdhaXQgdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgIGNvbnN0IHR4UmVjZWlwdFdvSGVscGVyTW9kaWZpZWQgPSB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlVHJhbnNhY3Rpb25SZWNlaXB0KHR4UmVjZWlwdFdvSGVscGVyKTtcbiAgICByZXR1cm4gbmV3IFJlY2VpcHRUeCh0eFJlY2VpcHRXb0hlbHBlck1vZGlmaWVkKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvblRyYWNlKHR4SGFzaCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXR1cyBvZiBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9ucyBBY2NvdW50SW52b2NhdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMgYmxvY2tJZGVudGlmaWVyIGFuZCBmbGFncyB0byBza2lwIHZhbGlkYXRpb24gYW5kIGZlZSBjaGFyZ2U8YnIvPlxuICAgKiAtIGJsb2NrSWRlbnRpZmllcjxici8+XG4gICAqIC0gc2tpcFZhbGlkYXRlIChkZWZhdWx0IGZhbHNlKTxici8+XG4gICAqIC0gc2tpcEZlZUNoYXJnZSAoZGVmYXVsdCB0cnVlKTxici8+XG4gICAqL1xuICBhc3luYyBnZXRTaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5zaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCBvcHRpb25zKS50aGVuKChyKSA9PiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKHIpKTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24odHhIYXNoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVjZWlwdFdvSGVscGVyID0gYXdhaXQgdGhpcy5jaGFubmVsLndhaXRGb3JUcmFuc2FjdGlvbihcbiAgICAgIHR4SGFzaCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiBuZXcgUmVjZWlwdFR4KHJlY2VpcHRXb0hlbHBlcik7XG4gIH1cbiAgYXN5bmMgZ2V0U3RvcmFnZUF0KGNvbnRyYWN0QWRkcmVzcywga2V5LCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0Q2xhc3NIYXNoQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQnlIYXNoKGNsYXNzSGFzaCkge1xuICAgIHJldHVybiB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q29udHJhY3RWZXJzaW9uKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCB7XG4gICAgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5jaGFubmVsLmJsb2NrSWRlbnRpZmllcixcbiAgICBjb21waWxlciA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgbGV0IGNvbnRyYWN0Q2xhc3M7XG4gICAgaWYgKGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgY29udHJhY3RDbGFzcyA9IGF3YWl0IHRoaXMuZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmIChjbGFzc0hhc2gpIHtcbiAgICAgIGNvbnRyYWN0Q2xhc3MgPSBhd2FpdCB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJnZXRDb250cmFjdFZlcnNpb24gcmVxdWlyZSBjb250cmFjdEFkZHJlc3Mgb3IgY2xhc3NIYXNoXCIpO1xuICAgIH1cbiAgICBpZiAoaXNTaWVycmEoY29udHJhY3RDbGFzcykpIHtcbiAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICBjb25zdCBhYmlUZXN0ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGNvbnRyYWN0Q2xhc3MuYWJpKTtcbiAgICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogYWJpVGVzdC5jb21waWxlciB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogdm9pZCAwIH07XG4gICAgfVxuICAgIHJldHVybiB7IGNhaXJvOiBcIjBcIiwgY29tcGlsZXI6IFwiMFwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBnZXQqdHlwZSpFc3RpbWF0ZUZlZSAod2lsbCBiZSByZWZhY3RvcmVkIGJhc2VkIG9uIHR5cGUgYWZ0ZXIgc2VxdWVuY2VyIGRlcHJlY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKTtcbiAgfVxuICBhc3luYyBnZXRJbnZva2VFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEVzdGltYXRlRmVlKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8sXG4gICAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uRGV0YWlsc1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgeyBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9XG4gICAgKS50aGVuKChyKSA9PiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZShyKSk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVjbGFyZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRFc3RpbWF0ZUZlZShcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgICAuLi5kZXRhaWxzXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH1cbiAgICApLnRoZW4oKHIpID0+IHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKHIpKTtcbiAgfVxuICBhc3luYyBnZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEVzdGltYXRlRmVlKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgeyBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9XG4gICAgKS50aGVuKChyKSA9PiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZShyKSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRFc3RpbWF0ZUZlZShpbnZvY2F0aW9ucywgb3B0aW9ucykudGhlbigocikgPT4gdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKHIpKTtcbiAgfVxuICBhc3luYyBpbnZva2VGdW5jdGlvbihmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmludm9rZShmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVDb250cmFjdCh0cmFuc2FjdGlvbiwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZGVjbGFyZSh0cmFuc2FjdGlvbiwgZGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZGVwbG95QWNjb3VudENvbnRyYWN0KHRyYW5zYWN0aW9uLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5kZXBsb3lBY2NvdW50KFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBkZXRhaWxzXG4gICAgKTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3QoY2FsbCwgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5jYWxsQ29udHJhY3QoY2FsbCwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICAvKipcbiAgICogTkVXOiBFc3RpbWF0ZSB0aGUgZmVlIGZvciBhIG1lc3NhZ2UgZnJvbSBMMVxuICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIEZyb20gTDFcbiAgICovXG4gIGFzeW5jIGVzdGltYXRlTWVzc2FnZUZlZShtZXNzYWdlLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmVzdGltYXRlTWVzc2FnZUZlZShtZXNzYWdlLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBhYm91dCB0aGUgc3luYyBzdGF0dXMsIG9yIGZhbHNlIGlmIHRoZSBub2RlIGlzIG5vdCBzeW5jaGluZ1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCB0aGUgc3RhdHMgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0U3luY2luZ1N0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0U3luY2luZ1N0YXRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGV2ZW50cyBtYXRjaGluZyB0aGUgZ2l2ZW4gZmlsdGVyXG4gICAqIEByZXR1cm5zIGV2ZW50cyBhbmQgdGhlIHBhZ2luYXRpb24gb2YgdGhlIGV2ZW50c1xuICAgKi9cbiAgYXN5bmMgZ2V0RXZlbnRzKGV2ZW50RmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRFdmVudHMoZXZlbnRGaWx0ZXIpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvZXh0ZW5zaW9ucy9kZWZhdWx0LnRzXG5pbXBvcnQgeyBNaXhpbiB9IGZyb20gXCJ0cy1taXhlclwiO1xuXG4vLyBzcmMvdXRpbHMvc3RhcmtuZXRJZC50c1xudmFyIHN0YXJrbmV0SWRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3RhcmtuZXRJZF9leHBvcnRzLCB7XG4gIFN0YXJrbmV0SWRDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZENvbnRyYWN0LFxuICBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QsXG4gIFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0LFxuICBTdGFya25ldElkUGZwQ29udHJhY3Q6ICgpID0+IFN0YXJrbmV0SWRQZnBDb250cmFjdCxcbiAgU3RhcmtuZXRJZFBvcENvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkUG9wQ29udHJhY3QsXG4gIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdCxcbiAgZHluYW1pY0NhbGxEYXRhOiAoKSA9PiBkeW5hbWljQ2FsbERhdGEsXG4gIGR5bmFtaWNGZWx0OiAoKSA9PiBkeW5hbWljRmVsdCxcbiAgZXhlY3V0aW9uOiAoKSA9PiBleGVjdXRpb24sXG4gIGdldFN0YXJrbmV0SWRDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZENvbnRyYWN0LFxuICBnZXRTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QsXG4gIGdldFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0LFxuICBnZXRTdGFya25ldElkUGZwQ29udHJhY3Q6ICgpID0+IGdldFN0YXJrbmV0SWRQZnBDb250cmFjdCxcbiAgZ2V0U3RhcmtuZXRJZFBvcENvbnRyYWN0OiAoKSA9PiBnZXRTdGFya25ldElkUG9wQ29udHJhY3QsXG4gIGdldFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0OiAoKSA9PiBnZXRTdGFya25ldElkVmVyaWZpZXJDb250cmFjdCxcbiAgdXNlRGVjb2RlZDogKCkgPT4gdXNlRGVjb2RlZCxcbiAgdXNlRW5jb2RlZDogKCkgPT4gdXNlRW5jb2RlZFxufSk7XG52YXIgYmFzaWNBbHBoYWJldCA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LVwiO1xudmFyIGJhc2ljU2l6ZVBsdXNPbmUgPSBCaWdJbnQoYmFzaWNBbHBoYWJldC5sZW5ndGggKyAxKTtcbnZhciBiaWdBbHBoYWJldCA9IFwiXFx1OEZEOVxcdTY3NjVcIjtcbnZhciBiYXNpY0FscGhhYmV0U2l6ZSA9IEJpZ0ludChiYXNpY0FscGhhYmV0Lmxlbmd0aCk7XG52YXIgYmlnQWxwaGFiZXRTaXplID0gQmlnSW50KGJpZ0FscGhhYmV0Lmxlbmd0aCk7XG52YXIgYmlnQWxwaGFiZXRTaXplUGx1c09uZSA9IEJpZ0ludChiaWdBbHBoYWJldC5sZW5ndGggKyAxKTtcbmZ1bmN0aW9uIGV4dHJhY3RTdGFycyhzdHIpIHtcbiAgbGV0IGsgPSAwO1xuICB3aGlsZSAoc3RyLmVuZHNXaXRoKGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdKSkge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgIGsgKz0gMTtcbiAgfVxuICByZXR1cm4gW3N0ciwga107XG59XG5mdW5jdGlvbiB1c2VEZWNvZGVkKGVuY29kZWQpIHtcbiAgbGV0IGRlY29kZWQgPSBcIlwiO1xuICBlbmNvZGVkLmZvckVhY2goKHN1YmRvbWFpbikgPT4ge1xuICAgIHdoaWxlIChzdWJkb21haW4gIT09IFpFUk8pIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdWJkb21haW4gJSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgc3ViZG9tYWluIC89IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICBpZiAoY29kZSA9PT0gQmlnSW50KGJhc2ljQWxwaGFiZXQubGVuZ3RoKSkge1xuICAgICAgICBjb25zdCBuZXh0U3ViZG9tYWluID0gc3ViZG9tYWluIC8gYmlnQWxwaGFiZXRTaXplUGx1c09uZTtcbiAgICAgICAgaWYgKG5leHRTdWJkb21haW4gPT09IFpFUk8pIHtcbiAgICAgICAgICBjb25zdCBjb2RlMiA9IHN1YmRvbWFpbiAlIGJpZ0FscGhhYmV0U2l6ZVBsdXNPbmU7XG4gICAgICAgICAgc3ViZG9tYWluID0gbmV4dFN1YmRvbWFpbjtcbiAgICAgICAgICBpZiAoY29kZTIgPT09IFpFUk8pXG4gICAgICAgICAgICBkZWNvZGVkICs9IGJhc2ljQWxwaGFiZXRbMF07XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVjb2RlZCArPSBiaWdBbHBoYWJldFtOdW1iZXIoY29kZTIpIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY29kZTIgPSBzdWJkb21haW4gJSBiaWdBbHBoYWJldFNpemU7XG4gICAgICAgICAgZGVjb2RlZCArPSBiaWdBbHBoYWJldFtOdW1iZXIoY29kZTIpXTtcbiAgICAgICAgICBzdWJkb21haW4gLz0gYmlnQWxwaGFiZXRTaXplO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgZGVjb2RlZCArPSBiYXNpY0FscGhhYmV0W051bWJlcihjb2RlKV07XG4gICAgfVxuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQpO1xuICAgIGlmIChrKVxuICAgICAgZGVjb2RlZCA9IHN0ciArIChrICUgMiA9PT0gMCA/IGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdChrIC8gMiAtIDEpICsgYmlnQWxwaGFiZXRbMF0gKyBiYXNpY0FscGhhYmV0WzFdIDogYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KChrIC0gMSkgLyAyICsgMSkpO1xuICAgIGRlY29kZWQgKz0gXCIuXCI7XG4gIH0pO1xuICBpZiAoIWRlY29kZWQpIHtcbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfVxuICByZXR1cm4gZGVjb2RlZC5jb25jYXQoXCJzdGFya1wiKTtcbn1cbmZ1bmN0aW9uIHVzZUVuY29kZWQoZGVjb2RlZCkge1xuICBsZXQgZW5jb2RlZCA9IEJpZ0ludCgwKTtcbiAgbGV0IG11bHRpcGxpZXIgPSBCaWdJbnQoMSk7XG4gIGlmIChkZWNvZGVkLmVuZHNXaXRoKGJpZ0FscGhhYmV0WzBdICsgYmFzaWNBbHBoYWJldFsxXSkpIHtcbiAgICBjb25zdCBbc3RyLCBrXSA9IGV4dHJhY3RTdGFycyhkZWNvZGVkLnN1YnN0cmluZygwLCBkZWNvZGVkLmxlbmd0aCAtIDIpKTtcbiAgICBkZWNvZGVkID0gc3RyICsgYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KDIgKiAoayArIDEpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbc3RyLCBrXSA9IGV4dHJhY3RTdGFycyhkZWNvZGVkKTtcbiAgICBpZiAoaylcbiAgICAgIGRlY29kZWQgPSBzdHIgKyBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoMSArIDIgKiAoayAtIDEpKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBjaGFyID0gZGVjb2RlZFtpXTtcbiAgICBjb25zdCBpbmRleCA9IGJhc2ljQWxwaGFiZXQuaW5kZXhPZihjaGFyKTtcbiAgICBjb25zdCBibkluZGV4ID0gQmlnSW50KGJhc2ljQWxwaGFiZXQuaW5kZXhPZihjaGFyKSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGkgPT09IGRlY29kZWQubGVuZ3RoIC0gMSAmJiBkZWNvZGVkW2ldID09PSBiYXNpY0FscGhhYmV0WzBdKSB7XG4gICAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIGJhc2ljQWxwaGFiZXRTaXplO1xuICAgICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIGJuSW5kZXg7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJpZ0FscGhhYmV0LmluZGV4T2YoY2hhcikgIT09IC0xKSB7XG4gICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBiYXNpY0FscGhhYmV0U2l6ZTtcbiAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIGNvbnN0IG5ld2lkID0gKGkgPT09IGRlY29kZWQubGVuZ3RoIC0gMSA/IDEgOiAwKSArIGJpZ0FscGhhYmV0LmluZGV4T2YoY2hhcik7XG4gICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBCaWdJbnQobmV3aWQpO1xuICAgICAgbXVsdGlwbGllciAqPSBiaWdBbHBoYWJldFNpemU7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxudmFyIFN0YXJrbmV0SWRDb250cmFjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXJrbmV0SWRDb250cmFjdDIpID0+IHtcbiAgU3RhcmtuZXRJZENvbnRyYWN0MltcIk1BSU5ORVRcIl0gPSBcIjB4NmFjNTk3ZjgxMTZmODg2ZmExYzk3YTIzZmE0ZTA4Mjk5OTc1ZWNhZjZiNTk4ODczY2E2NzkyYjliYmZiNjc4XCI7XG4gIFN0YXJrbmV0SWRDb250cmFjdDJbXCJURVNUTkVUX1NFUE9MSUFcIl0gPSBcIjB4MTU0YmMyZTFhZjkyNjBiOWU2NmFmMGU5YzQ2ZmM3NTdmZjg5M2IzZmY2YTg1NzE4YTgxMGJhZjE0NzRcIjtcbiAgcmV0dXJuIFN0YXJrbmV0SWRDb250cmFjdDI7XG59KShTdGFya25ldElkQ29udHJhY3QgfHwge30pO1xuZnVuY3Rpb24gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFwiMHg2YWM1OTdmODExNmY4ODZmYTFjOTdhMjNmYTRlMDgyOTk5NzVlY2FmNmI1OTg4NzNjYTY3OTJiOWJiZmI2NzhcIiAvKiBNQUlOTkVUICovO1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBcIjB4MTU0YmMyZTFhZjkyNjBiOWU2NmFmMGU5YzQ2ZmM3NTdmZjg5M2IzZmY2YTg1NzE4YTgxMGJhZjE0NzRcIiAvKiBURVNUTkVUX1NFUE9MSUEgKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXJrbmV0LmlkIGlzIG5vdCB5ZXQgZGVwbG95ZWQgb24gdGhpcyBuZXR3b3JrXCIpO1xuICB9XG59XG52YXIgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDIpID0+IHtcbiAgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyW1wiTUFJTk5FVFwiXSA9IFwiMHgwNWRiZGVkYzIwM2U5Mjc0OWUyZTc0NmUyZDQwYTc2OGQ5NjZiZDI0M2RmMDRhNmI3MTJlMjIyYmMwNDBhOWFmXCI7XG4gIFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0MltcIlRFU1RORVRfU0VQT0xJQVwiXSA9IFwiMHgzNjk3NjYwYTA5ODFkNzM0NzgwNzMxOTQ5ZWNiMmI0YTM4ZDZhNThmYzQxNjI5ZWQ2MTFlOGRlZmRhXCI7XG4gIHJldHVybiBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDI7XG59KShTdGFya25ldElkSWRlbnRpdHlDb250cmFjdCB8fCB7fSk7XG5mdW5jdGlvbiBnZXRTdGFya25ldElkSWRlbnRpdHlDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBcIjB4MDVkYmRlZGMyMDNlOTI3NDllMmU3NDZlMmQ0MGE3NjhkOTY2YmQyNDNkZjA0YTZiNzEyZTIyMmJjMDQwYTlhZlwiIC8qIE1BSU5ORVQgKi87XG4gICAgY2FzZSBcIjB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDFcIiAvKiBTTl9TRVBPTElBICovOlxuICAgICAgcmV0dXJuIFwiMHgzNjk3NjYwYTA5ODFkNzM0NzgwNzMxOTQ5ZWNiMmI0YTM4ZDZhNThmYzQxNjI5ZWQ2MTFlOGRlZmRhXCIgLyogVEVTVE5FVF9TRVBPTElBICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFya25ldC5pZCB2ZXJpZmllciBjb250cmFjdCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiKTtcbiAgfVxufVxudmFyIFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdCA9IFwiMHgwMzRmZmI4ZjQ0NTJkZjdhNjEzYTAyMTA4MjRkNjQxNGRiYWRjZGRjZTZjNmUxOWJmNGRkYzllMjJjZTVmOTcwXCI7XG5mdW5jdGlvbiBnZXRTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QoY2hhaW5JZCkge1xuICBzd2l0Y2ggKGNoYWluSWQpIHtcbiAgICBjYXNlIFwiMHg1MzRlNWY0ZDQxNDk0ZVwiIC8qIFNOX01BSU4gKi86XG4gICAgICByZXR1cm4gU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0O1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXJrbmV0LmlkIG11bHRpY2FsbCBjb250cmFjdCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiKTtcbiAgfVxufVxudmFyIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0ID0gLyogQF9fUFVSRV9fICovICgoU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QyKSA9PiB7XG4gIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0MltcIk1BSU5ORVRcIl0gPSBcIjB4MDdkMTRkZmQ4ZWU5NWI0MWZjZTE3OTE3MGQ4OGJhMWYwZDVhNTEyZTEzYWViMjMyZjE5Y2ZlZWMwYTg4ZjhiZlwiO1xuICBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDJbXCJURVNUTkVUX1NFUE9MSUFcIl0gPSBcIjB4NjBCOTRmRURlNTI1ZjgxNUFFNUU4Mzc3QTQ2M2UxMjFDNzg3Y0NDZjNhMzYzNThBYTlCMThjMTJjNEQ1NjZcIjtcbiAgcmV0dXJuIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0Mjtcbn0pKFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0IHx8IHt9KTtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFwiMHgwN2QxNGRmZDhlZTk1YjQxZmNlMTc5MTcwZDg4YmExZjBkNWE1MTJlMTNhZWIyMzJmMTljZmVlYzBhODhmOGJmXCIgLyogTUFJTk5FVCAqLztcbiAgICBjYXNlIFwiMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MVwiIC8qIFNOX1NFUE9MSUEgKi86XG4gICAgICByZXR1cm4gXCIweDYwQjk0ZkVEZTUyNWY4MTVBRTVFODM3N0E0NjNlMTIxQzc4N2NDQ2YzYTM2MzU4QWE5QjE4YzEyYzRENTY2XCIgLyogVEVTVE5FVF9TRVBPTElBICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFya25ldC5pZCB2ZXJpZmllciBjb250cmFjdCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiKTtcbiAgfVxufVxudmFyIFN0YXJrbmV0SWRQZnBDb250cmFjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXJrbmV0SWRQZnBDb250cmFjdDIpID0+IHtcbiAgU3RhcmtuZXRJZFBmcENvbnRyYWN0MltcIk1BSU5ORVRcIl0gPSBcIjB4MDcwYWFhMjBlYzRhNDZkYTU3YzkzMmQ5ZmQ4OWNhNWU2YmI5Y2EzMTg4ZDNkZjM2MWEzMjMwNmFmZjdkNTljN1wiO1xuICBTdGFya25ldElkUGZwQ29udHJhY3QyW1wiVEVTVE5FVF9TRVBPTElBXCJdID0gXCIweDllN2JkYjhkYWJkMDJlYThjZmMyM2IxZDFjNTI3OGU0NjQ5MGYxOTNmODc1MTZlZDVmZjJkZmVjMDJcIjtcbiAgcmV0dXJuIFN0YXJrbmV0SWRQZnBDb250cmFjdDI7XG59KShTdGFya25ldElkUGZwQ29udHJhY3QgfHwge30pO1xuZnVuY3Rpb24gZ2V0U3RhcmtuZXRJZFBmcENvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFwiMHgwNzBhYWEyMGVjNGE0NmRhNTdjOTMyZDlmZDg5Y2E1ZTZiYjljYTMxODhkM2RmMzYxYTMyMzA2YWZmN2Q1OWM3XCIgLyogTUFJTk5FVCAqLztcbiAgICBjYXNlIFwiMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MVwiIC8qIFNOX1NFUE9MSUEgKi86XG4gICAgICByZXR1cm4gXCIweDllN2JkYjhkYWJkMDJlYThjZmMyM2IxZDFjNTI3OGU0NjQ5MGYxOTNmODc1MTZlZDVmZjJkZmVjMDJcIiAvKiBURVNUTkVUX1NFUE9MSUEgKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJTdGFya25ldC5pZCBwcm9maWxlIHBpY3R1cmUgdmVyaWZpZXIgY29udHJhY3QgaXMgbm90IHlldCBkZXBsb3llZCBvbiB0aGlzIG5ldHdvcmtcIlxuICAgICAgKTtcbiAgfVxufVxudmFyIFN0YXJrbmV0SWRQb3BDb250cmFjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXJrbmV0SWRQb3BDb250cmFjdDIpID0+IHtcbiAgU3RhcmtuZXRJZFBvcENvbnRyYWN0MltcIk1BSU5ORVRcIl0gPSBcIjB4MDI5M2ViMmJhOTg2MmY3NjJiZDMwMzY1ODZkNTc1NWE3ODJiZDIyZTZmNTAyODMyMGYxZDA0MDVmZDQ3YmZmNFwiO1xuICBTdGFya25ldElkUG9wQ29udHJhY3QyW1wiVEVTVE5FVF9TRVBPTElBXCJdID0gXCIweDE1YWU4OGFlMDU0Y2FhNzQwOTBiODkwMjVjMTU5NTY4M2YxMmVkZjdhNGVkMmFkMDI3NGRlM2UxZDRhXCI7XG4gIHJldHVybiBTdGFya25ldElkUG9wQ29udHJhY3QyO1xufSkoU3RhcmtuZXRJZFBvcENvbnRyYWN0IHx8IHt9KTtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0SWRQb3BDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBcIjB4MDI5M2ViMmJhOTg2MmY3NjJiZDMwMzY1ODZkNTc1NWE3ODJiZDIyZTZmNTAyODMyMGYxZDA0MDVmZDQ3YmZmNFwiIC8qIE1BSU5ORVQgKi87XG4gICAgY2FzZSBcIjB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDFcIiAvKiBTTl9TRVBPTElBICovOlxuICAgICAgcmV0dXJuIFwiMHgxNWFlODhhZTA1NGNhYTc0MDkwYjg5MDI1YzE1OTU2ODNmMTJlZGY3YTRlZDJhZDAyNzRkZTNlMWQ0YVwiIC8qIFRFU1RORVRfU0VQT0xJQSAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlN0YXJrbmV0LmlkIHByb29mIG9mIHBlcnNvbmhvb2QgdmVyaWZpZXIgY29udHJhY3QgaXMgbm90IHlldCBkZXBsb3llZCBvbiB0aGlzIG5ldHdvcmtcIlxuICAgICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gZXhlY3V0aW9uKHN0YXRpY0V4LCBpZkVxdWFsID0gdm9pZCAwLCBpZk5vdEVxdWFsID0gdm9pZCAwKSB7XG4gIHJldHVybiBuZXcgQ2Fpcm9DdXN0b21FbnVtKHtcbiAgICBTdGF0aWM6IHN0YXRpY0V4LFxuICAgIElmRXF1YWw6IGlmRXF1YWwgPyB0dXBsZShpZkVxdWFsWzBdLCBpZkVxdWFsWzFdLCBpZkVxdWFsWzJdKSA6IHZvaWQgMCxcbiAgICBJZk5vdEVxdWFsOiBpZk5vdEVxdWFsID8gdHVwbGUoaWZOb3RFcXVhbFswXSwgaWZOb3RFcXVhbFsxXSwgaWZOb3RFcXVhbFsyXSkgOiB2b2lkIDBcbiAgfSk7XG59XG5mdW5jdGlvbiBkeW5hbWljRmVsdChoYXJkY29kZWQsIHJlZmVyZW5jZSA9IHZvaWQgMCkge1xuICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bSh7XG4gICAgSGFyZGNvZGVkOiBoYXJkY29kZWQsXG4gICAgUmVmZXJlbmNlOiByZWZlcmVuY2UgPyB0dXBsZShyZWZlcmVuY2VbMF0sIHJlZmVyZW5jZVsxXSkgOiB2b2lkIDBcbiAgfSk7XG59XG5mdW5jdGlvbiBkeW5hbWljQ2FsbERhdGEoaGFyZGNvZGVkLCByZWZlcmVuY2UgPSB2b2lkIDAsIGFycmF5UmVmZXJlbmNlID0gdm9pZCAwKSB7XG4gIHJldHVybiBuZXcgQ2Fpcm9DdXN0b21FbnVtKHtcbiAgICBIYXJkY29kZWQ6IGhhcmRjb2RlZCxcbiAgICBSZWZlcmVuY2U6IHJlZmVyZW5jZSA/IHR1cGxlKHJlZmVyZW5jZVswXSwgcmVmZXJlbmNlWzFdKSA6IHZvaWQgMCxcbiAgICBBcnJheVJlZmVyZW5jZTogYXJyYXlSZWZlcmVuY2UgPyB0dXBsZShhcnJheVJlZmVyZW5jZVswXSwgYXJyYXlSZWZlcmVuY2VbMV0pIDogdm9pZCAwXG4gIH0pO1xufVxuXG4vLyBzcmMvcHJvdmlkZXIvZXh0ZW5zaW9ucy9zdGFya25ldElkLnRzXG52YXIgU3RhcmtuZXRJZCA9IGNsYXNzIF9TdGFya25ldElkIHtcbiAgYXN5bmMgZ2V0U3RhcmtOYW1lKGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gX1N0YXJrbmV0SWQuZ2V0U3RhcmtOYW1lKFxuICAgICAgLy8gQWZ0ZXIgTWl4aW4sIHRoaXMgaXMgUHJvdmlkZXJJbnRlcmZhY2VcbiAgICAgIHRoaXMsXG4gICAgICBhZGRyZXNzLFxuICAgICAgU3RhcmtuZXRJZENvbnRyYWN0MlxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUobmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBfU3RhcmtuZXRJZC5nZXRBZGRyZXNzRnJvbVN0YXJrTmFtZShcbiAgICAgIC8vIEFmdGVyIE1peGluLCB0aGlzIGlzIFByb3ZpZGVySW50ZXJmYWNlXG4gICAgICB0aGlzLFxuICAgICAgbmFtZSxcbiAgICAgIFN0YXJrbmV0SWRDb250cmFjdDJcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldFN0YXJrUHJvZmlsZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyLCBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDIsIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0MiwgU3RhcmtuZXRJZFBmcENvbnRyYWN0MiwgU3RhcmtuZXRJZFBvcENvbnRyYWN0MiwgU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0Mikge1xuICAgIHJldHVybiBfU3RhcmtuZXRJZC5nZXRTdGFya1Byb2ZpbGUoXG4gICAgICAvLyBBZnRlciBNaXhpbiwgdGhpcyBpcyBQcm92aWRlckludGVyZmFjZVxuICAgICAgdGhpcyxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBTdGFya25ldElkQ29udHJhY3QyLFxuICAgICAgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyLFxuICAgICAgU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QyLFxuICAgICAgU3RhcmtuZXRJZFBmcENvbnRyYWN0MixcbiAgICAgIFN0YXJrbmV0SWRQb3BDb250cmFjdDIsXG4gICAgICBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QyXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZ2V0U3RhcmtOYW1lKHByb3ZpZGVyLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IFN0YXJrbmV0SWRDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZXhEb21haW4gPSBhd2FpdCBwcm92aWRlci5jYWxsQ29udHJhY3Qoe1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0LFxuICAgICAgICBlbnRyeXBvaW50OiBcImFkZHJlc3NfdG9fZG9tYWluXCIsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIGhpbnQ6IFtdXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlY2ltYWxEb21haW4gPSBoZXhEb21haW4ubWFwKChlbGVtZW50KSA9PiBCaWdJbnQoZWxlbWVudCkpLnNsaWNlKDEpO1xuICAgICAgY29uc3Qgc3RyaW5nRG9tYWluID0gdXNlRGVjb2RlZChkZWNpbWFsRG9tYWluKTtcbiAgICAgIGlmICghc3RyaW5nRG9tYWluKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiU3RhcmtuYW1lIG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmdEb21haW47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UgPT09IFwiU3RhcmtuYW1lIG5vdCBmb3VuZFwiKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgc3RhcmsgbmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKHByb3ZpZGVyLCBuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IFN0YXJrbmV0SWRDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmNvZGVkRG9tYWluID0gbmFtZS5yZXBsYWNlKFwiLnN0YXJrXCIsIFwiXCIpLnNwbGl0KFwiLlwiKS5tYXAoKHBhcnQpID0+IHVzZUVuY29kZWQocGFydCkudG9TdHJpbmcoMTApKTtcbiAgICAgIGNvbnN0IGFkZHJlc3NEYXRhID0gYXdhaXQgcHJvdmlkZXIuY2FsbENvbnRyYWN0KHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBjb250cmFjdCxcbiAgICAgICAgZW50cnlwb2ludDogXCJkb21haW5fdG9fYWRkcmVzc1wiLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7IGRvbWFpbjogZW5jb2RlZERvbWFpbiwgaGludDogW10gfSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFkZHJlc3NEYXRhWzBdO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGFkZHJlc3MgZnJvbSBzdGFyayBuYW1lXCIpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgZ2V0U3RhcmtQcm9maWxlKHByb3ZpZGVyLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyLCBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDIsIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0MiwgU3RhcmtuZXRJZFBmcENvbnRyYWN0MiwgU3RhcmtuZXRJZFBvcENvbnRyYWN0MiwgU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0Mikge1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCBwcm92aWRlci5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBTdGFya25ldElkQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKTtcbiAgICBjb25zdCBpZGVudGl0eUNvbnRyYWN0ID0gU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0KGNoYWluSWQpO1xuICAgIGNvbnN0IHZlcmlmaWVyQ29udHJhY3QgPSBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QoY2hhaW5JZCk7XG4gICAgY29uc3QgcGZwQ29udHJhY3QgPSBTdGFya25ldElkUGZwQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRQZnBDb250cmFjdChjaGFpbklkKTtcbiAgICBjb25zdCBwb3BDb250cmFjdCA9IFN0YXJrbmV0SWRQb3BDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZFBvcENvbnRyYWN0KGNoYWluSWQpO1xuICAgIGNvbnN0IG11bHRpY2FsbEFkZHJlc3MgPSBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdChjaGFpbklkKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FsbHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih7fSksXG4gICAgICAgICAgdG86IGR5bmFtaWNDYWxsRGF0YShjb250cmFjdCksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNDYWxsRGF0YShnZXRTZWxlY3RvckZyb21OYW1lKFwiYWRkcmVzc190b19kb21haW5cIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbZHluYW1pY0NhbGxEYXRhKGFkZHJlc3MpLCBkeW5hbWljQ2FsbERhdGEoXCIwXCIpXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgIHRvOiBkeW5hbWljRmVsdChjb250cmFjdCksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJkb21haW5fdG9faWRcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgdm9pZCAwLCBbMCwgMF0pXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgIHRvOiBkeW5hbWljRmVsdChpZGVudGl0eUNvbnRyYWN0KSxcbiAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0ZlbHQoZ2V0U2VsZWN0b3JGcm9tTmFtZShcImdldF92ZXJpZmllcl9kYXRhXCIpKSxcbiAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzEsIDBdKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShlbmNvZGVTaG9ydFN0cmluZyhcInR3aXR0ZXJcIikpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZlcmlmaWVyQ29udHJhY3QpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoaWRlbnRpdHlDb250cmFjdCksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJnZXRfdmVyaWZpZXJfZGF0YVwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFsxLCAwXSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoZW5jb2RlU2hvcnRTdHJpbmcoXCJnaXRodWJcIikpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZlcmlmaWVyQ29udHJhY3QpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoaWRlbnRpdHlDb250cmFjdCksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJnZXRfdmVyaWZpZXJfZGF0YVwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFsxLCAwXSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoZW5jb2RlU2hvcnRTdHJpbmcoXCJkaXNjb3JkXCIpKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2ZXJpZmllckNvbnRyYWN0KSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShcIjBcIilcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih7fSksXG4gICAgICAgICAgdG86IGR5bmFtaWNGZWx0KGlkZW50aXR5Q29udHJhY3QpLFxuICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodm9pZCAwLCBbMSwgMF0pLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKGVuY29kZVNob3J0U3RyaW5nKFwicHJvb2Zfb2ZfcGVyc29uaG9vZFwiKSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEocG9wQ29udHJhY3QpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gUEZQXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih7fSksXG4gICAgICAgICAgdG86IGR5bmFtaWNGZWx0KGlkZW50aXR5Q29udHJhY3QpLFxuICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodm9pZCAwLCBbMSwgMF0pLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKGVuY29kZVNob3J0U3RyaW5nKFwibmZ0X3BwX2NvbnRyYWN0XCIpKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShwZnBDb250cmFjdCksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoXCIwXCIpXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgIHRvOiBkeW5hbWljRmVsdChpZGVudGl0eUNvbnRyYWN0KSxcbiAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0ZlbHQoZ2V0U2VsZWN0b3JGcm9tTmFtZShcImdldF9leHRlbmRlZF92ZXJpZmllcl9kYXRhXCIpKSxcbiAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzEsIDBdKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShlbmNvZGVTaG9ydFN0cmluZyhcIm5mdF9wcF9pZFwiKSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoXCIyXCIpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHBmcENvbnRyYWN0KSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShcIjBcIilcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih2b2lkIDAsIHZvaWQgMCwgWzYsIDAsIDBdKSxcbiAgICAgICAgICB0bzogZHluYW1pY0ZlbHQodm9pZCAwLCBbNiwgMF0pLFxuICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwidG9rZW5VUklcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzcsIDFdKSwgZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzcsIDJdKV1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwcm92aWRlci5jYWxsQ29udHJhY3Qoe1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IG11bHRpY2FsbEFkZHJlc3MsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFwiYWdncmVnYXRlXCIsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgICBjYWxsc1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQoZGF0YVswXSwgMTYpO1xuICAgICAgICBjb25zdCBmaW5hbEFycmF5ID0gW107XG4gICAgICAgIGxldCBpbmRleCA9IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YkFycmF5U2l6ZSA9IHBhcnNlSW50KGRhdGFbaW5kZXhdLCAxNik7XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgY29uc3Qgc3ViQXJyYXkgPSBkYXRhLnNsaWNlKGluZGV4LCBpbmRleCArIHN1YkFycmF5U2l6ZSk7XG4gICAgICAgICAgICBmaW5hbEFycmF5LnB1c2goc3ViQXJyYXkpO1xuICAgICAgICAgICAgaW5kZXggKz0gc3ViQXJyYXlTaXplO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHVzZURlY29kZWQoZmluYWxBcnJheVswXS5zbGljZSgxKS5tYXAoKGhleFN0cmluZykgPT4gQmlnSW50KGhleFN0cmluZykpKTtcbiAgICAgICAgY29uc3QgdHdpdHRlciA9IGZpbmFsQXJyYXlbMl1bMF0gIT09IFwiMHgwXCIgPyBCaWdJbnQoZmluYWxBcnJheVsyXVswXSkudG9TdHJpbmcoKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZ2l0aHViID0gZmluYWxBcnJheVszXVswXSAhPT0gXCIweDBcIiA/IEJpZ0ludChmaW5hbEFycmF5WzNdWzBdKS50b1N0cmluZygpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBkaXNjb3JkID0gZmluYWxBcnJheVs0XVswXSAhPT0gXCIweDBcIiA/IEJpZ0ludChmaW5hbEFycmF5WzRdWzBdKS50b1N0cmluZygpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBwcm9vZk9mUGVyc29uaG9vZCA9IGZpbmFsQXJyYXlbNV1bMF0gPT09IFwiMHgxXCI7XG4gICAgICAgIGNvbnN0IHByb2ZpbGVQaWN0dXJlTWV0YWRhdGEgPSBkYXRhWzBdID09PSBcIjB4OVwiID8gZmluYWxBcnJheVs4XS5zbGljZSgxKS5tYXAoKHZhbCkgPT4gZGVjb2RlU2hvcnRTdHJpbmcodmFsKSkuam9pbihcIlwiKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgcHJvZmlsZVBpY3R1cmUgPSBwcm9maWxlUGljdHVyZU1ldGFkYXRhIHx8IGBodHRwczovL3N0YXJrbmV0LmlkL2FwaS9pZGVudGljb25zLyR7QmlnSW50KGZpbmFsQXJyYXlbMV1bMF0pLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHR3aXR0ZXIsXG4gICAgICAgICAgZ2l0aHViLFxuICAgICAgICAgIGRpc2NvcmQsXG4gICAgICAgICAgcHJvb2ZPZlBlcnNvbmhvb2QsXG4gICAgICAgICAgcHJvZmlsZVBpY3R1cmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFwiRXJyb3Igd2hpbGUgY2FsbGluZyBhZ2dyZWdhdGUgZnVuY3Rpb25cIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IHVzZXIgc3RhcmsgcHJvZmlsZSBkYXRhIGZyb20gYWRkcmVzc1wiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9leHRlbnNpb25zL2RlZmF1bHQudHNcbnZhciBScGNQcm92aWRlcjIgPSBjbGFzcyBleHRlbmRzIE1peGluKFJwY1Byb3ZpZGVyLCBTdGFya25ldElkKSB7XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvaW50ZXJmYWNlLnRzXG52YXIgUHJvdmlkZXJJbnRlcmZhY2UgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvaW5kZXgudHNcbnZhciBkZWZhdWx0UHJvdmlkZXIgPSBuZXcgUnBjUHJvdmlkZXIoeyBkZWZhdWx0OiB0cnVlIH0pO1xuXG4vLyBzcmMvc2lnbmVyL2ludGVyZmFjZS50c1xudmFyIFNpZ25lckludGVyZmFjZSA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbnZhciB0eXBlZERhdGFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZWREYXRhX2V4cG9ydHMsIHtcbiAgVHlwZWREYXRhUmV2aXNpb246ICgpID0+IFR5cGVkRGF0YVJldmlzaW9uLFxuICBlbmNvZGVEYXRhOiAoKSA9PiBlbmNvZGVEYXRhLFxuICBlbmNvZGVUeXBlOiAoKSA9PiBlbmNvZGVUeXBlLFxuICBlbmNvZGVWYWx1ZTogKCkgPT4gZW5jb2RlVmFsdWUsXG4gIGdldERlcGVuZGVuY2llczogKCkgPT4gZ2V0RGVwZW5kZW5jaWVzLFxuICBnZXRNZXNzYWdlSGFzaDogKCkgPT4gZ2V0TWVzc2FnZUhhc2gsXG4gIGdldFN0cnVjdEhhc2g6ICgpID0+IGdldFN0cnVjdEhhc2gsXG4gIGdldFR5cGVIYXNoOiAoKSA9PiBnZXRUeXBlSGFzaCxcbiAgaXNNZXJrbGVUcmVlVHlwZTogKCkgPT4gaXNNZXJrbGVUcmVlVHlwZSxcbiAgcHJlcGFyZVNlbGVjdG9yOiAoKSA9PiBwcmVwYXJlU2VsZWN0b3Jcbn0pO1xuXG4vLyBzcmMvdXRpbHMvbWVya2xlLnRzXG52YXIgbWVya2xlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG1lcmtsZV9leHBvcnRzLCB7XG4gIE1lcmtsZVRyZWU6ICgpID0+IE1lcmtsZVRyZWUsXG4gIHByb29mTWVya2xlUGF0aDogKCkgPT4gcHJvb2ZNZXJrbGVQYXRoXG59KTtcbnZhciBNZXJrbGVUcmVlID0gY2xhc3MgX01lcmtsZVRyZWUge1xuICBsZWF2ZXM7XG4gIGJyYW5jaGVzID0gW107XG4gIHJvb3Q7XG4gIGhhc2hNZXRob2Q7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBNZXJrbGUgdHJlZVxuICAgKlxuICAgKiBAcGFyYW0gbGVhZkhhc2hlcyBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEBwYXJhbSBoYXNoTWV0aG9kIGhhc2ggbWV0aG9kIHRvIHVzZSwgZGVmYXVsdDogUGVkZXJzZW5cbiAgICogQHJldHVybnMgY3JlYXRlZCBNZXJrbGUgdHJlZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGxlYXZlcyA9IFsnMHgxJywgJzB4MicsICcweDMnLCAnMHg0JywgJzB4NScsICcweDYnLCAnMHg3J107XG4gICAqIGNvbnN0IHRyZWUgPSBuZXcgTWVya2xlVHJlZShsZWF2ZXMpO1xuICAgKiAvLyB0cmVlID0ge1xuICAgKiAvLyAgIGJyYW5jaGVzOiBbWycweDViYjk0NDBlMi4uLicsICcweDI2MjY5N2I4OC4uLicsIC4uLl0sIFsnMHgzODExOGEzNDAuLi4nLCAuLi5dLCAuLi5dLFxuICAgKiAvLyAgIGxlYXZlczogWycweDEnLCAnMHgyJywgJzB4MycsICcweDQnLCAnMHg1JywgJzB4NicsICcweDcnXSxcbiAgICogLy8gICByb290OiAnMHg3Zjc0OGM3NWU1YmRiN2FlMjgwMTNmMDc2YjhhYjY1MGM0ZTAxZDM1MzBjNmU1YWI2NjVmOWYxYWNjYmU3ZDQnLFxuICAgKiAvLyAgIGhhc2hNZXRob2Q6IFtGdW5jdGlvbiBjb21wdXRlUGVkZXJzZW5IYXNoXSxcbiAgICogLy8gfVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxlYWZIYXNoZXMsIGhhc2hNZXRob2QgPSBjb21wdXRlUGVkZXJzZW5IYXNoKSB7XG4gICAgdGhpcy5oYXNoTWV0aG9kID0gaGFzaE1ldGhvZDtcbiAgICB0aGlzLmxlYXZlcyA9IGxlYWZIYXNoZXM7XG4gICAgdGhpcy5yb290ID0gdGhpcy5idWlsZChsZWFmSGFzaGVzKTtcbiAgfVxuICAvKiogQGlnbm9yZSAqL1xuICBidWlsZChsZWF2ZXMpIHtcbiAgICBpZiAobGVhdmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGxlYXZlc1swXTtcbiAgICB9XG4gICAgaWYgKGxlYXZlcy5sZW5ndGggIT09IHRoaXMubGVhdmVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5icmFuY2hlcy5wdXNoKGxlYXZlcyk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0xlYXZlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVhdmVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAoaSArIDEgPT09IGxlYXZlcy5sZW5ndGgpIHtcbiAgICAgICAgbmV3TGVhdmVzLnB1c2goX01lcmtsZVRyZWUuaGFzaChsZWF2ZXNbaV0sIFwiMHgwXCIsIHRoaXMuaGFzaE1ldGhvZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TGVhdmVzLnB1c2goX01lcmtsZVRyZWUuaGFzaChsZWF2ZXNbaV0sIGxlYXZlc1tpICsgMV0sIHRoaXMuaGFzaE1ldGhvZCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5idWlsZChuZXdMZWF2ZXMpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgaGFzaCBmcm9tIG9yZGVyZWQgYSBhbmQgYiwgUGVkZXJzZW4gaGFzaCBkZWZhdWx0XG4gICAqXG4gICAqIEBwYXJhbSBhIGZpcnN0IHZhbHVlXG4gICAqIEBwYXJhbSBiIHNlY29uZCB2YWx1ZVxuICAgKiBAcGFyYW0gaGFzaE1ldGhvZCBoYXNoIG1ldGhvZCB0byB1c2UsIGRlZmF1bHQ6IFBlZGVyc2VuXG4gICAqIEByZXR1cm5zIHJlc3VsdCBvZiB0aGUgaGFzaCBmdW5jdGlvblxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3VsdDEgPSBNZXJrbGVUcmVlLmhhc2goJzB4YWJjJywgJzB4ZGVmJyk7XG4gICAqIC8vIHJlc3VsdDEgPSAnMHg0ODRmMDI5ZGE3OTE0YWRhMDM4YjFhZGY2N2ZjODM2MzIzNjRhM2ViYzJjZDkzNDliNDFhYjYxNjI2ZDllODInXG4gICAqXG4gICAqIGNvbnN0IGN1c3RvbUhhc2hNZXRob2QgPSAoYSwgYikgPT4gYGN1c3RvbV8ke2F9XyR7Yn1gO1xuICAgKiBjb25zdCByZXN1bHQyID0gTWVya2xlVHJlZS5oYXNoKCcweGFiYycsICcweGRlZicsIGN1c3RvbUhhc2hNZXRob2QpO1xuICAgKiAvLyByZXN1bHQyID0gJ2N1c3RvbV8yNzQ4XzM1NjcnXG4gICAqIGBgYFxuICAgKi9cbiAgc3RhdGljIGhhc2goYSwgYiwgaGFzaE1ldGhvZCA9IGNvbXB1dGVQZWRlcnNlbkhhc2gpIHtcbiAgICBjb25zdCBbYVNvcnRlZCwgYlNvcnRlZF0gPSBbQmlnSW50KGEpLCBCaWdJbnQoYildLnNvcnQoKHgsIHkpID0+IHggPj0geSA/IDEgOiAtMSk7XG4gICAgcmV0dXJuIGhhc2hNZXRob2QoYVNvcnRlZCwgYlNvcnRlZCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG1lcmtsZSBtZW1iZXJzaGlwIHByb29mIHBhdGhcbiAgICpcbiAgICogQHBhcmFtIGxlYWYgaGV4LXN0cmluZ1xuICAgKiBAcGFyYW0gYnJhbmNoIGhleC1zdHJpbmcgYXJyYXlcbiAgICogQHBhcmFtIGhhc2hQYXRoIGhleC1zdHJpbmcgYXJyYXlcbiAgICogQHJldHVybnMgY29sbGVjdGlvbiBvZiBtZXJrbGUgcHJvb2YgaGV4LXN0cmluZyBoYXNoZXNcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBsZWF2ZXMgPSBbJzB4MScsICcweDInLCAnMHgzJywgJzB4NCcsICcweDUnLCAnMHg2JywgJzB4NyddO1xuICAgKiBjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUobGVhdmVzKTtcbiAgICogY29uc3QgcmVzdWx0ID0gdHJlZS5nZXRQcm9vZignMHgzJyk7XG4gICAqIC8vIHJlc3VsdCA9IFtcbiAgICogLy8gICAnMHg0JyxcbiAgICogLy8gICAnMHg1YmI5NDQwZTI3ODg5YTM2NGJjYjY3OGIxZjY3OWVjZDEzNDdhY2RlZGNiZjM2ZTgzNDk0Zjg1N2NjNTgwMjYnLFxuICAgKiAvLyAgICcweDhjMGU0NmRkMmRmOWFhZjNhOGViZmJjMjU0MDhhNTgyYWQ3ZmE3MTcxZjA2OThkZGJiYzUxMzBiNGI0ZTYwJyxcbiAgICogLy8gXVxuICAgKiBgYGBcbiAgICovXG4gIGdldFByb29mKGxlYWYsIGJyYW5jaCA9IHRoaXMubGVhdmVzLCBoYXNoUGF0aCA9IFtdKSB7XG4gICAgY29uc3QgaW5kZXggPSBicmFuY2guaW5kZXhPZihsZWFmKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZWFmIG5vdCBmb3VuZFwiKTtcbiAgICB9XG4gICAgaWYgKGJyYW5jaC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBoYXNoUGF0aDtcbiAgICB9XG4gICAgY29uc3QgaXNMZWZ0ID0gaW5kZXggJSAyID09PSAwO1xuICAgIGNvbnN0IG5lZWRlZEJyYW5jaCA9IChpc0xlZnQgPyBicmFuY2hbaW5kZXggKyAxXSA6IGJyYW5jaFtpbmRleCAtIDFdKSA/PyBcIjB4MFwiO1xuICAgIGNvbnN0IG5ld0hhc2hQYXRoID0gWy4uLmhhc2hQYXRoLCBuZWVkZWRCcmFuY2hdO1xuICAgIGNvbnN0IGN1cnJlbnRCcmFuY2hMZXZlbEluZGV4ID0gdGhpcy5sZWF2ZXMubGVuZ3RoID09PSBicmFuY2gubGVuZ3RoID8gLTEgOiB0aGlzLmJyYW5jaGVzLmZpbmRJbmRleCgoYikgPT4gYi5sZW5ndGggPT09IGJyYW5jaC5sZW5ndGgpO1xuICAgIGNvbnN0IG5leHRCcmFuY2ggPSB0aGlzLmJyYW5jaGVzW2N1cnJlbnRCcmFuY2hMZXZlbEluZGV4ICsgMV0gPz8gW3RoaXMucm9vdF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvb2YoXG4gICAgICBfTWVya2xlVHJlZS5oYXNoKGlzTGVmdCA/IGxlYWYgOiBuZWVkZWRCcmFuY2gsIGlzTGVmdCA/IG5lZWRlZEJyYW5jaCA6IGxlYWYsIHRoaXMuaGFzaE1ldGhvZCksXG4gICAgICBuZXh0QnJhbmNoLFxuICAgICAgbmV3SGFzaFBhdGhcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gcHJvb2ZNZXJrbGVQYXRoKHJvb3QsIGxlYWYsIHBhdGgsIGhhc2hNZXRob2QgPSBjb21wdXRlUGVkZXJzZW5IYXNoKSB7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiByb290ID09PSBsZWFmO1xuICB9XG4gIGNvbnN0IFtuZXh0LCAuLi5yZXN0XSA9IHBhdGg7XG4gIHJldHVybiBwcm9vZk1lcmtsZVBhdGgocm9vdCwgTWVya2xlVHJlZS5oYXNoKGxlYWYsIG5leHQsIGhhc2hNZXRob2QpLCByZXN0LCBoYXNoTWV0aG9kKTtcbn1cblxuLy8gc3JjL3V0aWxzL3R5cGVkRGF0YS50c1xudmFyIHByZXNldFR5cGVzID0ge1xuICB1MjU2OiBKU09OLnBhcnNlKCdbeyBcIm5hbWVcIjogXCJsb3dcIiwgXCJ0eXBlXCI6IFwidTEyOFwiIH0sIHsgXCJuYW1lXCI6IFwiaGlnaFwiLCBcInR5cGVcIjogXCJ1MTI4XCIgfV0nKSxcbiAgVG9rZW5BbW91bnQ6IEpTT04ucGFyc2UoXG4gICAgJ1t7IFwibmFtZVwiOiBcInRva2VuX2FkZHJlc3NcIiwgXCJ0eXBlXCI6IFwiQ29udHJhY3RBZGRyZXNzXCIgfSwgeyBcIm5hbWVcIjogXCJhbW91bnRcIiwgXCJ0eXBlXCI6IFwidTI1NlwiIH1dJ1xuICApLFxuICBOZnRJZDogSlNPTi5wYXJzZShcbiAgICAnW3sgXCJuYW1lXCI6IFwiY29sbGVjdGlvbl9hZGRyZXNzXCIsIFwidHlwZVwiOiBcIkNvbnRyYWN0QWRkcmVzc1wiIH0sIHsgXCJuYW1lXCI6IFwidG9rZW5faWRcIiwgXCJ0eXBlXCI6IFwidTI1NlwiIH1dJ1xuICApXG59O1xudmFyIHJldmlzaW9uQ29uZmlndXJhdGlvbiA9IHtcbiAgW1R5cGVkRGF0YVJldmlzaW9uLkFDVElWRV06IHtcbiAgICBkb21haW46IFwiU3RhcmtuZXREb21haW5cIixcbiAgICBoYXNoTWV0aG9kOiBjb21wdXRlUG9zZWlkb25IYXNoT25FbGVtZW50cyxcbiAgICBoYXNoTWVya2xlTWV0aG9kOiBjb21wdXRlUG9zZWlkb25IYXNoLFxuICAgIGVzY2FwZVR5cGVTdHJpbmc6IChzKSA9PiBgXCIke3N9XCJgLFxuICAgIHByZXNldFR5cGVzXG4gIH0sXG4gIFtUeXBlZERhdGFSZXZpc2lvbi5MRUdBQ1ldOiB7XG4gICAgZG9tYWluOiBcIlN0YXJrTmV0RG9tYWluXCIsXG4gICAgaGFzaE1ldGhvZDogY29tcHV0ZVBlZGVyc2VuSGFzaE9uRWxlbWVudHMsXG4gICAgaGFzaE1lcmtsZU1ldGhvZDogY29tcHV0ZVBlZGVyc2VuSGFzaCxcbiAgICBlc2NhcGVUeXBlU3RyaW5nOiAocykgPT4gcyxcbiAgICBwcmVzZXRUeXBlczoge31cbiAgfVxufTtcbmZ1bmN0aW9uIGFzc2VydFJhbmdlKGRhdGEsIHR5cGUsIHsgbWluLCBtYXggfSkge1xuICBjb25zdCB2YWx1ZSA9IEJpZ0ludChkYXRhKTtcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXgsIGAke3ZhbHVlfSAoJHt0eXBlfSkgaXMgb3V0IG9mIGJvdW5kcyBbJHttaW59LCAke21heH1dYCk7XG59XG5mdW5jdGlvbiBpZGVudGlmeVJldmlzaW9uKHsgdHlwZXMsIGRvbWFpbiB9KSB7XG4gIGlmIChyZXZpc2lvbkNvbmZpZ3VyYXRpb25bVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFXS5kb21haW4gaW4gdHlwZXMgJiYgZG9tYWluLnJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUpXG4gICAgcmV0dXJuIFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRTtcbiAgaWYgKHJldmlzaW9uQ29uZmlndXJhdGlvbltUeXBlZERhdGFSZXZpc2lvbi5MRUdBQ1ldLmRvbWFpbiBpbiB0eXBlcyAmJiAoZG9tYWluLnJldmlzaW9uID8/IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSkgPT09IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSlcbiAgICByZXR1cm4gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZO1xuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0SGV4KHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRvSGV4KHZhbHVlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0b0hleChlbmNvZGVTaG9ydFN0cmluZyh2YWx1ZSkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQmlnTnVtYmVyaXNoOiAke3ZhbHVlfWApO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVkRGF0YShkYXRhKSB7XG4gIGNvbnN0IHR5cGVkRGF0YSA9IGRhdGE7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIHR5cGVkRGF0YS5tZXNzYWdlICYmIHR5cGVkRGF0YS5wcmltYXJ5VHlwZSAmJiB0eXBlZERhdGEudHlwZXMgJiYgaWRlbnRpZnlSZXZpc2lvbih0eXBlZERhdGEpXG4gICk7XG59XG5mdW5jdGlvbiBwcmVwYXJlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGlzSGV4KHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogZ2V0U2VsZWN0b3JGcm9tTmFtZShzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBpc01lcmtsZVRyZWVUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUudHlwZSA9PT0gXCJtZXJrbGV0cmVlXCI7XG59XG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXModHlwZXMsIHR5cGUsIGRlcGVuZGVuY2llcyA9IFtdLCBjb250YWlucyA9IFwiXCIsIHJldmlzaW9uID0gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZKSB7XG4gIGlmICh0eXBlW3R5cGUubGVuZ3RoIC0gMV0gPT09IFwiKlwiKSB7XG4gICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgLTEpO1xuICB9IGVsc2UgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJlbnVtXCIpIHtcbiAgICAgIHR5cGUgPSBjb250YWlucztcbiAgICB9IGVsc2UgaWYgKHR5cGUubWF0Y2goL15cXCguKlxcKSQvKSkge1xuICAgICAgdHlwZSA9IHR5cGUuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgfVxuICBpZiAoZGVwZW5kZW5jaWVzLmluY2x1ZGVzKHR5cGUpIHx8ICF0eXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0eXBlLFxuICAgIC4uLnR5cGVzW3R5cGVdLnJlZHVjZShcbiAgICAgIChwcmV2aW91cywgdCkgPT4gW1xuICAgICAgICAuLi5wcmV2aW91cyxcbiAgICAgICAgLi4uZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0LnR5cGUsIHByZXZpb3VzLCB0LmNvbnRhaW5zLCByZXZpc2lvbikuZmlsdGVyKFxuICAgICAgICAgIChkZXBlbmRlbmN5KSA9PiAhcHJldmlvdXMuaW5jbHVkZXMoZGVwZW5kZW5jeSlcbiAgICAgICAgKVxuICAgICAgXSxcbiAgICAgIFtdXG4gICAgKVxuICBdO1xufVxuZnVuY3Rpb24gZ2V0TWVya2xlVHJlZVR5cGUodHlwZXMsIGN0eCkge1xuICBpZiAoY3R4LnBhcmVudCAmJiBjdHgua2V5KSB7XG4gICAgY29uc3QgcGFyZW50VHlwZSA9IHR5cGVzW2N0eC5wYXJlbnRdO1xuICAgIGNvbnN0IG1lcmtsZVR5cGUgPSBwYXJlbnRUeXBlLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gY3R4LmtleSk7XG4gICAgY29uc3QgaXNNZXJrbGVUcmVlID0gaXNNZXJrbGVUcmVlVHlwZShtZXJrbGVUeXBlKTtcbiAgICBpZiAoIWlzTWVya2xlVHJlZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2N0eC5rZXl9IGlzIG5vdCBhIG1lcmtsZSB0cmVlYCk7XG4gICAgfVxuICAgIGlmIChtZXJrbGVUeXBlLmNvbnRhaW5zLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXJrbGUgdHJlZSBjb250YWluIHByb3BlcnR5IG11c3Qgbm90IGJlIGFuIGFycmF5IGJ1dCB3YXMgZ2l2ZW4gJHtjdHgua2V5fWApO1xuICAgIH1cbiAgICByZXR1cm4gbWVya2xlVHlwZS5jb250YWlucztcbiAgfVxuICByZXR1cm4gXCJyYXdcIjtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUodHlwZXMsIHR5cGUsIHJldmlzaW9uID0gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZKSB7XG4gIGNvbnN0IGFsbFR5cGVzID0gcmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSA/IHsgLi4udHlwZXMsIC4uLnJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0ucHJlc2V0VHlwZXMgfSA6IHR5cGVzO1xuICBjb25zdCBbcHJpbWFyeSwgLi4uZGVwZW5kZW5jaWVzXSA9IGdldERlcGVuZGVuY2llcyhcbiAgICBhbGxUeXBlcyxcbiAgICB0eXBlLFxuICAgIHZvaWQgMCxcbiAgICB2b2lkIDAsXG4gICAgcmV2aXNpb25cbiAgKTtcbiAgY29uc3QgbmV3VHlwZXMgPSAhcHJpbWFyeSA/IFtdIDogW3ByaW1hcnksIC4uLmRlcGVuZGVuY2llcy5zb3J0KCldO1xuICBjb25zdCBlc2MgPSByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmVzY2FwZVR5cGVTdHJpbmc7XG4gIHJldHVybiBuZXdUeXBlcy5tYXAoKGRlcGVuZGVuY3kpID0+IHtcbiAgICBjb25zdCBkZXBlbmRlbmN5RWxlbWVudHMgPSBhbGxUeXBlc1tkZXBlbmRlbmN5XS5tYXAoKHQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldFR5cGUgPSB0LnR5cGUgPT09IFwiZW51bVwiICYmIHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUgPyB0LmNvbnRhaW5zIDogdC50eXBlO1xuICAgICAgY29uc3QgdHlwZVN0cmluZyA9IHRhcmdldFR5cGUubWF0Y2goL15cXCguKlxcKSQvKSA/IGAoJHt0YXJnZXRUeXBlLnNsaWNlKDEsIC0xKS5zcGxpdChcIixcIikubWFwKChlKSA9PiBlID8gZXNjKGUpIDogZSkuam9pbihcIixcIil9KWAgOiBlc2ModGFyZ2V0VHlwZSk7XG4gICAgICByZXR1cm4gYCR7ZXNjKHQubmFtZSl9OiR7dHlwZVN0cmluZ31gO1xuICAgIH0pO1xuICAgIHJldHVybiBgJHtlc2MoZGVwZW5kZW5jeSl9KCR7ZGVwZW5kZW5jeUVsZW1lbnRzfSlgO1xuICB9KS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZUhhc2godHlwZXMsIHR5cGUsIHJldmlzaW9uID0gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZKSB7XG4gIHJldHVybiBnZXRTZWxlY3RvckZyb21OYW1lKGVuY29kZVR5cGUodHlwZXMsIHR5cGUsIHJldmlzaW9uKSk7XG59XG5mdW5jdGlvbiBlbmNvZGVWYWx1ZSh0eXBlcywgdHlwZSwgZGF0YSwgY3R4ID0ge30sIHJldmlzaW9uID0gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZKSB7XG4gIGlmICh0eXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBbdHlwZSwgZ2V0U3RydWN0SGFzaCh0eXBlcywgdHlwZSwgZGF0YSwgcmV2aXNpb24pXTtcbiAgfVxuICBpZiAocmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5wcmVzZXRUeXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBbXG4gICAgICB0eXBlLFxuICAgICAgZ2V0U3RydWN0SGFzaChcbiAgICAgICAgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5wcmVzZXRUeXBlcyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcmV2aXNpb25cbiAgICAgIClcbiAgICBdO1xuICB9XG4gIGlmICh0eXBlLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIGNvbnN0IGhhc2hlcyA9IGRhdGEubWFwKFxuICAgICAgKGVudHJ5KSA9PiBlbmNvZGVWYWx1ZSh0eXBlcywgdHlwZS5zbGljZSgwLCAtMSksIGVudHJ5LCB2b2lkIDAsIHJldmlzaW9uKVsxXVxuICAgICk7XG4gICAgcmV0dXJuIFt0eXBlLCByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXRob2QoaGFzaGVzKV07XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImVudW1cIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUpIHtcbiAgICAgICAgY29uc3QgW3ZhcmlhbnRLZXksIHZhcmlhbnREYXRhXSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpWzBdO1xuICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gdHlwZXNbY3R4LnBhcmVudF1bMF07XG4gICAgICAgIGNvbnN0IGVudW1UeXBlID0gdHlwZXNbcGFyZW50VHlwZS5jb250YWluc107XG4gICAgICAgIGNvbnN0IHZhcmlhbnRUeXBlID0gZW51bVR5cGUuZmluZCgodCkgPT4gdC5uYW1lID09PSB2YXJpYW50S2V5KTtcbiAgICAgICAgY29uc3QgdmFyaWFudEluZGV4ID0gZW51bVR5cGUuaW5kZXhPZih2YXJpYW50VHlwZSk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRTdWJ0eXBlcyA9IHZhcmlhbnRUeXBlLnR5cGUuc2xpY2UoMSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoKHN1YnR5cGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJ0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG4gICAgICAgICAgY29uc3Qgc3VidHlwZURhdGEgPSB2YXJpYW50RGF0YVtpbmRleF07XG4gICAgICAgICAgcmV0dXJuIGVuY29kZVZhbHVlKHR5cGVzLCBzdWJ0eXBlLCBzdWJ0eXBlRGF0YSwgdm9pZCAwLCByZXZpc2lvbilbMV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKFt2YXJpYW50SW5kZXgsIC4uLmVuY29kZWRTdWJ0eXBlc10pXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJtZXJrbGV0cmVlXCI6IHtcbiAgICAgIGNvbnN0IG1lcmtsZVRyZWVUeXBlID0gZ2V0TWVya2xlVHJlZVR5cGUodHlwZXMsIGN0eCk7XG4gICAgICBjb25zdCBzdHJ1Y3RIYXNoZXMgPSBkYXRhLm1hcCgoc3RydWN0KSA9PiB7XG4gICAgICAgIHJldHVybiBlbmNvZGVWYWx1ZSh0eXBlcywgbWVya2xlVHJlZVR5cGUsIHN0cnVjdCwgdm9pZCAwLCByZXZpc2lvbilbMV07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHsgcm9vdCB9ID0gbmV3IE1lcmtsZVRyZWUoXG4gICAgICAgIHN0cnVjdEhhc2hlcyxcbiAgICAgICAgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWVya2xlTWV0aG9kXG4gICAgICApO1xuICAgICAgcmV0dXJuIFtcImZlbHRcIiwgcm9vdF07XG4gICAgfVxuICAgIGNhc2UgXCJzZWxlY3RvclwiOiB7XG4gICAgICByZXR1cm4gW1wiZmVsdFwiLCBwcmVwYXJlU2VsZWN0b3IoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwic3RyaW5nXCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IGJ5dGVBcnJheUZyb21TdHJpbmcoZGF0YSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW1xuICAgICAgICAgIGJ5dGVBcnJheS5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAuLi5ieXRlQXJyYXkuZGF0YSxcbiAgICAgICAgICBieXRlQXJyYXkucGVuZGluZ193b3JkLFxuICAgICAgICAgIGJ5dGVBcnJheS5wZW5kaW5nX3dvcmRfbGVuXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBbdHlwZSwgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKGVsZW1lbnRzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJpMTI4XCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KGRhdGEpO1xuICAgICAgICBhc3NlcnRSYW5nZSh2YWx1ZSwgdHlwZSwgUkFOR0VfSTEyOCk7XG4gICAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KHZhbHVlIDwgMG4gPyBQUklNRSArIHZhbHVlIDogdmFsdWUpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcInRpbWVzdGFtcFwiOlxuICAgIGNhc2UgXCJ1MTI4XCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGFzc2VydFJhbmdlKGRhdGEsIHR5cGUsIFJBTkdFX1UxMjgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwiZmVsdFwiOlxuICAgIGNhc2UgXCJzaG9ydHN0cmluZ1wiOiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSkge1xuICAgICAgICBhc3NlcnRSYW5nZShnZXRIZXgoZGF0YSksIHR5cGUsIFJBTkdFX0ZFTFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwiQ2xhc3NIYXNoXCI6XG4gICAgY2FzZSBcIkNvbnRyYWN0QWRkcmVzc1wiOiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSkge1xuICAgICAgICBhc3NlcnRSYW5nZShkYXRhLCB0eXBlLCBSQU5HRV9GRUxUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcImJvb2xcIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBkYXRhID09PSBcImJvb2xlYW5cIiwgYFR5cGUgbWlzbWF0Y2ggZm9yICR7dHlwZX0gJHtkYXRhfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZURhdGEodHlwZXMsIHR5cGUsIGRhdGEsIHJldmlzaW9uID0gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZKSB7XG4gIGNvbnN0IHRhcmdldFR5cGUgPSB0eXBlc1t0eXBlXSA/PyByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLnByZXNldFR5cGVzW3R5cGVdO1xuICBjb25zdCBbcmV0dXJuVHlwZXMsIHZhbHVlc10gPSB0YXJnZXRUeXBlLnJlZHVjZShcbiAgICAoW3RzLCB2c10sIGZpZWxkKSA9PiB7XG4gICAgICBpZiAoZGF0YVtmaWVsZC5uYW1lXSA9PT0gdm9pZCAwIHx8IGRhdGFbZmllbGQubmFtZV0gPT09IG51bGwgJiYgZmllbGQudHlwZSAhPT0gXCJlbnVtXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZW5jb2RlIGRhdGE6IG1pc3NpbmcgZGF0YSBmb3IgJyR7ZmllbGQubmFtZX0nYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICBjb25zdCBjdHggPSB7IHBhcmVudDogdHlwZSwga2V5OiBmaWVsZC5uYW1lIH07XG4gICAgICBjb25zdCBbdCwgZW5jb2RlZFZhbHVlXSA9IGVuY29kZVZhbHVlKHR5cGVzLCBmaWVsZC50eXBlLCB2YWx1ZSwgY3R4LCByZXZpc2lvbik7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbLi4udHMsIHRdLFxuICAgICAgICBbLi4udnMsIGVuY29kZWRWYWx1ZV1cbiAgICAgIF07XG4gICAgfSxcbiAgICBbW1wiZmVsdFwiXSwgW2dldFR5cGVIYXNoKHR5cGVzLCB0eXBlLCByZXZpc2lvbildXVxuICApO1xuICByZXR1cm4gW3JldHVyblR5cGVzLCB2YWx1ZXNdO1xufVxuZnVuY3Rpb24gZ2V0U3RydWN0SGFzaCh0eXBlcywgdHlwZSwgZGF0YSwgcmV2aXNpb24gPSBUeXBlZERhdGFSZXZpc2lvbi5MRUdBQ1kpIHtcbiAgcmV0dXJuIHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0uaGFzaE1ldGhvZChlbmNvZGVEYXRhKHR5cGVzLCB0eXBlLCBkYXRhLCByZXZpc2lvbilbMV0pO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCBhY2NvdW50KSB7XG4gIGlmICghdmFsaWRhdGVUeXBlZERhdGEodHlwZWREYXRhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVkIGRhdGEgZG9lcyBub3QgbWF0Y2ggSlNPTiBzY2hlbWFcIik7XG4gIH1cbiAgY29uc3QgcmV2aXNpb24gPSBpZGVudGlmeVJldmlzaW9uKHR5cGVkRGF0YSk7XG4gIGNvbnN0IHsgZG9tYWluLCBoYXNoTWV0aG9kIH0gPSByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dO1xuICBjb25zdCBtZXNzYWdlID0gW1xuICAgIGVuY29kZVNob3J0U3RyaW5nKFwiU3RhcmtOZXQgTWVzc2FnZVwiKSxcbiAgICBnZXRTdHJ1Y3RIYXNoKHR5cGVkRGF0YS50eXBlcywgZG9tYWluLCB0eXBlZERhdGEuZG9tYWluLCByZXZpc2lvbiksXG4gICAgYWNjb3VudCxcbiAgICBnZXRTdHJ1Y3RIYXNoKHR5cGVkRGF0YS50eXBlcywgdHlwZWREYXRhLnByaW1hcnlUeXBlLCB0eXBlZERhdGEubWVzc2FnZSwgcmV2aXNpb24pXG4gIF07XG4gIHJldHVybiBoYXNoTWV0aG9kKG1lc3NhZ2UpO1xufVxuXG4vLyBzcmMvc2lnbmVyL2RlZmF1bHQudHNcbnZhciBTaWduZXIgPSBjbGFzcyB7XG4gIHBrO1xuICBjb25zdHJ1Y3RvcihwayA9IHN0YXJrQ3VydmUudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKSB7XG4gICAgdGhpcy5wayA9IHBrIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ1ZjJoZXgocGspIDogdG9IZXgocGspO1xuICB9XG4gIGFzeW5jIGdldFB1YktleSgpIHtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5nZXRTdGFya0tleSh0aGlzLnBrKTtcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZSh0eXBlZERhdGEsIGFjY291bnRBZGRyZXNzKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGdldE1lc3NhZ2VIYXNoKHR5cGVkRGF0YSwgYWNjb3VudEFkZHJlc3MpO1xuICAgIHJldHVybiB0aGlzLnNpZ25SYXcobXNnSGFzaCk7XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9ucywgZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBnZXRFeGVjdXRlQ2FsbGRhdGEodHJhbnNhY3Rpb25zLCBkZXRhaWxzLmNhaXJvVmVyc2lvbik7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMih7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogZGV0LndhbGxldEFkZHJlc3MsXG4gICAgICAgIGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMih7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogZGV0LndhbGxldEFkZHJlc3MsXG4gICAgICAgIGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ25UcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduUmF3KG1zZ0hhc2gpO1xuICB9XG4gIGFzeW5jIHNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoZGV0YWlscy5jb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2FsdDogZGV0LmFkZHJlc3NTYWx0LFxuICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNhbHQ6IGRldC5hZGRyZXNzU2FsdCxcbiAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25SYXcobXNnSGFzaCk7XG4gIH1cbiAgYXN5bmMgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbihkZXRhaWxzKSB7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ25EZWNsYXJlVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnblJhdyhtc2dIYXNoKTtcbiAgfVxuICBhc3luYyBzaWduUmF3KG1zZ0hhc2gpIHtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5zaWduKG1zZ0hhc2gsIHRoaXMucGspO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVyL2V0aFNpZ25lci50c1xuaW1wb3J0IHsgc2VjcDI1NmsxIGFzIHNlY3AyNTZrMTIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcblxuLy8gc3JjL3V0aWxzL3VpbnQyNTYudHNcbnZhciB1aW50MjU2X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHVpbnQyNTZfZXhwb3J0cywge1xuICBVSU5UXzEyOF9NQVg6ICgpID0+IFVJTlRfMTI4X01BWCxcbiAgVUlOVF8yNTZfTUFYOiAoKSA9PiBVSU5UXzI1Nl9NQVgsXG4gIGJuVG9VaW50MjU2OiAoKSA9PiBiblRvVWludDI1NixcbiAgaXNVaW50MjU2OiAoKSA9PiBpc1VpbnQyNTYsXG4gIHVpbnQyNTZUb0JOOiAoKSA9PiB1aW50MjU2VG9CTlxufSk7XG5mdW5jdGlvbiB1aW50MjU2VG9CTih1aW50MjU2Mikge1xuICByZXR1cm4gbmV3IENhaXJvVWludDI1Nih1aW50MjU2MikudG9CaWdJbnQoKTtcbn1cbmZ1bmN0aW9uIGlzVWludDI1Nihibikge1xuICByZXR1cm4gQ2Fpcm9VaW50MjU2LmlzKGJuKTtcbn1cbmZ1bmN0aW9uIGJuVG9VaW50MjU2KGJuKSB7XG4gIHJldHVybiBuZXcgQ2Fpcm9VaW50MjU2KGJuKS50b1VpbnQyNTZIZXhTdHJpbmcoKTtcbn1cblxuLy8gc3JjL3NpZ25lci9ldGhTaWduZXIudHNcbnZhciBFdGhTaWduZXIgPSBjbGFzcyB7XG4gIHBrO1xuICAvLyBoZXggc3RyaW5nIHdpdGhvdXQgMHggYW5kIHdpdGggYW4gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gIGNvbnN0cnVjdG9yKHBrID0gZXRoUmFuZG9tUHJpdmF0ZUtleSgpKSB7XG4gICAgdGhpcy5wayA9IHBrIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ1ZjJoZXgocGspLnBhZFN0YXJ0KDY0LCBcIjBcIikgOiByZW1vdmVIZXhQcmVmaXgodG9IZXgocGspKS5wYWRTdGFydCg2NCwgXCIwXCIpO1xuICB9XG4gIC8qKlxuICAgKiBwcm92aWRlcyB0aGUgRXRoZXJldW0gZnVsbCBwdWJsaWMga2V5ICh3aXRob3V0IHBhcml0eSBwcmVmaXgpXG4gICAqIEByZXR1cm5zIGFuIGhleCBzdHJpbmcgOiA2NCBmaXJzdCBjaGFyYWN0ZXJzIGFyZSBQb2ludCBYIGNvb3JkaW5hdGUuIDY0IGxhc3QgY2hhcmFjdGVycyBhcmUgUG9pbnQgWSBjb29yZGluYXRlLlxuICAgKi9cbiAgYXN5bmMgZ2V0UHViS2V5KCkge1xuICAgIHJldHVybiBhZGRIZXhQcmVmaXgoXG4gICAgICBidWYyaGV4KHNlY3AyNTZrMTIuZ2V0UHVibGljS2V5KHRoaXMucGssIGZhbHNlKSkucGFkU3RhcnQoMTMwLCBcIjBcIikuc2xpY2UoMilcbiAgICApO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKHR5cGVkRGF0YSwgYWNjb3VudEFkZHJlc3MpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCBhY2NvdW50QWRkcmVzcyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxMi5zaWduKFxuICAgICAgcmVtb3ZlSGV4UHJlZml4KHNhbml0aXplSGV4KG1zZ0hhc2gpKSxcbiAgICAgIHRoaXMucGtcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdEV0aFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbnMsIGRldGFpbHMpIHtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgZGV0YWlscy5jYWlyb1ZlcnNpb24pO1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxMi5zaWduKFxuICAgICAgcmVtb3ZlSGV4UHJlZml4KHNhbml0aXplSGV4KG1zZ0hhc2gpKSxcbiAgICAgIHRoaXMucGtcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdEV0aFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICB9XG4gIGFzeW5jIHNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoZGV0YWlscy5jb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2FsdDogZGV0LmFkZHJlc3NTYWx0LFxuICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNhbHQ6IGRldC5hZGRyZXNzU2FsdCxcbiAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMTIuc2lnbihcbiAgICAgIHJlbW92ZUhleFByZWZpeChzYW5pdGl6ZUhleChtc2dIYXNoKSksXG4gICAgICB0aGlzLnBrXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRFdGhTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgfVxuICBhc3luYyBzaWduRGVjbGFyZVRyYW5zYWN0aW9uKGRldGFpbHMpIHtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMykuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSBzZWNwMjU2azEyLnNpZ24oXG4gICAgICByZW1vdmVIZXhQcmVmaXgoc2FuaXRpemVIZXgobXNnSGFzaCkpLFxuICAgICAgdGhpcy5wa1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0RXRoU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgc2lnbmF0dXJlIGluIGNvbmZvcm1pdHkgd2l0aCBzdGFya25ldDo6ZXRoX3NpZ25hdHVyZTo6U2lnbmF0dXJlXG4gICAqIEBwYXJhbSBldGhTaWduYXR1cmUgc2VjcDI1NmsxIHNpZ25hdHVyZSBmcm9tIE5vYmxlIGN1cnZlcyBsaWJyYXJ5XG4gICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgZmVsdHMsIHJlcHJlc2VudGluZyBhIENhaXJvIEV0aCBTaWduYXR1cmUuXG4gICAqL1xuICBmb3JtYXRFdGhTaWduYXR1cmUoZXRoU2lnbmF0dXJlKSB7XG4gICAgY29uc3QgciA9IGJuVG9VaW50MjU2KGV0aFNpZ25hdHVyZS5yKTtcbiAgICBjb25zdCBzID0gYm5Ub1VpbnQyNTYoZXRoU2lnbmF0dXJlLnMpO1xuICAgIHJldHVybiBbXG4gICAgICB0b0hleChyLmxvdyksXG4gICAgICB0b0hleChyLmhpZ2gpLFxuICAgICAgdG9IZXgocy5sb3cpLFxuICAgICAgdG9IZXgocy5oaWdoKSxcbiAgICAgIHRvSGV4KGV0aFNpZ25hdHVyZS5yZWNvdmVyeSlcbiAgICBdO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvZXZlbnRzL2luZGV4LnRzXG52YXIgZXZlbnRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGV2ZW50c19leHBvcnRzLCB7XG4gIGdldEFiaUV2ZW50czogKCkgPT4gZ2V0QWJpRXZlbnRzLFxuICBpc0FiaUV2ZW50OiAoKSA9PiBpc0FiaUV2ZW50LFxuICBpc09iamVjdDogKCkgPT4gaXNPYmplY3QsXG4gIHBhcnNlRXZlbnRzOiAoKSA9PiBwYXJzZUV2ZW50cyxcbiAgcGFyc2VVRENFdmVudDogKCkgPT4gcGFyc2VVRENFdmVudFxufSk7XG5mdW5jdGlvbiBpc0FiaUV2ZW50KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0LnR5cGUgPT09IFwiZXZlbnRcIjtcbn1cbmZ1bmN0aW9uIGdldENhaXJvMEFiaUV2ZW50cyhhYmkpIHtcbiAgcmV0dXJuIGFiaS5maWx0ZXIoKGFiaUVudHJ5KSA9PiBhYmlFbnRyeS50eXBlID09PSBcImV2ZW50XCIpLnJlZHVjZSgoYWNjLCBhYmlFbnRyeSkgPT4ge1xuICAgIGNvbnN0IGVudHJ5TmFtZSA9IGFiaUVudHJ5Lm5hbWU7XG4gICAgY29uc3QgYWJpRW50cnlNb2QgPSB7IC4uLmFiaUVudHJ5IH07XG4gICAgYWJpRW50cnlNb2QubmFtZSA9IGVudHJ5TmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYWNjLFxuICAgICAgW2FkZEhleFByZWZpeChzdGFya0N1cnZlLmtlY2Nhayh1dGY4VG9BcnJheShlbnRyeU5hbWUpKS50b1N0cmluZygxNikpXTogYWJpRW50cnlNb2RcbiAgICB9O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRDYWlybzFBYmlFdmVudHMoYWJpKSB7XG4gIGNvbnN0IGFiaUV2ZW50c1N0cnVjdHMgPSBhYmkuZmlsdGVyKChvYmopID0+IGlzQWJpRXZlbnQob2JqKSAmJiBvYmoua2luZCA9PT0gXCJzdHJ1Y3RcIik7XG4gIGNvbnN0IGFiaUV2ZW50c0VudW1zID0gYWJpLmZpbHRlcigob2JqKSA9PiBpc0FiaUV2ZW50KG9iaikgJiYgb2JqLmtpbmQgPT09IFwiZW51bVwiKTtcbiAgY29uc3QgYWJpRXZlbnRzRGF0YSA9IGFiaUV2ZW50c1N0cnVjdHMucmVkdWNlKChhY2MsIGV2ZW50KSA9PiB7XG4gICAgbGV0IG5hbWVMaXN0ID0gW107XG4gICAgbGV0IHsgbmFtZSB9ID0gZXZlbnQ7XG4gICAgbGV0IGZsYXQgPSBmYWxzZTtcbiAgICBjb25zdCBmaW5kTmFtZSA9ICh2YXJpYW50KSA9PiB2YXJpYW50LnR5cGUgPT09IG5hbWU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGV2ZW50RW51bSA9IGFiaUV2ZW50c0VudW1zLmZpbmQoKGV2ZW50RSkgPT4gZXZlbnRFLnZhcmlhbnRzLnNvbWUoZmluZE5hbWUpKTtcbiAgICAgIGlmICh0eXBlb2YgZXZlbnRFbnVtID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICBicmVhaztcbiAgICAgIGNvbnN0IHZhcmlhbnQgPSBldmVudEVudW0udmFyaWFudHMuZmluZChmaW5kTmFtZSk7XG4gICAgICBuYW1lTGlzdC51bnNoaWZ0KHZhcmlhbnQubmFtZSk7XG4gICAgICBpZiAodmFyaWFudC5raW5kID09PSBcImZsYXRcIilcbiAgICAgICAgZmxhdCA9IHRydWU7XG4gICAgICBuYW1lID0gZXZlbnRFbnVtLm5hbWU7XG4gICAgfVxuICAgIGlmIChuYW1lTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluY29uc2lzdGVuY3kgaW4gQUJJIGV2ZW50cyBkZWZpbml0aW9uLlwiKTtcbiAgICB9XG4gICAgaWYgKGZsYXQpXG4gICAgICBuYW1lTGlzdCA9IFtuYW1lTGlzdFtuYW1lTGlzdC5sZW5ndGggLSAxXV07XG4gICAgY29uc3QgZmluYWwgPSBuYW1lTGlzdC5wb3AoKTtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgW2FkZEhleFByZWZpeChzdGFya0N1cnZlLmtlY2Nhayh1dGY4VG9BcnJheShmaW5hbCkpLnRvU3RyaW5nKDE2KSldOiBldmVudFxuICAgIH07XG4gICAgd2hpbGUgKG5hbWVMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgW2FkZEhleFByZWZpeChzdGFya0N1cnZlLmtlY2Nhayh1dGY4VG9BcnJheShuYW1lTGlzdC5wb3AoKSkpLnRvU3RyaW5nKDE2KSldOiByZXN1bHRcbiAgICAgIH07XG4gICAgfVxuICAgIHJlc3VsdCA9IHsgLi4ucmVzdWx0IH07XG4gICAgcmV0dXJuIG1lcmdlQWJpRXZlbnRzKGFjYywgcmVzdWx0KTtcbiAgfSwge30pO1xuICByZXR1cm4gYWJpRXZlbnRzRGF0YTtcbn1cbmZ1bmN0aW9uIGdldEFiaUV2ZW50cyhhYmkpIHtcbiAgcmV0dXJuIGlzQ2Fpcm8xQWJpKGFiaSkgPyBnZXRDYWlybzFBYmlFdmVudHMoYWJpKSA6IGdldENhaXJvMEFiaUV2ZW50cyhhYmkpO1xufVxuZnVuY3Rpb24gaXNPYmplY3QoaXRlbSkge1xuICByZXR1cm4gaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShpdGVtKTtcbn1cbmZ1bmN0aW9uIG1lcmdlQWJpRXZlbnRzKHRhcmdldCwgc291cmNlKSB7XG4gIGNvbnN0IG91dHB1dCA9IHsgLi4udGFyZ2V0IH07XG4gIGlmIChpc09iamVjdCh0YXJnZXQpICYmIGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSlcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgeyBba2V5XTogc291cmNlW2tleV0gfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdXRwdXRba2V5XSA9IG1lcmdlQWJpRXZlbnRzKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgeyBba2V5XTogc291cmNlW2tleV0gfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXZlbnRzKHByb3ZpZGVyUmVjZWl2ZWRFdmVudHMsIGFiaUV2ZW50cywgYWJpU3RydWN0cywgYWJpRW51bXMpIHtcbiAgY29uc3QgcmV0ID0gcHJvdmlkZXJSZWNlaXZlZEV2ZW50cy5mbGF0KCkucmVkdWNlKChhY2MsIHJlY0V2ZW50KSA9PiB7XG4gICAgbGV0IGFiaUV2ZW50ID0gYWJpRXZlbnRzW3JlY0V2ZW50LmtleXMuc2hpZnQoKSA/PyAwXTtcbiAgICBpZiAoIWFiaUV2ZW50KSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICB3aGlsZSAoIWFiaUV2ZW50Lm5hbWUpIHtcbiAgICAgIGNvbnN0IGhhc2hOYW1lID0gcmVjRXZlbnQua2V5cy5zaGlmdCgpO1xuICAgICAgYXNzZXJ0KCEhaGFzaE5hbWUsICdOb3QgZW5vdWdoIGRhdGEgaW4gXCJrZXlcIiBwcm9wZXJ0eSBvZiB0aGlzIGV2ZW50LicpO1xuICAgICAgYWJpRXZlbnQgPSBhYmlFdmVudFtoYXNoTmFtZV07XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0ge307XG4gICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV0gPSB7fTtcbiAgICBjb25zdCBrZXlzSXRlciA9IHJlY0V2ZW50LmtleXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGRhdGFJdGVyID0gcmVjRXZlbnQuZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgYWJpRXZlbnRLZXlzID0gYWJpRXZlbnQubWVtYmVycz8uZmlsdGVyKChpdCkgPT4gaXQua2luZCA9PT0gXCJrZXlcIikgfHwgYWJpRXZlbnQua2V5cztcbiAgICBjb25zdCBhYmlFdmVudERhdGEgPSBhYmlFdmVudC5tZW1iZXJzPy5maWx0ZXIoKGl0KSA9PiBpdC5raW5kID09PSBcImRhdGFcIikgfHwgYWJpRXZlbnQuZGF0YTtcbiAgICBhYmlFdmVudEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVtrZXkubmFtZV0gPSByZXNwb25zZVBhcnNlcihcbiAgICAgICAga2V5c0l0ZXIsXG4gICAgICAgIGtleSxcbiAgICAgICAgYWJpU3RydWN0cyxcbiAgICAgICAgYWJpRW51bXMsXG4gICAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdXG4gICAgICApO1xuICAgIH0pO1xuICAgIGFiaUV2ZW50RGF0YS5mb3JFYWNoKChkYXRhKSA9PiB7XG4gICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVtkYXRhLm5hbWVdID0gcmVzcG9uc2VQYXJzZXIoXG4gICAgICAgIGRhdGFJdGVyLFxuICAgICAgICBkYXRhLFxuICAgICAgICBhYmlTdHJ1Y3RzLFxuICAgICAgICBhYmlFbnVtcyxcbiAgICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgYWNjLnB1c2gocGFyc2VkRXZlbnQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHBhcnNlVURDRXZlbnQodHhSZWNlaXB0KSB7XG4gIGlmICghdHhSZWNlaXB0LmV2ZW50cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVEQyBlbWl0dGVkIGV2ZW50IGlzIGVtcHR5XCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gdHhSZWNlaXB0LmV2ZW50cy5maW5kKFxuICAgIChpdCkgPT4gY2xlYW5IZXgoaXQuZnJvbV9hZGRyZXNzKSA9PT0gY2xlYW5IZXgoVURDLkFERFJFU1MpXG4gICkgfHwge1xuICAgIGRhdGE6IFtdXG4gIH07XG4gIHJldHVybiB7XG4gICAgdHJhbnNhY3Rpb25faGFzaDogdHhSZWNlaXB0LnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgY29udHJhY3RfYWRkcmVzczogZXZlbnQuZGF0YVswXSxcbiAgICBhZGRyZXNzOiBldmVudC5kYXRhWzBdLFxuICAgIGRlcGxveWVyOiBldmVudC5kYXRhWzFdLFxuICAgIHVuaXF1ZTogZXZlbnQuZGF0YVsyXSxcbiAgICBjbGFzc0hhc2g6IGV2ZW50LmRhdGFbM10sXG4gICAgY2FsbGRhdGFfbGVuOiBldmVudC5kYXRhWzRdLFxuICAgIGNhbGxkYXRhOiBldmVudC5kYXRhLnNsaWNlKDUsIDUgKyBwYXJzZUludChldmVudC5kYXRhWzRdLCAxNikpLFxuICAgIHNhbHQ6IGV2ZW50LmRhdGFbZXZlbnQuZGF0YS5sZW5ndGggLSAxXVxuICB9O1xufVxuXG4vLyBzcmMvYWNjb3VudC9kZWZhdWx0LnRzXG52YXIgQWNjb3VudCA9IGNsYXNzIGV4dGVuZHMgUnBjUHJvdmlkZXIyIHtcbiAgc2lnbmVyO1xuICBhZGRyZXNzO1xuICBjYWlyb1ZlcnNpb247XG4gIHRyYW5zYWN0aW9uVmVyc2lvbjtcbiAgY29uc3RydWN0b3IocHJvdmlkZXJPck9wdGlvbnMsIGFkZHJlc3MsIHBrT3JTaWduZXIsIGNhaXJvVmVyc2lvbiwgdHJhbnNhY3Rpb25WZXJzaW9uID0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMikge1xuICAgIHN1cGVyKHByb3ZpZGVyT3JPcHRpb25zKTtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5zaWduZXIgPSBpc1N0cmluZyhwa09yU2lnbmVyKSB8fCBwa09yU2lnbmVyIGluc3RhbmNlb2YgVWludDhBcnJheSA/IG5ldyBTaWduZXIocGtPclNpZ25lcikgOiBwa09yU2lnbmVyO1xuICAgIGlmIChjYWlyb1ZlcnNpb24pIHtcbiAgICAgIHRoaXMuY2Fpcm9WZXJzaW9uID0gY2Fpcm9WZXJzaW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNhY3Rpb25WZXJzaW9uID0gdHJhbnNhY3Rpb25WZXJzaW9uO1xuICB9XG4gIC8vIHByb3ZpZGVkIHZlcnNpb24gb3IgY29udHJhY3QgYmFzZWQgcHJlZmVycmVkIHRyYW5zYWN0aW9uVmVyc2lvblxuICBnZXRQcmVmZXJyZWRWZXJzaW9uKHR5cGUxMiwgdHlwZTMpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvblZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpXG4gICAgICByZXR1cm4gdHlwZTM7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb25WZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyKVxuICAgICAgcmV0dXJuIHR5cGUxMjtcbiAgICByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMztcbiAgfVxuICBhc3luYyBnZXROb25jZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0Tm9uY2VGb3JBZGRyZXNzKHRoaXMuYWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXROb25jZVNhZmUobm9uY2UpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRvQmlnSW50KG5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiAwbjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgQ2Fpcm8gdmVyc2lvbiBmcm9tIHRoZSBuZXR3b3JrIGFuZCBzZXRzIGBjYWlyb1ZlcnNpb25gIGlmIG5vdCBhbHJlYWR5IHNldCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSBjbGFzc0hhc2ggaWYgcHJvdmlkZWQgZGV0ZWN0cyBDYWlybyB2ZXJzaW9uIGZyb20gY2xhc3NIYXNoLCBvdGhlcndpc2UgZnJvbSB0aGUgYWNjb3VudCBhZGRyZXNzXG4gICAqL1xuICBhc3luYyBnZXRDYWlyb1ZlcnNpb24oY2xhc3NIYXNoKSB7XG4gICAgaWYgKCF0aGlzLmNhaXJvVmVyc2lvbikge1xuICAgICAgY29uc3QgeyBjYWlybyB9ID0gY2xhc3NIYXNoID8gYXdhaXQgc3VwZXIuZ2V0Q29udHJhY3RWZXJzaW9uKHZvaWQgMCwgY2xhc3NIYXNoKSA6IGF3YWl0IHN1cGVyLmdldENvbnRyYWN0VmVyc2lvbih0aGlzLmFkZHJlc3MpO1xuICAgICAgdGhpcy5jYWlyb1ZlcnNpb24gPSBjYWlybztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2Fpcm9WZXJzaW9uO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRmVlKGNhbGxzLCBlc3RpbWF0ZUZlZURldGFpbHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlSW52b2tlRmVlKGNhbGxzLCBlc3RpbWF0ZUZlZURldGFpbHMpO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlSW52b2tlRmVlKGNhbGxzLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBub25jZTogcHJvdmlkZWROb25jZSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHZlcnNpb246IHByb3ZpZGVkVmVyc2lvbixcbiAgICAgIHNraXBWYWxpZGF0ZSA9IHRydWVcbiAgICB9ID0gZGV0YWlscztcbiAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBBcnJheS5pc0FycmF5KGNhbGxzKSA/IGNhbGxzIDogW2NhbGxzXTtcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KHByb3ZpZGVkTm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMSwgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMyksXG4gICAgICB0b0ZlZVZlcnNpb24ocHJvdmlkZWRWZXJzaW9uKVxuICAgICk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHNpZ25lckRldGFpbHMgPSB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBub25jZSxcbiAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgIHZlcnNpb24sXG4gICAgICBjaGFpbklkLFxuICAgICAgY2Fpcm9WZXJzaW9uOiBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24odHJhbnNhY3Rpb25zLCBzaWduZXJEZXRhaWxzKTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0SW52b2tlRXN0aW1hdGVGZWUoXG4gICAgICB7IC4uLmludm9jYXRpb24gfSxcbiAgICAgIHsgLi4udjNEZXRhaWxzKGRldGFpbHMpLCB2ZXJzaW9uLCBub25jZSB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgZGV0YWlscy5za2lwVmFsaWRhdGVcbiAgICApO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRGVjbGFyZUZlZShwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBub25jZTogcHJvdmlkZWROb25jZSxcbiAgICAgIHZlcnNpb246IHByb3ZpZGVkVmVyc2lvbixcbiAgICAgIHNraXBWYWxpZGF0ZSA9IHRydWVcbiAgICB9ID0gZGV0YWlscztcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KHByb3ZpZGVkTm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICAhaXNTaWVycmEocGF5bG9hZC5jb250cmFjdCkgPyBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxIDogdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjIsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjMpLFxuICAgICAgdG9GZWVWZXJzaW9uKHByb3ZpZGVkVmVyc2lvbilcbiAgICApO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuYnVpbGREZWNsYXJlUGF5bG9hZChwYXlsb2FkLCB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICBub25jZSxcbiAgICAgIGNoYWluSWQsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDAsXG4gICAgICAvLyB1bnVzZWQgcGFyYW1ldGVyXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0RGVjbGFyZUVzdGltYXRlRmVlKFxuICAgICAgZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24sXG4gICAgICB7IC4uLnYzRGV0YWlscyhkZXRhaWxzKSwgdmVyc2lvbiwgbm9uY2UgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIGRldGFpbHMuc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUFjY291bnREZXBsb3lGZWUoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBhZGRyZXNzU2FsdCA9IDAsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdLFxuICAgIGNvbnRyYWN0QWRkcmVzc1xuICB9LCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7IGJsb2NrSWRlbnRpZmllciwgdmVyc2lvbjogcHJvdmlkZWRWZXJzaW9uLCBza2lwVmFsaWRhdGUgPSB0cnVlIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzKSxcbiAgICAgIHRvRmVlVmVyc2lvbihwcm92aWRlZFZlcnNpb24pXG4gICAgKTtcbiAgICBjb25zdCBub25jZSA9IFpFUk87XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQoXG4gICAgICB7IGNsYXNzSGFzaCwgYWRkcmVzc1NhbHQsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGNvbnRyYWN0QWRkcmVzcyB9LFxuICAgICAge1xuICAgICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICAgIG5vbmNlLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIC8vIHVudXNlZCBwYXJhbWV0ZXJcbiAgICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgICBjYWlyb1ZlcnNpb246IHZvaWQgMCxcbiAgICAgICAgLy8gdW51c2VkIHBhcmFtZXRlcixcbiAgICAgICAgc2tpcFZhbGlkYXRlXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlKFxuICAgICAgeyAuLi5wYXlsb2FkIH0sXG4gICAgICB7IC4uLnYzRGV0YWlscyhkZXRhaWxzKSwgdmVyc2lvbiwgbm9uY2UgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIGRldGFpbHMuc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZURlcGxveUZlZShwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCBjYWxscyA9IHRoaXMuYnVpbGRVRENDb250cmFjdFBheWxvYWQocGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVJbnZva2VGZWUoY2FsbHMsIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgeyBub25jZSwgYmxvY2tJZGVudGlmaWVyLCB2ZXJzaW9uLCBza2lwVmFsaWRhdGUgfSA9IGRldGFpbHM7XG4gICAgY29uc3QgYWNjb3VudEludm9jYXRpb25zID0gYXdhaXQgdGhpcy5hY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICB2ZXJzaW9uczogW1xuICAgICAgICBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxLFxuICAgICAgICAvLyBub24tc2llcnJhXG4gICAgICAgIHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYyLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzKSxcbiAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgIClcbiAgICAgICAgLy8gc2llcnJhXG4gICAgICBdLFxuICAgICAgbm9uY2UsXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0RXN0aW1hdGVGZWVCdWxrKGFjY291bnRJbnZvY2F0aW9ucywge1xuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgeyBub25jZSwgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSB0cnVlLCBza2lwRXhlY3V0ZSwgdmVyc2lvbiB9ID0gZGV0YWlscztcbiAgICBjb25zdCBhY2NvdW50SW52b2NhdGlvbnMgPSBhd2FpdCB0aGlzLmFjY291bnRJbnZvY2F0aW9uc0ZhY3RvcnkoaW52b2NhdGlvbnMsIHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIHZlcnNpb25zOiBbXG4gICAgICAgIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgIC8vIG5vbi1zaWVycmFcbiAgICAgICAgdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICAgICAgdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpLFxuICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgKVxuICAgICAgXSxcbiAgICAgIG5vbmNlLFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfSk7XG4gICAgcmV0dXJuIHN1cGVyLmdldFNpbXVsYXRlVHJhbnNhY3Rpb24oYWNjb3VudEludm9jYXRpb25zLCB7XG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGUsXG4gICAgICBza2lwRXhlY3V0ZVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGV4ZWN1dGUodHJhbnNhY3Rpb25zLCBhcmcyLCB0cmFuc2FjdGlvbnNEZXRhaWwgPSB7fSkge1xuICAgIGNvbnN0IGRldGFpbHMgPSBhcmcyID09PSB2b2lkIDAgfHwgQXJyYXkuaXNBcnJheShhcmcyKSA/IHRyYW5zYWN0aW9uc0RldGFpbCA6IGFyZzI7XG4gICAgY29uc3QgY2FsbHMgPSBBcnJheS5pc0FycmF5KHRyYW5zYWN0aW9ucykgPyB0cmFuc2FjdGlvbnMgOiBbdHJhbnNhY3Rpb25zXTtcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KGRldGFpbHMubm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSwgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMyksXG4gICAgICAvLyBUT0RPOiBkb2VzIHRoaXMgZGVwZW5kIG9uIGNhaXJvIHZlcnNpb24gP1xuICAgICAgZGV0YWlscy52ZXJzaW9uXG4gICAgKTtcbiAgICBjb25zdCBlc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlKFxuICAgICAgdmVyc2lvbixcbiAgICAgIHsgdHlwZTogXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8sIHBheWxvYWQ6IHRyYW5zYWN0aW9ucyB9LFxuICAgICAge1xuICAgICAgICAuLi5kZXRhaWxzLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZS5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIG5vbmNlLFxuICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGNhaXJvVmVyc2lvbjogYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKVxuICAgIH07XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduZXIuc2lnblRyYW5zYWN0aW9uKGNhbGxzLCBzaWduZXJEZXRhaWxzKTtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldEV4ZWN1dGVDYWxsZGF0YShjYWxscywgYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSk7XG4gICAgcmV0dXJuIHRoaXMuaW52b2tlRnVuY3Rpb24oXG4gICAgICB7IGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLCBjYWxsZGF0YSwgc2lnbmF0dXJlIH0sXG4gICAgICB7XG4gICAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlLnJlc291cmNlQm91bmRzLFxuICAgICAgICBub25jZSxcbiAgICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBGaXJzdCBjaGVjayBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkLCBpZiBub3QgZGVjbGFyZSBpdFxuICAgKiBJZiBjb250cmFjdCBhbHJlYWR5IGRlY2xhcmVkIHJldHVybmVkIHRyYW5zYWN0aW9uX2hhc2ggaXMgJycuXG4gICAqIE1ldGhvZCB3aWxsIHBhc3MgZXZlbiBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbnNEZXRhaWwgKG9wdGlvbmFsKVxuICAgKi9cbiAgYXN5bmMgZGVjbGFyZUlmTm90KHBheWxvYWQsIHRyYW5zYWN0aW9uc0RldGFpbCA9IHt9KSB7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5nZXRDbGFzc0J5SGFzaChkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmUocGF5bG9hZCwgdHJhbnNhY3Rpb25zRGV0YWlsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IFwiXCIsXG4gICAgICBjbGFzc19oYXNoOiBkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaFxuICAgIH07XG4gIH1cbiAgYXN5bmMgZGVjbGFyZShwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RQYXlsb2FkID0gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpO1xuICAgIGNvbnN0IHsgbm9uY2UsIHZlcnNpb246IHByb3ZpZGVkVmVyc2lvbiB9ID0gZGV0YWlscztcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICAhaXNTaWVycmEocGF5bG9hZC5jb250cmFjdCkgPyBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxIDogdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpLFxuICAgICAgcHJvdmlkZWRWZXJzaW9uXG4gICAgKTtcbiAgICBjb25zdCBlc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlKFxuICAgICAgdmVyc2lvbixcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLyxcbiAgICAgICAgcGF5bG9hZDogZGVjbGFyZUNvbnRyYWN0UGF5bG9hZFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLi4uZGV0YWlscyxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgZGVjbGFyZURldGFpbHMgPSB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGUucmVzb3VyY2VCb3VuZHMsXG4gICAgICBtYXhGZWU6IGVzdGltYXRlLm1heEZlZSxcbiAgICAgIG5vbmNlOiB0b0JpZ0ludChub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGNoYWluSWQ6IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpLFxuICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDBcbiAgICB9O1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5idWlsZERlY2xhcmVQYXlsb2FkKFxuICAgICAgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCxcbiAgICAgIGRlY2xhcmVEZXRhaWxzXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5kZWNsYXJlQ29udHJhY3QoZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24sIGRlY2xhcmVEZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZXBsb3kocGF5bG9hZCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgeyBjYWxscywgYWRkcmVzc2VzIH0gPSBidWlsZFVEQ0NhbGwocGF5bG9hZCwgdGhpcy5hZGRyZXNzKTtcbiAgICBjb25zdCBpbnZva2VSZXNwb25zZSA9IGF3YWl0IHRoaXMuZXhlY3V0ZShjYWxscywgdm9pZCAwLCBkZXRhaWxzKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaW52b2tlUmVzcG9uc2UsXG4gICAgICBjb250cmFjdF9hZGRyZXNzOiBhZGRyZXNzZXNcbiAgICB9O1xuICB9XG4gIGFzeW5jIGRlcGxveUNvbnRyYWN0KHBheWxvYWQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IGRlcGxveVR4ID0gYXdhaXQgdGhpcy5kZXBsb3kocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgY29uc3QgdHhSZWNlaXB0ID0gYXdhaXQgdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oZGVwbG95VHgudHJhbnNhY3Rpb25faGFzaCk7XG4gICAgcmV0dXJuIHBhcnNlVURDRXZlbnQodHhSZWNlaXB0KTtcbiAgfVxuICBhc3luYyBkZWNsYXJlQW5kRGVwbG95KHBheWxvYWQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHsgY29uc3RydWN0b3JDYWxsZGF0YSwgc2FsdCwgdW5pcXVlIH0gPSBwYXlsb2FkO1xuICAgIGxldCBkZWNsYXJlID0gYXdhaXQgdGhpcy5kZWNsYXJlSWZOb3QocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgaWYgKGRlY2xhcmUudHJhbnNhY3Rpb25faGFzaCAhPT0gXCJcIikge1xuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbihkZWNsYXJlLnRyYW5zYWN0aW9uX2hhc2gpO1xuICAgICAgZGVjbGFyZSA9IHsgLi4uZGVjbGFyZSwgLi4udHggfTtcbiAgICB9XG4gICAgY29uc3QgZGVwbG95ID0gYXdhaXQgdGhpcy5kZXBsb3lDb250cmFjdChcbiAgICAgIHsgY2xhc3NIYXNoOiBkZWNsYXJlLmNsYXNzX2hhc2gsIHNhbHQsIHVuaXF1ZSwgY29uc3RydWN0b3JDYWxsZGF0YSB9LFxuICAgICAgZGV0YWlsc1xuICAgICk7XG4gICAgcmV0dXJuIHsgZGVjbGFyZTogeyAuLi5kZWNsYXJlIH0sIGRlcGxveSB9O1xuICB9XG4gIGRlcGxveVNlbGYgPSB0aGlzLmRlcGxveUFjY291bnQ7XG4gIGFzeW5jIGRlcGxveUFjY291bnQoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW10sXG4gICAgYWRkcmVzc1NhbHQgPSAwLFxuICAgIGNvbnRyYWN0QWRkcmVzczogcHJvdmlkZWRDb250cmFjdEFkZHJlc3NcbiAgfSwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpLFxuICAgICAgZGV0YWlscy52ZXJzaW9uXG4gICAgKTtcbiAgICBjb25zdCBub25jZSA9IFpFUk87XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzID8/IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKGFkZHJlc3NTYWx0LCBjbGFzc0hhc2gsIGNvbXBpbGVkQ2FsbGRhdGEsIDApO1xuICAgIGNvbnN0IGVzdGltYXRlID0gYXdhaXQgdGhpcy5nZXRVbml2ZXJzYWxTdWdnZXN0ZWRGZWUoXG4gICAgICB2ZXJzaW9uLFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgICAgICBhZGRyZXNzU2FsdCxcbiAgICAgICAgICBjb250cmFjdEFkZHJlc3NcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRldGFpbHNcbiAgICApO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oe1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgY2hhaW5JZCxcbiAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZS5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIG1heEZlZTogZXN0aW1hdGUubWF4RmVlLFxuICAgICAgdmVyc2lvbixcbiAgICAgIG5vbmNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZGVwbG95QWNjb3VudENvbnRyYWN0KFxuICAgICAgeyBjbGFzc0hhc2gsIGFkZHJlc3NTYWx0LCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBzaWduYXR1cmUgfSxcbiAgICAgIHtcbiAgICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgICBub25jZSxcbiAgICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlLnJlc291cmNlQm91bmRzLFxuICAgICAgICBtYXhGZWU6IGVzdGltYXRlLm1heEZlZSxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UodHlwZWREYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmVyLnNpZ25NZXNzYWdlKHR5cGVkRGF0YSwgdGhpcy5hZGRyZXNzKTtcbiAgfVxuICBhc3luYyBoYXNoTWVzc2FnZSh0eXBlZERhdGEpIHtcbiAgICByZXR1cm4gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCB0aGlzLmFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIHZlcmlmeU1lc3NhZ2VIYXNoKGhhc2gsIHNpZ25hdHVyZSwgc2lnbmF0dXJlVmVyaWZpY2F0aW9uRnVuY3Rpb25OYW1lLCBzaWduYXR1cmVWZXJpZmljYXRpb25SZXNwb25zZSkge1xuICAgIGNvbnN0IGtub3duU2lnVmVyaWZpY2F0aW9uRk5hbWUgPSBzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbk5hbWUgPyBbc2lnbmF0dXJlVmVyaWZpY2F0aW9uRnVuY3Rpb25OYW1lXSA6IFtcImlzVmFsaWRTaWduYXR1cmVcIiwgXCJpc192YWxpZF9zaWduYXR1cmVcIl07XG4gICAgY29uc3Qga25vd25TaWduYXR1cmVSZXNwb25zZSA9IHNpZ25hdHVyZVZlcmlmaWNhdGlvblJlc3BvbnNlIHx8IHtcbiAgICAgIG9rUmVzcG9uc2U6IFtcbiAgICAgICAgLy8gYW55IG5vbi1ub2sgcmVzcG9uc2UgaXMgdHJ1ZVxuICAgICAgXSxcbiAgICAgIG5va1Jlc3BvbnNlOiBbXG4gICAgICAgIFwiMHgwXCIsXG4gICAgICAgIC8vIERldm5ldFxuICAgICAgICBcIjB4MDBcIlxuICAgICAgICAvLyBPcGVuWmVwcGVsaW4gMC43LjAgdG8gMC45LjAgaW52YWxpZCBzaWduYXR1cmVcbiAgICAgIF0sXG4gICAgICBlcnJvcjogW1xuICAgICAgICBcImFyZ2VudC9pbnZhbGlkLXNpZ25hdHVyZVwiLFxuICAgICAgICAvLyBBcmdlbnRYIDAuMy4wIHRvIDAuMy4xXG4gICAgICAgIFwiaXMgaW52YWxpZCwgd2l0aCByZXNwZWN0IHRvIHRoZSBwdWJsaWMga2V5XCIsXG4gICAgICAgIC8vIE9wZW5aZXBwZWxpbiB1bnRpbCAwLjYuMSwgQnJhYXZvcyAwLjAuMTFcbiAgICAgICAgXCJJTlZBTElEX1NJR1wiXG4gICAgICAgIC8vIEJyYWF2b3MgMS4wLjBcbiAgICAgIF1cbiAgICB9O1xuICAgIGxldCBlcnJvcjtcbiAgICBmb3IgKGNvbnN0IFNpZ1ZlcmlmaWNhdGlvbkZOYW1lIG9mIGtub3duU2lnVmVyaWZpY2F0aW9uRk5hbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmNhbGxDb250cmFjdCh7XG4gICAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgZW50cnlwb2ludDogU2lnVmVyaWZpY2F0aW9uRk5hbWUsXG4gICAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoe1xuICAgICAgICAgICAgaGFzaDogdG9CaWdJbnQoaGFzaCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZm9ybWF0U2lnbmF0dXJlKHNpZ25hdHVyZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGtub3duU2lnbmF0dXJlUmVzcG9uc2Uubm9rUmVzcG9uc2UuaW5jbHVkZXMocmVzcFswXS50b1N0cmluZygpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa25vd25TaWduYXR1cmVSZXNwb25zZS5va1Jlc3BvbnNlLmxlbmd0aCA9PT0gMCB8fCBrbm93blNpZ25hdHVyZVJlc3BvbnNlLm9rUmVzcG9uc2UuaW5jbHVkZXMocmVzcFswXS50b1N0cmluZygpKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKFwic2lnbmF0dXJlVmVyaWZpY2F0aW9uUmVzcG9uc2UgRXJyb3I6IHJlc3BvbnNlIGlzIG5vdCBwYXJ0IG9mIGtub3duIHJlc3BvbnNlc1wiKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoa25vd25TaWduYXR1cmVSZXNwb25zZS5lcnJvci5zb21lKFxuICAgICAgICAgIChlcnJNZXNzYWdlKSA9PiBlcnIubWVzc2FnZS5pbmNsdWRlcyhlcnJNZXNzYWdlKVxuICAgICAgICApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBFcnJvcihgU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBFcnJvcjogJHtlcnJvcn1gKTtcbiAgfVxuICBhc3luYyB2ZXJpZnlNZXNzYWdlKHR5cGVkRGF0YSwgc2lnbmF0dXJlLCBzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbk5hbWUsIHNpZ25hdHVyZVZlcmlmaWNhdGlvblJlc3BvbnNlKSB7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuaGFzaE1lc3NhZ2UodHlwZWREYXRhKTtcbiAgICByZXR1cm4gdGhpcy52ZXJpZnlNZXNzYWdlSGFzaChcbiAgICAgIGhhc2gsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbk5hbWUsXG4gICAgICBzaWduYXR1cmVWZXJpZmljYXRpb25SZXNwb25zZVxuICAgICk7XG4gIH1cbiAgLypcbiAgICogU3VwcG9ydCBtZXRob2RzXG4gICAqL1xuICBhc3luYyBnZXRVbml2ZXJzYWxTdWdnZXN0ZWRGZWUodmVyc2lvbiwgeyB0eXBlLCBwYXlsb2FkIH0sIGRldGFpbHMpIHtcbiAgICBsZXQgbWF4RmVlID0gMDtcbiAgICBsZXQgcmVzb3VyY2VCb3VuZHMgPSBlc3RpbWF0ZUZlZVRvQm91bmRzKFpFUk8pO1xuICAgIGlmICh2ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzKSB7XG4gICAgICByZXNvdXJjZUJvdW5kcyA9IGRldGFpbHMucmVzb3VyY2VCb3VuZHMgPz8gKGF3YWl0IHRoaXMuZ2V0U3VnZ2VzdGVkRmVlKHsgdHlwZSwgcGF5bG9hZCB9LCBkZXRhaWxzKSkucmVzb3VyY2VCb3VuZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEZlZSA9IGRldGFpbHMubWF4RmVlID8/IChhd2FpdCB0aGlzLmdldFN1Z2dlc3RlZEZlZSh7IHR5cGUsIHBheWxvYWQgfSwgZGV0YWlscykpLnN1Z2dlc3RlZE1heEZlZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heEZlZSxcbiAgICAgIHJlc291cmNlQm91bmRzXG4gICAgfTtcbiAgfVxuICBhc3luYyBnZXRTdWdnZXN0ZWRGZWUoeyB0eXBlLCBwYXlsb2FkIH0sIGRldGFpbHMpIHtcbiAgICBsZXQgZmVlRXN0aW1hdGU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVJbnZva2VGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVEZWNsYXJlRmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVBY2NvdW50RGVwbG95RmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJERVBMT1lcIiAvKiBERVBMT1kgKi86XG4gICAgICAgIGZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5lc3RpbWF0ZURlcGxveUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IHtcbiAgICAgICAgICBnYXNfY29uc3VtZWQ6IDBuLFxuICAgICAgICAgIGdhc19wcmljZTogMG4sXG4gICAgICAgICAgb3ZlcmFsbF9mZWU6IFpFUk8sXG4gICAgICAgICAgdW5pdDogXCJGUklcIixcbiAgICAgICAgICBzdWdnZXN0ZWRNYXhGZWU6IFpFUk8sXG4gICAgICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlRmVlVG9Cb3VuZHMoWkVSTyksXG4gICAgICAgICAgZGF0YV9nYXNfY29uc3VtZWQ6IDBuLFxuICAgICAgICAgIGRhdGFfZ2FzX3ByaWNlOiAwblxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGZlZUVzdGltYXRlO1xuICB9XG4gIGFzeW5jIGJ1aWxkSW52b2NhdGlvbihjYWxsLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRFeGVjdXRlQ2FsbGRhdGEoY2FsbCwgYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gIWRldGFpbHMuc2tpcFZhbGlkYXRlID8gYXdhaXQgdGhpcy5zaWduZXIuc2lnblRyYW5zYWN0aW9uKGNhbGwsIGRldGFpbHMpIDogW107XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgY2FsbGRhdGEsXG4gICAgICBzaWduYXR1cmVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGJ1aWxkRGVjbGFyZVBheWxvYWQocGF5bG9hZCwgZGV0YWlscykge1xuICAgIGNvbnN0IHsgY2xhc3NIYXNoLCBjb250cmFjdCwgY29tcGlsZWRDbGFzc0hhc2ggfSA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICBjb25zdCBjb21wcmVzc2VkQ29tcGlsZWRDb250cmFjdCA9IHBhcnNlQ29udHJhY3QoY29udHJhY3QpO1xuICAgIGlmICh0eXBlb2YgY29tcGlsZWRDbGFzc0hhc2ggPT09IFwidW5kZWZpbmVkXCIgJiYgKGRldGFpbHMudmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMuRjMgfHwgZGV0YWlscy52ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMy5WMykpIHtcbiAgICAgIHRocm93IEVycm9yKFwiVjMgVHJhbnNhY3Rpb24gd29yayB3aXRoIENhaXJvMSBDb250cmFjdHMgYW5kIHJlcXVpcmUgY29tcGlsZWRDbGFzc0hhc2hcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICFkZXRhaWxzLnNraXBWYWxpZGF0ZSA/IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oe1xuICAgICAgLi4uZGV0YWlscyxcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgLy8gVE9ETzogVFMsIGNhc3QgYmVjYXVzZSBvcHRpb25hbCBmb3IgdjIgYW5kIHJlcXVpcmVkIGZvciB2MywgdGhyb3duIGlmIG5vdCBwcmVzZW50XG4gICAgICBzZW5kZXJBZGRyZXNzOiBkZXRhaWxzLndhbGxldEFkZHJlc3NcbiAgICB9KSA6IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBzZW5kZXJBZGRyZXNzOiBkZXRhaWxzLndhbGxldEFkZHJlc3MsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBjb250cmFjdDogY29tcHJlc3NlZENvbXBpbGVkQ29udHJhY3QsXG4gICAgICBjb21waWxlZENsYXNzSGFzaFxuICAgIH07XG4gIH1cbiAgYXN5bmMgYnVpbGRBY2NvdW50RGVwbG95UGF5bG9hZCh7XG4gICAgY2xhc3NIYXNoLFxuICAgIGFkZHJlc3NTYWx0ID0gMCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW10sXG4gICAgY29udHJhY3RBZGRyZXNzOiBwcm92aWRlZENvbnRyYWN0QWRkcmVzc1xuICB9LCBkZXRhaWxzKSB7XG4gICAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gcHJvdmlkZWRDb250cmFjdEFkZHJlc3MgPz8gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goYWRkcmVzc1NhbHQsIGNsYXNzSGFzaCwgY29tcGlsZWRDYWxsZGF0YSwgMCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gIWRldGFpbHMuc2tpcFZhbGlkYXRlID8gYXdhaXQgdGhpcy5zaWduZXIuc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbih7XG4gICAgICAuLi5kZXRhaWxzLFxuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhXG4gICAgfSkgOiBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfVxuICBidWlsZFVEQ0NvbnRyYWN0UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgY29uc3QgY2FsbHMgPSBbXS5jb25jYXQocGF5bG9hZCkubWFwKChpdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIHNhbHQgPSBcIjBcIixcbiAgICAgICAgdW5pcXVlID0gdHJ1ZSxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdXG4gICAgICB9ID0gaXQ7XG4gICAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBVREMuQUREUkVTUyxcbiAgICAgICAgZW50cnlwb2ludDogVURDLkVOVFJZUE9JTlQsXG4gICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIHNhbHQsXG4gICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBjYWxscztcbiAgfVxuICBhc3luYyBhY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgeyBub25jZSwgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSB0cnVlIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IHNhZmVOb25jZSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2VTYWZlKG5vbmNlKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgdmVyc2lvbnMgPSBkZXRhaWxzLnZlcnNpb25zLm1hcCgoaXQpID0+IHRvVHJhbnNhY3Rpb25WZXJzaW9uKGl0KSk7XG4gICAgY29uc3QgdHgwUGF5bG9hZCA9IFwicGF5bG9hZFwiIGluIGludm9jYXRpb25zWzBdID8gaW52b2NhdGlvbnNbMF0ucGF5bG9hZCA6IGludm9jYXRpb25zWzBdO1xuICAgIGNvbnN0IGNhaXJvVmVyc2lvbiA9IGludm9jYXRpb25zWzBdLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyA/IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKHR4MFBheWxvYWQuY2xhc3NIYXNoKSA6IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgW10uY29uY2F0KGludm9jYXRpb25zKS5tYXAoYXN5bmMgKHRyYW5zYWN0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB0eFBheWxvYWQgPSBcInBheWxvYWRcIiBpbiB0cmFuc2FjdGlvbiA/IHRyYW5zYWN0aW9uLnBheWxvYWQgOiB0cmFuc2FjdGlvbjtcbiAgICAgICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgIG5vbmNlOiB0b0JpZ0ludChOdW1iZXIoc2FmZU5vbmNlKSArIGluZGV4KSxcbiAgICAgICAgICBtYXhGZWU6IFpFUk8sXG4gICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICBjYWlyb1ZlcnNpb24sXG4gICAgICAgICAgdmVyc2lvbjogXCJcIixcbiAgICAgICAgICBza2lwVmFsaWRhdGVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tbW9uID0ge1xuICAgICAgICAgIHR5cGU6IHRyYW5zYWN0aW9uLnR5cGUsXG4gICAgICAgICAgbm9uY2U6IHRvQmlnSW50KE51bWJlcihzYWZlTm9uY2UpICsgaW5kZXgpLFxuICAgICAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgICAgICB2ZXJzaW9uOiBcIlwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLykge1xuICAgICAgICAgIGNvbnN0IHZlcnNpb25YID0gcmVkdWNlVjIodmVyc2lvbnNbMV0pO1xuICAgICAgICAgIHNpZ25lckRldGFpbHMudmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbW1vbi52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGRJbnZvY2F0aW9uKFxuICAgICAgICAgICAgW10uY29uY2F0KHR4UGF5bG9hZCksXG4gICAgICAgICAgICBzaWduZXJEZXRhaWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovKSB7XG4gICAgICAgICAgY29uc3QgdmVyc2lvblggPSByZWR1Y2VWMih2ZXJzaW9uc1sxXSk7XG4gICAgICAgICAgc2lnbmVyRGV0YWlscy52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29tbW9uLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb25zdCBjYWxscyA9IHRoaXMuYnVpbGRVRENDb250cmFjdFBheWxvYWQodHhQYXlsb2FkKTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24oY2FsbHMsIHNpZ25lckRldGFpbHMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgdHlwZTogXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi9cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovKSB7XG4gICAgICAgICAgY29uc3QgdmVyc2lvblggPSAhaXNTaWVycmEodHhQYXlsb2FkLmNvbnRyYWN0KSA/IHZlcnNpb25zWzBdIDogdmVyc2lvbnNbMV07XG4gICAgICAgICAgc2lnbmVyRGV0YWlscy52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29tbW9uLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZERlY2xhcmVQYXlsb2FkKHR4UGF5bG9hZCwgc2lnbmVyRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8pIHtcbiAgICAgICAgICBjb25zdCB2ZXJzaW9uWCA9IHJlZHVjZVYyKHZlcnNpb25zWzFdKTtcbiAgICAgICAgICBzaWduZXJEZXRhaWxzLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb21tb24udmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQodHhQYXlsb2FkLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgRXJyb3IoYGFjY291bnRJbnZvY2F0aW9uc0ZhY3Rvcnk6IHVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGU6ICR7dHJhbnNhY3Rpb259YCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0U3RhcmtOYW1lKGFkZHJlc3MgPSB0aGlzLmFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0U3RhcmtOYW1lKGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpO1xuICB9XG59O1xuXG4vLyBzcmMvYWNjb3VudC9pbnRlcmZhY2UudHNcbnZhciBBY2NvdW50SW50ZXJmYWNlID0gY2xhc3MgZXh0ZW5kcyBQcm92aWRlckludGVyZmFjZSB7XG59O1xuXG4vLyBzcmMvd2FsbGV0L2Nvbm5lY3QudHNcbnZhciBjb25uZWN0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbm5lY3RfZXhwb3J0cywge1xuICBhZGREZWNsYXJlVHJhbnNhY3Rpb246ICgpID0+IGFkZERlY2xhcmVUcmFuc2FjdGlvbixcbiAgYWRkSW52b2tlVHJhbnNhY3Rpb246ICgpID0+IGFkZEludm9rZVRyYW5zYWN0aW9uLFxuICBhZGRTdGFya25ldENoYWluOiAoKSA9PiBhZGRTdGFya25ldENoYWluLFxuICBkZXBsb3ltZW50RGF0YTogKCkgPT4gZGVwbG95bWVudERhdGEsXG4gIGdldFBlcm1pc3Npb25zOiAoKSA9PiBnZXRQZXJtaXNzaW9ucyxcbiAgb25BY2NvdW50Q2hhbmdlOiAoKSA9PiBvbkFjY291bnRDaGFuZ2UsXG4gIG9uTmV0d29ya0NoYW5nZWQ6ICgpID0+IG9uTmV0d29ya0NoYW5nZWQsXG4gIHJlcXVlc3RBY2NvdW50czogKCkgPT4gcmVxdWVzdEFjY291bnRzLFxuICByZXF1ZXN0Q2hhaW5JZDogKCkgPT4gcmVxdWVzdENoYWluSWQsXG4gIHNpZ25NZXNzYWdlOiAoKSA9PiBzaWduTWVzc2FnZSxcbiAgc3VwcG9ydGVkU3BlY3M6ICgpID0+IHN1cHBvcnRlZFNwZWNzLFxuICBzd2l0Y2hTdGFya25ldENoYWluOiAoKSA9PiBzd2l0Y2hTdGFya25ldENoYWluLFxuICB3YXRjaEFzc2V0OiAoKSA9PiB3YXRjaEFzc2V0XG59KTtcbmZ1bmN0aW9uIHJlcXVlc3RBY2NvdW50cyhzd28sIHNpbGVudF9tb2RlID0gZmFsc2UpIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHtcbiAgICB0eXBlOiBcIndhbGxldF9yZXF1ZXN0QWNjb3VudHNcIixcbiAgICBwYXJhbXM6IHtcbiAgICAgIHNpbGVudF9tb2RlXG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFBlcm1pc3Npb25zKHN3bykge1xuICByZXR1cm4gc3dvLnJlcXVlc3QoeyB0eXBlOiBcIndhbGxldF9nZXRQZXJtaXNzaW9uc1wiIH0pO1xufVxuZnVuY3Rpb24gd2F0Y2hBc3NldChzd28sIGFzc2V0KSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfd2F0Y2hBc3NldFwiLFxuICAgIHBhcmFtczogYXNzZXRcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRTdGFya25ldENoYWluKHN3bywgY2hhaW4pIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHtcbiAgICB0eXBlOiBcIndhbGxldF9hZGRTdGFya25ldENoYWluXCIsXG4gICAgcGFyYW1zOiBjaGFpblxuICB9KTtcbn1cbmZ1bmN0aW9uIHN3aXRjaFN0YXJrbmV0Q2hhaW4oc3dvLCBjaGFpbklkKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfc3dpdGNoU3RhcmtuZXRDaGFpblwiLFxuICAgIHBhcmFtczoge1xuICAgICAgY2hhaW5JZFxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXF1ZXN0Q2hhaW5JZChzd28pIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHsgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdENoYWluSWRcIiB9KTtcbn1cbmZ1bmN0aW9uIGRlcGxveW1lbnREYXRhKHN3bykge1xuICByZXR1cm4gc3dvLnJlcXVlc3QoeyB0eXBlOiBcIndhbGxldF9kZXBsb3ltZW50RGF0YVwiIH0pO1xufVxuZnVuY3Rpb24gYWRkSW52b2tlVHJhbnNhY3Rpb24oc3dvLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHtcbiAgICB0eXBlOiBcIndhbGxldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLFxuICAgIHBhcmFtc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZERlY2xhcmVUcmFuc2FjdGlvbihzd28sIHBhcmFtcykge1xuICByZXR1cm4gc3dvLnJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLFxuICAgIHBhcmFtc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNpZ25NZXNzYWdlKHN3bywgdHlwZWREYXRhKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfc2lnblR5cGVkRGF0YVwiLFxuICAgIHBhcmFtczogdHlwZWREYXRhXG4gIH0pO1xufVxuZnVuY3Rpb24gc3VwcG9ydGVkU3BlY3Moc3dvKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7IHR5cGU6IFwid2FsbGV0X3N1cHBvcnRlZFNwZWNzXCIgfSk7XG59XG5mdW5jdGlvbiBvbkFjY291bnRDaGFuZ2Uoc3dvLCBjYWxsYmFjaykge1xuICBzd28ub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gb25OZXR3b3JrQ2hhbmdlZChzd28sIGNhbGxiYWNrKSB7XG4gIHN3by5vbihcIm5ldHdvcmtDaGFuZ2VkXCIsIGNhbGxiYWNrKTtcbn1cblxuLy8gc3JjL3dhbGxldC9hY2NvdW50LnRzXG52YXIgV2FsbGV0QWNjb3VudCA9IGNsYXNzIGV4dGVuZHMgQWNjb3VudCB7XG4gIGFkZHJlc3MgPSBcIlwiO1xuICB3YWxsZXRQcm92aWRlcjtcbiAgY29uc3RydWN0b3IocHJvdmlkZXJPck9wdGlvbnMsIHdhbGxldFByb3ZpZGVyLCBjYWlyb1ZlcnNpb24pIHtcbiAgICBzdXBlcihwcm92aWRlck9yT3B0aW9ucywgXCJcIiwgXCJcIiwgY2Fpcm9WZXJzaW9uKTtcbiAgICB0aGlzLndhbGxldFByb3ZpZGVyID0gd2FsbGV0UHJvdmlkZXI7XG4gICAgdGhpcy53YWxsZXRQcm92aWRlci5vbihcImFjY291bnRzQ2hhbmdlZFwiLCAocmVzKSA9PiB7XG4gICAgICBpZiAoIXJlcylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5hZGRyZXNzID0gcmVzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgdGhpcy53YWxsZXRQcm92aWRlci5vbihcIm5ldHdvcmtDaGFuZ2VkXCIsIChyZXMpID0+IHtcbiAgICAgIGlmICghcmVzKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmNoYW5uZWwuc2V0Q2hhaW5JZChyZXMpO1xuICAgIH0pO1xuICAgIHdhbGxldFByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzXCIsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgc2lsZW50X21vZGU6IGZhbHNlXG4gICAgICB9XG4gICAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgICB0aGlzLmFkZHJlc3MgPSByZXNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogV0FMTEVUIEVWRU5UU1xuICAgKi9cbiAgb25BY2NvdW50Q2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgb25BY2NvdW50Q2hhbmdlKHRoaXMud2FsbGV0UHJvdmlkZXIsIGNhbGxiYWNrKTtcbiAgfVxuICBvbk5ldHdvcmtDaGFuZ2VkKGNhbGxiYWNrKSB7XG4gICAgb25OZXR3b3JrQ2hhbmdlZCh0aGlzLndhbGxldFByb3ZpZGVyLCBjYWxsYmFjayk7XG4gIH1cbiAgLyoqXG4gICAqIFdBTExFVCBTUEVDSUZJQyBNRVRIT0RTXG4gICAqL1xuICByZXF1ZXN0QWNjb3VudHMoc2lsZW50TW9kZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RBY2NvdW50cyh0aGlzLndhbGxldFByb3ZpZGVyLCBzaWxlbnRNb2RlKTtcbiAgfVxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gZ2V0UGVybWlzc2lvbnModGhpcy53YWxsZXRQcm92aWRlcik7XG4gIH1cbiAgc3dpdGNoU3RhcmtuZXRDaGFpbihjaGFpbklkKSB7XG4gICAgcmV0dXJuIHN3aXRjaFN0YXJrbmV0Q2hhaW4odGhpcy53YWxsZXRQcm92aWRlciwgY2hhaW5JZCk7XG4gIH1cbiAgd2F0Y2hBc3NldChhc3NldCkge1xuICAgIHJldHVybiB3YXRjaEFzc2V0KHRoaXMud2FsbGV0UHJvdmlkZXIsIGFzc2V0KTtcbiAgfVxuICBhZGRTdGFya25ldENoYWluKGNoYWluKSB7XG4gICAgcmV0dXJuIGFkZFN0YXJrbmV0Q2hhaW4odGhpcy53YWxsZXRQcm92aWRlciwgY2hhaW4pO1xuICB9XG4gIC8qKlxuICAgKiBBQ0NPVU5UIE1FVEhPRFNcbiAgICovXG4gIGV4ZWN1dGUoY2FsbHMpIHtcbiAgICBjb25zdCB0eENhbGxzID0gW10uY29uY2F0KGNhbGxzKS5tYXAoKGl0KSA9PiB7XG4gICAgICBjb25zdCB7IGNvbnRyYWN0QWRkcmVzcywgZW50cnlwb2ludCwgY2FsbGRhdGEgfSA9IGl0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBlbnRyeV9wb2ludDogZW50cnlwb2ludCxcbiAgICAgICAgY2FsbGRhdGFcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgY2FsbHM6IHR4Q2FsbHNcbiAgICB9O1xuICAgIHJldHVybiBhZGRJbnZva2VUcmFuc2FjdGlvbih0aGlzLndhbGxldFByb3ZpZGVyLCBwYXJhbXMpO1xuICB9XG4gIGRlY2xhcmUocGF5bG9hZCkge1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFBheWxvYWQgPSBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCk7XG4gICAgY29uc3QgcENvbnRyYWN0ID0gcGF5bG9hZC5jb250cmFjdDtcbiAgICBjb25zdCBjYWlybzFDb250cmFjdCA9IHtcbiAgICAgIC4uLnBDb250cmFjdCxcbiAgICAgIGFiaTogc3RyaW5naWZ5MihwQ29udHJhY3QuYWJpKVxuICAgIH07XG4gICAgaWYgKCFkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNvbXBpbGVkQ2xhc3NIYXNoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcImNvbXBpbGVkQ2xhc3NIYXNoIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgY29udHJhY3RfY2xhc3M6IGNhaXJvMUNvbnRyYWN0XG4gICAgfTtcbiAgICByZXR1cm4gYWRkRGVjbGFyZVRyYW5zYWN0aW9uKHRoaXMud2FsbGV0UHJvdmlkZXIsIHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgZGVwbG95KHBheWxvYWQpIHtcbiAgICBjb25zdCB7IGNhbGxzLCBhZGRyZXNzZXMgfSA9IGJ1aWxkVURDQ2FsbChwYXlsb2FkLCB0aGlzLmFkZHJlc3MpO1xuICAgIGNvbnN0IGludm9rZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlKGNhbGxzKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaW52b2tlUmVzcG9uc2UsXG4gICAgICBjb250cmFjdF9hZGRyZXNzOiBhZGRyZXNzZXNcbiAgICB9O1xuICB9XG4gIHNpZ25NZXNzYWdlKHR5cGVkRGF0YSkge1xuICAgIHJldHVybiBzaWduTWVzc2FnZSh0aGlzLndhbGxldFByb3ZpZGVyLCB0eXBlZERhdGEpO1xuICB9XG4gIC8vIFRPRE86IE1JU1NJTkcgRVNUSU1BVEVTXG59O1xuXG4vLyBzcmMvY29udHJhY3QvZGVmYXVsdC50c1xudmFyIHNwbGl0QXJnc0FuZE9wdGlvbnMgPSAoYXJncykgPT4ge1xuICBjb25zdCBvcHRpb25zID0gW1xuICAgIFwiYmxvY2tJZGVudGlmaWVyXCIsXG4gICAgXCJwYXJzZVJlcXVlc3RcIixcbiAgICBcInBhcnNlUmVzcG9uc2VcIixcbiAgICBcImZvcm1hdFJlc3BvbnNlXCIsXG4gICAgXCJtYXhGZWVcIixcbiAgICBcIm5vbmNlXCIsXG4gICAgXCJzaWduYXR1cmVcIixcbiAgICBcImFkZHJlc3NTYWx0XCJcbiAgXTtcbiAgY29uc3QgbGFzdEFyZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgaWYgKHR5cGVvZiBsYXN0QXJnID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuc29tZSgoeCkgPT4geCBpbiBsYXN0QXJnKSkge1xuICAgIHJldHVybiB7IGFyZ3MsIG9wdGlvbnM6IGFyZ3MucG9wKCkgfTtcbiAgfVxuICByZXR1cm4geyBhcmdzIH07XG59O1xuZnVuY3Rpb24gYnVpbGRDYWxsKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0QXJnc0FuZE9wdGlvbnMoYXJncyk7XG4gICAgcmV0dXJuIGNvbnRyYWN0LmNhbGwoZnVuY3Rpb25BYmkubmFtZSwgcGFyYW1zLmFyZ3MsIHtcbiAgICAgIHBhcnNlUmVxdWVzdDogdHJ1ZSxcbiAgICAgIHBhcnNlUmVzcG9uc2U6IHRydWUsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRJbnZva2UoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICByZXR1cm4gY29udHJhY3QuaW52b2tlKGZ1bmN0aW9uQWJpLm5hbWUsIHBhcmFtcy5hcmdzLCB7XG4gICAgICBwYXJzZVJlcXVlc3Q6IHRydWUsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGREZWZhdWx0KGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICBpZiAoZnVuY3Rpb25BYmkuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBmdW5jdGlvbkFiaS5zdGF0ZV9tdXRhYmlsaXR5ID09PSBcInZpZXdcIikge1xuICAgIHJldHVybiBidWlsZENhbGwoY29udHJhY3QsIGZ1bmN0aW9uQWJpKTtcbiAgfVxuICByZXR1cm4gYnVpbGRJbnZva2UoY29udHJhY3QsIGZ1bmN0aW9uQWJpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9wdWxhdGUoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGNvbnRyYWN0LnBvcHVsYXRlKGZ1bmN0aW9uQWJpLm5hbWUsIGFyZ3MpO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFc3RpbWF0ZShjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY29udHJhY3QuZXN0aW1hdGUoZnVuY3Rpb25BYmkubmFtZSwgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDYWxsZGF0YShhcmdzLCBjYWxsYmFjaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBcIl9fY29tcGlsZWRfX1wiIGluIGFyZ3MpXG4gICAgcmV0dXJuIGFyZ3M7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBhcmdzWzBdKVxuICAgIHJldHVybiBhcmdzWzBdO1xuICByZXR1cm4gY2FsbGJhY2soKTtcbn1cbnZhciBDb250cmFjdCA9IGNsYXNzIHtcbiAgYWJpO1xuICBhZGRyZXNzO1xuICBwcm92aWRlck9yQWNjb3VudDtcbiAgZGVwbG95VHJhbnNhY3Rpb25IYXNoO1xuICBzdHJ1Y3RzO1xuICBldmVudHM7XG4gIGZ1bmN0aW9ucztcbiAgY2FsbFN0YXRpYztcbiAgcG9wdWxhdGVUcmFuc2FjdGlvbjtcbiAgZXN0aW1hdGVGZWU7XG4gIGNhbGxEYXRhO1xuICAvKipcbiAgICogQ29udHJhY3QgY2xhc3MgdG8gaGFuZGxlIGNvbnRyYWN0IG1ldGhvZHNcbiAgICpcbiAgICogQHBhcmFtIGFiaSAtIEFiaSBvZiB0aGUgY29udHJhY3Qgb2JqZWN0XG4gICAqIEBwYXJhbSBhZGRyZXNzIChvcHRpb25hbCkgLSBhZGRyZXNzIHRvIGNvbm5lY3QgdG9cbiAgICogQHBhcmFtIHByb3ZpZGVyT3JBY2NvdW50IChvcHRpb25hbCkgLSBQcm92aWRlciBvciBBY2NvdW50IHRvIGF0dGFjaCB0b1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWJpLCBhZGRyZXNzLCBwcm92aWRlck9yQWNjb3VudCA9IGRlZmF1bHRQcm92aWRlcikge1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3MgJiYgYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdmlkZXJPckFjY291bnQgPSBwcm92aWRlck9yQWNjb3VudDtcbiAgICB0aGlzLmNhbGxEYXRhID0gbmV3IENhbGxEYXRhKGFiaSk7XG4gICAgdGhpcy5zdHJ1Y3RzID0gQ2FsbERhdGEuZ2V0QWJpU3RydWN0KGFiaSk7XG4gICAgdGhpcy5ldmVudHMgPSBnZXRBYmlFdmVudHMoYWJpKTtcbiAgICBjb25zdCBwYXJzZXIgPSBjcmVhdGVBYmlQYXJzZXIoYWJpKTtcbiAgICB0aGlzLmFiaSA9IHBhcnNlci5nZXRMZWdhY3lGb3JtYXQoKTtcbiAgICBjb25zdCBvcHRpb25zID0geyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIGZ1bmN0aW9uczogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9LFxuICAgICAgY2FsbFN0YXRpYzogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9LFxuICAgICAgcG9wdWxhdGVUcmFuc2FjdGlvbjogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9LFxuICAgICAgZXN0aW1hdGVGZWU6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfVxuICAgIH0pO1xuICAgIHRoaXMuYWJpLmZvckVhY2goKGFiaUVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChhYmlFbGVtZW50LnR5cGUgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYWJpRWxlbWVudC5uYW1lO1xuICAgICAgaWYgKCF0aGlzW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkRGVmYXVsdCh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5mdW5jdGlvbnNbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5mdW5jdGlvbnMsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkRGVmYXVsdCh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jYWxsU3RhdGljW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuY2FsbFN0YXRpYywgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGRDYWxsKHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25bc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZFBvcHVsYXRlKHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmVzdGltYXRlRmVlW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZXN0aW1hdGVGZWUsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkRXN0aW1hdGUodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXR0YWNoKGFkZHJlc3MpIHtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICB9XG4gIGNvbm5lY3QocHJvdmlkZXJPckFjY291bnQpIHtcbiAgICB0aGlzLnByb3ZpZGVyT3JBY2NvdW50ID0gcHJvdmlkZXJPckFjY291bnQ7XG4gIH1cbiAgYXN5bmMgZGVwbG95ZWQoKSB7XG4gICAgaWYgKHRoaXMuZGVwbG95VHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICBhd2FpdCB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LndhaXRGb3JUcmFuc2FjdGlvbih0aGlzLmRlcGxveVRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICB0aGlzLmRlcGxveVRyYW5zYWN0aW9uSGFzaCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXN5bmMgY2FsbChtZXRob2QsIGFyZ3MgPSBbXSwge1xuICAgIHBhcnNlUmVxdWVzdCA9IHRydWUsXG4gICAgcGFyc2VSZXNwb25zZSA9IHRydWUsXG4gICAgZm9ybWF0UmVzcG9uc2UgPSB2b2lkIDAsXG4gICAgYmxvY2tJZGVudGlmaWVyID0gdm9pZCAwXG4gIH0gPSB7fSkge1xuICAgIGFzc2VydCh0aGlzLmFkZHJlc3MgIT09IG51bGwsIFwiY29udHJhY3QgaXMgbm90IGNvbm5lY3RlZCB0byBhbiBhZGRyZXNzXCIpO1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0Q2FsbGRhdGEoYXJncywgKCkgPT4ge1xuICAgICAgaWYgKHBhcnNlUmVxdWVzdCkge1xuICAgICAgICB0aGlzLmNhbGxEYXRhLnZhbGlkYXRlKFwiQ0FMTFwiIC8qIENBTEwgKi8sIG1ldGhvZCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkNhbGwgc2tpcHBlZCBwYXJzaW5nIGJ1dCBwcm92aWRlZCByYXdBcmdzLCBwb3NzaWJsZSBtYWxmdW5jdGlvbiByZXF1ZXN0XCIpO1xuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuY2FsbENvbnRyYWN0KFxuICAgICAge1xuICAgICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgY2FsbGRhdGEsXG4gICAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZFxuICAgICAgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllclxuICAgICkudGhlbigoaXQpID0+IHtcbiAgICAgIGlmICghcGFyc2VSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gaXQ7XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0UmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEuZm9ybWF0KG1ldGhvZCwgaXQsIGZvcm1hdFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLnBhcnNlKG1ldGhvZCwgaXQpO1xuICAgIH0pO1xuICB9XG4gIGludm9rZShtZXRob2QsIGFyZ3MgPSBbXSwgeyBwYXJzZVJlcXVlc3QgPSB0cnVlLCBtYXhGZWUsIG5vbmNlLCBzaWduYXR1cmUgfSA9IHt9KSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB7XG4gICAgICBpZiAocGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8sIG1ldGhvZCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkludm9rZSBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9KTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZFxuICAgIH07XG4gICAgaWYgKFwiZXhlY3V0ZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmV4ZWN1dGUoaW52b2NhdGlvbiwgdm9pZCAwLCB7XG4gICAgICAgIG1heEZlZSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW5vbmNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb25jZSBpcyByZXF1aXJlZCB3aGVuIGludm9raW5nIGEgZnVuY3Rpb24gd2l0aG91dCBhbiBhY2NvdW50YCk7XG4gICAgY29uc29sZS53YXJuKGBJbnZva2luZyAke21ldGhvZH0gd2l0aG91dCBhbiBhY2NvdW50LiBUaGlzIHdpbGwgbm90IHdvcmsgb24gYSBwdWJsaWMgbm9kZS5gKTtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5pbnZva2VGdW5jdGlvbihcbiAgICAgIHtcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgc2lnbmF0dXJlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBub25jZVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGUobWV0aG9kLCBhcmdzID0gW10pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBpZiAoIWdldENhbGxkYXRhKGFyZ3MsICgpID0+IGZhbHNlKSkge1xuICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIklOVk9LRVwiIC8qIElOVk9LRSAqLywgbWV0aG9kLCBhcmdzKTtcbiAgICB9XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IHRoaXMucG9wdWxhdGUobWV0aG9kLCBhcmdzKTtcbiAgICBpZiAoXCJlc3RpbWF0ZUludm9rZUZlZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmVzdGltYXRlSW52b2tlRmVlKGludm9jYXRpb24pO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIkNvbnRyYWN0IG11c3QgYmUgY29ubmVjdGVkIHRvIHRoZSBhY2NvdW50IGNvbnRyYWN0IHRvIGVzdGltYXRlXCIpO1xuICB9XG4gIHBvcHVsYXRlKG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgZW50cnlwb2ludDogbWV0aG9kLFxuICAgICAgY2FsbGRhdGFcbiAgICB9O1xuICB9XG4gIHBhcnNlRXZlbnRzKHJlY2VpcHQpIHtcbiAgICByZXR1cm4gcGFyc2VFdmVudHMoXG4gICAgICByZWNlaXB0LmV2ZW50cz8uZmlsdGVyKFxuICAgICAgICAoZXZlbnQpID0+IGNsZWFuSGV4KGV2ZW50LmZyb21fYWRkcmVzcykgPT09IGNsZWFuSGV4KHRoaXMuYWRkcmVzcyksXG4gICAgICAgIFtdXG4gICAgICApIHx8IFtdLFxuICAgICAgdGhpcy5ldmVudHMsXG4gICAgICB0aGlzLnN0cnVjdHMsXG4gICAgICBDYWxsRGF0YS5nZXRBYmlFbnVtKHRoaXMuYWJpKVxuICAgICk7XG4gIH1cbiAgaXNDYWlybzEoKSB7XG4gICAgcmV0dXJuIGNhaXJvX2V4cG9ydHMuaXNDYWlybzFBYmkodGhpcy5hYmkpO1xuICB9XG4gIGFzeW5jIGdldFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuZ2V0Q29udHJhY3RWZXJzaW9uKHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgdHlwZWR2Mih0QWJpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8vIHNyYy9jb250cmFjdC9pbnRlcmZhY2UudHNcbnZhciBDb250cmFjdEludGVyZmFjZSA9IGNsYXNzIHtcbiAgZnVuY3Rpb25zO1xuICBjYWxsU3RhdGljO1xuICBwb3B1bGF0ZVRyYW5zYWN0aW9uO1xuICBlc3RpbWF0ZUZlZTtcbn07XG5cbi8vIHNyYy9jb250cmFjdC9jb250cmFjdEZhY3RvcnkudHNcbnZhciBDb250cmFjdEZhY3RvcnkgPSBjbGFzcyB7XG4gIGNvbXBpbGVkQ29udHJhY3Q7XG4gIGFjY291bnQ7XG4gIGFiaTtcbiAgY2xhc3NIYXNoO1xuICBjYXNtO1xuICBjb21waWxlZENsYXNzSGFzaDtcbiAgQ2FsbERhdGE7XG4gIC8qKlxuICAgKiBAcGFyYW0gcGFyYW1zIENGUGFyYW1zXG4gICAqICAtIGNvbXBpbGVkQ29udHJhY3Q6IENvbXBpbGVkQ29udHJhY3Q7XG4gICAqICAtIGFjY291bnQ6IEFjY291bnRJbnRlcmZhY2U7XG4gICAqICAtIGNhc20/OiBDYWlyb0Fzc2VtYmx5O1xuICAgKiAgLSBjbGFzc0hhc2g/OiBzdHJpbmc7XG4gICAqICAtIGNvbXBpbGVkQ2xhc3NIYXNoPzogc3RyaW5nO1xuICAgKiAgLSBhYmk/OiBBYmk7XG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICB0aGlzLmNvbXBpbGVkQ29udHJhY3QgPSBwYXJhbXMuY29tcGlsZWRDb250cmFjdDtcbiAgICB0aGlzLmFjY291bnQgPSBwYXJhbXMuYWNjb3VudDtcbiAgICB0aGlzLmNhc20gPSBwYXJhbXMuY2FzbTtcbiAgICB0aGlzLmFiaSA9IHBhcmFtcy5hYmkgPz8gcGFyYW1zLmNvbXBpbGVkQ29udHJhY3QuYWJpO1xuICAgIHRoaXMuY2xhc3NIYXNoID0gcGFyYW1zLmNsYXNzSGFzaDtcbiAgICB0aGlzLmNvbXBpbGVkQ2xhc3NIYXNoID0gcGFyYW1zLmNvbXBpbGVkQ2xhc3NIYXNoO1xuICAgIHRoaXMuQ2FsbERhdGEgPSBuZXcgQ2FsbERhdGEodGhpcy5hYmkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXBsb3lzIGNvbnRyYWN0IGFuZCByZXR1cm5zIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ29udHJhY3RcbiAgICpcbiAgICogSWYgY29udHJhY3QgaXMgbm90IGRlY2xhcmVkIGl0IHdpbGwgZmlyc3QgZGVjbGFyZSBpdCwgYW5kIHRoZW4gZGVwbG95XG4gICAqL1xuICBhc3luYyBkZXBsb3koLi4uYXJncykge1xuICAgIGNvbnN0IHsgYXJnczogcGFyYW0sIG9wdGlvbnMgPSB7IHBhcnNlUmVxdWVzdDogdHJ1ZSB9IH0gPSBzcGxpdEFyZ3NBbmRPcHRpb25zKGFyZ3MpO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBnZXRDYWxsZGF0YShwYXJhbSwgKCkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuQ2FsbERhdGEudmFsaWRhdGUoXCJERVBMT1lcIiAvKiBERVBMT1kgKi8sIFwiY29uc3RydWN0b3JcIiwgcGFyYW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5DYWxsRGF0YS5jb21waWxlKFwiY29uc3RydWN0b3JcIiwgcGFyYW0pO1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiQ2FsbCBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gcGFyYW07XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgZGVwbG95OiB7IGNvbnRyYWN0X2FkZHJlc3MsIHRyYW5zYWN0aW9uX2hhc2ggfVxuICAgIH0gPSBhd2FpdCB0aGlzLmFjY291bnQuZGVjbGFyZUFuZERlcGxveSh7XG4gICAgICBjb250cmFjdDogdGhpcy5jb21waWxlZENvbnRyYWN0LFxuICAgICAgY2FzbTogdGhpcy5jYXNtLFxuICAgICAgY2xhc3NIYXNoOiB0aGlzLmNsYXNzSGFzaCxcbiAgICAgIGNvbXBpbGVkQ2xhc3NIYXNoOiB0aGlzLmNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgIHNhbHQ6IG9wdGlvbnMuYWRkcmVzc1NhbHRcbiAgICB9KTtcbiAgICBhc3NlcnQoQm9vbGVhbihjb250cmFjdF9hZGRyZXNzKSwgXCJEZXBsb3ltZW50IG9mIHRoZSBjb250cmFjdCBmYWlsZWRcIik7XG4gICAgY29uc3QgY29udHJhY3RJbnN0YW5jZSA9IG5ldyBDb250cmFjdChcbiAgICAgIHRoaXMuY29tcGlsZWRDb250cmFjdC5hYmksXG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgdGhpcy5hY2NvdW50XG4gICAgKTtcbiAgICBjb250cmFjdEluc3RhbmNlLmRlcGxveVRyYW5zYWN0aW9uSGFzaCA9IHRyYW5zYWN0aW9uX2hhc2g7XG4gICAgcmV0dXJuIGNvbnRyYWN0SW5zdGFuY2U7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaGVzIHRvIG5ldyBBY2NvdW50XG4gICAqXG4gICAqIEBwYXJhbSBhY2NvdW50IC0gbmV3IEFjY291bnQgdG8gYXR0YWNoIHRvXG4gICAqL1xuICBjb25uZWN0KGFjY291bnQpIHtcbiAgICB0aGlzLmFjY291bnQgPSBhY2NvdW50O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyBjdXJyZW50IGFiaSBhbmQgYWNjb3VudCB0byB0aGUgbmV3IGFkZHJlc3NcbiAgICovXG4gIGF0dGFjaChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBDb250cmFjdCh0aGlzLmFiaSwgYWRkcmVzcywgdGhpcy5hY2NvdW50KTtcbiAgfVxuICAvLyBldGhlcnMuanMnIGdldERlcGxveVRyYW5zYWN0aW9uIGNhbid0IGJlIHN1cHBvcnRlZCBhcyBpdCByZXF1aXJlcyB0aGUgYWNjb3VudCBvciBzaWduZXIgdG8gcmV0dXJuIGEgc2lnbmVkIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG5vdCBwb3NzaWJsZSB3aXRoIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uXG59O1xuXG4vLyBzcmMvdXRpbHMvcmVzcG9uc2VQYXJzZXIvaW50ZXJmYWNlLnRzXG52YXIgUmVzcG9uc2VQYXJzZXIgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvdXRpbHMvYWRkcmVzcy50c1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzMiB9IGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCI7XG5mdW5jdGlvbiBhZGRBZGRyZXNzUGFkZGluZyhhZGRyZXNzKSB7XG4gIGNvbnN0IGhleCA9IHRvSGV4KGFkZEhleFByZWZpeChhZGRyZXNzLnRvU3RyaW5nKCkpKTtcbiAgY29uc3QgcGFkZGVkID0gcmVtb3ZlSGV4UHJlZml4KGhleCkucGFkU3RhcnQoNjQsIFwiMFwiKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChwYWRkZWQpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MoYWRkcmVzcykge1xuICBjb25zdCByZXN1bHQgPSBhZGRBZGRyZXNzUGFkZGluZyhhZGRyZXNzKTtcbiAgaWYgKCFyZXN1bHQubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezY0fSQvKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQWRkcmVzcyBGb3JtYXRcIik7XG4gIH1cbiAgYXNzZXJ0SW5SYW5nZShyZXN1bHQsIFpFUk8sIEFERFJfQk9VTkQgLSAxbiwgXCJTdGFya25ldCBBZGRyZXNzXCIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgY29uc3QgY2hhcnMgPSByZW1vdmVIZXhQcmVmaXgodmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MoYWRkcmVzcykpLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCJcIik7XG4gIGNvbnN0IGhleCA9IHJlbW92ZUhleFByZWZpeChrZWNjYWtCbihhZGRyZXNzKSk7XG4gIGNvbnN0IGhhc2hlZCA9IGhleFRvQnl0ZXMyKGhleC5wYWRTdGFydCg2NCwgXCIwXCIpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGlmIChoYXNoZWRbaSA+PiAxXSA+PiA0ID49IDgpIHtcbiAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDE1KSA+PSA4KSB7XG4gICAgICBjaGFyc1tpICsgMV0gPSBjaGFyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkZEhleFByZWZpeChjaGFycy5qb2luKFwiXCIpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSA9PT0gYWRkcmVzcztcbn1cblxuLy8gc3JjL3V0aWxzL3VybC50c1xuaW1wb3J0IHVybGpvaW4gZnJvbSBcInVybC1qb2luXCI7XG52YXIgcHJvdG9jb2xBbmREb21haW5SRSA9IC9eKD86XFx3KzopP1xcL1xcLyhcXFMrKSQvO1xudmFyIGxvY2FsaG9zdERvbWFpblJFID0gL15sb2NhbGhvc3RbOj9cXGRdKig/OlteOj9cXGRdXFxTKik/JC87XG52YXIgbm9uTG9jYWxob3N0RG9tYWluUkUgPSAvXlteXFxzLl0rXFwuXFxTezIsfSQvO1xuZnVuY3Rpb24gaXNVcmwocykge1xuICBpZiAoIXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gcy5tYXRjaChwcm90b2NvbEFuZERvbWFpblJFKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCA9IG1hdGNoWzFdO1xuICBpZiAoIWV2ZXJ5dGhpbmdBZnRlclByb3RvY29sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsb2NhbGhvc3REb21haW5SRS50ZXN0KGV2ZXJ5dGhpbmdBZnRlclByb3RvY29sKSB8fCBub25Mb2NhbGhvc3REb21haW5SRS50ZXN0KGV2ZXJ5dGhpbmdBZnRlclByb3RvY29sKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVXJsKGJhc2VVcmwsIGRlZmF1bHRQYXRoLCB1cmxPclBhdGgpIHtcbiAgcmV0dXJuIGlzVXJsKHVybE9yUGF0aCkgPyB1cmxPclBhdGggOiB1cmxqb2luKGJhc2VVcmwsIHVybE9yUGF0aCA/PyBkZWZhdWx0UGF0aCk7XG59XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIG51bWJlciA9IG51bV9leHBvcnRzO1xuZXhwb3J0IHtcbiAgQWNjb3VudCxcbiAgQWNjb3VudEludGVyZmFjZSxcbiAgQmxvY2tTdGF0dXMsXG4gIEJsb2NrVGFnLFxuICBDYWlyb0N1c3RvbUVudW0sXG4gIENhaXJvT3B0aW9uLFxuICBDYWlyb09wdGlvblZhcmlhbnQsXG4gIENhaXJvUmVzdWx0LFxuICBDYWlyb1Jlc3VsdFZhcmlhbnQsXG4gIENhaXJvVWludDI1NixcbiAgQ2Fpcm9VaW50NTEyLFxuICBDYWxsRGF0YSxcbiAgQ29udHJhY3QsXG4gIENvbnRyYWN0RmFjdG9yeSxcbiAgQ29udHJhY3RJbnRlcmZhY2UsXG4gIEN1c3RvbUVycm9yLFxuICBFbnRyeVBvaW50VHlwZSxcbiAgRXRoU2lnbmVyLFxuICBHYXRld2F5RXJyb3IsXG4gIEh0dHBFcnJvcixcbiAgTGlicmFyeUVycm9yLFxuICBMaXRlcmFsLFxuICBScGNQcm92aWRlcjIgYXMgUHJvdmlkZXIsXG4gIFByb3ZpZGVySW50ZXJmYWNlLFxuICBhcGlfZXhwb3J0cyBhcyBSUEMsXG4gIHJwY18wXzZfZXhwb3J0cyBhcyBSUEMwNixcbiAgcnBjXzBfN19leHBvcnRzIGFzIFJQQzA3LFxuICBSUENSZXNwb25zZVBhcnNlcixcbiAgUmVjZWlwdFR4LFxuICBSZXNwb25zZVBhcnNlcixcbiAgUnBjQ2hhbm5lbDIgYXMgUnBjQ2hhbm5lbCxcbiAgUnBjUHJvdmlkZXIyIGFzIFJwY1Byb3ZpZGVyLFxuICBTaWduZXIsXG4gIFNpZ25lckludGVyZmFjZSxcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMsXG4gIFRyYW5zYWN0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvblR5cGUsXG4gIFR5cGVkRGF0YVJldmlzaW9uLFxuICBVSU5UXzEyOF9NQVgsXG4gIFVJTlRfMTI4X01JTixcbiAgVUlOVF8yNTZfSElHSF9NQVgsXG4gIFVJTlRfMjU2X0hJR0hfTUlOLFxuICBVSU5UXzI1Nl9MT1dfTUFYLFxuICBVSU5UXzI1Nl9MT1dfTUlOLFxuICBVSU5UXzI1Nl9NQVgsXG4gIFVJTlRfMjU2X01JTixcbiAgVUlOVF81MTJfTUFYLFxuICBVSU5UXzUxMl9NSU4sXG4gIFVpbnQsXG4gIFZhbGlkYXRlVHlwZSxcbiAgV2FsbGV0QWNjb3VudCxcbiAgYWRkQWRkcmVzc1BhZGRpbmcsXG4gIGJ1aWxkVXJsLFxuICBieXRlQXJyYXlfZXhwb3J0cyBhcyBieXRlQXJyYXksXG4gIGNhaXJvX2V4cG9ydHMgYXMgY2Fpcm8sXG4gIGNvbnN0YW50c19leHBvcnRzIGFzIGNvbnN0YW50cyxcbiAgY29udHJhY3RDbGFzc1Jlc3BvbnNlVG9MZWdhY3lDb21waWxlZENvbnRyYWN0LFxuICBkZWZhdWx0UHJvdmlkZXIsXG4gIGVjX2V4cG9ydHMgYXMgZWMsXG4gIGVuY29kZV9leHBvcnRzIGFzIGVuY29kZSxcbiAgZXRoX2V4cG9ydHMgYXMgZXRoLFxuICBldmVudHNfZXhwb3J0cyBhcyBldmVudHMsXG4gIGV4dHJhY3RDb250cmFjdEhhc2hlcyxcbiAgZml4UHJvdG8sXG4gIGZpeFN0YWNrLFxuICBnZXRDYWxsZGF0YSxcbiAgZ2V0Q2hlY2tzdW1BZGRyZXNzLFxuICBoYXNoX2V4cG9ydHMgYXMgaGFzaCxcbiAgaXNTaWVycmEsXG4gIGlzVXJsLFxuICBqc29uX2V4cG9ydHMgYXMganNvbixcbiAgbWVya2xlX2V4cG9ydHMgYXMgbWVya2xlLFxuICBudW1fZXhwb3J0cyBhcyBudW0sXG4gIG51bWJlcixcbiAgcGFyc2VDYWxsZGF0YUZpZWxkLFxuICBwcm92aWRlcl9leHBvcnRzIGFzIHByb3ZpZGVyLFxuICBzZWxlY3Rvcl9leHBvcnRzIGFzIHNlbGVjdG9yLFxuICBzaG9ydFN0cmluZ19leHBvcnRzIGFzIHNob3J0U3RyaW5nLFxuICBzcGxpdEFyZ3NBbmRPcHRpb25zLFxuICBzdGFya19leHBvcnRzIGFzIHN0YXJrLFxuICBzdGFya25ldElkX2V4cG9ydHMgYXMgc3RhcmtuZXRJZCxcbiAgdHJhbnNhY3Rpb25fZXhwb3J0cyBhcyB0cmFuc2FjdGlvbixcbiAgdHlwZWREYXRhX2V4cG9ydHMgYXMgdHlwZWREYXRhLFxuICB0eXBlc19leHBvcnRzIGFzIHR5cGVzLFxuICB1aW50MjU2X2V4cG9ydHMgYXMgdWludDI1NixcbiAgdjJfZXhwb3J0cyBhcyB2Mmhhc2gsXG4gIHYzX2V4cG9ydHMgYXMgdjNoYXNoLFxuICB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyxcbiAgdmFsaWRhdGVDaGVja3N1bUFkZHJlc3MsXG4gIGNvbm5lY3RfZXhwb3J0cyBhcyB3YWxsZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19nZXRPd25Qcm9wRGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZ2V0T3duUHJvcE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9faGFzT3duUHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsIl9fY29weVByb3BzIiwidG8iLCJmcm9tIiwiZXhjZXB0IiwiZGVzYyIsImtleSIsImNhbGwiLCJfX3JlRXhwb3J0IiwibW9kIiwic2Vjb25kVGFyZ2V0IiwiY29uc3RhbnRzX2V4cG9ydHMiLCJBRERSX0JPVU5EIiwiQVBJX1ZFUlNJT04iLCJCYXNlVXJsIiwiRmVlTWFyZ2luUGVyY2VudGFnZSIsIklTX0JST1dTRVIiLCJNQVNLXzI1MCIsIk1BWF9TVE9SQUdFX0lURU1fU0laRSIsIk5ldHdvcmtOYW1lIiwiUFJJTUUiLCJSQU5HRV9GRUxUIiwiUkFOR0VfSTEyOCIsIlJBTkdFX1UxMjgiLCJSUENfREVGQVVMVF9WRVJTSU9OIiwiUlBDX05PREVTIiwiU3RhcmtuZXRDaGFpbklkIiwiVEVYVF9UT19GRUxUX01BWF9MRU4iLCJUUkFOU0FDVElPTl9WRVJTSU9OIiwiYXBpX2V4cG9ydHMiLCJFVHJhbnNhY3Rpb25WZXJzaW9uIiwiVHJhbnNhY3Rpb25IYXNoUHJlZml4IiwiVURDIiwiWkVSTyIsIkpSUEMiLCJqc29ucnBjX2V4cG9ydHMiLCJSUENTUEVDMDYiLCJycGNzcGVjXzBfNl9leHBvcnRzIiwiUlBDU1BFQzA3IiwiRUJsb2NrVGFnIiwiRURBTW9kZSIsIkVEYXRhQXZhaWxhYmlsaXR5TW9kZSIsIkVTaW11bGF0aW9uRmxhZyIsIkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyIsIkVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzIiwiRVRyYW5zYWN0aW9uU3RhdHVzIiwiRVRyYW5zYWN0aW9uVHlwZSIsIkVUcmFuc2FjdGlvblZlcnNpb24yIiwiRVRyYW5zYWN0aW9uVmVyc2lvbjMiLCJFcnJvcnMiLCJlcnJvcnNfZXhwb3J0cyIsIlNQRUMiLCJjb21wb25lbnRzX2V4cG9ydHMiLCJFVHJhbnNhY3Rpb25UeXBlMiIsIkVTaW11bGF0aW9uRmxhZzIiLCJFVHJhbnNhY3Rpb25TdGF0dXMyIiwiRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyIiwiRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMiIsIkVCbG9ja1RhZzIiLCJFRGF0YUF2YWlsYWJpbGl0eU1vZGUzIiwiRURBTW9kZTQiLCJFVHJhbnNhY3Rpb25WZXJzaW9uMTAiLCJFVHJhbnNhY3Rpb25WZXJzaW9uMjUiLCJFVHJhbnNhY3Rpb25WZXJzaW9uMzYiLCJzdGFya25ldF90eXBlc18wN19zdGFyIiwiZW5jb2RlX2V4cG9ydHMiLCJhZGRIZXhQcmVmaXgiLCJhcnJheUJ1ZmZlclRvU3RyaW5nIiwiYXRvYlVuaXZlcnNhbCIsImJ0b2FVbml2ZXJzYWwiLCJidWYyaGV4IiwiY2FsY0J5dGVMZW5ndGgiLCJwYWRMZWZ0IiwicGFzY2FsVG9TbmFrZSIsInJlbW92ZUhleFByZWZpeCIsInNhbml0aXplQnl0ZXMiLCJzYW5pdGl6ZUhleCIsInN0cmluZ1RvQXJyYXlCdWZmZXIiLCJ1dGY4VG9BcnJheSIsImJhc2U2NCIsIlNUUklOR19aRVJPIiwiYXJyYXkiLCJVaW50OEFycmF5IiwicmVkdWNlIiwiZGF0YSIsImJ5dGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImEiLCJkZWNvZGUiLCJiIiwiYnVmZmVyIiwiciIsIngiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiaGV4IiwicmVwbGFjZSIsInBhZFN0cmluZyIsImxlbmd0aCIsImxlZnQiLCJwYWRkaW5nIiwiZGlmZiIsInJlc3VsdCIsInBhZCIsInJlcGVhdCIsImJ5dGVTaXplIiwicmVtYWluZGVyIiwidGV4dCIsInRlc3QiLCJzcGxpdCIsImpvaW4iLCJ0b1VwcGVyQ2FzZSIsInJhbmdlIiwibWluIiwibWF4IiwiQmFzZVVybDIiLCJOZXR3b3JrTmFtZTIiLCJTdGFya25ldENoYWluSWQ2IiwiVHJhbnNhY3Rpb25IYXNoUHJlZml4MiIsIkZlZU1hcmdpblBlcmNlbnRhZ2UyIiwiQUREUkVTUyIsIkVOVFJZUE9JTlQiLCJTTl9NQUlOIiwiU05fU0VQT0xJQSIsImJ5dGVzVG9IZXgiLCJrZWNjYWtfMjU2IiwicnBjXzBfNl9leHBvcnRzIiwiUnBjQ2hhbm5lbCIsImZpeFN0YWNrIiwiZm4iLCJjb25zdHJ1Y3RvciIsImNhcHR1cmVTdGFja1RyYWNlIiwiRXJyb3IiLCJmaXhQcm90byIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQ3VzdG9tRXJyb3IiLCJtZXNzYWdlIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJMaWJyYXJ5RXJyb3IiLCJHYXRld2F5RXJyb3IiLCJlcnJvckNvZGUiLCJIdHRwRXJyb3IiLCJ0eXBlc19leHBvcnRzIiwiQmxvY2tTdGF0dXMiLCJCbG9ja1RhZyIsIkVudHJ5UG9pbnRUeXBlIiwiTGl0ZXJhbCIsIlJQQyIsIlRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzIiwiVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyIsIlRyYW5zYWN0aW9uU3RhdHVzIiwiVHJhbnNhY3Rpb25UeXBlIiwiVHlwZWREYXRhUmV2aXNpb24iLCJVaW50IiwiVmFsaWRhdGVUeXBlIiwiVmFsaWRhdGVUeXBlMiIsIlVpbnQyIiwiTGl0ZXJhbDIiLCJFbnRyeVBvaW50VHlwZTIiLCJUcmFuc2FjdGlvblR5cGUyIiwiVHJhbnNhY3Rpb25TdGF0dXMyIiwiVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czIiLCJUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czIiLCJCbG9ja1N0YXR1czIiLCJCbG9ja1RhZzIiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJudW1fZXhwb3J0cyIsImFkZFBlcmNlbnQiLCJhc3NlcnRJblJhbmdlIiwiYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheSIsImJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5IiwiY2xlYW5IZXgiLCJnZXREZWNpbWFsU3RyaW5nIiwiZ2V0SGV4U3RyaW5nIiwiZ2V0SGV4U3RyaW5nQXJyYXkiLCJoZXhUb0J5dGVzIiwiaGV4VG9EZWNpbWFsU3RyaW5nIiwiaXNCaWdJbnQiLCJpc0Jvb2xlYW4iLCJpc0hleCIsImlzTnVtYmVyIiwiaXNTdHJpbmdXaG9sZU51bWJlciIsInRvQmlnSW50IiwidG9DYWlyb0Jvb2wiLCJ0b0hleCIsInRvSGV4U3RyaW5nIiwidG9TdG9yYWdlS2V5IiwiaGV4VG9CeXRlc05vYmxlIiwiQmlnSW50IiwibnVtYmVyMiIsInRvTG93ZXJDYXNlIiwiaW5wdXQiLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsImlucHV0TmFtZSIsIm1lc3NhZ2VTdWZmaXgiLCJpbnB1dEJpZ0ludCIsImxvd2VyQm91bmRCaWdJbnQiLCJ1cHBlckJvdW5kQmlnSW50IiwibWFwIiwiYWRhcHRlZFZhbHVlIiwicGVyY2VudCIsImJpZ0ludE51bSIsInNlbGVjdG9yX2V4cG9ydHMiLCJnZXRTZWxlY3RvciIsImdldFNlbGVjdG9yRnJvbU5hbWUiLCJrZWNjYWtCbiIsInN0YXJrbmV0S2VjY2FrIiwia2VjY2FrIiwiaGV4V2l0aG91dFByZWZpeCIsImV2ZW5IZXgiLCJrZWNjYWtIZXgiLCJoYXNoIiwiZnVuY05hbWUiLCJzaG9ydFN0cmluZ19leHBvcnRzIiwiZGVjb2RlU2hvcnRTdHJpbmciLCJlbmNvZGVTaG9ydFN0cmluZyIsImlzQVNDSUkiLCJpc0RlY2ltYWxTdHJpbmciLCJpc0xvbmdUZXh0IiwiaXNTaG9ydFN0cmluZyIsImlzU2hvcnRUZXh0IiwiaXNTdHJpbmciLCJpc1RleHQiLCJzcGxpdExvbmdTdHJpbmciLCJ2YWwiLCJsb25nU3RyIiwicmVnZXgiLCJSZWdFeHAiLCJtYXRjaCIsImNoYXIiLCJjaGFyQ29kZUF0IiwicGFyc2VJbnQiLCJjb25jYXQiLCJieXRlQXJyYXlfZXhwb3J0cyIsImJ5dGVBcnJheUZyb21TdHJpbmciLCJzdHJpbmdGcm9tQnl0ZUFycmF5IiwibXlCeXRlQXJyYXkiLCJwZW5kaW5nX3dvcmQiLCJjdW11bGVkU3RyaW5nIiwiZW5jb2RlZFN0cmluZyIsImFkZCIsInRhcmdldFN0cmluZyIsInNob3J0U3RyaW5ncyIsInNob3J0U3RyaW5nc0VuY29kZWQiLCJwZW5kaW5nV29yZCIsInBlbmRpbmdXb3JkTGVuZ3RoIiwicG9wIiwicGVuZGluZ193b3JkX2xlbiIsImNhaXJvX2V4cG9ydHMiLCJmZWx0IiwiZ2V0QWJpQ29udHJhY3RWZXJzaW9uIiwiZ2V0QXJyYXlUeXBlIiwiaXNDYWlybzFBYmkiLCJpc0NhaXJvMVR5cGUiLCJpc0xlbiIsImlzVHlwZUFycmF5IiwiaXNUeXBlQm9vbCIsImlzVHlwZUJ5dGVBcnJheSIsImlzVHlwZUJ5dGVzMzEiLCJpc1R5cGVDb250cmFjdEFkZHJlc3MiLCJpc1R5cGVFbnVtIiwiaXNUeXBlRXRoQWRkcmVzcyIsImlzVHlwZUZlbHQiLCJpc1R5cGVMaXRlcmFsIiwiaXNUeXBlTmFtZWRUdXBsZSIsImlzVHlwZU5vblplcm8iLCJpc1R5cGVPcHRpb24iLCJpc1R5cGVSZXN1bHQiLCJpc1R5cGVTZWNwMjU2azFQb2ludCIsImlzVHlwZVN0cnVjdCIsImlzVHlwZVR1cGxlIiwiaXNUeXBlVWludCIsImlzVHlwZVVpbnQyNTYiLCJ0dXBsZSIsInVpbnQyNTYiLCJ1aW50NTEyIiwiQ2Fpcm9GZWx0IiwiaXQiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJVSU5UXzEyOF9NQVgiLCJVSU5UXzI1Nl9NQVgiLCJVSU5UXzI1Nl9NSU4iLCJVSU5UXzI1Nl9MT1dfTUFYIiwiVUlOVF8yNTZfSElHSF9NQVgiLCJVSU5UXzI1Nl9MT1dfTUlOIiwiVUlOVF8yNTZfSElHSF9NSU4iLCJDYWlyb1VpbnQyNTYiLCJfQ2Fpcm9VaW50MjU2IiwiYWJpU2VsZWN0b3IiLCJhcnIiLCJwcm9wcyIsInZhbGlkYXRlUHJvcHMiLCJsb3ciLCJoaWdoIiwiYmlnSW50IiwidmFsaWRhdGUiLCJiaWdOdW1iZXJpc2giLCJiaWdJbnRMb3ciLCJiaWdJbnRIaWdoIiwiaXMiLCJlcnJvciIsImlzQWJpVHlwZSIsImFiaVR5cGUiLCJ0b1VpbnQyNTZIZXhTdHJpbmciLCJ0b1VpbnQyNTZEZWNpbWFsU3RyaW5nIiwidG9BcGlSZXF1ZXN0IiwiVUlOVF81MTJfTUFYIiwiVUlOVF81MTJfTUlOIiwiVUlOVF8xMjhfTUlOIiwiQ2Fpcm9VaW50NTEyIiwiX0NhaXJvVWludDUxMiIsImxpbWIwIiwibGltYjEiLCJsaW1iMiIsImxpbWIzIiwibDAiLCJsMSIsImwyIiwibDMiLCJmb3JFYWNoIiwiaW5kZXgiLCJ0b1VpbnQ1MTJIZXhTdHJpbmciLCJ0b1VpbnQ1MTJEZWNpbWFsU3RyaW5nIiwidHlwZSIsInN0YXJ0c1dpdGgiLCJpbmNsdWRlcyIsInN0cnVjdHMiLCJlbnVtcyIsInZhbHVlcyIsInN1YnN0cmluZyIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImFiaSIsImNhaXJvIiwiZmluZCIsImNvbXBpbGVyIiwidGVzdEZ1bmN0aW9uIiwiaW5wdXRzIiwib3V0cHV0cyIsImlvIiwiYXJncyIsIkNhaXJvQ3VzdG9tRW51bSIsImVudW1Db250ZW50IiwidmFyaWFudHNMaXN0IiwibmJBY3RpdmVWYXJpYW50cyIsImZpbHRlciIsImNvbnRlbnQiLCJ2YXJpYW50IiwidW53cmFwIiwidmFyaWFudHMiLCJlbnRyaWVzIiwiYWN0aXZlVmFyaWFudCIsIml0ZW0iLCJDYWlyb09wdGlvblZhcmlhbnQiLCJDYWlyb09wdGlvblZhcmlhbnQyIiwiQ2Fpcm9PcHRpb24iLCJzb21lQ29udGVudCIsIlNvbWUiLCJOb25lIiwiaXNTb21lIiwiaXNOb25lIiwiQ2Fpcm9SZXN1bHRWYXJpYW50IiwiQ2Fpcm9SZXN1bHRWYXJpYW50MiIsIkNhaXJvUmVzdWx0IiwicmVzdWx0Q29udGVudCIsIk9rIiwiRXJyIiwiaXNPayIsImlzRXJyIiwiZ3VhcmQiLCJpc0JOIiwidW5rbm93biIsImZvcm1hdHRlciIsInNhbWVUeXBlIiwiYWNjIiwiZWxUeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyYXlTdHIiLCJfIiwiYXJyYXlPYmoiLCJBYmlQYXJzZXIxIiwibWV0aG9kSW5wdXRzTGVuZ3RoIiwiYWJpTWV0aG9kIiwiZ2V0TWV0aG9kIiwiZ2V0TGVnYWN5Rm9ybWF0IiwiQWJpUGFyc2VyMiIsImludGYiLCJpdGVtcyIsImZsYXRNYXAiLCJlIiwiY3JlYXRlQWJpUGFyc2VyIiwidmVyc2lvbiIsImdldEFiaVZlcnNpb24iLCJpc05vQ29uc3RydWN0b3JWYWxpZCIsIm1ldGhvZCIsImFyZ3NDYWxsZGF0YSIsInBhcnNlTmFtZWRUdXBsZSIsIm5hbWVkVHVwbGUiLCJwYXJzZVN1YlR1cGxlIiwicyIsInN1YlR1cGxlIiwiaSIsImNvdW50ZXIiLCJsQnJhY2tldCIsInB1c2giLCJleHRyYWN0Q2Fpcm8wVHVwbGUiLCJjbGVhblR5cGUiLCJzbGljZSIsInJlY29tcG9zZWQiLCJzaGlmdCIsImdldENsb3N1cmVPZmZzZXQiLCJvcGVuIiwiY2xvc2UiLCJQT1NJVElWRV9JTkZJTklUWSIsImV4dHJhY3RDYWlybzFUdXBsZSIsImN1cnJlbnRJbmRleCIsImxpbWl0SW5kZXgiLCJjb21tYUluZGV4IiwiZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXMiLCJlcnJvclUyNTYiLCJlcnJvclU1MTIiLCJvcmRlclByb3BzQnlBYmkiLCJ1bm9yZGVyZWRPYmplY3QiLCJhYmlPZk9iamVjdCIsIm9yZGVySW5wdXQiLCJ1bm9yZGVyZWRJdGVtIiwib3JkZXJBcnJheSIsImFiaU9iaiIsIm9yZGVyRW51bSIsIm9yZGVyVHVwbGUiLCJ1MjU2IiwidTUxMiIsImV2ZXJ5IiwiYWJpT2ZTdHJ1Y3QiLCJtZW1iZXJzIiwib3JkZXJTdHJ1Y3QiLCJ1bm9yZGVyZWRPYmplY3QyIiwiYWJpT2JqZWN0Iiwib3JkZXJlZE9iamVjdDIiLCJvcmRlcmVkT2JqZWN0IiwiYWJpUGFyYW0iLCJzZXRQcm9wZXJ0eSIsIm15QXJyYXkiLCJ0eXBlSW5BcnJheSIsIm15RWxlbSIsInR5cGVMaXN0IiwiYWJpVHlwZUNhaXJvWCIsIm15T2JqS2V5cyIsImtleXMiLCJ1bm9yZGVyZWRSZXN1bHQiLCJyZXN1bHRPa1R5cGUiLCJyZXN1bHRFcnJUeXBlIiwidW5vcmRlcmVkT3B0aW9uIiwicmVzdWx0U29tZVR5cGUiLCJ1bm9yZGVyZWRDdXN0b21FbnVtIiwibmV3RW50cmllcyIsInZhcmlhbnRUeXBlIiwiZnJvbUVudHJpZXMiLCJmaW5hbE9yZGVyZWRPYmplY3QiLCJwYXJzZUJhc2VUeXBlcyIsInB1YktleUVUSCIsInB1YktleUVUSHkiLCJwdWJLZXlFVEh4IiwicGFyc2VUdXBsZSIsImVsZW1lbnQiLCJ0eXBlU3RyIiwibWVtYmVyVHlwZXMiLCJlbGVtZW50cyIsImR4IiwicGFyc2VCeXRlQXJyYXkiLCJibiIsInBhcnNlQ2FsbGRhdGFWYWx1ZSIsImFycmF5VHlwZSIsInN1YkVsZW1lbnQiLCJ0dXBsZWQiLCJwYXJzZWREYXRhIiwibXlPcHRpb24iLCJsaXN0VHlwZVZhcmlhbnQyIiwidHlwZVZhcmlhbnRTb21lIiwicGFyc2VkUGFyYW1ldGVyMiIsIm15UmVzdWx0IiwibGlzdFR5cGVWYXJpYW50MyIsInR5cGVWYXJpYW50T2siLCJwYXJzZWRQYXJhbWV0ZXIzIiwidHlwZVZhcmlhbnRFcnIiLCJteUVudW0iLCJsaXN0VHlwZVZhcmlhbnQiLCJ0eXBlQWN0aXZlVmFyaWFudCIsIm51bUFjdGl2ZVZhcmlhbnQiLCJmaW5kSW5kZXgiLCJwYXJzZWRQYXJhbWV0ZXIiLCJwYXJzZUNhbGxkYXRhRmllbGQiLCJhcmdzSXRlcmF0b3IiLCJuZXh0IiwicGFyc2VCYXNlVHlwZXMyIiwidGVtcCIsIkJvb2xlYW4iLCJ4TG93IiwieEhpZ2giLCJ5TG93IiwieUhpZ2giLCJwdWJLIiwicGFyc2VSZXNwb25zZVZhbHVlIiwicmVzcG9uc2VJdGVyYXRvciIsInBhcnNlZEJ5dGVzMzFBcnIiLCJieXRlczMxQXJyTGVuIiwicGFyc2VkRGF0YUFyciIsImVsIiwibGVuIiwidmFyaWFudE51bSIsInJhd0VudW0iLCJudW0iLCJjdXN0b21FbnVtIiwiaWR4IiwicmVzcG9uc2VQYXJzZXIiLCJvdXRwdXQiLCJwYXJzZWRSZXN1bHQiLCJhcnJMZW4iLCJ2YWxpZGF0ZUZlbHQiLCJwYXJhbWV0ZXIiLCJwYXJhbSIsInZhbGlkYXRlQnl0ZXMzMSIsInZhbGlkYXRlQnl0ZUFycmF5IiwidmFsaWRhdGVVaW50IiwiTUFYX1NBRkVfSU5URUdFUiIsInZhbGlkYXRlQm9vbCIsInZhbGlkYXRlU3RydWN0IiwidmFsaWRhdGVFbnVtIiwibWV0aG9kc0tleXMiLCJnZXRQcm90b3R5cGVPZiIsInZhbGlkYXRlVHVwbGUiLCJ2YWxpZGF0ZUFycmF5IiwiYmFzZVR5cGUiLCJ2YWxpZGF0ZU5vblplcm8iLCJ2YWxpZGF0ZUZpZWxkcyIsIkNhbGxEYXRhIiwiX0NhbGxEYXRhIiwiZ2V0QWJpU3RydWN0IiwiZ2V0QWJpRW51bSIsInBhcnNlciIsImludm9jYWJsZUZ1bmN0aW9uTmFtZXMiLCJpc1ZpZXciLCJzdGF0ZU11dGFiaWxpdHkiLCJzdGF0ZV9tdXRhYmlsaXR5IiwiaW5wdXRzTGVuZ3RoIiwiY29tcGlsZSIsImFiaUZ1bmN0aW9uIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjYWxsQXJyYXkiLCJ3cml0YWJsZSIsInJhd0FyZ3MiLCJjcmVhdGVUcmVlIiwib2JqIiwiZ2V0RW50cmllcyIsIm8iLCJwcmVmaXgiLCJvZSIsImsiLCJ2Iiwia2siLCJ2YXJpYW50TmIiLCJsaXN0VmFyaWFudHMiLCJhY3RpdmVWYXJpYW50TmIiLCJjYWxsVHJlZUFycmF5IiwiY2FsbFRyZWUiLCJjYWxsT2JqIiwicGFyc2UiLCJyZXNwb25zZSIsImZsYXQiLCJwYXJzZWQiLCJwcm9wTmFtZSIsImZvcm1hdCIsImFiaUVudHJ5IiwiZnVsbEVudW1MaXN0IiwidG9DYWxsZGF0YSIsInJhd0NhbGxkYXRhIiwicmF3IiwiY2FsbGRhdGEiLCJkZWNvZGVQYXJhbWV0ZXJzIiwidHlwZUNhaXJvIiwidHlwZUNhaXJvQXJyYXkiLCJkZWNvZGVkQXJyYXkiLCJ0eXBlUGFyYW0iLCJoYXNoX2V4cG9ydHMiLCJjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaCIsImNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2giLCJjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyIsImNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2giLCJjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyIsImNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaCIsImNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIiLCJjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2giLCJjb21wdXRlQ29udHJhY3RDbGFzc0hhc2giLCJjb21wdXRlSGFzaE9uRWxlbWVudHMiLCJjb21wdXRlSGFzaE9uRWxlbWVudHMyIiwiY29tcHV0ZUhpbnRlZENsYXNzSGFzaCIsImNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaCIsImNvbXB1dGVQZWRlcnNlbkhhc2giLCJjb21wdXRlUGVkZXJzZW5IYXNoT25FbGVtZW50cyIsImNvbXB1dGVQb3NlaWRvbkhhc2giLCJjb21wdXRlUG9zZWlkb25IYXNoT25FbGVtZW50cyIsImNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaCIsImZvcm1hdFNwYWNlcyIsImhhc2hCeXRlQ29kZVNlZ21lbnRzIiwicG9zZWlkb24iLCJ2Ml9leHBvcnRzIiwiY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoIiwiY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uIiwiZWNfZXhwb3J0cyIsInN0YXJrQ3VydmUiLCJ3ZWllcnN0cmFzcyIsInkiLCJwZWRlcnNlbiIsInR4SGFzaFByZWZpeCIsImNvbnRyYWN0QWRkcmVzcyIsImVudHJ5UG9pbnRTZWxlY3RvciIsIm1heEZlZSIsImNoYWluSWQiLCJhZGRpdGlvbmFsRGF0YSIsImNhbGxkYXRhSGFzaCIsImRhdGFUb0hhc2giLCJjbGFzc0hhc2giLCJzZW5kZXJBZGRyZXNzIiwibm9uY2UiLCJjb21waWxlZENsYXNzSGFzaCIsImNvbnN0cnVjdG9yQ2FsbGRhdGEiLCJzYWx0IiwidjNfZXhwb3J0cyIsImNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gyIiwiY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDIiLCJjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yIiwiaGFzaERBTW9kZSIsImhhc2hGZWVGaWVsZCIsInBvc2VpZG9uSGFzaE1hbnkiLCJBVG9CSSIsIkRBVEFfQVZBSUxBQklMSVRZX01PREVfQklUUyIsIk1BWF9BTU9VTlRfQklUUyIsIk1BWF9QUklDRV9QRVJfVU5JVF9CSVRTIiwiUkVTT1VSQ0VfVkFMVUVfT0ZGU0VUIiwiTDFfR0FTX05BTUUiLCJMMl9HQVNfTkFNRSIsIm5vbmNlREFNb2RlIiwiZmVlREFNb2RlIiwidGlwIiwiYm91bmRzIiwiTDFCb3VuZCIsImwxX2dhcyIsIm1heF9hbW91bnQiLCJtYXhfcHJpY2VfcGVyX3VuaXQiLCJMMkJvdW5kIiwibDJfZ2FzIiwicGF5bWFzdGVyRGF0YSIsIm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUiLCJmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSIsInJlc291cmNlQm91bmRzIiwiZmVlRmllbGRIYXNoIiwiZEFNb2RlSGFzaCIsImNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSIsImFjY291bnREZXBsb3ltZW50RGF0YSIsImNvbXBpbGVkQ2FsbGRhdGEiLCJpc1YzSW52b2tlVHgiLCJWMyIsIkYzIiwiaXNWM0RlY2xhcmVUeCIsImlzVjNEZXBsb3lBY2NvdW50VHgiLCJwb3NlaWRvbkhhc2hNYW55MiIsImpzb25fZXhwb3J0cyIsInBhcnNlMiIsInBhcnNlQWx3YXlzQXNCaWciLCJzdHJpbmdpZnkiLCJzdHJpbmdpZnkyIiwic3RyaW5naWZ5QWx3YXlzQXNCaWciLCJqc29uIiwicGFyc2VJbnRBc051bWJlck9yQmlnSW50IiwicGFyc2VGbG9hdCIsImlzU2FmZUludGVnZXIiLCJwYXJzZU51bWJlckFuZEJpZ0ludCIsInJlcGxhY2VyIiwic3BhY2UiLCJudW1iZXJTdHJpbmdpZmllcnMiLCJwb3NlaWRvbkhhc2giLCJkZXBsb3llckFkZHJlc3MiLCJjb25zdHJ1Y3RvckNhbGxkYXRhSGFzaCIsIkNPTlRSQUNUX0FERFJFU1NfUFJFRklYIiwibnVsbFNraXBSZXBsYWNlciIsImpzb24yIiwiaW5zaWRlUXVvdGVzIiwibmV3U3RyaW5nIiwiY29tcGlsZWRDb250cmFjdCIsInByb2dyYW0iLCJjb250cmFjdENsYXNzIiwic2VyaWFsaXplZEpzb24iLCJjb250cmFjdCIsImFwaVZlcnNpb24iLCJleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCIsImVudHJ5X3BvaW50c19ieV90eXBlIiwiRVhURVJOQUwiLCJzZWxlY3RvciIsIm9mZnNldCIsImwxSGFuZGxlckVudHJ5UG9pbnRzSGFzaCIsIkwxX0hBTkRMRVIiLCJjb25zdHJ1Y3RvckVudHJ5UG9pbnRIYXNoIiwiQ09OU1RSVUNUT1IiLCJidWlsdGluc0hhc2giLCJidWlsdGlucyIsImhpbnRlZENsYXNzSGFzaCIsImRhdGFIYXNoIiwiaGFzaEJ1aWx0aW5zIiwiaGFzaEVudHJ5UG9pbnQiLCJiYXNlIiwiY2FzbSIsImJ5dGVDb2RlIiwiYnl0ZWNvZGUiLCJuIiwiYnl0ZWNvZGVTZWdtZW50TGVuZ3RocyIsImJ5dGVjb2RlX3NlZ21lbnRfbGVuZ3RocyIsInNlZ21lbnRTdGFydCIsImhhc2hMZWF2ZXMiLCJzZWdtZW50IiwiQ09NUElMRURfQ0xBU1NfVkVSU0lPTiIsImNvbXBpbGVkQ2xhc3NWZXJzaW9uIiwibDFIYW5kbGVycyIsImhhc2hFbnRyeVBvaW50U2llcnJhIiwiZnVuY3Rpb25faWR4IiwiaGFzaEFiaSIsInNpZXJyYSIsImluZGVudFN0cmluZyIsIkNPTlRSQUNUX0NMQVNTX1ZFUlNJT04iLCJhYmlIYXNoIiwic2llcnJhUHJvZ3JhbSIsInNpZXJyYV9wcm9ncmFtIiwic3RhcmtfZXhwb3J0cyIsImNvbXByZXNzUHJvZ3JhbSIsImRlY29tcHJlc3NQcm9ncmFtIiwiZXN0aW1hdGVGZWVUb0JvdW5kcyIsImVzdGltYXRlZEZlZVRvTWF4RmVlIiwiZm9ybWF0U2lnbmF0dXJlIiwiaW50REFNIiwibWFrZUFkZHJlc3MiLCJyYW5kb21BZGRyZXNzIiwicmVkdWNlVjIiLCJzaWduYXR1cmVUb0RlY2ltYWxBcnJheSIsInNpZ25hdHVyZVRvSGV4QXJyYXkiLCJ0b0ZlZVZlcnNpb24iLCJ0b1RyYW5zYWN0aW9uVmVyc2lvbiIsInYzRGV0YWlscyIsImdldFN0YXJrS2V5IiwidXRpbHMiLCJnemlwIiwidW5nemlwIiwianNvblByb2dyYW0iLCJzdHJpbmdpZmllZCIsImNvbXByZXNzZWRQcm9ncmFtIiwiYmFzZTY0MiIsImRlY29tcHJlc3NlZCIsInJhbmRvbUtleVBhaXIiLCJyYW5kb21Qcml2YXRlS2V5Iiwic2lnIiwiZXN0aW1hdGVkRmVlIiwib3ZlcmhlYWQiLCJlc3RpbWF0ZSIsImFtb3VudE92ZXJoZWFkIiwicHJpY2VPdmVyaGVhZCIsImdhc19jb25zdW1lZCIsImdhc19wcmljZSIsIm1heFVuaXRzIiwiZGF0YV9nYXNfY29uc3VtZWQiLCJkYXRhX2dhc19wcmljZSIsIm92ZXJhbGxfZmVlIiwibWF4VW5pdFByaWNlIiwiZGFtIiwiTDEiLCJMMiIsImRlZmF1bHRWZXJzaW9uIiwicHJvdmlkZWRWZXJzaW9uIiwicHJvdmlkZWRWZXJzaW9uMHhzIiwiZGVmYXVsdFZlcnNpb24weHMiLCJWMCIsIkYwIiwiVjEiLCJGMSIsIlYyIiwiRjIiLCJkZXRhaWxzIiwiaXNTaWVycmEiLCJleHRyYWN0Q29udHJhY3RIYXNoZXMiLCJwYXlsb2FkIiwiY29udHJhY3RDbGFzc1Jlc3BvbnNlVG9MZWdhY3lDb21waWxlZENvbnRyYWN0IiwiY2NyIiwiZXRoX2V4cG9ydHMiLCJldGhSYW5kb21Qcml2YXRlS2V5IiwidmFsaWRhdGVBbmRQYXJzZUV0aEFkZHJlc3MiLCJzZWNwMjU2azEiLCJhZGRyZXNzIiwibWFrZUZldGNoQ29va2llIiwiaXNvbW9ycGhpY0ZldGNoIiwiZmV0Y2hQb255ZmlsbF9kZWZhdWx0Iiwid2luZG93IiwiZmV0Y2giLCJnbG9iYWwiLCJwcm92aWRlcl9leHBvcnRzIiwiQmxvY2siLCJjcmVhdGVTaWVycmFDb250cmFjdENsYXNzIiwiZ2V0RGVmYXVsdE5vZGVVcmwiLCJpc1BlbmRpbmdCbG9jayIsImlzUGVuZGluZ1N0YXRlVXBkYXRlIiwiaXNQZW5kaW5nVHJhbnNhY3Rpb24iLCJpc1YzVHgiLCJpc1ZlcnNpb24iLCJwYXJzZUNvbnRyYWN0IiwidmFsaWRCbG9ja1RhZ3MiLCJ3YWl0IiwiZGVsYXkiLCJQcm9taXNlIiwicmVzIiwic2V0VGltZW91dCIsInNpZXJyYV9wcm9ncmFtX2RlYnVnX2luZm8iLCJwYXJzZWRDb250cmFjdCIsIm5ldHdvcmtOYW1lIiwibXV0ZSIsImNvbnNvbGUiLCJ3YXJuIiwibm9kZXMiLCJyYW5kSWR4IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwic2V0SWRlbnRpZmllciIsIl9faWRlbnRpZmllciIsIm51bWJlciIsInRhZyIsIlR5cGVFcnJvciIsIl9pZGVudGlmaWVyIiwidmFsdWVPZiIsInF1ZXJ5SWRlbnRpZmllciIsImlkZW50aWZpZXIiLCJibG9ja19udW1iZXIiLCJibG9ja19oYXNoIiwibWFqb3JTIiwibWlub3JTIiwibWFqb3JSIiwibWlub3JSIiwic3RhdHVzIiwidHJhbnNhY3Rpb25fZXhwb3J0cyIsImJ1aWxkVURDQ2FsbCIsImZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhIiwiZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFXaXRoTm9uY2UiLCJmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YV9jYWlybzEiLCJnZXRFeGVjdXRlQ2FsbGRhdGEiLCJnZXRWZXJzaW9uc0J5VHlwZSIsInRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMiLCJ0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMSIsImNhbGxzIiwiZW50cnlwb2ludCIsImRhdGFfb2Zmc2V0IiwiZGF0YV9sZW4iLCJjb21waWxlZENhbGxzIiwib3JkZXJDYWxscyIsImNhaXJvVmVyc2lvbiIsInBhcmFtcyIsInVuaXF1ZSIsImNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSIsImRlcGxveVNhbHQiLCJhZGRyZXNzZXMiLCJ2ZXJzaW9uVHlwZSIsInYxIiwidjIiLCJ2MyIsImRlZmF1bHRPcHRpb25zIiwiaGVhZGVycyIsImJsb2NrSWRlbnRpZmllciIsInJldHJpZXMiLCJvcHRpb25zT3JQcm92aWRlciIsIm5vZGVVcmwiLCJzcGVjVmVyc2lvbiIsIndhaXRNb2RlIiwiZGVmYXVsdCIsInJlcXVlc3RJZCIsInNldENoYWluSWQiLCJpZCIsInJwY1JlcXVlc3RCb2R5IiwianNvbnJwYyIsImJvZHkiLCJlcnJvckhhbmRsZXIiLCJycGNFcnJvciIsIm90aGVyRXJyb3IiLCJjb2RlIiwiZmV0Y2hFbmRwb2ludCIsInJhd1Jlc3VsdCIsImdldENoYWluSWQiLCJnZXRTcGVjVmVyc2lvbiIsImdldE5vbmNlRm9yQWRkcmVzcyIsImNvbnRyYWN0X2FkZHJlc3MiLCJibG9ja19pZCIsImdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQiLCJnZXRCbG9ja051bWJlciIsImdldEJsb2NrV2l0aFR4SGFzaGVzIiwiZ2V0QmxvY2tXaXRoVHhzIiwiZ2V0QmxvY2tTdGF0ZVVwZGF0ZSIsImdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzIiwiZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50IiwiZ2V0VHJhbnNhY3Rpb25CeUhhc2giLCJ0eEhhc2giLCJ0cmFuc2FjdGlvbl9oYXNoIiwiZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleCIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsImdldFRyYW5zYWN0aW9uVHJhY2UiLCJnZXRUcmFuc2FjdGlvblN0YXR1cyIsInRyYW5zYWN0aW9uSGFzaCIsInNpbXVsYXRlVHJhbnNhY3Rpb24iLCJpbnZvY2F0aW9ucyIsInNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zIiwic2tpcFZhbGlkYXRlIiwic2tpcEZlZUNoYXJnZSIsInNpbXVsYXRpb25GbGFncyIsIlNLSVBfVkFMSURBVEUiLCJTS0lQX0ZFRV9DSEFSR0UiLCJ0cmFuc2FjdGlvbnMiLCJidWlsZFRyYW5zYWN0aW9uIiwic2ltdWxhdGlvbl9mbGFncyIsIndhaXRGb3JUcmFuc2FjdGlvbiIsIm9wdGlvbnMiLCJvbmNoYWluIiwiaXNFcnJvclN0YXRlIiwicmV0cnlJbnRlcnZhbCIsImVycm9yU3RhdGVzIiwiUkVKRUNURUQiLCJzdWNjZXNzU3RhdGVzIiwiU1VDQ0VFREVEIiwiQUNDRVBURURfT05fTDIiLCJBQ0NFUFRFRF9PTl9MMSIsInR4U3RhdHVzIiwiZXhlY3V0aW9uU3RhdHVzIiwiZXhlY3V0aW9uX3N0YXR1cyIsImZpbmFsaXR5U3RhdHVzIiwiZmluYWxpdHlfc3RhdHVzIiwidHhSZWNlaXB0IiwiZ2V0U3RvcmFnZUF0IiwicGFyc2VkS2V5IiwiZ2V0Q2xhc3NIYXNoQXQiLCJnZXRDbGFzcyIsImNsYXNzX2hhc2giLCJnZXRDbGFzc0F0IiwiZ2V0RXN0aW1hdGVGZWUiLCJmbGFncyIsInJlcXVlc3QiLCJpbnZva2UiLCJmdW5jdGlvbkludm9jYXRpb24iLCJwcm9taXNlIiwiaW52b2tlX3RyYW5zYWN0aW9uIiwic2VuZGVyX2FkZHJlc3MiLCJJTlZPS0UiLCJtYXhfZmVlIiwic2lnbmF0dXJlIiwicmVzb3VyY2VfYm91bmRzIiwicGF5bWFzdGVyX2RhdGEiLCJhY2NvdW50X2RlcGxveW1lbnRfZGF0YSIsIm5vbmNlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGUiLCJmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZSIsImRlY2xhcmUiLCJkZWNsYXJlX3RyYW5zYWN0aW9uIiwiREVDTEFSRSIsImNvbnRyYWN0X2NsYXNzIiwiY29udHJhY3RfY2xhc3NfdmVyc2lvbiIsImNvbXBpbGVkX2NsYXNzX2hhc2giLCJkZXBsb3lBY2NvdW50IiwiYWRkcmVzc1NhbHQiLCJkZXBsb3lfYWNjb3VudF90cmFuc2FjdGlvbiIsImNvbnN0cnVjdG9yX2NhbGxkYXRhIiwiY29udHJhY3RfYWRkcmVzc19zYWx0IiwiREVQTE9ZX0FDQ09VTlQiLCJjYWxsQ29udHJhY3QiLCJlbnRyeV9wb2ludF9zZWxlY3RvciIsImVzdGltYXRlTWVzc2FnZUZlZSIsImZyb21fYWRkcmVzcyIsInRvX2FkZHJlc3MiLCJmb3JtYXR0ZWRNZXNzYWdlIiwiZ2V0U3luY2luZ1N0YXRzIiwiZ2V0RXZlbnRzIiwiZXZlbnRGaWx0ZXIiLCJpbnZvY2F0aW9uIiwiZGVmYXVsdFZlcnNpb25zIiwicmVzdERldGFpbHMiLCJycGNfMF83X2V4cG9ydHMiLCJScGNDaGFubmVsMiIsImRlZmF1bHRPcHRpb25zMiIsInRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbEZhbGxiYWNrIiwidHJhbnNhY3Rpb25SZXRyeUludGVydmFsRGVmYXVsdCIsImdldEJsb2NrV2l0aFJlY2VpcHRzIiwiUlBDUmVzcG9uc2VQYXJzZXIiLCJtYXJnaW4iLCJsMUJvdW5kTWF4QW1vdW50IiwibDFCb3VuZE1heFByaWNlUGVyVW5pdCIsInBhcnNlR2V0QmxvY2tSZXNwb25zZSIsInBhcnNlVHJhbnNhY3Rpb25SZWNlaXB0IiwiYWN0dWFsX2ZlZSIsImFtb3VudCIsInVuaXQiLCJwYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UiLCJzdWdnZXN0ZWRNYXhGZWUiLCJwYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlIiwicGFyc2VTaW11bGF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UiLCJmZWVfZXN0aW1hdGlvbiIsInBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlIiwiSlNPTiIsInBhcnNlTDFHYXNQcmljZVJlc3BvbnNlIiwibDFfZ2FzX3ByaWNlIiwicHJpY2VfaW5fd2VpIiwiUmVjZWlwdFR4IiwiX1JlY2VpcHRUeCIsInJlY2VpcHQiLCJzdGF0dXNSZWNlaXB0IiwiaXNTdWNjZXNzIiwiaXNSZXZlcnRlZCIsImlzUmVqZWN0ZWQiLCJjYWxsYmFja3MiLCJpc0Vycm9yIiwidHJhbnNhY3Rpb25SZWNlaXB0IiwiUnBjUHJvdmlkZXIiLCJnZXRTdGF0ZVVwZGF0ZSIsImNoYW5uZWwiLCJmZWVNYXJnaW5QZXJjZW50YWdlIiwiZ2V0QmxvY2siLCJ0aGVuIiwid2FpdEZvckJsb2NrIiwiY3VycmVudEJsb2NrIiwidGFyZ2V0QmxvY2siLCJyZXRyaWVzQ291bnQiLCJpc1RhcmdldEJsb2NrIiwiY3VyckJsb2NrIiwiZ2V0TDFHYXNQcmljZSIsImdldEwxTWVzc2FnZUhhc2giLCJsMlR4SGFzaCIsInRyYW5zYWN0aW9uIiwibXlFbmNvZGUiLCJwYXIiLCJnZXRQZW5kaW5nVHJhbnNhY3Rpb25zIiwiZ2V0VHJhbnNhY3Rpb24iLCJ0eFJlY2VpcHRXb0hlbHBlciIsInR4UmVjZWlwdFdvSGVscGVyTW9kaWZpZWQiLCJnZXRTaW11bGF0ZVRyYW5zYWN0aW9uIiwicmVjZWlwdFdvSGVscGVyIiwiZ2V0Q2xhc3NCeUhhc2giLCJnZXRDb250cmFjdFZlcnNpb24iLCJhYmlUZXN0IiwiaW52b2NhdGlvbkRldGFpbHMiLCJnZXRJbnZva2VFc3RpbWF0ZUZlZSIsImdldERlY2xhcmVFc3RpbWF0ZUZlZSIsImdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZSIsImdldEVzdGltYXRlRmVlQnVsayIsImludm9rZUZ1bmN0aW9uIiwiZGVjbGFyZUNvbnRyYWN0IiwiZGVwbG95QWNjb3VudENvbnRyYWN0IiwiTWl4aW4iLCJzdGFya25ldElkX2V4cG9ydHMiLCJTdGFya25ldElkQ29udHJhY3QiLCJTdGFya25ldElkSWRlbnRpdHlDb250cmFjdCIsIlN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdCIsIlN0YXJrbmV0SWRQZnBDb250cmFjdCIsIlN0YXJrbmV0SWRQb3BDb250cmFjdCIsIlN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0IiwiZHluYW1pY0NhbGxEYXRhIiwiZHluYW1pY0ZlbHQiLCJleGVjdXRpb24iLCJnZXRTdGFya25ldElkQ29udHJhY3QiLCJnZXRTdGFya25ldElkSWRlbnRpdHlDb250cmFjdCIsImdldFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdCIsImdldFN0YXJrbmV0SWRQZnBDb250cmFjdCIsImdldFN0YXJrbmV0SWRQb3BDb250cmFjdCIsImdldFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0IiwidXNlRGVjb2RlZCIsInVzZUVuY29kZWQiLCJiYXNpY0FscGhhYmV0IiwiYmFzaWNTaXplUGx1c09uZSIsImJpZ0FscGhhYmV0IiwiYmFzaWNBbHBoYWJldFNpemUiLCJiaWdBbHBoYWJldFNpemUiLCJiaWdBbHBoYWJldFNpemVQbHVzT25lIiwiZXh0cmFjdFN0YXJzIiwiZW5kc1dpdGgiLCJlbmNvZGVkIiwiZGVjb2RlZCIsInN1YmRvbWFpbiIsIm5leHRTdWJkb21haW4iLCJjb2RlMiIsIm11bHRpcGxpZXIiLCJibkluZGV4IiwibmV3aWQiLCJTdGFya25ldElkQ29udHJhY3QyIiwiU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyIiwiU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QyIiwiU3RhcmtuZXRJZFBmcENvbnRyYWN0MiIsIlN0YXJrbmV0SWRQb3BDb250cmFjdDIiLCJzdGF0aWNFeCIsImlmRXF1YWwiLCJpZk5vdEVxdWFsIiwiU3RhdGljIiwiSWZFcXVhbCIsIklmTm90RXF1YWwiLCJoYXJkY29kZWQiLCJyZWZlcmVuY2UiLCJIYXJkY29kZWQiLCJSZWZlcmVuY2UiLCJhcnJheVJlZmVyZW5jZSIsIkFycmF5UmVmZXJlbmNlIiwiU3RhcmtuZXRJZCIsIl9TdGFya25ldElkIiwiZ2V0U3RhcmtOYW1lIiwiZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUiLCJnZXRTdGFya1Byb2ZpbGUiLCJTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QyIiwicHJvdmlkZXIiLCJoZXhEb21haW4iLCJoaW50IiwiZGVjaW1hbERvbWFpbiIsInN0cmluZ0RvbWFpbiIsImVuY29kZWREb21haW4iLCJwYXJ0IiwiYWRkcmVzc0RhdGEiLCJkb21haW4iLCJpZGVudGl0eUNvbnRyYWN0IiwidmVyaWZpZXJDb250cmFjdCIsInBmcENvbnRyYWN0IiwicG9wQ29udHJhY3QiLCJtdWx0aWNhbGxBZGRyZXNzIiwic2l6ZSIsImZpbmFsQXJyYXkiLCJzdWJBcnJheVNpemUiLCJzdWJBcnJheSIsImhleFN0cmluZyIsInR3aXR0ZXIiLCJnaXRodWIiLCJkaXNjb3JkIiwicHJvb2ZPZlBlcnNvbmhvb2QiLCJwcm9maWxlUGljdHVyZU1ldGFkYXRhIiwicHJvZmlsZVBpY3R1cmUiLCJScGNQcm92aWRlcjIiLCJQcm92aWRlckludGVyZmFjZSIsImRlZmF1bHRQcm92aWRlciIsIlNpZ25lckludGVyZmFjZSIsInR5cGVkRGF0YV9leHBvcnRzIiwiZW5jb2RlRGF0YSIsImVuY29kZVR5cGUiLCJlbmNvZGVWYWx1ZSIsImdldERlcGVuZGVuY2llcyIsImdldE1lc3NhZ2VIYXNoIiwiZ2V0U3RydWN0SGFzaCIsImdldFR5cGVIYXNoIiwiaXNNZXJrbGVUcmVlVHlwZSIsInByZXBhcmVTZWxlY3RvciIsIm1lcmtsZV9leHBvcnRzIiwiTWVya2xlVHJlZSIsInByb29mTWVya2xlUGF0aCIsIl9NZXJrbGVUcmVlIiwibGVhZkhhc2hlcyIsImhhc2hNZXRob2QiLCJicmFuY2hlcyIsImxlYXZlcyIsInJvb3QiLCJidWlsZCIsIm5ld0xlYXZlcyIsImFTb3J0ZWQiLCJiU29ydGVkIiwic29ydCIsImdldFByb29mIiwibGVhZiIsImJyYW5jaCIsImhhc2hQYXRoIiwiaXNMZWZ0IiwibmVlZGVkQnJhbmNoIiwibmV3SGFzaFBhdGgiLCJjdXJyZW50QnJhbmNoTGV2ZWxJbmRleCIsIm5leHRCcmFuY2giLCJwYXRoIiwicmVzdCIsInByZXNldFR5cGVzIiwiVG9rZW5BbW91bnQiLCJOZnRJZCIsInJldmlzaW9uQ29uZmlndXJhdGlvbiIsIkFDVElWRSIsImhhc2hNZXJrbGVNZXRob2QiLCJlc2NhcGVUeXBlU3RyaW5nIiwiTEVHQUNZIiwiYXNzZXJ0UmFuZ2UiLCJpZGVudGlmeVJldmlzaW9uIiwidHlwZXMiLCJyZXZpc2lvbiIsImdldEhleCIsInZhbGlkYXRlVHlwZWREYXRhIiwidHlwZWREYXRhIiwicHJpbWFyeVR5cGUiLCJkZXBlbmRlbmNpZXMiLCJjb250YWlucyIsInByZXZpb3VzIiwidCIsImRlcGVuZGVuY3kiLCJnZXRNZXJrbGVUcmVlVHlwZSIsImN0eCIsInBhcmVudCIsInBhcmVudFR5cGUiLCJtZXJrbGVUeXBlIiwiaXNNZXJrbGVUcmVlIiwiYWxsVHlwZXMiLCJwcmltYXJ5IiwibmV3VHlwZXMiLCJlc2MiLCJkZXBlbmRlbmN5RWxlbWVudHMiLCJ0YXJnZXRUeXBlIiwidHlwZVN0cmluZyIsImhhc2hlcyIsImVudHJ5IiwidmFyaWFudEtleSIsInZhcmlhbnREYXRhIiwiZW51bVR5cGUiLCJ2YXJpYW50SW5kZXgiLCJlbmNvZGVkU3VidHlwZXMiLCJzdWJ0eXBlIiwic3VidHlwZURhdGEiLCJtZXJrbGVUcmVlVHlwZSIsInN0cnVjdEhhc2hlcyIsInN0cnVjdCIsImJ5dGVBcnJheSIsInJldHVyblR5cGVzIiwidHMiLCJ2cyIsImZpZWxkIiwiZW5jb2RlZFZhbHVlIiwiYWNjb3VudCIsIlNpZ25lciIsInBrIiwiZ2V0UHViS2V5Iiwic2lnbk1lc3NhZ2UiLCJhY2NvdW50QWRkcmVzcyIsIm1zZ0hhc2giLCJzaWduUmF3Iiwic2lnblRyYW5zYWN0aW9uIiwiZGV0Iiwid2FsbGV0QWRkcmVzcyIsInNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24iLCJzaWduRGVjbGFyZVRyYW5zYWN0aW9uIiwic2lnbiIsInNlY3AyNTZrMTIiLCJ1aW50MjU2X2V4cG9ydHMiLCJiblRvVWludDI1NiIsImlzVWludDI1NiIsInVpbnQyNTZUb0JOIiwidWludDI1NjIiLCJFdGhTaWduZXIiLCJnZXRQdWJsaWNLZXkiLCJmb3JtYXRFdGhTaWduYXR1cmUiLCJldGhTaWduYXR1cmUiLCJyZWNvdmVyeSIsImV2ZW50c19leHBvcnRzIiwiZ2V0QWJpRXZlbnRzIiwiaXNBYmlFdmVudCIsImlzT2JqZWN0IiwicGFyc2VFdmVudHMiLCJwYXJzZVVEQ0V2ZW50Iiwib2JqZWN0IiwiZ2V0Q2Fpcm8wQWJpRXZlbnRzIiwiZW50cnlOYW1lIiwiYWJpRW50cnlNb2QiLCJnZXRDYWlybzFBYmlFdmVudHMiLCJhYmlFdmVudHNTdHJ1Y3RzIiwia2luZCIsImFiaUV2ZW50c0VudW1zIiwiYWJpRXZlbnRzRGF0YSIsImV2ZW50IiwibmFtZUxpc3QiLCJmaW5kTmFtZSIsImV2ZW50RW51bSIsImV2ZW50RSIsInNvbWUiLCJ1bnNoaWZ0IiwiZmluYWwiLCJtZXJnZUFiaUV2ZW50cyIsInNvdXJjZSIsImFzc2lnbiIsInByb3ZpZGVyUmVjZWl2ZWRFdmVudHMiLCJhYmlFdmVudHMiLCJhYmlTdHJ1Y3RzIiwiYWJpRW51bXMiLCJyZXQiLCJyZWNFdmVudCIsImFiaUV2ZW50IiwiaGFzaE5hbWUiLCJwYXJzZWRFdmVudCIsImtleXNJdGVyIiwiZGF0YUl0ZXIiLCJhYmlFdmVudEtleXMiLCJhYmlFdmVudERhdGEiLCJldmVudHMiLCJkZXBsb3llciIsImNhbGxkYXRhX2xlbiIsIkFjY291bnQiLCJwcm92aWRlck9yT3B0aW9ucyIsInBrT3JTaWduZXIiLCJ0cmFuc2FjdGlvblZlcnNpb24iLCJkZXBsb3lTZWxmIiwic2lnbmVyIiwiZ2V0UHJlZmVycmVkVmVyc2lvbiIsInR5cGUxMiIsInR5cGUzIiwiZ2V0Tm9uY2UiLCJnZXROb25jZVNhZmUiLCJnZXRDYWlyb1ZlcnNpb24iLCJlc3RpbWF0ZUZlZSIsImVzdGltYXRlRmVlRGV0YWlscyIsImVzdGltYXRlSW52b2tlRmVlIiwicHJvdmlkZWROb25jZSIsInNpZ25lckRldGFpbHMiLCJidWlsZEludm9jYXRpb24iLCJlc3RpbWF0ZURlY2xhcmVGZWUiLCJkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiIsImJ1aWxkRGVjbGFyZVBheWxvYWQiLCJlc3RpbWF0ZUFjY291bnREZXBsb3lGZWUiLCJidWlsZEFjY291bnREZXBsb3lQYXlsb2FkIiwiZXN0aW1hdGVEZXBsb3lGZWUiLCJidWlsZFVEQ0NvbnRyYWN0UGF5bG9hZCIsImVzdGltYXRlRmVlQnVsayIsImFjY291bnRJbnZvY2F0aW9ucyIsImFjY291bnRJbnZvY2F0aW9uc0ZhY3RvcnkiLCJ2ZXJzaW9ucyIsInNraXBFeGVjdXRlIiwiZXhlY3V0ZSIsImFyZzIiLCJ0cmFuc2FjdGlvbnNEZXRhaWwiLCJnZXRVbml2ZXJzYWxTdWdnZXN0ZWRGZWUiLCJkZWNsYXJlSWZOb3QiLCJkZWNsYXJlQ29udHJhY3RQYXlsb2FkIiwiZGVjbGFyZURldGFpbHMiLCJkZXBsb3kiLCJpbnZva2VSZXNwb25zZSIsImRlcGxveUNvbnRyYWN0IiwiZGVwbG95VHgiLCJkZWNsYXJlQW5kRGVwbG95IiwidHgiLCJwcm92aWRlZENvbnRyYWN0QWRkcmVzcyIsImhhc2hNZXNzYWdlIiwidmVyaWZ5TWVzc2FnZUhhc2giLCJzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbk5hbWUiLCJzaWduYXR1cmVWZXJpZmljYXRpb25SZXNwb25zZSIsImtub3duU2lnVmVyaWZpY2F0aW9uRk5hbWUiLCJrbm93blNpZ25hdHVyZVJlc3BvbnNlIiwib2tSZXNwb25zZSIsIm5va1Jlc3BvbnNlIiwiU2lnVmVyaWZpY2F0aW9uRk5hbWUiLCJyZXNwIiwiZXJyIiwiZXJyTWVzc2FnZSIsInZlcmlmeU1lc3NhZ2UiLCJnZXRTdWdnZXN0ZWRGZWUiLCJmZWVFc3RpbWF0ZSIsImNvbXByZXNzZWRDb21waWxlZENvbnRyYWN0Iiwic2FmZU5vbmNlIiwidHgwUGF5bG9hZCIsInR4UGF5bG9hZCIsImNvbW1vbiIsInZlcnNpb25YIiwiQWNjb3VudEludGVyZmFjZSIsImNvbm5lY3RfZXhwb3J0cyIsImFkZERlY2xhcmVUcmFuc2FjdGlvbiIsImFkZEludm9rZVRyYW5zYWN0aW9uIiwiYWRkU3RhcmtuZXRDaGFpbiIsImRlcGxveW1lbnREYXRhIiwiZ2V0UGVybWlzc2lvbnMiLCJvbkFjY291bnRDaGFuZ2UiLCJvbk5ldHdvcmtDaGFuZ2VkIiwicmVxdWVzdEFjY291bnRzIiwicmVxdWVzdENoYWluSWQiLCJzdXBwb3J0ZWRTcGVjcyIsInN3aXRjaFN0YXJrbmV0Q2hhaW4iLCJ3YXRjaEFzc2V0Iiwic3dvIiwic2lsZW50X21vZGUiLCJhc3NldCIsImNoYWluIiwiY2FsbGJhY2siLCJvbiIsIldhbGxldEFjY291bnQiLCJ3YWxsZXRQcm92aWRlciIsInNpbGVudE1vZGUiLCJ0eENhbGxzIiwiZW50cnlfcG9pbnQiLCJwQ29udHJhY3QiLCJjYWlybzFDb250cmFjdCIsInNwbGl0QXJnc0FuZE9wdGlvbnMiLCJsYXN0QXJnIiwiYnVpbGRDYWxsIiwiZnVuY3Rpb25BYmkiLCJwYXJzZVJlcXVlc3QiLCJwYXJzZVJlc3BvbnNlIiwiYnVpbGRJbnZva2UiLCJidWlsZERlZmF1bHQiLCJidWlsZFBvcHVsYXRlIiwicG9wdWxhdGUiLCJidWlsZEVzdGltYXRlIiwiZ2V0Q2FsbGRhdGEiLCJDb250cmFjdCIsInByb3ZpZGVyT3JBY2NvdW50IiwiY2FsbERhdGEiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZnVuY3Rpb25zIiwiY2FsbFN0YXRpYyIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJhYmlFbGVtZW50IiwiYXR0YWNoIiwiY29ubmVjdCIsImRlcGxveWVkIiwiZGVwbG95VHJhbnNhY3Rpb25IYXNoIiwiZm9ybWF0UmVzcG9uc2UiLCJpc0NhaXJvMSIsImdldFZlcnNpb24iLCJ0eXBlZHYyIiwidEFiaSIsIkNvbnRyYWN0SW50ZXJmYWNlIiwiQ29udHJhY3RGYWN0b3J5IiwiY29udHJhY3RJbnN0YW5jZSIsIlJlc3BvbnNlUGFyc2VyIiwiaGV4VG9CeXRlczIiLCJhZGRBZGRyZXNzUGFkZGluZyIsInBhZGRlZCIsInZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzIiwiZ2V0Q2hlY2tzdW1BZGRyZXNzIiwiY2hhcnMiLCJoYXNoZWQiLCJ2YWxpZGF0ZUNoZWNrc3VtQWRkcmVzcyIsInVybGpvaW4iLCJwcm90b2NvbEFuZERvbWFpblJFIiwibG9jYWxob3N0RG9tYWluUkUiLCJub25Mb2NhbGhvc3REb21haW5SRSIsImlzVXJsIiwiZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wiLCJidWlsZFVybCIsImJhc2VVcmwiLCJkZWZhdWx0UGF0aCIsInVybE9yUGF0aCIsIlByb3ZpZGVyIiwiUlBDMDYiLCJSUEMwNyIsImNvbnN0YW50cyIsImVjIiwiZXRoIiwibWVya2xlIiwic2hvcnRTdHJpbmciLCJzdGFyayIsInN0YXJrbmV0SWQiLCJ2Mmhhc2giLCJ2M2hhc2giLCJ3YWxsZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create\n    });\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDMUI7QUFDcUI7QUFDUDtBQUN4RCx3Q0FBd0M7QUFDakMsU0FBU0ksUUFBUUMsSUFBSTtJQUN4QixPQUFPO1FBQ0hBO1FBQ0FMLE1BQU0sQ0FBQ00sS0FBSyxHQUFHQyxPQUFTUCx3REFBSUEsQ0FBQ0ssTUFBTUMsS0FBS0wsZ0VBQVdBLElBQUlNO1FBQ3ZETCxXQUFXQSw4REFBQUE7SUFDZjtBQUNKO0FBQ08sU0FBU00sWUFBWUMsUUFBUSxFQUFFQyxPQUFPO0lBQ3pDLE1BQU1DLFNBQVMsQ0FBQ04sT0FBU0YscUVBQVdBLENBQUM7WUFBRSxHQUFHTSxRQUFRO1lBQUUsR0FBR0wsUUFBUUMsS0FBSztRQUFDO0lBQ3JFLE9BQU9PLE9BQU9DLE1BQU0sQ0FBQztRQUFFLEdBQUdGLE9BQU9ELFFBQVE7UUFBRUM7SUFBTztBQUN0RCxFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWRhcHAvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanM/ZDdkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImhtYWMiLCJjb25jYXRCeXRlcyIsInJhbmRvbUJ5dGVzIiwid2VpZXJzdHJhc3MiLCJnZXRIYXNoIiwiaGFzaCIsImtleSIsIm1zZ3MiLCJjcmVhdGVDdXJ2ZSIsImN1cnZlRGVmIiwiZGVmSGFzaCIsImNyZWF0ZSIsIk9iamVjdCIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/curve.js":
/*!********************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item)=>{\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W)=>{\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return {\n            windows,\n            windowSize\n        };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        wNAFCached (P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        }\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsMEJBQTBCO0FBQzRCO0FBQ1Y7QUFDNUMsTUFBTUcsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLDZEQUE2RDtBQUM3RCxtR0FBbUc7QUFDbkcseURBQXlEO0FBQ3pELDREQUE0RDtBQUM1RCwrRUFBK0U7QUFDL0Usb0dBQW9HO0FBQ3BHLG9HQUFvRztBQUNwRyxxQ0FBcUM7QUFDckMsa0dBQWtHO0FBQ2xHLGdHQUFnRztBQUNoRyw4Q0FBOEM7QUFDdkMsU0FBU0UsS0FBS0MsQ0FBQyxFQUFFQyxJQUFJO0lBQ3hCLE1BQU1DLGtCQUFrQixDQUFDQyxXQUFXQztRQUNoQyxNQUFNQyxNQUFNRCxLQUFLRSxNQUFNO1FBQ3ZCLE9BQU9ILFlBQVlFLE1BQU1EO0lBQzdCO0lBQ0EsTUFBTUcsT0FBTyxDQUFDQztRQUNWLE1BQU1DLFVBQVVDLEtBQUtDLElBQUksQ0FBQ1YsT0FBT08sS0FBSyxHQUFHLGNBQWM7UUFDdkQsTUFBTUksYUFBYSxLQUFNSixDQUFBQSxJQUFJLElBQUksMEJBQTBCO1FBQzNELE9BQU87WUFBRUM7WUFBU0c7UUFBVztJQUNqQztJQUNBLE9BQU87UUFDSFY7UUFDQSx1Q0FBdUM7UUFDdkNXLGNBQWFDLEdBQUcsRUFBRUMsQ0FBQztZQUNmLElBQUlDLElBQUloQixFQUFFaUIsSUFBSTtZQUNkLElBQUlDLElBQUlKO1lBQ1IsTUFBT0MsSUFBSW5CLElBQUs7Z0JBQ1osSUFBSW1CLElBQUlqQixLQUNKa0IsSUFBSUEsRUFBRUcsR0FBRyxDQUFDRDtnQkFDZEEsSUFBSUEsRUFBRUUsTUFBTTtnQkFDWkwsTUFBTWpCO1lBQ1Y7WUFDQSxPQUFPa0I7UUFDWDtRQUNBOzs7Ozs7Ozs7U0FTQyxHQUNESyxrQkFBaUJQLEdBQUcs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QUN5RCxNQUFNQyxFQUFFO0lBQ3RCeEQseURBQWNBLENBQUN1RCxPQUFPO1FBQ2xCbkMsR0FBRztRQUNIcUMsR0FBRztRQUNIQyxJQUFJO1FBQ0pDLElBQUk7SUFDUixHQUFHO1FBQ0NDLFlBQVk7UUFDWkMsYUFBYTtJQUNqQjtJQUNBLGVBQWU7SUFDZixPQUFPQyxPQUFPQyxNQUFNLENBQUM7UUFDakIsR0FBR2hFLG9EQUFPQSxDQUFDd0QsTUFBTW5DLENBQUMsRUFBRW1DLE1BQU1LLFVBQVUsQ0FBQztRQUNyQyxHQUFHTCxLQUFLO1FBQ1IsR0FBRztZQUFFbEMsR0FBR2tDLE1BQU1DLEVBQUUsQ0FBQ1EsS0FBSztRQUFDLENBQUM7SUFDNUI7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWRhcHAvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzP2JkZTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmltcG9ydCB7IHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGVjayB0aGF0IHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/IHdOQUYgYmVoYXZpb3VzIGlzIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFcgPSBQLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCBjb21wLCBuKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsidmFsaWRhdGVGaWVsZCIsIm5MZW5ndGgiLCJ2YWxpZGF0ZU9iamVjdCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIndOQUYiLCJjIiwiYml0cyIsImNvbnN0VGltZU5lZ2F0ZSIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJuZWdhdGUiLCJvcHRzIiwiVyIsIndpbmRvd3MiLCJNYXRoIiwiY2VpbCIsIndpbmRvd1NpemUiLCJ1bnNhZmVMYWRkZXIiLCJlbG0iLCJuIiwicCIsIlpFUk8iLCJkIiwiYWRkIiwiZG91YmxlIiwicHJlY29tcHV0ZVdpbmRvdyIsInBvaW50cyIsImJhc2UiLCJ3aW5kb3ciLCJwdXNoIiwiaSIsInByZWNvbXB1dGVzIiwiZiIsIkJBU0UiLCJtYXNrIiwibWF4TnVtYmVyIiwic2hpZnRCeSIsIm9mZnNldCIsIndiaXRzIiwiTnVtYmVyIiwib2Zmc2V0MSIsIm9mZnNldDIiLCJhYnMiLCJjb25kMSIsImNvbmQyIiwid05BRkNhY2hlZCIsIlAiLCJwcmVjb21wdXRlc01hcCIsInRyYW5zZm9ybSIsIl9XSU5ET1dfU0laRSIsImNvbXAiLCJnZXQiLCJzZXQiLCJ2YWxpZGF0ZUJhc2ljIiwiY3VydmUiLCJGcCIsImgiLCJHeCIsIkd5IiwibkJpdExlbmd0aCIsIm5CeXRlTGVuZ3RoIiwiT2JqZWN0IiwiZnJlZXplIiwiT1JERVIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << 8 * length) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255) throw new Error(\"Invalid xmd length\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"mapToCurve: expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtQztBQUM0RDtBQUMvRiw2RkFBNkY7QUFDN0YsTUFBTU0sUUFBUUosc0RBQWVBO0FBQzdCLDRDQUE0QztBQUM1QyxTQUFTSyxNQUFNQyxLQUFLLEVBQUVDLE1BQU07SUFDeEIsSUFBSUQsUUFBUSxLQUFLQSxTQUFTLEtBQU0sSUFBSUMsUUFBUztRQUN6QyxNQUFNLElBQUlDLE1BQU0sQ0FBQyxzQkFBc0IsRUFBRUYsTUFBTSxRQUFRLEVBQUVDLE9BQU8sQ0FBQztJQUNyRTtJQUNBLE1BQU1FLE1BQU1DLE1BQU1DLElBQUksQ0FBQztRQUFFSjtJQUFPLEdBQUdLLElBQUksQ0FBQztJQUN4QyxJQUFLLElBQUlDLElBQUlOLFNBQVMsR0FBR00sS0FBSyxHQUFHQSxJQUFLO1FBQ2xDSixHQUFHLENBQUNJLEVBQUUsR0FBR1AsUUFBUTtRQUNqQkEsV0FBVztJQUNmO0lBQ0EsT0FBTyxJQUFJUSxXQUFXTDtBQUMxQjtBQUNBLFNBQVNNLE9BQU9DLENBQUMsRUFBRUMsQ0FBQztJQUNoQixNQUFNQyxNQUFNLElBQUlKLFdBQVdFLEVBQUVULE1BQU07SUFDbkMsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlHLEVBQUVULE1BQU0sRUFBRU0sSUFBSztRQUMvQkssR0FBRyxDQUFDTCxFQUFFLEdBQUdHLENBQUMsQ0FBQ0gsRUFBRSxHQUFHSSxDQUFDLENBQUNKLEVBQUU7SUFDeEI7SUFDQSxPQUFPSztBQUNYO0FBQ0EsU0FBU0MsS0FBS0MsSUFBSTtJQUNkLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixPQUN0QixNQUFNLElBQUlaLE1BQU07QUFDeEI7QUFDQSxvR0FBb0c7QUFDcEcsdURBQXVEO0FBQ2hELFNBQVNlLG1CQUFtQkMsR0FBRyxFQUFFQyxHQUFHLEVBQUVD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QUN6Qyx3RUFBd0U7UUFDeEVHLGVBQWN2RSxHQUFHLEVBQUUwQixPQUFPO1lBQ3RCLE1BQU1XLElBQUliLGNBQWN4QixLQUFLLEdBQUc7Z0JBQUUsR0FBRytELEdBQUc7Z0JBQUU5RCxLQUFLOEQsSUFBSVMsU0FBUztnQkFBRSxHQUFHOUMsT0FBTztZQUFDO1lBQ3pFLE1BQU0wQyxJQUFJUCxNQUFNSyxVQUFVLENBQUNKLFdBQVd6QixDQUFDLENBQUMsRUFBRSxHQUFHZ0MsYUFBYTtZQUMxREQsRUFBRUUsY0FBYztZQUNoQixPQUFPRjtRQUNYO1FBQ0EsMENBQTBDO1FBQzFDTixZQUFXVyxPQUFPO1lBQ2QsSUFBSSxDQUFDdkYsTUFBTXdGLE9BQU8sQ0FBQ0QsVUFDZixNQUFNLElBQUl6RixNQUFNO1lBQ3BCLEtBQUssTUFBTUssS0FBS29GLFFBQ1osSUFBSSxPQUFPcEYsTUFBTSxVQUNiLE1BQU0sSUFBSUwsTUFBTSxDQUFDLDJDQUEyQyxFQUFFSyxFQUFFLFNBQVMsQ0FBQztZQUNsRixNQUFNK0UsSUFBSVAsTUFBTUssVUFBVSxDQUFDSixXQUFXVyxVQUFVSixhQUFhO1lBQzdERCxFQUFFRSxjQUFjO1lBQ2hCLE9BQU9GO1FBQ1g7SUFDSjtBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZGFwcC8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz9mNzlmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBhYnl0ZXMsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIEkyT1NQIGNhbGw6IHZhbHVlPSR7dmFsdWV9IGxlbmd0aD0ke2xlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhbnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0c1xuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFieXRlcyhEU1QpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAoZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgeG1kIGxlbmd0aCcpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuLy8gMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuLy8gICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgX0RTVCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhfRFNUKSA6IF9EU1Q7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gaGFzaF90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgeyAuLi5kZWYsIERTVDogZGVmLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMV0pKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSB1MC5hZGQodTEpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBlbmNvZGVfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgZW5jb2RlVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgeyAuLi5kZWYsIERTVDogZGVmLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTYW1lIGFzIGVuY29kZVRvQ3VydmUsIGJ1dCB3aXRob3V0IGhhc2hcbiAgICAgICAgbWFwVG9DdXJ2ZShzY2FsYXJzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlOiBleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgb2Ygc2NhbGFycylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1hcFRvQ3VydmU6IGV4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMsIGdvdCAke2l9IGluIGFycmF5YCk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHNjYWxhcnMpKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsibW9kIiwiYWJ5dGVzIiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJ1dGY4VG9CeXRlcyIsInZhbGlkYXRlT2JqZWN0Iiwib3MyaXAiLCJpMm9zcCIsInZhbHVlIiwibGVuZ3RoIiwiRXJyb3IiLCJyZXMiLCJBcnJheSIsImZyb20iLCJmaWxsIiwiaSIsIlVpbnQ4QXJyYXkiLCJzdHJ4b3IiLCJhIiwiYiIsImFyciIsImFudW0iLCJpdGVtIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsImV4cGFuZF9tZXNzYWdlX3htZCIsIm1zZyIsIkRTVCIsImxlbkluQnl0ZXMiLCJIIiwib3V0cHV0TGVuIiwiYl9pbl9ieXRlcyIsImJsb2NrTGVuIiwicl9pbl9ieXRlcyIsImVsbCIsIk1hdGgiLCJjZWlsIiwiRFNUX3ByaW1lIiwiWl9wYWQiLCJsX2lfYl9zdHIiLCJiXzAiLCJhcmdzIiwicHNldWRvX3JhbmRvbV9ieXRlcyIsInNsaWNlIiwiZXhwYW5kX21lc3NhZ2VfeG9mIiwiayIsImRrTGVuIiwiY3JlYXRlIiwidXBkYXRlIiwiZGlnZXN0IiwiaGFzaF90b19maWVsZCIsImNvdW50Iiwib3B0aW9ucyIsInAiLCJtIiwiaGFzaCIsImV4cGFuZCIsIl9EU1QiLCJsb2cycCIsInRvU3RyaW5nIiwiTCIsImxlbl9pbl9ieXRlcyIsInByYiIsInUiLCJlIiwiaiIsImVsbV9vZmZzZXQiLCJ0diIsInN1YmFycmF5IiwiaXNvZ2VueU1hcCIsImZpZWxkIiwibWFwIiwiQ09FRkYiLCJyZXZlcnNlIiwieCIsInkiLCJ4TnVtIiwieERlbiIsInlOdW0iLCJ5RGVuIiwidmFsIiwicmVkdWNlIiwiYWNjIiwiYWRkIiwibXVsIiwiZGl2IiwiY3JlYXRlSGFzaGVyIiwiUG9pbnQiLCJtYXBUb0N1cnZlIiwiZGVmIiwiaGFzaFRvQ3VydmUiLCJ1MCIsImZyb21BZmZpbmUiLCJ1MSIsIlAiLCJjbGVhckNvZmFjdG9yIiwiYXNzZXJ0VmFsaWRpdHkiLCJlbmNvZGVUb0N1cnZlIiwiZW5jb2RlRFNUIiwic2NhbGFycyIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/modular.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n) throw new Error(\"Expected power/modulo > 0\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"Expected power > 0\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x)=>{\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLHNEQUFzRDtBQUNpRjtBQUN2SSxrQkFBa0I7QUFDbEIsTUFBTU8sTUFBTUMsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLElBQUlFLE1BQU1GLE9BQU8sSUFBSUcsTUFBTUgsT0FBTztBQUN0RSxrQkFBa0I7QUFDbEIsTUFBTUksTUFBTUosT0FBTyxJQUFJSyxNQUFNTCxPQUFPLElBQUlNLE1BQU1OLE9BQU87QUFDckQsa0JBQWtCO0FBQ2xCLE1BQU1PLE1BQU1QLE9BQU8sSUFBSVEsT0FBT1IsT0FBTztBQUNyQyx3QkFBd0I7QUFDakIsU0FBU1MsSUFBSUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3BCLE1BQU1DLFNBQVNGLElBQUlDO0lBQ25CLE9BQU9DLFVBQVViLE1BQU1hLFNBQVNELElBQUlDO0FBQ3hDO0FBQ0E7Ozs7O0NBS0MsR0FDRCxvQ0FBb0M7QUFDN0IsU0FBU0MsSUFBSUMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLE1BQU07SUFDbEMsSUFBSUEsVUFBVWpCLE9BQU9nQixRQUFRaEIsS0FDekIsTUFBTSxJQUFJa0IsTUFBTTtJQUNwQixJQUFJRCxXQUFXZixLQUNYLE9BQU9GO0lBQ1gsSUFBSW1CLE1BQU1qQjtJQUNWLE1BQU9jLFFBQVFoQixJQUFLO1FBQ2hCLElBQUlnQixRQUFRZCxLQUNSaUIsTUFBTSxNQUFPSixNQUFPRTtRQUN4QkYsTUFBTSxNQUFPQSxNQUFPRTtRQUNwQkQsVUFBVWQ7SUFDZDtJQUNBLE9BQU9pQjtBQUNYO0FBQ0EsMERBQTBEO0FBQ25ELFNBQVNDLEtBQUtDLENBQUMsRUFBRUwsS0FBSyxFQUFFQyxNQUFNO0lBQ2pDLElBQUlFLE1BQU1FO0lBQ1YsTUFBT0wsVUFBVWhCLElBQUs7UUFDbEJtQixP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dGFya25ldC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcz9mNTFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuaW1wb3J0IHsgYml0TWFzaywgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBOT1RFOiBkaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyQkUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJMRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbImJpdE1hc2siLCJieXRlc1RvTnVtYmVyQkUiLCJieXRlc1RvTnVtYmVyTEUiLCJlbnN1cmVCeXRlcyIsIm51bWJlclRvQnl0ZXNCRSIsIm51bWJlclRvQnl0ZXNMRSIsInZhbGlkYXRlT2JqZWN0IiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzNuIiwiXzRuIiwiXzVuIiwiXzhuIiwiXzluIiwiXzE2biIsIm1vZCIsImEiLCJiIiwicmVzdWx0IiwicG93IiwibnVtIiwicG93ZXIiLCJtb2R1bG8iLCJFcnJvciIsInJlcyIsInBvdzIiLCJ4IiwiaW52ZXJ0IiwibnVtYmVyIiwieSIsInUiLCJ2IiwicSIsInIiLCJtIiwibiIsImdjZCIsInRvbmVsbGlTaGFua3MiLCJQIiwibGVnZW5kcmVDIiwiUSIsIlMiLCJaIiwicDFkaXY0IiwidG9uZWxsaUZhc3QiLCJGcCIsInJvb3QiLCJlcWwiLCJzcXIiLCJRMWRpdjIiLCJ0b25lbGxpU2xvdyIsIm5lZyIsIk9ORSIsImciLCJtdWwiLCJaRVJPIiwidDIiLCJnZSIsIkZwU3FydCIsInNxcnQzbW9kNCIsImMxIiwic3FydDVtb2Q4IiwibjIiLCJudiIsImkiLCJzdWIiLCJpc05lZ2F0aXZlTEUiLCJGSUVMRF9GSUVMRFMiLCJ2YWxpZGF0ZUZpZWxkIiwiZmllbGQiLCJpbml0aWFsIiwiT1JERVIiLCJNQVNLIiwiQllURVMiLCJCSVRTIiwib3B0cyIsInJlZHVjZSIsIm1hcCIsInZhbCIsIkZwUG93IiwiZiIsInAiLCJkIiwiRnBJbnZlcnRCYXRjaCIsIm51bXMiLCJ0bXAiLCJBcnJheSIsImxlbmd0aCIsImxhc3RNdWx0aXBsaWVkIiwiYWNjIiwiaXMwIiwiaW52ZXJ0ZWQiLCJpbnYiLCJyZWR1Y2VSaWdodCIsIkZwRGl2IiwibGhzIiwicmhzIiwiRnBJc1NxdWFyZSIsImxlZ2VuZHJlQ29uc3QiLCJuTGVuZ3RoIiwibkJpdExlbmd0aCIsIl9uQml0TGVuZ3RoIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJuQnl0ZUxlbmd0aCIsIk1hdGgiLCJjZWlsIiwiRmllbGQiLCJiaXRMZW4iLCJpc0xFIiwicmVkZWYiLCJzcXJ0UCIsIk9iamVjdCIsImZyZWV6ZSIsImNyZWF0ZSIsImlzVmFsaWQiLCJpc09kZCIsImFkZCIsImRpdiIsInNxck4iLCJhZGROIiwic3ViTiIsIm11bE4iLCJzcXJ0IiwiaW52ZXJ0QmF0Y2giLCJsc3QiLCJjbW92IiwiYyIsInRvQnl0ZXMiLCJmcm9tQnl0ZXMiLCJieXRlcyIsIkZwU3FydE9kZCIsImVsbSIsIkZwU3FydEV2ZW4iLCJoYXNoVG9Qcml2YXRlU2NhbGFyIiwiaGFzaCIsImdyb3VwT3JkZXIiLCJoYXNoTGVuIiwibWluTGVuIiwiZ2V0RmllbGRCeXRlc0xlbmd0aCIsImZpZWxkT3JkZXIiLCJiaXRMZW5ndGgiLCJnZXRNaW5IYXNoTGVuZ3RoIiwibWFwSGFzaFRvRmllbGQiLCJrZXkiLCJsZW4iLCJmaWVsZExlbiIsInJlZHVjZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/poseidon.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/curves/esm/abstract/poseidon.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   poseidon: () => (/* binding */ poseidon),\n/* harmony export */   splitConstants: () => (/* binding */ splitConstants),\n/* harmony export */   validateOpts: () => (/* binding */ validateOpts)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Poseidon Hash: https://eprint.iacr.org/2019/458.pdf, https://www.poseidon-hash.info\n\nfunction validateOpts(opts) {\n    const { Fp, mds, reversePartialPowIdx: rev, roundConstants: rc } = opts;\n    const { roundsFull, roundsPartial, sboxPower, t } = opts;\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(Fp);\n    for (const i of [\n        \"t\",\n        \"roundsFull\",\n        \"roundsPartial\"\n    ]){\n        if (typeof opts[i] !== \"number\" || !Number.isSafeInteger(opts[i])) throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);\n    }\n    // MDS is TxT matrix\n    if (!Array.isArray(mds) || mds.length !== t) throw new Error(\"Poseidon: wrong MDS matrix\");\n    const _mds = mds.map((mdsRow)=>{\n        if (!Array.isArray(mdsRow) || mdsRow.length !== t) throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);\n        return mdsRow.map((i)=>{\n            if (typeof i !== \"bigint\") throw new Error(`Poseidon MDS matrix value=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (rev !== undefined && typeof rev !== \"boolean\") throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);\n    if (roundsFull % 2 !== 0) throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);\n    const rounds = roundsFull + roundsPartial;\n    if (!Array.isArray(rc) || rc.length !== rounds) throw new Error(\"Poseidon: wrong round constants\");\n    const roundConstants = rc.map((rc)=>{\n        if (!Array.isArray(rc) || rc.length !== t) throw new Error(`Poseidon wrong round constants: ${rc}`);\n        return rc.map((i)=>{\n            if (typeof i !== \"bigint\" || !Fp.isValid(i)) throw new Error(`Poseidon wrong round constant=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (!sboxPower || ![\n        3,\n        5,\n        7\n    ].includes(sboxPower)) throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);\n    const _sboxPower = BigInt(sboxPower);\n    let sboxFn = (n)=>(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow)(Fp, n, _sboxPower);\n    // Unwrapped sbox power for common cases (195->142μs)\n    if (sboxPower === 3) sboxFn = (n)=>Fp.mul(Fp.sqrN(n), n);\n    else if (sboxPower === 5) sboxFn = (n)=>Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);\n    return Object.freeze({\n        ...opts,\n        rounds,\n        sboxFn,\n        roundConstants,\n        mds: _mds\n    });\n}\nfunction splitConstants(rc, t) {\n    if (typeof t !== \"number\") throw new Error(\"poseidonSplitConstants: wrong t\");\n    if (!Array.isArray(rc) || rc.length % t) throw new Error(\"poseidonSplitConstants: wrong rc\");\n    const res = [];\n    let tmp = [];\n    for(let i = 0; i < rc.length; i++){\n        tmp.push(rc[i]);\n        if (tmp.length === t) {\n            res.push(tmp);\n            tmp = [];\n        }\n    }\n    return res;\n}\nfunction poseidon(opts) {\n    const _opts = validateOpts(opts);\n    const { Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t } = _opts;\n    const halfRoundsFull = _opts.roundsFull / 2;\n    const partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0;\n    const poseidonRound = (values, isFull, idx)=>{\n        values = values.map((i, j)=>Fp.add(i, roundConstants[idx][j]));\n        if (isFull) values = values.map((i)=>sboxFn(i));\n        else values[partialIdx] = sboxFn(values[partialIdx]);\n        // Matrix multiplication\n        values = mds.map((i)=>i.reduce((acc, i, j)=>Fp.add(acc, Fp.mulN(i, values[j])), Fp.ZERO));\n        return values;\n    };\n    const poseidonHash = function poseidonHash(values) {\n        if (!Array.isArray(values) || values.length !== t) throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);\n        values = values.map((i)=>{\n            if (typeof i !== \"bigint\") throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);\n            return Fp.create(i);\n        });\n        let round = 0;\n        // Apply r_f/2 full rounds.\n        for(let i = 0; i < halfRoundsFull; i++)values = poseidonRound(values, true, round++);\n        // Apply r_p partial rounds.\n        for(let i = 0; i < roundsPartial; i++)values = poseidonRound(values, false, round++);\n        // Apply r_f/2 full rounds.\n        for(let i = 0; i < halfRoundsFull; i++)values = poseidonRound(values, true, round++);\n        if (round !== rounds) throw new Error(`Poseidon: wrong number of rounds: last round=${round}, total=${rounds}`);\n        return values;\n    };\n    // For verification in tests\n    poseidonHash.roundConstants = roundConstants;\n    return poseidonHash;\n} //# sourceMappingURL=poseidon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3Bvc2VpZG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsc0ZBQXNGO0FBQ2xDO0FBQzdDLFNBQVNFLGFBQWFDLElBQUk7SUFDN0IsTUFBTSxFQUFFQyxFQUFFLEVBQUVDLEdBQUcsRUFBRUMsc0JBQXNCQyxHQUFHLEVBQUVDLGdCQUFnQkMsRUFBRSxFQUFFLEdBQUdOO0lBQ25FLE1BQU0sRUFBRU8sVUFBVSxFQUFFQyxhQUFhLEVBQUVDLFNBQVMsRUFBRUMsQ0FBQyxFQUFFLEdBQUdWO0lBQ3BERiwwREFBYUEsQ0FBQ0c7SUFDZCxLQUFLLE1BQU1VLEtBQUs7UUFBQztRQUFLO1FBQWM7S0FBZ0IsQ0FBRTtRQUNsRCxJQUFJLE9BQU9YLElBQUksQ0FBQ1csRUFBRSxLQUFLLFlBQVksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDYixJQUFJLENBQUNXLEVBQUUsR0FDNUQsTUFBTSxJQUFJRyxNQUFNLENBQUMsd0JBQXdCLEVBQUVILEVBQUUsQ0FBQyxFQUFFWCxJQUFJLENBQUNXLEVBQUUsQ0FBQyxFQUFFLEVBQUUsT0FBT1gsSUFBSSxDQUFDVyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3JGO0lBQ0Esb0JBQW9CO0lBQ3BCLElBQUksQ0FBQ0ksTUFBTUMsT0FBTyxDQUFDZCxRQUFRQSxJQUFJZSxNQUFNLEtBQUtQLEdBQ3RDLE1BQU0sSUFBSUksTUFBTTtJQUNwQixNQUFNSSxPQUFPaEIsSUFBSWlCLEdBQUcsQ0FBQyxDQUFDQztRQUNsQixJQUFJLENBQUNMLE1BQU1DLE9BQU8sQ0FBQ0ksV0FBV0EsT0FBT0gsTUFBTSxLQUFLUCxHQUM1QyxNQUFNLElBQUlJLE1BQU0sQ0FBQyx5QkFBeUIsRUFBRU0sT0FBTyxDQUFDO1FBQ3hELE9BQU9BLE9BQU9ELEdBQUcsQ0FBQyxDQUFDUjtZQUNmLElBQUksT0FBT0EsTUFBTSxV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UUFDNUIsSUFBSyxJQUFJMUMsSUFBSSxHQUFHQSxJQUFJSCxlQUFlRyxJQUMvQmdDLFNBQVNELGNBQWNDLFFBQVEsT0FBT1U7UUFDMUMsMkJBQTJCO1FBQzNCLElBQUssSUFBSTFDLElBQUksR0FBR0EsSUFBSTZCLGdCQUFnQjdCLElBQ2hDZ0MsU0FBU0QsY0FBY0MsUUFBUSxNQUFNVTtRQUN6QyxJQUFJQSxVQUFVOUIsUUFDVixNQUFNLElBQUlULE1BQU0sQ0FBQyw2Q0FBNkMsRUFBRXVDLE1BQU0sUUFBUSxFQUFFOUIsT0FBTyxDQUFDO1FBQzVGLE9BQU9vQjtJQUNYO0lBQ0EsNEJBQTRCO0lBQzVCUyxhQUFhL0MsY0FBYyxHQUFHQTtJQUM5QixPQUFPK0M7QUFDWCxFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWRhcHAvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3Bvc2VpZG9uLmpzPzIyNDciXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gUG9zZWlkb24gSGFzaDogaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxOS80NTgucGRmLCBodHRwczovL3d3dy5wb3NlaWRvbi1oYXNoLmluZm9cbmltcG9ydCB7IEZwUG93LCB2YWxpZGF0ZUZpZWxkIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9wdHMob3B0cykge1xuICAgIGNvbnN0IHsgRnAsIG1kcywgcmV2ZXJzZVBhcnRpYWxQb3dJZHg6IHJldiwgcm91bmRDb25zdGFudHM6IHJjIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgcm91bmRzRnVsbCwgcm91bmRzUGFydGlhbCwgc2JveFBvd2VyLCB0IH0gPSBvcHRzO1xuICAgIHZhbGlkYXRlRmllbGQoRnApO1xuICAgIGZvciAoY29uc3QgaSBvZiBbJ3QnLCAncm91bmRzRnVsbCcsICdyb3VuZHNQYXJ0aWFsJ10pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzW2ldICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIob3B0c1tpXSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uOiBpbnZhbGlkIHBhcmFtICR7aX09JHtvcHRzW2ldfSAoJHt0eXBlb2Ygb3B0c1tpXX0pYCk7XG4gICAgfVxuICAgIC8vIE1EUyBpcyBUeFQgbWF0cml4XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1kcykgfHwgbWRzLmxlbmd0aCAhPT0gdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NlaWRvbjogd3JvbmcgTURTIG1hdHJpeCcpO1xuICAgIGNvbnN0IF9tZHMgPSBtZHMubWFwKChtZHNSb3cpID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1kc1JvdykgfHwgbWRzUm93Lmxlbmd0aCAhPT0gdClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gTURTIG1hdHJpeCByb3c6ICR7bWRzUm93fWApO1xuICAgICAgICByZXR1cm4gbWRzUm93Lm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIE1EUyBtYXRyaXggdmFsdWU9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIEZwLmNyZWF0ZShpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJldiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXYgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogaW52YWxpZCBwYXJhbSByZXZlcnNlUGFydGlhbFBvd0lkeD0ke3Jldn1gKTtcbiAgICBpZiAocm91bmRzRnVsbCAlIDIgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gcm91bmRzRnVsbCBpcyBub3QgZXZlbjogJHtyb3VuZHNGdWxsfWApO1xuICAgIGNvbnN0IHJvdW5kcyA9IHJvdW5kc0Z1bGwgKyByb3VuZHNQYXJ0aWFsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyYykgfHwgcmMubGVuZ3RoICE9PSByb3VuZHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zZWlkb246IHdyb25nIHJvdW5kIGNvbnN0YW50cycpO1xuICAgIGNvbnN0IHJvdW5kQ29uc3RhbnRzID0gcmMubWFwKChyYykgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmMpIHx8IHJjLmxlbmd0aCAhPT0gdClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gd3Jvbmcgcm91bmQgY29uc3RhbnRzOiAke3JjfWApO1xuICAgICAgICByZXR1cm4gcmMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnIHx8ICFGcC5pc1ZhbGlkKGkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gd3Jvbmcgcm91bmQgY29uc3RhbnQ9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIEZwLmNyZWF0ZShpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKCFzYm94UG93ZXIgfHwgIVszLCA1LCA3XS5pbmNsdWRlcyhzYm94UG93ZXIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIHdyb25nIHNib3hQb3dlcj0ke3Nib3hQb3dlcn1gKTtcbiAgICBjb25zdCBfc2JveFBvd2VyID0gQmlnSW50KHNib3hQb3dlcik7XG4gICAgbGV0IHNib3hGbiA9IChuKSA9PiBGcFBvdyhGcCwgbiwgX3Nib3hQb3dlcik7XG4gICAgLy8gVW53cmFwcGVkIHNib3ggcG93ZXIgZm9yIGNvbW1vbiBjYXNlcyAoMTk1LT4xNDLOvHMpXG4gICAgaWYgKHNib3hQb3dlciA9PT0gMylcbiAgICAgICAgc2JveEZuID0gKG4pID0+IEZwLm11bChGcC5zcXJOKG4pLCBuKTtcbiAgICBlbHNlIGlmIChzYm94UG93ZXIgPT09IDUpXG4gICAgICAgIHNib3hGbiA9IChuKSA9PiBGcC5tdWwoRnAuc3FyTihGcC5zcXJOKG4pKSwgbik7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzLCByb3VuZHMsIHNib3hGbiwgcm91bmRDb25zdGFudHMsIG1kczogX21kcyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdENvbnN0YW50cyhyYywgdCkge1xuICAgIGlmICh0eXBlb2YgdCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9zZWlkb25TcGxpdENvbnN0YW50czogd3JvbmcgdCcpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyYykgfHwgcmMubGVuZ3RoICUgdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NlaWRvblNwbGl0Q29uc3RhbnRzOiB3cm9uZyByYycpO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGxldCB0bXAgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRtcC5wdXNoKHJjW2ldKTtcbiAgICAgICAgaWYgKHRtcC5sZW5ndGggPT09IHQpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHRtcCk7XG4gICAgICAgICAgICB0bXAgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uKG9wdHMpIHtcbiAgICBjb25zdCBfb3B0cyA9IHZhbGlkYXRlT3B0cyhvcHRzKTtcbiAgICBjb25zdCB7IEZwLCBtZHMsIHJvdW5kQ29uc3RhbnRzLCByb3VuZHMsIHJvdW5kc1BhcnRpYWwsIHNib3hGbiwgdCB9ID0gX29wdHM7XG4gICAgY29uc3QgaGFsZlJvdW5kc0Z1bGwgPSBfb3B0cy5yb3VuZHNGdWxsIC8gMjtcbiAgICBjb25zdCBwYXJ0aWFsSWR4ID0gX29wdHMucmV2ZXJzZVBhcnRpYWxQb3dJZHggPyB0IC0gMSA6IDA7XG4gICAgY29uc3QgcG9zZWlkb25Sb3VuZCA9ICh2YWx1ZXMsIGlzRnVsbCwgaWR4KSA9PiB7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoKGksIGopID0+IEZwLmFkZChpLCByb3VuZENvbnN0YW50c1tpZHhdW2pdKSk7XG4gICAgICAgIGlmIChpc0Z1bGwpXG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKChpKSA9PiBzYm94Rm4oaSkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWx1ZXNbcGFydGlhbElkeF0gPSBzYm94Rm4odmFsdWVzW3BhcnRpYWxJZHhdKTtcbiAgICAgICAgLy8gTWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgICAgIHZhbHVlcyA9IG1kcy5tYXAoKGkpID0+IGkucmVkdWNlKChhY2MsIGksIGopID0+IEZwLmFkZChhY2MsIEZwLm11bE4oaSwgdmFsdWVzW2pdKSksIEZwLlpFUk8pKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIGNvbnN0IHBvc2VpZG9uSGFzaCA9IGZ1bmN0aW9uIHBvc2VpZG9uSGFzaCh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aCAhPT0gdClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb246IHdyb25nIHZhbHVlcyAoZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cyB3aXRoIGxlbmd0aCAke3R9KWApO1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb246IHdyb25nIHZhbHVlPSR7aX0gKCR7dHlwZW9mIGl9KWApO1xuICAgICAgICAgICAgcmV0dXJuIEZwLmNyZWF0ZShpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByb3VuZCA9IDA7XG4gICAgICAgIC8vIEFwcGx5IHJfZi8yIGZ1bGwgcm91bmRzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhbGZSb3VuZHNGdWxsOyBpKyspXG4gICAgICAgICAgICB2YWx1ZXMgPSBwb3NlaWRvblJvdW5kKHZhbHVlcywgdHJ1ZSwgcm91bmQrKyk7XG4gICAgICAgIC8vIEFwcGx5IHJfcCBwYXJ0aWFsIHJvdW5kcy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZHNQYXJ0aWFsOyBpKyspXG4gICAgICAgICAgICB2YWx1ZXMgPSBwb3NlaWRvblJvdW5kKHZhbHVlcywgZmFsc2UsIHJvdW5kKyspO1xuICAgICAgICAvLyBBcHBseSByX2YvMiBmdWxsIHJvdW5kcy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYWxmUm91bmRzRnVsbDsgaSsrKVxuICAgICAgICAgICAgdmFsdWVzID0gcG9zZWlkb25Sb3VuZCh2YWx1ZXMsIHRydWUsIHJvdW5kKyspO1xuICAgICAgICBpZiAocm91bmQgIT09IHJvdW5kcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb246IHdyb25nIG51bWJlciBvZiByb3VuZHM6IGxhc3Qgcm91bmQ9JHtyb3VuZH0sIHRvdGFsPSR7cm91bmRzfWApO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgLy8gRm9yIHZlcmlmaWNhdGlvbiBpbiB0ZXN0c1xuICAgIHBvc2VpZG9uSGFzaC5yb3VuZENvbnN0YW50cyA9IHJvdW5kQ29uc3RhbnRzO1xuICAgIHJldHVybiBwb3NlaWRvbkhhc2g7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3NlaWRvbi5qcy5tYXAiXSwibmFtZXMiOlsiRnBQb3ciLCJ2YWxpZGF0ZUZpZWxkIiwidmFsaWRhdGVPcHRzIiwib3B0cyIsIkZwIiwibWRzIiwicmV2ZXJzZVBhcnRpYWxQb3dJZHgiLCJyZXYiLCJyb3VuZENvbnN0YW50cyIsInJjIiwicm91bmRzRnVsbCIsInJvdW5kc1BhcnRpYWwiLCJzYm94UG93ZXIiLCJ0IiwiaSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsIl9tZHMiLCJtYXAiLCJtZHNSb3ciLCJjcmVhdGUiLCJ1bmRlZmluZWQiLCJyb3VuZHMiLCJpc1ZhbGlkIiwiaW5jbHVkZXMiLCJfc2JveFBvd2VyIiwiQmlnSW50Iiwic2JveEZuIiwibiIsIm11bCIsInNxck4iLCJPYmplY3QiLCJmcmVlemUiLCJzcGxpdENvbnN0YW50cyIsInJlcyIsInRtcCIsInB1c2giLCJwb3NlaWRvbiIsIl9vcHRzIiwiaGFsZlJvdW5kc0Z1bGwiLCJwYXJ0aWFsSWR4IiwicG9zZWlkb25Sb3VuZCIsInZhbHVlcyIsImlzRnVsbCIsImlkeCIsImoiLCJhZGQiLCJyZWR1Y2UiLCJhY2MiLCJtdWxOIiwiWkVSTyIsInBvc2VpZG9uSGFzaCIsInJvdW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/poseidon.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/utils.js":
/*!********************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\nfunction abytes(item) {\n    if (!isBytes(item)) throw new Error(\"Uint8Array expected\");\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // Big Endian\n    return BigInt(hex === \"\" ? \"0\" : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    _A: 65,\n    _F: 70,\n    _a: 97,\n    _f: 102\n};\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    } else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ function bitSet(n, pos, value) {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n())=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || isBytes(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n} // validate type tests\n // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n // // Should fail type-check\n // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSwwRUFBMEU7QUFDMUUsOERBQThEO0FBQzlELCtFQUErRTtBQUMvRSx1Q0FBdUM7QUFDdkMsTUFBTUEsTUFBTSxhQUFhLEdBQUdDLE9BQU87QUFDbkMsTUFBTUMsTUFBTSxhQUFhLEdBQUdELE9BQU87QUFDbkMsTUFBTUUsTUFBTSxhQUFhLEdBQUdGLE9BQU87QUFDNUIsU0FBU0csUUFBUUMsQ0FBQztJQUNyQixPQUFRQSxhQUFhQyxjQUNoQkQsS0FBSyxRQUFRLE9BQU9BLE1BQU0sWUFBWUEsRUFBRUUsV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdEU7QUFDTyxTQUFTQyxPQUFPQyxJQUFJO0lBQ3ZCLElBQUksQ0FBQ04sUUFBUU0sT0FDVCxNQUFNLElBQUlDLE1BQU07QUFDeEI7QUFDQSx3REFBd0Q7QUFDeEQsTUFBTUMsUUFBUSxhQUFhLEdBQUdDLE1BQU1DLElBQUksQ0FBQztJQUFFQyxRQUFRO0FBQUksR0FBRyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUc7QUFDL0Y7O0NBRUMsR0FDTSxTQUFTQyxXQUFXQyxLQUFLO0lBQzVCWixPQUFPWTtJQUNQLG9DQUFvQztJQUNwQyxJQUFJQyxNQUFNO0lBQ1YsSUFBSyxJQUFJTCxJQUFJLEdBQUdBLElBQUlJLE1BQU1OLE1BQU0sRUFBRUUsSUFBSztRQUNuQ0ssT0FBT1YsS0FBSyxDQUFDUyxLQUFLLENBQUNKLEVBQUUsQ0FBQztJQUMxQjtJQUNBLE9BQU9LO0FBQ1g7QUFDTyxTQUFTQyxvQkFBb0JDLEdBQUc7SUFDbkMsTUFBTUYsTUFBTUUsSUFBSU4sUUFBUSxDQUFDO0lBQ3pCLE9BQU9JLElBQUlQLE1BQU0sR0FBRyxJQUFJ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RSxjQUFjcEIsUUFBUXhELFdBQ3RCO1FBQ0osSUFBSSxDQUFDNkUsU0FBU3JCLEtBQUtTLFNBQVM7WUFDeEIsTUFBTSxJQUFJbEcsTUFBTSxDQUFDLGNBQWMsRUFBRStHLE9BQU9KLFdBQVcsQ0FBQyxFQUFFbEIsSUFBSSxFQUFFLEVBQUUsT0FBT0EsSUFBSSxZQUFZLEVBQUVtQixLQUFLLENBQUM7UUFDakc7SUFDSjtJQUNBLEtBQUssTUFBTSxDQUFDRCxXQUFXQyxLQUFLLElBQUlJLE9BQU9DLE9BQU8sQ0FBQ1QsWUFDM0NFLFdBQVdDLFdBQVdDLE1BQU07SUFDaEMsS0FBSyxNQUFNLENBQUNELFdBQVdDLEtBQUssSUFBSUksT0FBT0MsT0FBTyxDQUFDUixlQUMzQ0MsV0FBV0MsV0FBV0MsTUFBTTtJQUNoQyxPQUFPVjtBQUNYLEVBQ0Esc0JBQXNCO0NBQ3RCLHVFQUF1RTtDQUN2RSxnRkFBZ0Y7Q0FDaEYsNEJBQTRCO0NBQzVCLDJEQUEyRDtDQUMzRCxxRUFBcUU7Q0FDckUsK0RBQStEO0NBQy9ELDREQUE0RDtDQUM1RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1kYXBwLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcz9mZDlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIDEwMCBsaW5lcyBvZiBjb2RlIGluIHRoZSBmaWxlIGFyZSBkdXBsaWNhdGVkIGZyb20gbm9ibGUtaGFzaGVzICh1dGlscykuXG4vLyBUaGlzIGlzIE9LOiBgYWJzdHJhY3RgIGRpcmVjdG9yeSBkb2VzIG5vdCB1c2Ugbm9ibGUtaGFzaGVzLlxuLy8gVXNlciBtYXkgb3B0LWluIGludG8gdXNpbmcgZGlmZmVyZW50IGhhc2hpbmcgbGlicmFyeS4gVGhpcyB3YXksIG5vYmxlLWhhc2hlc1xuLy8gd29uJ3QgYmUgaW5jbHVkZWQgaW50byB0aGVpciBidW5kbGUuXG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xuY29uc3QgXzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFieXRlcyhpdGVtKSB7XG4gICAgaWYgKCFpc0J5dGVzKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQmlnIEVuZGlhblxuICAgIHJldHVybiBCaWdJbnQoaGV4ID09PSAnJyA/ICcwJyA6IGAweCR7aGV4fWApO1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0J5dGVzKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gZXhwZWN0ZWQgJHtleHBlY3RlZExlbmd0aH0gYnl0ZXMsIGdvdCAke2xlbn1gKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQ29tcGFyZXMgMiB1OGEtcyBpbiBraW5kYSBjb25zdGFudCB0aW1lXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkaWZmID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGRpZmYgfD0gYVtpXSBeIGJbaV07XG4gICAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdFNldChuLCBwb3MsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XG4vLyBEUkJHXG5jb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuY29uc3QgdThmciA9IChhcnIpID0+IFVpbnQ4QXJyYXkuZnJvbShhcnIpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4vKipcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IGlzQnl0ZXModmFsKSxcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxufTtcbi8vIHR5cGUgUmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIFQ+ID0geyBbUCBpbiBLXTogVDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHt0eXBlfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoZmllbGROYW1lKX09JHt2YWx9ICgke3R5cGVvZiB2YWx9KSwgZXhwZWN0ZWQgJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsImlzQnl0ZXMiLCJhIiwiVWludDhBcnJheSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImFieXRlcyIsIml0ZW0iLCJFcnJvciIsImhleGVzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXNUb0hleCIsImJ5dGVzIiwiaGV4IiwibnVtYmVyVG9IZXhVbnBhZGRlZCIsIm51bSIsImhleFRvTnVtYmVyIiwiYXNjaWlzIiwiXzAiLCJfOSIsIl9BIiwiX0YiLCJfYSIsIl9mIiwiYXNjaWlUb0Jhc2UxNiIsImNoYXIiLCJoZXhUb0J5dGVzIiwiaGwiLCJhbCIsImFycmF5IiwiYWkiLCJoaSIsIm4xIiwiY2hhckNvZGVBdCIsIm4yIiwidW5kZWZpbmVkIiwiYnl0ZXNUb051bWJlckJFIiwiYnl0ZXNUb051bWJlckxFIiwicmV2ZXJzZSIsIm51bWJlclRvQnl0ZXNCRSIsIm4iLCJsZW4iLCJudW1iZXJUb0J5dGVzTEUiLCJudW1iZXJUb1ZhckJ5dGVzQkUiLCJlbnN1cmVCeXRlcyIsInRpdGxlIiwiZXhwZWN0ZWRMZW5ndGgiLCJyZXMiLCJlIiwiY29uY2F0Qnl0ZXMiLCJhcnJheXMiLCJzdW0iLCJwYWQiLCJzZXQiLCJlcXVhbEJ5dGVzIiwiYiIsImRpZmYiLCJ1dGY4VG9CeXRlcyIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiYml0TGVuIiwiYml0R2V0IiwicG9zIiwiYml0U2V0IiwidmFsdWUiLCJiaXRNYXNrIiwidThuIiwiZGF0YSIsInU4ZnIiLCJhcnIiLCJjcmVhdGVIbWFjRHJiZyIsImhhc2hMZW4iLCJxQnl0ZUxlbiIsImhtYWNGbiIsInYiLCJrIiwicmVzZXQiLCJmaWxsIiwiaCIsInJlc2VlZCIsInNlZWQiLCJnZW4iLCJvdXQiLCJzbCIsInNsaWNlIiwicHVzaCIsImdlblVudGlsIiwicHJlZCIsInZhbGlkYXRvckZucyIsImJpZ2ludCIsInZhbCIsImZ1bmN0aW9uIiwiYm9vbGVhbiIsInN0cmluZyIsInN0cmluZ09yVWludDhBcnJheSIsImlzU2FmZUludGVnZXIiLCJOdW1iZXIiLCJpc0FycmF5IiwiZmllbGQiLCJvYmplY3QiLCJGcCIsImlzVmFsaWQiLCJoYXNoIiwib3V0cHV0TGVuIiwidmFsaWRhdGVPYmplY3QiLCJ2YWxpZGF0b3JzIiwib3B0VmFsaWRhdG9ycyIsImNoZWNrRmllbGQiLCJmaWVsZE5hbWUiLCJ0eXBlIiwiaXNPcHRpb25hbCIsImNoZWNrVmFsIiwiU3RyaW5nIiwiT2JqZWN0IiwiZW50cmllcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = \"\"){\n            super(m);\n        }\n    },\n    _parseInt (data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02) throw new E(\"Invalid signature integer tag\");\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len) throw new E(\"Invalid signature integer: wrong length\");\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 128) throw new E(\"Invalid signature integer: negative\");\n        if (res[0] === 0x00 && !(res[1] & 128)) throw new E(\"Invalid signature integer: unnecessary leading zero\");\n        return {\n            d: b2n(res),\n            l: data.subarray(len + 2)\n        }; // d is data, l is left\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30) throw new E(\"Invalid signature tag\");\n        if (data[1] !== l - 2) throw new E(\"Invalid signature: incorrect length\");\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length) throw new E(\"Invalid signature: left bytes after parsing\");\n        return {\n            r,\n            s\n        };\n    },\n    hexFromSig (sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? \"00\" + s : s;\n        const h = (num)=>{\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === \"bigint\" && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num)) throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key)) key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"Invalid key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey) num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n                throw new Error(\"bad point: ZERO\");\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n            if (!this.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{\n                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));\n                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n) return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n) return this;\n            const { endo } = CURVE;\n            if (!endo) return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0) return {\n                x: Fp.ZERO,\n                y: Fp.ZERO\n            };\n            if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                } catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                    throw new Error(\"Point is not on curve\" + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r)) throw new Error(\"r must be 0 < r < CURVE.n\");\n            if (!isWithinCurveOrder(this.s)) throw new Error(\"s must be 0 < s < CURVE.n\");\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        if (typeof num !== \"bigint\") throw new Error(\"bigint expected\");\n        if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"publicKey\", publicKey);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === \"string\" || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            } else if (typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\") {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            } else {\n                throw new Error(\"PARSE\");\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            if (error.message === \"PARSE\") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLDREQUE0RDtBQUNYO0FBQ2I7QUFDSDtBQUNRO0FBQ3pDLFNBQVNLLGtCQUFrQkMsS0FBSztJQUM1QixNQUFNQyxPQUFPUCx3REFBYUEsQ0FBQ007SUFDM0JILHFEQUFpQixDQUFDSSxNQUFNO1FBQ3BCRSxHQUFHO1FBQ0hDLEdBQUc7SUFDUCxHQUFHO1FBQ0NDLDBCQUEwQjtRQUMxQkMsZ0JBQWdCO1FBQ2hCQyxlQUFlO1FBQ2ZDLGVBQWU7UUFDZkMsb0JBQW9CO1FBQ3BCQyxXQUFXO1FBQ1hDLFNBQVM7SUFDYjtJQUNBLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVWLENBQUMsRUFBRSxHQUFHRjtJQUN4QixJQUFJVyxNQUFNO1FBQ04sSUFBSSxDQUFDQyxHQUFHQyxHQUFHLENBQUNYLEdBQUdVLEdBQUdFLElBQUksR0FBRztZQUNyQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJLE9BQU9KLFNBQVMsWUFDaEIsT0FBT0EsS0FBS0ssSUFBSSxLQUFLLFlBQ3JCLE9BQU9MLEtBQUtNLFdBQVcsS0FBSyxZQUFZO1lBQ3hDLE1BQU0sSUFBSUYsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsT0FBT0csT0FBT0MsTUFBTSxDQUFDO1FBQUUsR0FBR25CLElBQUk7SUFBQztBQUNuQztBQUNBLCtCQUErQjtBQUMvQixNQUFNLEVBQUVvQixpQkFBaUJDLEdBQUcsRUFBRUMsWUFBWUMsR0FBRyxFQUFFLEdBQUczQixzQ0FBRUE7QUFDN0MsTUFBTTRCLE1BQU07SUFDZiwyQkFBMkI7SUFDM0JDLEtBQUssTUFBTUMsZUFBZVg7UUFDdEJZLFlBQVlDLElBQUksRUFBRSxDQUFFO1lBQ2hCLEtBQUssQ0FBQ0E7UUFDVjtJQUNKO0lBQ0FDLFdB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LHNCQUFzQjtRQUM1QyxNQUFNLEVBQUVoTixPQUFPLEVBQUV1TixLQUFLLEVBQUUsR0FBR1gsVUFBVUcsS0FBS2MsTUFBTSxpREFBaUQ7UUFDakc3UCxJQUFJN0QsR0FBR3FFLEdBQUcsQ0FBQ3NPLEtBQUtELElBQUkscUNBQXFDO1FBQ3pEN08sSUFBSTdELEdBQUdxRSxHQUFHLENBQUNSLEdBQUd1UCxRQUFRLG1CQUFtQjtRQUN6Q3hQLElBQUk1RCxHQUFHaVQsSUFBSSxDQUFDclAsR0FBR2lQLEtBQUtoTixVQUFVLHdDQUF3QztRQUN0RWhDLElBQUk3RCxHQUFHaVQsSUFBSSxDQUFDcFAsR0FBR3VQLE9BQU92TixVQUFVLHVDQUF1QztRQUN2RSxNQUFNc04sS0FBS25ULEdBQUdzSCxLQUFLLENBQUNvTCxPQUFPMVMsR0FBR3NILEtBQUssQ0FBQ3pELElBQUksK0JBQStCO1FBQ3ZFQSxJQUFJN0QsR0FBR2lULElBQUksQ0FBQ2pULEdBQUdpSSxHQUFHLENBQUNwRSxJQUFJQSxHQUFHc1AsS0FBSyw0QkFBNEI7UUFDM0R2UCxJQUFJNUQsR0FBRzJULEdBQUcsQ0FBQy9QLEdBQUdtUCxNQUFNLG9CQUFvQjtRQUN4QyxPQUFPO1lBQUVuUDtZQUFHQztRQUFFO0lBQ2xCO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1kYXBwLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcz80ZjI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiXG5pbXBvcnQgeyB2YWxpZGF0ZUJhc2ljLCB3TkFGIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5zdXJlQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVuZG9tb3JwaGlzbSB3aXRoIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLy8gQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllc1xuY29uc3QgeyBieXRlc1RvTnVtYmVyQkU6IGIybiwgaGV4VG9CeXRlczogaDJiIH0gPSB1dDtcbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZycpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgICAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoJyk7XG4gICAgICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgICAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgICAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICAgICAgaWYgKHJlc1swXSAmIDBiMTAwMDAwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcbiAgICAgICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiAhKHJlc1sxXSAmIDBiMTAwMDAwMDApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVybycpO1xuICAgICAgICByZXR1cm4geyBkOiBiMm4ocmVzKSwgbDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9OyAvLyBkIGlzIGRhdGEsIGwgaXMgbGVmdFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIHV0LmFieXRlcyhkYXRhKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmICh1dC5pc0J5dGVzKGtleSkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZC5tb2QobnVtLCBuKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGFzc2VydFByalBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMCh0aGlzLnB5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgLy8gVmFsaWRhdGUgaWYgZ2VuZXJhdG9yIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZpZWxkRWxlbWVudChudW0pIHtcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHV0LmlzQnl0ZXMoaXRlbSk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gdXQuY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0gR2tcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgICAgICAgICAgLy8gYSkgZGVwZW5kZW5jeSBvbiBDU1BSTkcgYikgMTUlIHNsb3dkb3duIGMpIGRvZXNuJ3QgcmVhbGx5IGhlbHAgc2luY2UgYmlnaW50cyBhcmUgbm90IENUXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXG4gICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICBjb25zdCBkZWZhdWx0VmVyT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuICAgICAqIGBgYFxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG1zZ0hhc2ggTk9UIG1lc3NhZ2UuIG1zZyBuZWVkcyB0byBiZSBoYXNoZWQgdG8gYG1zZ0hhc2hgLCBvciB1c2UgYHByZWhhc2hgLlxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIG9wdHMgbG93UyBmb3Igbm9uLW1hbGxlYWJsZSBzaWdzLiBleHRyYUVudHJvcHkgZm9yIG1peGluZyByYW5kb21uZXNzIGludG8gay4gcHJlaGFzaCB3aWxsIGhhc2ggZmlyc3QgYXJnLlxuICAgICAqIEByZXR1cm5zIHNpZ25hdHVyZSB3aXRoIHJlY292ZXJ5IHBhcmFtXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xuICAgICAgICBjb25zdCBkcmJnID0gdXQuY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgfVxuICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGhhc2ggYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXG4gICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgVTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCB9ID0gb3B0cztcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgdXQuaXNCeXRlcyhzZykpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOlsidmFsaWRhdGVCYXNpYyIsIndOQUYiLCJtb2QiLCJ1dCIsImVuc3VyZUJ5dGVzIiwidmFsaWRhdGVQb2ludE9wdHMiLCJjdXJ2ZSIsIm9wdHMiLCJ2YWxpZGF0ZU9iamVjdCIsImEiLCJiIiwiYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIiwid3JhcFByaXZhdGVLZXkiLCJpc1RvcnNpb25GcmVlIiwiY2xlYXJDb2ZhY3RvciIsImFsbG93SW5maW5pdHlQb2ludCIsImZyb21CeXRlcyIsInRvQnl0ZXMiLCJlbmRvIiwiRnAiLCJlcWwiLCJaRVJPIiwiRXJyb3IiLCJiZXRhIiwic3BsaXRTY2FsYXIiLCJPYmplY3QiLCJmcmVlemUiLCJieXRlc1RvTnVtYmVyQkUiLCJiMm4iLCJoZXhUb0J5dGVzIiwiaDJiIiwiREVSIiwiRXJyIiwiREVSRXJyIiwiY29uc3RydWN0b3IiLCJtIiwiX3BhcnNlSW50IiwiZGF0YSIsIkUiLCJsZW5ndGgiLCJsZW4iLCJyZXMiLCJzdWJhcnJheSIsImQiLCJsIiwidG9TaWciLCJoZXgiLCJhYnl0ZXMiLCJyIiwic0J5dGVzIiwicyIsInJCeXRlc0xlZnQiLCJoZXhGcm9tU2lnIiwic2lnIiwic2xpY2UiLCJOdW1iZXIiLCJwYXJzZUludCIsImgiLCJudW0iLCJ0b1N0cmluZyIsInNobCIsInJobCIsInNsIiwicmwiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJ3ZWllcnN0cmFzc1BvaW50cyIsIkNVUlZFIiwiX2MiLCJwb2ludCIsIl9pc0NvbXByZXNzZWQiLCJ0b0FmZmluZSIsImNvbmNhdEJ5dGVzIiwiVWludDhBcnJheSIsImZyb20iLCJ4IiwieSIsImJ5dGVzIiwidGFpbCIsIkJZVEVTIiwid2VpZXJzdHJhc3NFcXVhdGlvbiIsIngyIiwic3FyIiwieDMiLCJtdWwiLCJhZGQiLCJHeSIsIkd4IiwiaXNXaXRoaW5DdXJ2ZU9yZGVyIiwibiIsImFzc2VydEdFIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsImtleSIsImxlbmd0aHMiLCJuQnl0ZUxlbmd0aCIsImlzQnl0ZXMiLCJieXRlc1RvSGV4IiwiaW5jbHVkZXMiLCJwYWRTdGFydCIsImVycm9yIiwicG9pbnRQcmVjb21wdXRlcyIsIk1hcCIsImFzc2VydFByalBvaW50Iiwib3RoZXIiLCJQb2ludCIsInB4IiwicHkiLCJweiIsImlzVmFsaWQiLCJmcm9tQWZmaW5lIiwicCIsImlzMCIsImkiLCJPTkUiLCJub3JtYWxpemVaIiwicG9pbnRzIiwidG9JbnYiLCJpbnZlcnRCYXRjaCIsIm1hcCIsImZyb21IZXgiLCJQIiwiYXNzZXJ0VmFsaWRpdHkiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJCQVNFIiwibXVsdGlwbHkiLCJfc2V0V2luZG93U2l6ZSIsIndpbmRvd1NpemUiLCJfV0lORE9XX1NJWkUiLCJkZWxldGUiLCJsZWZ0IiwicmlnaHQiLCJoYXNFdmVuWSIsImlzT2RkIiwiZXF1YWxzIiwiWDEiLCJZMSIsIloxIiwiWDIiLCJZMiIsIloyIiwiVTEiLCJVMiIsIm5lZ2F0ZSIsIm5lZyIsImRvdWJsZSIsImIzIiwiWDMiLCJZMyIsIlozIiwidDAiLCJ0MSIsInQyIiwidDMiLCJzdWIiLCJ0NCIsInQ1Iiwic3VidHJhY3QiLCJ3bmFmIiwid05BRkNhY2hlZCIsImNvbXAiLCJtdWx0aXBseVVuc2FmZSIsIkkiLCJ1bnNhZmVMYWRkZXIiLCJrMW5lZyIsImsxIiwiazJuZWciLCJrMiIsImsxcCIsImsycCIsInNjYWxhciIsImZha2UiLCJmIiwiZjFwIiwiZjJwIiwiY29uc3RUaW1lTmVnYXRlIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJRIiwiRyIsInN1bSIsInVuZGVmaW5lZCIsIml6IiwieiIsImludiIsImF4IiwiYXkiLCJ6eiIsImNvZmFjdG9yIiwidG9SYXdCeXRlcyIsImlzQ29tcHJlc3NlZCIsInRvSGV4IiwiX2JpdHMiLCJuQml0TGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJQcm9qZWN0aXZlUG9pbnQiLCJ2YWxpZGF0ZU9wdHMiLCJoYXNoIiwiaG1hYyIsInJhbmRvbUJ5dGVzIiwiYml0czJpbnQiLCJiaXRzMmludF9tb2ROIiwibG93UyIsIndlaWVyc3RyYXNzIiwiY3VydmVEZWYiLCJDVVJWRV9PUkRFUiIsImNvbXByZXNzZWRMZW4iLCJ1bmNvbXByZXNzZWRMZW4iLCJpc1ZhbGlkRmllbGRFbGVtZW50IiwiT1JERVIiLCJtb2ROIiwiaW52TiIsImludmVydCIsImNhdCIsImhlYWQiLCJ5MiIsInNxcnQiLCJzcXJ0RXJyb3IiLCJzdWZmaXgiLCJtZXNzYWdlIiwiaXNZT2RkIiwiaXNIZWFkT2RkIiwibnVtVG9OQnl0ZVN0ciIsIm51bWJlclRvQnl0ZXNCRSIsImlzQmlnZ2VyVGhhbkhhbGZPcmRlciIsIm51bWJlciIsIkhBTEYiLCJub3JtYWxpemVTIiwic2xjTnVtIiwidG8iLCJTaWduYXR1cmUiLCJyZWNvdmVyeSIsImZyb21Db21wYWN0IiwiZnJvbURFUiIsImFkZFJlY292ZXJ5Qml0IiwicmVjb3ZlclB1YmxpY0tleSIsIm1zZ0hhc2giLCJyZWMiLCJyYWRqIiwicHJlZml4IiwiUiIsImlyIiwidTEiLCJ1MiIsImhhc0hpZ2hTIiwidG9ERVJSYXdCeXRlcyIsInRvREVSSGV4IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJ0b0NvbXBhY3RIZXgiLCJ1dGlscyIsImlzVmFsaWRQcml2YXRlS2V5IiwicmFuZG9tUHJpdmF0ZUtleSIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsInByZWNvbXB1dGUiLCJnZXRQdWJsaWNLZXkiLCJpc1Byb2JQdWIiLCJpdGVtIiwiYXJyIiwic3RyIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdmF0ZUEiLCJwdWJsaWNCIiwiZGVsdGEiLCJPUkRFUl9NQVNLIiwiYml0TWFzayIsImludDJvY3RldHMiLCJwcmVwU2lnIiwiZGVmYXVsdFNpZ09wdHMiLCJzb21lIiwiayIsInByZWhhc2giLCJleHRyYUVudHJvcHkiLCJlbnQiLCJoMWludCIsInNlZWRBcmdzIiwiZSIsInB1c2giLCJzZWVkIiwiazJzaWciLCJrQnl0ZXMiLCJpayIsInEiLCJub3JtUyIsImRlZmF1bHRWZXJPcHRzIiwic2lnbiIsInByaXZLZXkiLCJDIiwiZHJiZyIsImNyZWF0ZUhtYWNEcmJnIiwib3V0cHV0TGVuIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwicHVibGljS2V5Iiwic2ciLCJfc2lnIiwiZGVyRXJyb3IiLCJpcyIsInYiLCJTV1VGcFNxcnRSYXRpbyIsIloiLCJvIiwiYzEiLCJfMm5fcG93X2MxXzEiLCJfMm5fcG93X2MxIiwiYzIiLCJjMyIsImM0IiwiYzUiLCJjNiIsInBvdyIsImM3Iiwic3FydFJhdGlvIiwidSIsInR2MSIsInR2MiIsInR2MyIsInR2NSIsInR2NCIsImlzUVIiLCJjbW92IiwidHZ2NSIsImUxIiwidmFsdWUiLCJ5MSIsIm1hcFRvQ3VydmVTaW1wbGVTV1UiLCJ2YWxpZGF0ZUZpZWxkIiwiQSIsIkIiLCJ0djYiLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/secp256k1.js":
/*!***************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/curves/esm/secp256k1.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */ endo: {\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1P;\nconst ge = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    if (!fe(x)) throw new Error(\"bad x: need 0 < x < p\"); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r)) return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    } catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n            bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n            taggedHash,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fp.create(BigInt(\"-11\"))\n    }))();\nconst htf = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fp.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\nconst hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUN0QjtBQUNJO0FBQ0Q7QUFDc0I7QUFDZDtBQUN3QztBQUNqQztBQUNoRSxNQUFNYSxhQUFhQyxPQUFPO0FBQzFCLE1BQU1DLGFBQWFELE9BQU87QUFDMUIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNSCxPQUFPO0FBQ25CLE1BQU1JLGFBQWEsQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDRCxJQUFJQyxJQUFJSCxHQUFFLElBQUtHO0FBQzdDOzs7Q0FHQyxHQUNELFNBQVNDLFFBQVFDLENBQUM7SUFDZCxNQUFNQyxJQUFJVjtJQUNWLGtCQUFrQjtJQUNsQixNQUFNVyxNQUFNVixPQUFPLElBQUlXLE1BQU1YLE9BQU8sSUFBSVksT0FBT1osT0FBTyxLQUFLYSxPQUFPYixPQUFPO0lBQ3pFLGtCQUFrQjtJQUNsQixNQUFNYyxPQUFPZCxPQUFPLEtBQUtlLE9BQU9mLE9BQU8sS0FBS2dCLE9BQU9oQixPQUFPO0lBQzFELE1BQU1pQixLQUFLLElBQUtULElBQUlBLElBQUtDLEdBQUcsVUFBVTtJQUN0QyxNQUFNUyxLQUFLLEtBQU1ELEtBQUtULElBQUtDLEdBQUcsTUFBTTtJQUNwQyxNQUFNVSxLQUFLLDJEQUFNRCxJQUFJUixLQUFLRCxLQUFLUyxLQUFNVDtJQUNyQyxNQUFNVyxLQUFLLDJEQUFNRCxJQUFJVCxLQUFLRCxLQUFLUyxLQUFNVDtJQUNyQyxNQUFNWSxNQUFNLDJEQUFNRCxJQUFJakIsS0FBS00sS0FBS1EsS0FBTVI7SUFDdEMsTUFBTWEsTUFBTSwyREFBTUQsS0FBS1QsTUFBTUgsS0FBS1ksTUFBT1o7SUFDekMsTUFBTWMsTUFBTSwyREFBTUQsS0FBS1QsTUFBTUosS0FBS2EsTUFBT2I7SUFDekMsTUFBTWUsTUFBTSwyREFBTUQsS0FBS1Is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QzVDLE9BQU9WLE9BQU90RSxHQUFHbkQ7SUFDckIsR0FBRztRQUNDb0ksS0FBSztRQUNMQyxXQUFXO1FBQ1hwRCxHQUFHMUQsR0FBRytHLEtBQUs7UUFDWHRDLEdBQUc7UUFDSDFELEdBQUc7UUFDSGlHLFFBQVE7UUFDUkMsTUFBTTlKLHdEQUFNQTtJQUNoQixFQUFDO0FBQ00sTUFBTStKLGNBQThCLGFBQUgsR0FBSSxLQUFNUCxJQUFJTyxXQUFXLElBQUk7QUFDOUQsTUFBTUMsZ0JBQWdDLGFBQUgsR0FBSSxLQUFNUixJQUFJUSxhQUFhLElBQUksQ0FDekUscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZGFwcC8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzPzE1OGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2hlciwgaXNvZ2VueU1hcCB9IGZyb20gJy4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyc7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSAnLi9hYnN0cmFjdC9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUgfSBmcm9tICcuL2Fic3RyYWN0L3V0aWxzLmpzJztcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwID0gRmllbGQoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLCAvLyBlcXVhdGlvbiBwYXJhbXM6IGEsIGJcbiAgICBiOiBCaWdJbnQoNyksIC8vIFNlZW0gdG8gYmUgcmlnaWQ6IGJpdGNvaW50YWxrLm9yZy9pbmRleC5waHA/dG9waWM9Mjg5Nzk1Lm1zZzMxODM5NzUjbXNnMzE4Mzk3NVxuICAgIEZwLCAvLyBGaWVsZCdzIHByaW1lOiAybioqMjU2biAtIDJuKiozMm4gLSAybioqOW4gLSAybioqOG4gLSAybioqN24gLSAybioqNm4gLSAybioqNG4gLSAxblxuICAgIG46IHNlY3AyNTZrMU4sIC8vIEN1cnZlIG9yZGVyLCB0b3RhbCBjb3VudCBvZiB2YWxpZCBwb2ludHMgaW4gdGhlIGZpZWxkXG4gICAgLy8gQmFzZSBwb2ludCAoeCwgeSkgYWthIGdlbmVyYXRvciBwb2ludFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBoOiBCaWdJbnQoMSksIC8vIENvZmFjdG9yXG4gICAgbG93UzogdHJ1ZSwgLy8gQWxsb3cgb25seSBsb3ctUyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQgaW4gc2lnbigpIGFuZCB2ZXJpZnkoKVxuICAgIC8qKlxuICAgICAqIHNlY3AyNTZrMSBiZWxvbmdzIHRvIEtvYmxpdHogY3VydmVzOiBpdCBoYXMgZWZmaWNpZW50bHkgY29tcHV0YWJsZSBlbmRvbW9ycGhpc20uXG4gICAgICogRW5kb21vcnBoaXNtIHVzZXMgMnggbGVzcyBSQU0sIHNwZWVkcyB1cCBwcmVjb21wdXRhdGlvbiBieSAyeCBhbmQgRUNESCAvIGtleSByZWNvdmVyeSBieSAyMCUuXG4gICAgICogRm9yIHByZWNvbXB1dGVkIHdOQUYgaXQgdHJhZGVzIG9mZiAxLzIgaW5pdCB0aW1lICYgMS8zIHJhbSBmb3IgMjAlIHBlcmYgaGl0LlxuICAgICAqIEV4cGxhbmF0aW9uOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsbWlsbHIvZWI2NzA4MDY3OTNlODRkZjYyOGE3YzQzNGE4NzMwNjZcbiAgICAgKi9cbiAgICBlbmRvOiB7XG4gICAgICAgIGJldGE6IEJpZ0ludCgnMHg3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyksXG4gICAgICAgIHNwbGl0U2NhbGFyOiAoaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbiA9IHNlY3AyNTZrMU47XG4gICAgICAgICAgICBjb25zdCBhMSA9IEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpO1xuICAgICAgICAgICAgY29uc3QgYjEgPSAtXzFuICogQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyk7XG4gICAgICAgICAgICBjb25zdCBhMiA9IEJpZ0ludCgnMHgxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnKTtcbiAgICAgICAgICAgIGNvbnN0IGIyID0gYTE7XG4gICAgICAgICAgICBjb25zdCBQT1dfMl8xMjggPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7IC8vICgybioqMTI4bikudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICBjb25zdCBjMSA9IGRpdk5lYXJlc3QoYjIgKiBrLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gZGl2TmVhcmVzdCgtYjEgKiBrLCBuKTtcbiAgICAgICAgICAgIGxldCBrMSA9IG1vZChrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgICAgICAgICAgbGV0IGsyID0gbW9kKC1jMSAqIGIxIC0gYzIgKiBiMiwgbik7XG4gICAgICAgICAgICBjb25zdCBrMW5lZyA9IGsxID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMSA9IG4gLSBrMTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMiA9IG4gLSBrMjtcbiAgICAgICAgICAgIGlmIChrMSA+IFBPV18yXzEyOCB8fCBrMiA+IFBPV18yXzEyOCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXI6IEVuZG9tb3JwaGlzbSBmYWlsZWQsIGs9JyArIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbiAgICAgICAgfSxcbiAgICB9LFxufSwgc2hhMjU2KTtcbi8vIFNjaG5vcnIgc2lnbmF0dXJlcyBhcmUgc3VwZXJpb3IgdG8gRUNEU0EgZnJvbSBhYm92ZS4gQmVsb3cgaXMgU2Nobm9yci1zcGVjaWZpYyBCSVAwMzQwIGNvZGUuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgZmUgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMVA7XG5jb25zdCBnZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxTjtcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gc2hhMjU2KFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiBudW1iZXJUb0J5dGVzQkUobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IEdtdWxBZGQgPSAoUSwgYSwgYikgPT4gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKTtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgbGV0IGRfID0gc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdik7IC8vIHNhbWUgbWV0aG9kIGV4ZWN1dGVkIGluIGZyb21Qcml2YXRlS2V5XG4gICAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcbiAgICBjb25zdCBzY2FsYXIgPSBwLmhhc0V2ZW5ZKCkgPyBkXyA6IG1vZE4oLWRfKTtcbiAgICByZXR1cm4geyBzY2FsYXI6IHNjYWxhciwgYnl0ZXM6IHBvaW50VG9CeXRlcyhwKSB9O1xufVxuLyoqXG4gKiBsaWZ0X3ggZnJvbSBCSVAzNDAuIENvbnZlcnQgMzItYnl0ZSB4IGNvb3JkaW5hdGUgdG8gZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKiBAcmV0dXJucyB2YWxpZCBwb2ludCBjaGVja2VkIGZvciBiZWluZyBvbi1jdXJ2ZVxuICovXG5mdW5jdGlvbiBsaWZ0X3goeCkge1xuICAgIGlmICghZmUoeCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHg6IG5lZWQgMCA8IHggPCBwJyk7IC8vIEZhaWwgaWYgeCDiiaUgcC5cbiAgICBjb25zdCB4eCA9IG1vZFAoeCAqIHgpO1xuICAgIGNvbnN0IGMgPSBtb2RQKHh4ICogeCArIEJpZ0ludCg3KSk7IC8vIExldCBjID0geMKzICsgNyBtb2QgcC5cbiAgICBsZXQgeSA9IHNxcnRNb2QoYyk7IC8vIExldCB5ID0gY14ocCsxKS80IG1vZCBwLlxuICAgIGlmICh5ICUgXzJuICE9PSBfMG4pXG4gICAgICAgIHkgPSBtb2RQKC15KTsgLy8gUmV0dXJuIHRoZSB1bmlxdWUgcG9pbnQgUCBzdWNoIHRoYXQgeChQKSA9IHggYW5kXG4gICAgY29uc3QgcCA9IG5ldyBQb2ludCh4LCB5LCBfMW4pOyAvLyB5KFApID0geSBpZiB5IG1vZCAyID0gMCBvciB5KFApID0gcC15IG90aGVyd2lzZS5cbiAgICBwLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIENyZWF0ZSB0YWdnZWQgaGFzaCwgY29udmVydCBpdCB0byBiaWdpbnQsIHJlZHVjZSBtb2R1bG8tbi5cbiAqL1xuZnVuY3Rpb24gY2hhbGxlbmdlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbW9kTihieXRlc1RvTnVtYmVyQkUodGFnZ2VkSGFzaCgnQklQMDM0MC9jaGFsbGVuZ2UnLCAuLi5hcmdzKSkpO1xufVxuLyoqXG4gKiBTY2hub3JyIHB1YmxpYyBrZXkgaXMganVzdCBgeGAgY29vcmRpbmF0ZSBvZiBQb2ludCBhcyBwZXIgQklQMzQwLlxuICovXG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KS5ieXRlczsgLy8gZCc9aW50KHNrKS4gRmFpbCBpZiBkJz0wIG9yIGQn4omlbi4gUmV0IGJ5dGVzKGQn4ouFRylcbn1cbi8qKlxuICogQ3JlYXRlcyBTY2hub3JyIHNpZ25hdHVyZSBhcyBwZXIgQklQMzQwLiBWZXJpZmllcyBpdHNlbGYgYmVmb3JlIHJldHVybmluZyBhbnl0aGluZy5cbiAqIGF1eFJhbmQgaXMgb3B0aW9uYWwgYW5kIGlzIG5vdCB0aGUgc29sZSBzb3VyY2Ugb2YgayBnZW5lcmF0aW9uOiBiYWQgQ1NQUk5HIHdvbid0IGJlIGRhbmdlcm91cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgYXV4UmFuZCA9IHJhbmRvbUJ5dGVzKDMyKSkge1xuICAgIGNvbnN0IG0gPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHsgYnl0ZXM6IHB4LCBzY2FsYXI6IGQgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSk7IC8vIGNoZWNrcyBmb3IgaXNXaXRoaW5DdXJ2ZU9yZGVyXG4gICAgY29uc3QgYSA9IGVuc3VyZUJ5dGVzKCdhdXhSYW5kJywgYXV4UmFuZCwgMzIpOyAvLyBBdXhpbGlhcnkgcmFuZG9tIGRhdGEgYTogYSAzMi1ieXRlIGFycmF5XG4gICAgY29uc3QgdCA9IG51bVRvMzJiKGQgXiBieXRlc1RvTnVtYmVyQkUodGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpOyAvLyBMZXQgdCBiZSB0aGUgYnl0ZS13aXNlIHhvciBvZiBieXRlcyhkKSBhbmQgaGFzaC9hdXgoYSlcbiAgICBjb25zdCByYW5kID0gdGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIHQsIHB4LCBtKTsgLy8gTGV0IHJhbmQgPSBoYXNoL25vbmNlKHQgfHwgYnl0ZXMoUCkgfHwgbSlcbiAgICBjb25zdCBrXyA9IG1vZE4oYnl0ZXNUb051bWJlckJFKHJhbmQpKTsgLy8gTGV0IGsnID0gaW50KHJhbmQpIG1vZCBuXG4gICAgaWYgKGtfID09PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbiBmYWlsZWQ6IGsgaXMgemVybycpOyAvLyBGYWlsIGlmIGsnID0gMC5cbiAgICBjb25zdCB7IGJ5dGVzOiByeCwgc2NhbGFyOiBrIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KGtfKTsgLy8gTGV0IFIgPSBrJ+KLhUcuXG4gICAgY29uc3QgZSA9IGNoYWxsZW5nZShyeCwgcHgsIG0pOyAvLyBMZXQgZSA9IGludChoYXNoL2NoYWxsZW5nZShieXRlcyhSKSB8fCBieXRlcyhQKSB8fCBtKSkgbW9kIG4uXG4gICAgY29uc3Qgc2lnID0gbmV3IFVpbnQ4QXJyYXkoNjQpOyAvLyBMZXQgc2lnID0gYnl0ZXMoUikgfHwgYnl0ZXMoKGsgKyBlZCkgbW9kIG4pLlxuICAgIHNpZy5zZXQocngsIDApO1xuICAgIHNpZy5zZXQobnVtVG8zMmIobW9kTihrICsgZSAqIGQpKSwgMzIpO1xuICAgIC8vIElmIFZlcmlmeShieXRlcyhQKSwgbSwgc2lnKSAoc2VlIGJlbG93KSByZXR1cm5zIGZhaWx1cmUsIGFib3J0XG4gICAgaWYgKCFzY2hub3JyVmVyaWZ5KHNpZywgbSwgcHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ246IEludmFsaWQgc2lnbmF0dXJlIHByb2R1Y2VkJyk7XG4gICAgcmV0dXJuIHNpZztcbn1cbi8qKlxuICogVmVyaWZpZXMgU2Nobm9yciBzaWduYXR1cmUuXG4gKiBXaWxsIHN3YWxsb3cgZXJyb3JzICYgcmV0dXJuIGZhbHNlIGV4Y2VwdCBmb3IgaW5pdGlhbCB0eXBlIHZhbGlkYXRpb24gb2YgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3Qgc2lnID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSwgNjQpO1xuICAgIGNvbnN0IG0gPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHB1YiA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIDMyKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBQID0gbGlmdF94KGJ5dGVzVG9OdW1iZXJCRShwdWIpKTsgLy8gUCA9IGxpZnRfeChpbnQocGspKTsgZmFpbCBpZiB0aGF0IGZhaWxzXG4gICAgICAgIGNvbnN0IHIgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDAsIDMyKSk7IC8vIExldCByID0gaW50KHNpZ1swOjMyXSk7IGZhaWwgaWYgciDiiaUgcC5cbiAgICAgICAgaWYgKCFmZShyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcyA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMzIsIDY0KSk7IC8vIExldCBzID0gaW50KHNpZ1szMjo2NF0pOyBmYWlsIGlmIHMg4omlIG4uXG4gICAgICAgIGlmICghZ2UocykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UobnVtVG8zMmIociksIHBvaW50VG9CeXRlcyhQKSwgbSk7IC8vIGludChjaGFsbGVuZ2UoYnl0ZXMocil8fGJ5dGVzKFApfHxtKSklblxuICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBz4ouFRyAtIGXii4VQXG4gICAgICAgIGlmICghUiB8fCAhUi5oYXNFdmVuWSgpIHx8IFIudG9BZmZpbmUoKS54ICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyAtZVAgPT0gKG4tZSlQXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIOKJoCByLlxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBzY2hub3JyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoe1xuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgdXRpbHM6IHtcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXksXG4gICAgICAgIGxpZnRfeCxcbiAgICAgICAgcG9pbnRUb0J5dGVzLFxuICAgICAgICBudW1iZXJUb0J5dGVzQkUsXG4gICAgICAgIGJ5dGVzVG9OdW1iZXJCRSxcbiAgICAgICAgdGFnZ2VkSGFzaCxcbiAgICAgICAgbW9kLFxuICAgIH0sXG59KSkoKTtcbmNvbnN0IGlzb01hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaXNvZ2VueU1hcChGcCwgW1xuICAgIC8vIHhOdW1cbiAgICBbXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4YzcnLFxuICAgICAgICAnMHg3ZDNkNGM4MGJjMzIxZDViOWYzMTVjZWE3ZmQ0NGM1ZDU5NWQyZmMwYmY2M2I5MmRmZmYxMDQ0ZjE3YzY1ODEnLFxuICAgICAgICAnMHg1MzRjMzI4ZDIzZjIzNGU2ZTJhNDEzZGVjYTI1Y2FlY2U0NTA2MTQ0MDM3YzQwMzE0ZWNiZDBiNTNkOWRkMjYyJyxcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYTg4YycsXG4gICAgXSxcbiAgICAvLyB4RGVuXG4gICAgW1xuICAgICAgICAnMHhkMzU3NzExOTNkOTQ5MThhOWNhMzRjY2JiN2I2NDBkZDg2Y2Q0MDk1NDJmODQ4N2Q5ZmU2Yjc0NTc4MWViNDliJyxcbiAgICAgICAgJzB4ZWRhZGM2ZjY0MzgzZGMxZGY3YzRiMmQ1MWI1NDIyNTQwNmQzNmI2NDFmNWU0MWJiYzUyYTU2NjEyYThjNmQxNCcsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuICAgIC8vIHlOdW1cbiAgICBbXG4gICAgICAgICcweDRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiOGUzOGUyM2MnLFxuICAgICAgICAnMHhjNzVlMGMzMmQ1Y2I3YzBmYTlkMGE1NGIxMmEwYTZkNTY0N2FiMDQ2ZDY4NmRhNmZkZmZjOTBmYzIwMWQ3MWEzJyxcbiAgICAgICAgJzB4MjlhNjE5NDY5MWY5MWE3MzcxNTIwOWVmNjUxMmU1NzY3MjI4MzBhMjAxYmUyMDE4YTc2NWU4NWE5ZWNlZTkzMScsXG4gICAgICAgICcweDJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmMzhlMzhkODQnLFxuICAgIF0sXG4gICAgLy8geURlblxuICAgIFtcbiAgICAgICAgJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZjkzYicsXG4gICAgICAgICcweDdhMDY1MzRiYjhiZGI0OWZkNWU5ZTY2MzI3MjJjMjk4OTQ2N2MxYmZjOGU4ZDk3OGRmYjQyNWQyNjg1YzI1NzMnLFxuICAgICAgICAnMHg2NDg0YWE3MTY1NDVjYTJjZjNhNzBjM2ZhOGZlMzM3ZTBhM2QyMTE2MmYwZDYyOTlhN2JmODE5MmJmZDJhNzZmJyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG5dLm1hcCgoaSkgPT4gaS5tYXAoKGopID0+IEJpZ0ludChqKSkpKSkoKTtcbmNvbnN0IG1hcFNXVSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnAuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSkpKCk7XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwLmNyZWF0ZShzY2FsYXJzWzBdKSk7XG4gICAgcmV0dXJuIGlzb01hcCh4LCB5KTtcbn0sIHtcbiAgICBEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9ST18nLFxuICAgIGVuY29kZURTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX05VXycsXG4gICAgcDogRnAuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGEyNTYsXG59KSkoKTtcbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6WyJzaGEyNTYiLCJyYW5kb21CeXRlcyIsImNyZWF0ZUN1cnZlIiwiY3JlYXRlSGFzaGVyIiwiaXNvZ2VueU1hcCIsIkZpZWxkIiwibW9kIiwicG93MiIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwiZW5zdXJlQnl0ZXMiLCJudW1iZXJUb0J5dGVzQkUiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwic2VjcDI1NmsxUCIsIkJpZ0ludCIsInNlY3AyNTZrMU4iLCJfMW4iLCJfMm4iLCJkaXZOZWFyZXN0IiwiYSIsImIiLCJzcXJ0TW9kIiwieSIsIlAiLCJfM24iLCJfNm4iLCJfMTFuIiwiXzIybiIsIl8yM24iLCJfNDRuIiwiXzg4biIsImIyIiwiYjMiLCJiNiIsImI5IiwiYjExIiwiYjIyIiwiYjQ0IiwiYjg4IiwiYjE3NiIsImIyMjAiLCJiMjIzIiwidDEiLCJ0MiIsInJvb3QiLCJGcCIsImVxbCIsInNxciIsIkVycm9yIiwidW5kZWZpbmVkIiwic3FydCIsInNlY3AyNTZrMSIsIm4iLCJHeCIsIkd5IiwiaCIsImxvd1MiLCJlbmRvIiwiYmV0YSIsInNwbGl0U2NhbGFyIiwiayIsImExIiwiYjEiLCJhMiIsIlBPV18yXzEyOCIsImMxIiwiYzIiLCJrMSIsImsyIiwiazFuZWciLCJrMm5lZyIsIl8wbiIsImZlIiwieCIsImdlIiwiVEFHR0VEX0hBU0hfUFJFRklYRVMiLCJ0YWdnZWRIYXNoIiwidGFnIiwibWVzc2FnZXMiLCJ0YWdQIiwidGFnSCIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwiYyIsImNoYXJDb2RlQXQiLCJwb2ludFRvQnl0ZXMiLCJwb2ludCIsInRvUmF3Qnl0ZXMiLCJzbGljZSIsIm51bVRvMzJiIiwibW9kUCIsIm1vZE4iLCJQb2ludCIsIlByb2plY3RpdmVQb2ludCIsIkdtdWxBZGQiLCJRIiwiQkFTRSIsIm11bHRpcGx5QW5kQWRkVW5zYWZlIiwic2Nobm9yckdldEV4dFB1YktleSIsInByaXYiLCJkXyIsInV0aWxzIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsInAiLCJmcm9tUHJpdmF0ZUtleSIsInNjYWxhciIsImhhc0V2ZW5ZIiwiYnl0ZXMiLCJsaWZ0X3giLCJ4eCIsImFzc2VydFZhbGlkaXR5IiwiY2hhbGxlbmdlIiwiYXJncyIsInNjaG5vcnJHZXRQdWJsaWNLZXkiLCJwcml2YXRlS2V5Iiwic2Nobm9yclNpZ24iLCJtZXNzYWdlIiwiYXV4UmFuZCIsIm0iLCJweCIsImQiLCJ0IiwicmFuZCIsImtfIiwicngiLCJlIiwic2lnIiwic2V0Iiwic2Nobm9yclZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInB1YiIsInIiLCJzdWJhcnJheSIsInMiLCJSIiwidG9BZmZpbmUiLCJlcnJvciIsInNjaG5vcnIiLCJnZXRQdWJsaWNLZXkiLCJzaWduIiwidmVyaWZ5IiwicmFuZG9tUHJpdmF0ZUtleSIsImlzb01hcCIsIm1hcCIsImkiLCJqIiwibWFwU1dVIiwiQSIsIkIiLCJaIiwiY3JlYXRlIiwiaHRmIiwic2NhbGFycyIsIkRTVCIsImVuY29kZURTVCIsIk9SREVSIiwiZXhwYW5kIiwiaGFzaCIsImhhc2hUb0N1cnZlIiwiZW5jb2RlVG9DdXJ2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/_assert.js":
/*!*************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/hashes/esm/_assert.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert); //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxPQUFPQyxDQUFDO0lBQ2IsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE1BQU1BLElBQUksR0FDaEMsTUFBTSxJQUFJRyxNQUFNLENBQUMsK0JBQStCLEVBQUVILEVBQUUsQ0FBQztBQUM3RDtBQUNBLFNBQVNJLEtBQUtDLENBQUM7SUFDWCxJQUFJLE9BQU9BLE1BQU0sV0FDYixNQUFNLElBQUlGLE1BQU0sQ0FBQyxzQkFBc0IsRUFBRUUsRUFBRSxDQUFDO0FBQ3BEO0FBQ0Esb0JBQW9CO0FBQ2IsU0FBU0MsUUFBUUMsQ0FBQztJQUNyQixPQUFRQSxhQUFhQyxjQUNoQkQsS0FBSyxRQUFRLE9BQU9BLE1BQU0sWUFBWUEsRUFBRUUsV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdEU7QUFDQSxTQUFTQyxNQUFNTixDQUFDLEVBQUUsR0FBR08sT0FBTztJQUN4QixJQUFJLENBQUNOLFFBQVFELElBQ1QsTUFBTSxJQUFJRixNQUFNO0lBQ3BCLElBQUlTLFFBQVFDLE1BQU0sR0FBRyxLQUFLLENBQUNELFFBQVFFLFFBQVEsQ0FBQ1QsRUFBRVEsTUFBTSxHQUNoRCxNQUFNLElBQUlWLE1BQU0sQ0FBQyw4QkFBOEIsRUFBRVMsUUFBUSxnQkFBZ0IsRUFBRVAsRUFBRVEsTUFBTSxDQUFDLENBQUM7QUFDN0Y7QUFDQSxTQUFTRSxLQUFLQyxDQUFDO0lBQ1gsSUFBSSxPQUFPQSxNQUFNLGNBQWMsT0FBT0EsRUFBRUMsTUFBTSxLQUFLLFlBQy9DLE1BQU0sSUFBSWQsTUFBTTtJQUNwQkosT0FBT2lCLEVBQUVFLFNBQVM7SUFDbEJuQixPQUFPaUIsRUFBRUcsUUFBUTtBQUNyQjtBQUNBLFNBQVNDLE9BQU9DLFFBQVEsRUFBRUMsZ0JBQWdCLElBQUk7SUFDMUMsSUFBSUQsU0FBU0UsU0FBUyxFQUNsQixNQUFNLElBQUlwQixNQUFNO0lBQ3BCLElBQUltQixpQkFBaUJELFNBQVNHLFFBQVEsRUFDbEMsTUFBTSxJQUFJckIsTUFBTTtBQUN4QjtBQUNBLFNBQVNzQixPQUFPQyxHQUFHLEVBQUVMLFFBQVE7SUFDekJWLE1BQU1lO0lBQ04sTUFBTUMsTUFBTU4sU0FBU0gsU0FBUztJQUM5QixJQUFJUSxJQUFJYixNQUFNLEdBQUdjLEtBQUs7UUFDbEIsTUFBTSxJQUFJeEIsTUFBTSxDQUFDLHNEQUFzRCxFQUFFd0IsSUFBSSxDQUFDO0lBQ2xGO0FBQ0o7QUFDcUQ7QUFDckQsTUFBTUMsU0FBUztJQUFFN0I7SUFBUUs7SUFBTU87SUFBT0k7SUFBTUs7SUFBUUs7QUFBTztBQUMzRCxpRUFBZUcsTUFBTUEsRUFBQyxDQUN0QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1kYXBwLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzPzRkMGUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIG5vdCAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBib29sZWFuIGV4cGVjdGVkLCBub3QgJHtifWApO1xufVxuLy8gY29waWVkIGZyb20gdXRpbHNcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoKGgpIHtcbiAgICBpZiAodHlwZW9mIGggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGguY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGgub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOlsibnVtYmVyIiwibiIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImJvb2wiLCJiIiwiaXNCeXRlcyIsImEiLCJVaW50OEFycmF5IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYnl0ZXMiLCJsZW5ndGhzIiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJoYXNoIiwiaCIsImNyZWF0ZSIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiZXhpc3RzIiwiaW5zdGFuY2UiLCJjaGVja0ZpbmlzaGVkIiwiZGVzdHJveWVkIiwiZmluaXNoZWQiLCJvdXRwdXQiLCJvdXQiLCJtaW4iLCJhc3NlcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/_md.js":
/*!*********************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/hashes/esm/_md.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c)=>a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n} //# sourceMappingURL=_md.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE4QztBQUNTO0FBQ3ZELHlCQUF5QjtBQUN6QixTQUFTSyxhQUFhQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsS0FBSyxFQUFFQyxJQUFJO0lBQy9DLElBQUksT0FBT0gsS0FBS0QsWUFBWSxLQUFLLFlBQzdCLE9BQU9DLEtBQUtELFlBQVksQ0FBQ0UsWUFBWUMsT0FBT0M7SUFDaEQsTUFBTUMsT0FBT0MsT0FBTztJQUNwQixNQUFNQyxXQUFXRCxPQUFPO0lBQ3hCLE1BQU1FLEtBQUtDLE9BQU8sU0FBVUosT0FBUUU7SUFDcEMsTUFBTUcsS0FBS0QsT0FBT04sUUFBUUk7SUFDMUIsTUFBTUksSUFBSVAsT0FBTyxJQUFJO0lBQ3JCLE1BQU1RLElBQUlSLE9BQU8sSUFBSTtJQUNyQkgsS0FBS1ksU0FBUyxDQUFDWCxhQUFhUyxHQUFHSCxJQUFJSjtJQUNuQ0gsS0FBS1ksU0FBUyxDQUFDWCxhQUFhVSxHQUFHRixJQUFJTjtBQUN2QztBQUNBLG9CQUFvQjtBQUNiLE1BQU1VLE1BQU0sQ0FBQ0MsR0FBR0MsR0FBR0MsSUFBTSxJQUFLRCxJQUFNLENBQUNELElBQUlFLEVBQUc7QUFDbkQsb0RBQW9EO0FBQzdDLE1BQU1DLE1BQU0sQ0FBQ0gsR0FBR0MsR0FBR0MsSUFBTSxJQUFLRCxJQUFNRCxJQUFJRSxJQUFNRCxJQUFJQyxFQUFHO0FBQzVEOzs7Q0FHQyxHQUNNLE1BQU1FLGVBQWV0QiwyQ0FBSUE7SUFDNUJ1QixZQUFZQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFbkIsSUFBSSxDQUFFO1FBQzlDLEtBQUs7UUFDTCxJQUFJLENBQUNpQixRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDbkIsSUFB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USxJQUFJLENBQUNDLEdBQUc7UUFDdEIsSUFBSUYsU0FBU0MsTUFBTXZCLE1BQU0sRUFDckIsTUFBTSxJQUFJcUIsTUFBTTtRQUNwQixJQUFLLElBQUlGLElBQUksR0FBR0EsSUFBSUcsUUFBUUgsSUFDeEJDLE1BQU1oQyxTQUFTLENBQUMsSUFBSStCLEdBQUdJLEtBQUssQ0FBQ0osRUFBRSxFQUFFeEM7SUFDekM7SUFDQThDLFNBQVM7UUFDTCxNQUFNLEVBQUV0QixNQUFNLEVBQUVOLFNBQVMsRUFBRSxHQUFHLElBQUk7UUFDbEMsSUFBSSxDQUFDbUIsVUFBVSxDQUFDYjtRQUNoQixNQUFNdUIsTUFBTXZCLE9BQU93QixLQUFLLENBQUMsR0FBRzlCO1FBQzVCLElBQUksQ0FBQytCLE9BQU87UUFDWixPQUFPRjtJQUNYO0lBQ0FHLFdBQVdDLEVBQUUsRUFBRTtRQUNYQSxNQUFPQSxDQUFBQSxLQUFLLElBQUksSUFBSSxDQUFDbkMsV0FBVyxFQUFDO1FBQ2pDbUMsR0FBR2pCLEdBQUcsSUFBSSxJQUFJLENBQUNXLEdBQUc7UUFDbEIsTUFBTSxFQUFFNUIsUUFBUSxFQUFFTyxNQUFNLEVBQUVILE1BQU0sRUFBRUQsUUFBUSxFQUFFRyxTQUFTLEVBQUVELEdBQUcsRUFBRSxHQUFHLElBQUk7UUFDbkU2QixHQUFHOUIsTUFBTSxHQUFHQTtRQUNaOEIsR0FBRzdCLEdBQUcsR0FBR0E7UUFDVDZCLEdBQUcvQixRQUFRLEdBQUdBO1FBQ2QrQixHQUFHNUIsU0FBUyxHQUFHQTtRQUNmLElBQUlGLFNBQVNKLFVBQ1RrQyxHQUFHM0IsTUFBTSxDQUFDVSxHQUFHLENBQUNWO1FBQ2xCLE9BQU8yQjtJQUNYO0FBQ0osRUFDQSwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1kYXBwLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanM/ZWZjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmV4cG9ydCBjb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuZXhwb3J0IGNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhhc2hNRCBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X21kLmpzLm1hcCJdLCJuYW1lcyI6WyJleGlzdHMiLCJvdXRwdXQiLCJIYXNoIiwiY3JlYXRlVmlldyIsInRvQnl0ZXMiLCJzZXRCaWdVaW50NjQiLCJ2aWV3IiwiYnl0ZU9mZnNldCIsInZhbHVlIiwiaXNMRSIsIl8zMm4iLCJCaWdJbnQiLCJfdTMyX21heCIsIndoIiwiTnVtYmVyIiwid2wiLCJoIiwibCIsInNldFVpbnQzMiIsIkNoaSIsImEiLCJiIiwiYyIsIk1haiIsIkhhc2hNRCIsImNvbnN0cnVjdG9yIiwiYmxvY2tMZW4iLCJvdXRwdXRMZW4iLCJwYWRPZmZzZXQiLCJmaW5pc2hlZCIsImxlbmd0aCIsInBvcyIsImRlc3Ryb3llZCIsImJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJ1cGRhdGUiLCJkYXRhIiwibGVuIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJkYXRhVmlldyIsInByb2Nlc3MiLCJzZXQiLCJzdWJhcnJheSIsInJvdW5kQ2xlYW4iLCJkaWdlc3RJbnRvIiwib3V0IiwiZmlsbCIsImkiLCJvdmlldyIsIkVycm9yIiwib3V0TGVuIiwic3RhdGUiLCJnZXQiLCJkaWdlc3QiLCJyZXMiLCJzbGljZSIsImRlc3Ryb3kiLCJfY2xvbmVJbnRvIiwidG8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/_u64.js":
/*!**********************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/hashes/esm/_u64.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nconst rotr32L = (h, _l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64); //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFNQSxhQUFhLGFBQWEsR0FBR0MsT0FBTyxLQUFLLEtBQUs7QUFDcEQsTUFBTUMsT0FBTyxhQUFhLEdBQUdELE9BQU87QUFDcEMsK0VBQStFO0FBQy9FLFNBQVNFLFFBQVFDLENBQUMsRUFBRUMsS0FBSyxLQUFLO0lBQzFCLElBQUlBLElBQ0EsT0FBTztRQUFFQyxHQUFHQyxPQUFPSCxJQUFJSjtRQUFhUSxHQUFHRCxPQUFPLEtBQU1MLE9BQVFGO0lBQVk7SUFDNUUsT0FBTztRQUFFTSxHQUFHQyxPQUFPLEtBQU1MLE9BQVFGLGNBQWM7UUFBR1EsR0FBR0QsT0FBT0gsSUFBSUosY0FBYztJQUFFO0FBQ3BGO0FBQ0EsU0FBU1MsTUFBTUMsR0FBRyxFQUFFTCxLQUFLLEtBQUs7SUFDMUIsSUFBSU0sS0FBSyxJQUFJQyxZQUFZRixJQUFJRyxNQUFNO0lBQ25DLElBQUlDLEtBQUssSUFBSUYsWUFBWUYsSUFBSUcsTUFBTTtJQUNuQyxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUFLO1FBQ2pDLE1BQU0sRUFBRVQsQ0FBQyxFQUFFRSxDQUFDLEVBQUUsR0FBR0wsUUFBUU8sR0FBRyxDQUFDSyxFQUFFLEVBQUVWO1FBQ2pDLENBQUNNLEVBQUUsQ0FBQ0ksRUFBRSxFQUFFRCxFQUFFLENBQUNDLEVBQUUsQ0FBQyxHQUFHO1lBQUNUO1lBQUdFO1NBQUU7SUFDM0I7SUFDQSxPQUFPO1FBQUNHO1FBQUlHO0tBQUc7QUFDbkI7QUFDQSxNQUFNRSxRQUFRLENBQUNWLEdBQUdFLElBQU0sT0FBUUYsTUFBTSxNQUFNSixPQUFRRCxPQUFPTyxNQUFNO0FBQ2pFLHVCQUF1QjtBQUN2QixNQUFNUyxRQUFRLENBQUNYLEdBQUdZLElBQUlDLElB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LEdBQUdBLEVBQUMsQ0FDbkIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZGFwcC8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcz8yZWMxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IHsgZnJvbUJpZywgc3BsaXQsIHRvQmlnLCBzaHJTSCwgc2hyU0wsIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCwgcm90cjMySCwgcm90cjMyTCwgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLCBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsIH07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0IGRlZmF1bHQgdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiXSwibmFtZXMiOlsiVTMyX01BU0s2NCIsIkJpZ0ludCIsIl8zMm4iLCJmcm9tQmlnIiwibiIsImxlIiwiaCIsIk51bWJlciIsImwiLCJzcGxpdCIsImxzdCIsIkFoIiwiVWludDMyQXJyYXkiLCJsZW5ndGgiLCJBbCIsImkiLCJ0b0JpZyIsInNoclNIIiwiX2wiLCJzIiwic2hyU0wiLCJyb3RyU0giLCJyb3RyU0wiLCJyb3RyQkgiLCJyb3RyQkwiLCJyb3RyMzJIIiwiX2giLCJyb3RyMzJMIiwicm90bFNIIiwicm90bFNMIiwicm90bEJIIiwicm90bEJMIiwiYWRkIiwiQmgiLCJCbCIsImFkZDNMIiwiQ2wiLCJhZGQzSCIsImxvdyIsIkNoIiwiYWRkNEwiLCJEbCIsImFkZDRIIiwiRGgiLCJhZGQ1TCIsIkVsIiwiYWRkNUgiLCJFaCIsInU2NCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!****************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0b05vZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0ZBQW9GO0FBQ3BGLDRCQUE0QjtBQUM1QixpREFBaUQ7QUFDakQsYUFBYTtBQUNxQjtBQUMzQixNQUFNQyxTQUFTRCwyTUFBRUEsSUFBSSxPQUFPQSwyTUFBRUEsS0FBSyxZQUFZLDBOQUFpQkEsR0FBR0Esa0RBQVksR0FBR0csVUFBVSxDQUNuRyxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1kYXBwLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzP2RlNWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG4vLyBUaGUgZmlsZSB3aWxsIHRocm93IG9uIG5vZGUuanMgMTQgYW5kIGVhcmxpZXIuXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgKiBhcyBuYyBmcm9tICdub2RlOmNyeXB0byc7XG5leHBvcnQgY29uc3QgY3J5cHRvID0gbmMgJiYgdHlwZW9mIG5jID09PSAnb2JqZWN0JyAmJiAnd2ViY3J5cHRvJyBpbiBuYyA/IG5jLndlYmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0b05vZGUuanMubWFwIl0sIm5hbWVzIjpbIm5jIiwiY3J5cHRvIiwid2ViY3J5cHRvIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/hmac.js":
/*!**********************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/hashes/esm/hmac.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRztBQUNyRDtBQUMzQyxrQkFBa0I7QUFDWCxNQUFNUSxhQUFhRiwyQ0FBSUE7SUFDMUJHLFlBQVlULElBQUksRUFBRVUsSUFBSSxDQUFFO1FBQ3BCLEtBQUs7UUFDTCxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQlgsZ0RBQVVBLENBQUNEO1FBQ1gsTUFBTWEsTUFBTU4sa0RBQU9BLENBQUNHO1FBQ3BCLElBQUksQ0FBQ0ksS0FBSyxHQUFHZCxLQUFLZSxNQUFNO1FBQ3hCLElBQUksT0FBTyxJQUFJLENBQUNELEtBQUssQ0FBQ0UsTUFBTSxLQUFLLFlBQzdCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ksUUFBUTtRQUNuQyxJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJLENBQUNMLEtBQUssQ0FBQ0ssU0FBUztRQUNyQyxNQUFNRCxXQUFXLElBQUksQ0FBQ0EsUUFBUTtRQUM5QixNQUFNRSxNQUFNLElBQUlDLFdBQVdIO1FBQzNCLHdDQUF3QztRQUN4Q0UsSUFBSUUsR0FBRyxDQUFDVCxJQUFJVSxNQUFNLEdBQUdMLFdBQVdsQixLQUFLZSxNQUFNLEdBQUdDLE1BQU0sQ0FBQ0gsS0FBS1csTUFBTSxLQUFLWDtRQUNyRSxJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUk7UUFDZCxJQUFJLENBQUNYLEtBQUssQ0FBQ0UsTUFBTSxDQUFDSTtRQUNsQixtSEFBbUg7UUFDbkgsSUFBSSxDQUFDTSxLQUFLLEdBQUcxQixLQUFLZSxNQUFNO1FBQ3hCLHVDQUF1QztRQUN2QyxJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUksT0FBTztRQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQ1YsTUFBTSxDQUFDSTtRQUNsQkEsSUFBSU8sSUFBSSxDQUFDO0lBQ2I7SUFDQVgsT0FBT1ksR0FBRyxFQUFFO1FBQ1J2QixrREFBWUEsQ0FBQyxJQUFJO1FBQ2pCLElBQUksQ0FBQ1MsS0FBSyxDQUFDRSxNQUFNLENBQUNZO1FBQ2xCLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLFdBQVdDLEdBQUcsRUFBRTtRQUNaekIsa0RBQVlBLENBQUMsSUFBSTtRQUNqQkYsaURBQVdBLENBQUMyQixLQUFLLElBQUksQ0FBQ1gsU0FBUztRQUMvQixJQUFJLENBQUNSLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNHLEtBQUssQ0FBQ2UsVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNKLEtBQUssQ0FBQ1YsTUFBTSxDQUFDYztRQUNsQixJQUFJLENBQUNKLEtBQUssQ0FBQ0csVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNDLE9BQU87SUFDaEI7SUFDQVAsU0FBUztRQUNMLE1BQU1NLE1BQU0sSUFBSVQsV0FBVyxJQUFJLENBQUNLLEtBQUssQ0FBQ1AsU0FBUztRQUMvQyxJQUFJLENBQUNVLFVBQVUsQ0FBQ0M7UUFDaEIsT0FBT0E7SUFDWDtJQUNBRSxXQUFXQyxFQUFFLEVBQUU7UUFDWCxtR0FBbUc7UUFDbkdBLE1BQU9BLENBQUFBLEtBQUtDLE9BQU9uQixNQUFNLENBQUNtQixPQUFPQyxjQUFjLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBQztRQUN6RCxNQUFNLEVBQUVULEtBQUssRUFBRVosS0FBSyxFQUFFSCxRQUFRLEVBQUVDLFNBQVMsRUFBRU0sUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBRyxJQUFJO1FBQ3ZFYyxLQUFLQTtRQUNMQSxHQUFHdEIsUUFBUSxHQUFHQTtRQUNkc0IsR0FBR3JCLFNBQVMsR0FBR0E7UUFDZnFCLEdBQUdmLFFBQVEsR0FBR0E7UUFDZGUsR0FBR2QsU0FBUyxHQUFHQTtRQUNmYyxHQUFHUCxLQUFLLEdBQUdBLE1BQU1NLFVBQVUsQ0FBQ0MsR0FBR1AsS0FBSztRQUNwQ08sR0FBR25CLEtBQUssR0FBR0EsTUFBTWtCLFVBQVUsQ0FBQ0MsR0FBR25CLEtBQUs7UUFDcEMsT0FBT21CO0lBQ1g7SUFDQUYsVUFBVTtRQUNOLElBQUksQ0FBQ25CLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNjLEtBQUssQ0FBQ0ssT0FBTztRQUNsQixJQUFJLENBQUNqQixLQUFLLENBQUNpQixPQUFPO0lBQ3RCO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1LLE9BQU8sQ0FBQ3BDLE1BQU1hLEtBQUt3QixVQUFZLElBQUk3QixLQUFLUixNQUFNYSxLQUFLRyxNQUFNLENBQUNxQixTQUFTYixNQUFNLEdBQUc7QUFDekZZLEtBQUtyQixNQUFNLEdBQUcsQ0FBQ2YsTUFBTWEsTUFBUSxJQUFJTCxLQUFLUixNQUFNYSxNQUM1QyxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1kYXBwLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzPzNhY2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBieXRlcyBhcyBhc3NlcnRCeXRlcywgZXhpc3RzIGFzIGFzc2VydEV4aXN0cyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBITUFDIChSRkMgMjEwNClcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnRCeXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbImhhc2giLCJhc3NlcnRIYXNoIiwiYnl0ZXMiLCJhc3NlcnRCeXRlcyIsImV4aXN0cyIsImFzc2VydEV4aXN0cyIsIkhhc2giLCJ0b0J5dGVzIiwiSE1BQyIsImNvbnN0cnVjdG9yIiwiX2tleSIsImZpbmlzaGVkIiwiZGVzdHJveWVkIiwia2V5IiwiaUhhc2giLCJjcmVhdGUiLCJ1cGRhdGUiLCJFcnJvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkIiwiVWludDhBcnJheSIsInNldCIsImxlbmd0aCIsImRpZ2VzdCIsImkiLCJvSGFzaCIsImZpbGwiLCJidWYiLCJkaWdlc3RJbnRvIiwib3V0IiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiaG1hYyIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/sha256.js":
/*!************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/hashes/esm/sha256.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor(){\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA224()); //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBQ087QUFDbkQsZ0VBQWdFO0FBQ2hFLDBEQUEwRDtBQUMxRCxtQkFBbUI7QUFDbkIseUZBQXlGO0FBQ3pGLGtCQUFrQjtBQUNsQixNQUFNSyxXQUFXLGFBQWEsR0FBRyxJQUFJQyxZQUFZO0lBQzdDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RjtBQUNELGlCQUFpQjtBQUNqQix3RkFBd0Y7QUFDeEYsa0JBQWtCO0FBQ2xCLE1BQU1DLFlBQVksYUFBYSxHQUFHLElBQUlELFlBQVk7SUFDOUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RjtBQUNELDREQUE0RDtBQUM1RCxtREFBbUQ7QUFDbkQsTUFBTUUsV0FBVyxhQUFhLEdBQUcsSUFBSUYsWUFBWTtBQUNqRCxNQUFNRyxlQUFlVCwwQ0FBTUE7SUFDdkJVLGFBQWM7UUFDVixLQUFLLENBQUMsSUFBSSxJQUFJLEdBQUc7UUFDakIsbUVBQW1FO1FBQ25FLHVEQUF1RDtRQUN2RCxJQUFJLENBQUNDLENBQUMsR0FBR0osU0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENB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Q3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDcUIsU0FBUyxHQUFHO0lBQ3JCO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNQyxTQUFTLGFBQWEsR0FBR3BDLDBEQUFlQSxDQUFDLElBQU0sSUFBSUssVUFBVTtBQUNuRSxNQUFNZ0MsU0FBUyxhQUFhLEdBQUdyQywwREFBZUEsQ0FBQyxJQUFNLElBQUlrQyxVQUFVLENBQzFFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWRhcHAvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcz8wNjJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhc2hNRCwgQ2hpLCBNYWogfSBmcm9tICcuL19tZC5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGU6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IFNIQTI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IFNIQTI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IFNIQTI1Nl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IFNIQTI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IFNIQTI1Nl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IFNIQTI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IFNIQTI1Nl9JVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6WyJIYXNoTUQiLCJDaGkiLCJNYWoiLCJyb3RyIiwid3JhcENvbnN0cnVjdG9yIiwiU0hBMjU2X0siLCJVaW50MzJBcnJheSIsIlNIQTI1Nl9JViIsIlNIQTI1Nl9XIiwiU0hBMjU2IiwiY29uc3RydWN0b3IiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsImdldCIsInNldCIsInByb2Nlc3MiLCJ2aWV3Iiwib2Zmc2V0IiwiaSIsImdldFVpbnQzMiIsIlcxNSIsIlcyIiwiczAiLCJzMSIsInNpZ21hMSIsIlQxIiwic2lnbWEwIiwiVDIiLCJyb3VuZENsZWFuIiwiZmlsbCIsImRlc3Ryb3kiLCJidWZmZXIiLCJTSEEyMjQiLCJvdXRwdXRMZW4iLCJzaGEyNTYiLCJzaGEyMjQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/sha3.js":
/*!**********************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/hashes/esm/sha3.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta θ\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */ const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */ const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZEO0FBQ0s7QUFDOEM7QUFDaEgsb0dBQW9HO0FBQ3BHLGlDQUFpQztBQUNqQywyQ0FBMkM7QUFDM0MsTUFBTWdCLFVBQVUsRUFBRTtBQUNsQixNQUFNQyxZQUFZLEVBQUU7QUFDcEIsTUFBTUMsYUFBYSxFQUFFO0FBQ3JCLE1BQU1DLE1BQU0sYUFBYSxHQUFHQyxPQUFPO0FBQ25DLE1BQU1DLE1BQU0sYUFBYSxHQUFHRCxPQUFPO0FBQ25DLE1BQU1FLE1BQU0sYUFBYSxHQUFHRixPQUFPO0FBQ25DLE1BQU1HLE1BQU0sYUFBYSxHQUFHSCxPQUFPO0FBQ25DLE1BQU1JLFFBQVEsYUFBYSxHQUFHSixPQUFPO0FBQ3JDLE1BQU1LLFNBQVMsYUFBYSxHQUFHTCxPQUFPO0FBQ3RDLElBQUssSUFBSU0sUUFBUSxHQUFHQyxJQUFJTixLQUFLTyxJQUFJLEdBQUdDLElBQUksR0FBR0gsUUFBUSxJQUFJQSxRQUFTO0lBQzVELEtBQUs7SUFDTCxDQUFDRSxHQUFHQyxFQUFFLEdBQUc7UUFBQ0E7UUFBSSxLQUFJRCxJQUFJLElBQUlDLENBQUFBLElBQUs7S0FBRTtJQUNqQ2IsUUFBUWMsSUFBSSxDQUFDLElBQUssS0FBSUQsSUFBSUQsQ0FBQUE7SUFDMUIsYUFBYTtJQUNiWCxVQUFVYSxJQUFJLENBQUMsQ0FBR0osUUFBUSxLQUFNQSxDQUFBQSxRQUFRLEtBQU0sSUFBSztJQUNuRCxPQUFPO0lBQ1AsSUFBSUssSUFBSVo7SUFDUixJQUFLLElBQUlhLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1FBQ3hCTCxJQUFJLENBQUMsS0FBTU4sTUFBUSxDQUFDTSxLQUFLSixHQUFFLElBQUtFLE1BQU0sSUFBS0Q7UUFDM0MsSUFBSUcsSUFBSUwsS0FDSlMsS0FBS1YsT0FBUSxDQUFDQSxPQUFPLGFB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QU0sR0FBRztBQUN6RCxNQUFNSSxXQUFXLGFBQWEsR0FBR0osSUFBSSxNQUFNLElBQUksTUFBTSxHQUFHO0FBQ3hELE1BQU1LLGFBQWEsYUFBYSxHQUFHTCxJQUFJLE1BQU0sS0FBSyxNQUFNLEdBQUc7QUFDbEU7OztDQUdDLEdBQ00sTUFBTU0sYUFBYSxhQUFhLEdBQUdOLElBQUksTUFBTSxLQUFLLE1BQU0sR0FBRztBQUMzRCxNQUFNTyxhQUFhLGFBQWEsR0FBR1AsSUFBSSxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQzNELE1BQU1RLGFBQWEsYUFBYSxHQUFHUixJQUFJLE1BQU0sSUFBSSxNQUFNLEdBQUc7QUFDakUsTUFBTVMsV0FBVyxDQUFDMUMsUUFBUUQsVUFBVUUsWUFBYzlDLHFFQUEwQkEsQ0FBQyxDQUFDd0YsT0FBTyxDQUFDLENBQUMsR0FBSyxJQUFJOUMsT0FBT0UsVUFBVUMsUUFBUTJDLEtBQUtDLEtBQUssS0FBS0MsWUFBWTVDLFlBQVkwQyxLQUFLQyxLQUFLLEVBQUU7QUFDckssTUFBTUUsV0FBVyxhQUFhLEdBQUdKLFNBQVMsTUFBTSxLQUFLLE1BQU0sR0FBRztBQUM5RCxNQUFNSyxXQUFXLGFBQWEsR0FBR0wsU0FBUyxNQUFNLEtBQUssTUFBTSxHQUFHLENBQ3JFLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWRhcHAvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanM/YWEwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBieXRlcywgZXhpc3RzLCBudW1iZXIsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyByb3RsQkgsIHJvdGxCTCwgcm90bFNILCByb3RsU0wsIHNwbGl0IH0gZnJvbSAnLi9fdTY0LmpzJztcbmltcG9ydCB7IEhhc2gsIHUzMiwgdG9CeXRlcywgd3JhcENvbnN0cnVjdG9yLCB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cywgaXNMRSwgYnl0ZVN3YXAzMiwgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTMgKGtlY2NhaykgaXMgYmFzZWQgb24gYSBuZXcgZGVzaWduOiBiYXNpY2FsbHksIHRoZSBpbnRlcm5hbCBzdGF0ZSBpcyBiaWdnZXIgdGhhbiBvdXRwdXQgc2l6ZS5cbi8vIEl0J3MgY2FsbGVkIGEgc3BvbmdlIGZ1bmN0aW9uLlxuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgU0hBM19QSSA9IFtdO1xuY29uc3QgU0hBM19ST1RMID0gW107XG5jb25zdCBfU0hBM19JT1RBID0gW107XG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xuY29uc3QgXzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG5jb25zdCBfN24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDcpO1xuY29uc3QgXzI1Nm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgLyogQF9fUFVSRV9fICovIEJpZ0ludChqKSkgLSBfMW4pO1xuICAgIH1cbiAgICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBbU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MXSA9IC8qIEBfX1BVUkVfXyAqLyBzcGxpdChfU0hBM19JT1RBLCB0cnVlKTtcbi8vIExlZnQgcm90YXRpb24gKHdpdGhvdXQgMCwgMzIsIDY0KVxuY29uc3Qgcm90bEggPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCSChoLCBsLCBzKSA6IHJvdGxTSChoLCBsLCBzKSk7XG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJMKGgsIGwsIHMpIDogcm90bFNMKGgsIGwsIHMpKTtcbi8vIFNhbWUgYXMga2VjY2FrZjE2MDAsIGJ1dCBhbGxvd3MgdG8gc2tpcCBzb21lIHJvdW5kc1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgIEIuZmlsbCgwKTtcbn1cbmV4cG9ydCBjbGFzcyBLZWNjYWsgZXh0ZW5kcyBIYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgIG51bWJlcihvdXRwdXRMZW4pO1xuICAgICAgICAvLyAxNjAwID0gNXg1IG1hdHJpeCBvZiA2NGJpdC4gIDE2MDAgYml0cyA9PT0gMjAwIGJ5dGVzXG4gICAgICAgIGlmICgwID49IHRoaXMuYmxvY2tMZW4gfHwgdGhpcy5ibG9ja0xlbiA+PSAyMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYTMgc3VwcG9ydHMgb25seSBrZWNjYWstZjE2MDAgZnVuY3Rpb24nKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBVaW50OEFycmF5KDIwMCk7XG4gICAgICAgIHRoaXMuc3RhdGUzMiA9IHUzMih0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAga2VjY2FrKCkge1xuICAgICAgICBpZiAoIWlzTEUpXG4gICAgICAgICAgICBieXRlU3dhcDMyKHRoaXMuc3RhdGUzMik7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIGlmICghaXNMRSlcbiAgICAgICAgICAgIGJ5dGVTd2FwMzIodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIG51bWJlcihieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICogU0hBMy0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhM18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMjI0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnQgY29uc3Qgc2hha2UxMjggPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiXSwibmFtZXMiOlsiYnl0ZXMiLCJleGlzdHMiLCJudW1iZXIiLCJvdXRwdXQiLCJyb3RsQkgiLCJyb3RsQkwiLCJyb3RsU0giLCJyb3RsU0wiLCJzcGxpdCIsIkhhc2giLCJ1MzIiLCJ0b0J5dGVzIiwid3JhcENvbnN0cnVjdG9yIiwid3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMiLCJpc0xFIiwiYnl0ZVN3YXAzMiIsIlNIQTNfUEkiLCJTSEEzX1JPVEwiLCJfU0hBM19JT1RBIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzduIiwiXzI1Nm4iLCJfMHg3MW4iLCJyb3VuZCIsIlIiLCJ4IiwieSIsInB1c2giLCJ0IiwiaiIsIlNIQTNfSU9UQV9IIiwiU0hBM19JT1RBX0wiLCJyb3RsSCIsImgiLCJsIiwicyIsInJvdGxMIiwia2VjY2FrUCIsInJvdW5kcyIsIkIiLCJVaW50MzJBcnJheSIsImlkeDEiLCJpZHgwIiwiQjAiLCJCMSIsIlRoIiwiVGwiLCJjdXJIIiwiY3VyTCIsInNoaWZ0IiwiUEkiLCJmaWxsIiwiS2VjY2FrIiwiY29uc3RydWN0b3IiLCJibG9ja0xlbiIsInN1ZmZpeCIsIm91dHB1dExlbiIsImVuYWJsZVhPRiIsInBvcyIsInBvc091dCIsImZpbmlzaGVkIiwiZGVzdHJveWVkIiwiRXJyb3IiLCJzdGF0ZSIsIlVpbnQ4QXJyYXkiLCJzdGF0ZTMyIiwia2VjY2FrIiwidXBkYXRlIiwiZGF0YSIsImxlbiIsImxlbmd0aCIsInRha2UiLCJNYXRoIiwibWluIiwiaSIsImZpbmlzaCIsIndyaXRlSW50byIsIm91dCIsImJ1ZmZlck91dCIsInNldCIsInN1YmFycmF5IiwieG9mSW50byIsInhvZiIsImRpZ2VzdEludG8iLCJkZXN0cm95IiwiZGlnZXN0IiwiX2Nsb25lSW50byIsInRvIiwiZ2VuIiwic2hhM18yMjQiLCJzaGEzXzI1NiIsInNoYTNfMzg0Iiwic2hhM181MTIiLCJrZWNjYWtfMjI0Iiwia2VjY2FrXzI1NiIsImtlY2Nha18zODQiLCJrZWNjYWtfNTEyIiwiZ2VuU2hha2UiLCJvcHRzIiwiZGtMZW4iLCJ1bmRlZmluZWQiLCJzaGFrZTEyOCIsInNoYWtlMjU2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/starknet/node_modules/@noble/hashes/esm/utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift)=>word << shift | word >>> 32 - shift >>> 0;\nconst isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word)=>word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n)=>n : (n)=>byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++){\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    _A: 65,\n    _F: 70,\n    _a: 97,\n    _f: 102\n};\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== \"[object Object]\") throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsb0ZBQW9GO0FBQ3BGLHNFQUFzRTtBQUN0RSxrRUFBa0U7QUFDbEUsOERBQThEO0FBQzlELCtEQUErRDtBQUMvRCwyRUFBMkU7QUFDN0I7QUFDQztBQUMvQywwQ0FBMEM7QUFDMUMsb0ZBQW9GO0FBQzdFLFNBQVNHLFFBQVFDLENBQUM7SUFDckIsT0FBUUEsYUFBYUMsY0FDaEJELEtBQUssUUFBUSxPQUFPQSxNQUFNLFlBQVlBLEVBQUVFLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLO0FBQ3RFO0FBQ0EsK0JBQStCO0FBQ3hCLE1BQU1DLEtBQUssQ0FBQ0MsTUFBUSxJQUFJSixXQUFXSSxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVSxFQUFFO0FBQy9FLE1BQU1DLE1BQU0sQ0FBQ0osTUFBUSxJQUFJSyxZQUFZTCxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUksS0FBS0MsS0FBSyxDQUFDUCxJQUFJRyxVQUFVLEdBQUcsSUFBSTtBQUN4RyxxQkFBcUI7QUFDZCxNQUFNSyxhQUFhLENBQUNSLE1BQVEsSUFBSVMsU0FBU1QsSUFBSUMsTUFBTSxFQUFFRCxJQUFJRSxVQUFVLEVBQUVGLElBQUlHLFVBQVUsRUFBRTtBQUM1RiwrREFBK0Q7QUFDeEQsTUFBTU8sT0FBTyxDQUFDQyxNQUFNQyxRQUFVLFFBQVUsS0FBS0EsUUFBV0QsU0FBU0MsTUFBTztBQUMvRSw2REFBNkQ7QUFDdEQsTUFBTUMsT0FBTyxDQUFDRixNQUFNQyxRQUFVLFFBQVNBLFFBQVUsU0FBVyxLQUFLQSxVQUFZLEVBQUc7QUFDaEYsTUFBTUUsT0FBTyxJQUFJbEIsV0FBVyxJQUFJUyxZQUFZO0lBQUM7Q0FBVyxFQUFFSixNQUFNLENB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RSxNQUFNO0lBQ3ZFLE1BQU1DLE1BQU1MLFNBQVMsQ0FBQztJQUN0QkMsTUFBTUssU0FBUyxHQUFHRCxJQUFJQyxTQUFTO0lBQy9CTCxNQUFNTSxRQUFRLEdBQUdGLElBQUlFLFFBQVE7SUFDN0JOLE1BQU1PLE1BQU0sR0FBRyxDQUFDZCxPQUFTTSxTQUFTTjtJQUNsQyxPQUFPTztBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTVSxZQUFZQyxjQUFjLEVBQUU7SUFDeEMsSUFBSXZHLHdEQUFNQSxJQUFJLE9BQU9BLHdEQUFNQSxDQUFDd0csZUFBZSxLQUFLLFlBQVk7UUFDeEQsT0FBT3hHLHdEQUFNQSxDQUFDd0csZUFBZSxDQUFDLElBQUluRyxXQUFXa0c7SUFDakQ7SUFDQSxNQUFNLElBQUl2RCxNQUFNO0FBQ3BCLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZGFwcC8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/MWQxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5pbXBvcnQgeyBieXRlcyBhcyBhYnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuLy8gZXhwb3J0IHsgaXNCeXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBXZSBjYW4ndCByZXVzZSBpc0J5dGVzIGZyb20gX2Fzc2VydCwgYmVjYXVzZSBzb21laG93IHRoaXMgY2F1c2VzIGh1Z2UgcGVyZiBpc3N1ZXNcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICgod29yZCA+Pj4gKDMyIC0gc2hpZnQpKSA+Pj4gMCk7XG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG4vLyBUaGUgYnl0ZSBzd2FwIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3QgYnl0ZVN3YXAgPSAod29yZCkgPT4gKCh3b3JkIDw8IDI0KSAmIDB4ZmYwMDAwMDApIHxcbiAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAoKHdvcmQgPj4+IDI0KSAmIDB4ZmYpO1xuLy8gQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtXG5leHBvcnQgY29uc3QgYnl0ZVN3YXBJZkJFID0gaXNMRSA/IChuKSA9PiBuIDogKG4pID0+IGJ5dGVTd2FwKG4pO1xuLy8gSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB0b1N0ci5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJjcnlwdG8iLCJieXRlcyIsImFieXRlcyIsImlzQnl0ZXMiLCJhIiwiVWludDhBcnJheSIsImNvbnN0cnVjdG9yIiwibmFtZSIsInU4IiwiYXJyIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJ1MzIiLCJVaW50MzJBcnJheSIsIk1hdGgiLCJmbG9vciIsImNyZWF0ZVZpZXciLCJEYXRhVmlldyIsInJvdHIiLCJ3b3JkIiwic2hpZnQiLCJyb3RsIiwiaXNMRSIsImJ5dGVTd2FwIiwiYnl0ZVN3YXBJZkJFIiwibiIsImJ5dGVTd2FwMzIiLCJpIiwibGVuZ3RoIiwiaGV4ZXMiLCJBcnJheSIsImZyb20iLCJfIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImJ5dGVzVG9IZXgiLCJoZXgiLCJhc2NpaXMiLCJfMCIsIl85IiwiX0EiLCJfRiIsIl9hIiwiX2YiLCJhc2NpaVRvQmFzZTE2IiwiY2hhciIsImhleFRvQnl0ZXMiLCJFcnJvciIsImhsIiwiYWwiLCJhcnJheSIsImFpIiwiaGkiLCJuMSIsImNoYXJDb2RlQXQiLCJuMiIsInVuZGVmaW5lZCIsIm5leHRUaWNrIiwiYXN5bmNMb29wIiwiaXRlcnMiLCJ0aWNrIiwiY2IiLCJ0cyIsIkRhdGUiLCJub3ciLCJkaWZmIiwidXRmOFRvQnl0ZXMiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsInRvQnl0ZXMiLCJkYXRhIiwiY29uY2F0Qnl0ZXMiLCJhcnJheXMiLCJzdW0iLCJyZXMiLCJwYWQiLCJzZXQiLCJIYXNoIiwiY2xvbmUiLCJfY2xvbmVJbnRvIiwidG9TdHIiLCJjaGVja09wdHMiLCJkZWZhdWx0cyIsIm9wdHMiLCJjYWxsIiwibWVyZ2VkIiwiT2JqZWN0IiwiYXNzaWduIiwid3JhcENvbnN0cnVjdG9yIiwiaGFzaENvbnMiLCJoYXNoQyIsIm1zZyIsInVwZGF0ZSIsImRpZ2VzdCIsInRtcCIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiY3JlYXRlIiwid3JhcENvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyIsInJhbmRvbUJ5dGVzIiwiYnl0ZXNMZW5ndGgiLCJnZXRSYW5kb21WYWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/LosslessNumber.js":
/*!************************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/LosslessNumber.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LosslessNumber: () => (/* binding */ LosslessNumber),\n/* harmony export */   isLosslessNumber: () => (/* binding */ isLosslessNumber),\n/* harmony export */   toLosslessNumber: () => (/* binding */ toLosslessNumber)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js\");\n\n/**\n * A lossless number. Stores its numeric value as string\n */ class LosslessNumber {\n    constructor(value){\n        // numeric value as string\n        // type information\n        this.isLosslessNumber = true;\n        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(value)) {\n            throw new Error('Invalid number (value: \"' + value + '\")');\n        }\n        this.value = value;\n    }\n    /**\n   * Get the value of the LosslessNumber as number or bigint.\n   *\n   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits\n   * - a bigint is returned for big integer numbers\n   * - an Error is thrown for values that will overflow or underflow\n   *\n   * Note that you can implement your own strategy for conversion by just getting the value as string\n   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,\n   * and toSafeNumberOrThrow to convert it to a numeric value.\n   */ valueOf() {\n        const unsafeReason = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getUnsafeNumberReason)(this.value);\n        // safe or truncate_float\n        if (unsafeReason === undefined || unsafeReason === _utils_js__WEBPACK_IMPORTED_MODULE_0__.UnsafeNumberReason.truncate_float) {\n            return parseFloat(this.value);\n        }\n        // truncate_integer\n        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(this.value)) {\n            return BigInt(this.value);\n        }\n        // overflow or underflow\n        throw new Error(\"Cannot safely convert to number: \" + `the value '${this.value}' would ${unsafeReason} and become ${parseFloat(this.value)}`);\n    }\n    /**\n   * Get the value of the LosslessNumber as string.\n   */ toString() {\n        return this.value;\n    }\n}\n/**\n * Test whether a value is a LosslessNumber\n */ function isLosslessNumber(value) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return value && typeof value === \"object\" && value.isLosslessNumber === true || false;\n}\n/**\n * Convert a number into a LosslessNumber if this is possible in a safe way\n * If the value has too many digits, or is NaN or Infinity, an error will be thrown\n */ function toLosslessNumber(value) {\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.extractSignificantDigits)(value + \"\").length > 15) {\n        throw new Error(\"Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself \" + `(value: ${value})`);\n    }\n    if (isNaN(value)) {\n        throw new Error(\"Invalid number: NaN\");\n    }\n    if (!isFinite(value)) {\n        throw new Error(\"Invalid number: \" + value);\n    }\n    return new LosslessNumber(String(value));\n} //# sourceMappingURL=LosslessNumber.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9Mb3NzbGVzc051bWJlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNIO0FBRXRIOztDQUVDLEdBQ00sTUFBTUs7SUFLWEMsWUFBWUMsS0FBSyxDQUFFO1FBSm5CLDBCQUEwQjtRQUUxQixtQkFBbUI7YUFDbkJDLG1CQUFtQjtRQUVqQixJQUFJLENBQUNMLG1EQUFRQSxDQUFDSSxRQUFRO1lBQ3BCLE1BQU0sSUFBSUUsTUFBTSw2QkFBNkJGLFFBQVE7UUFDdkQ7UUFDQSxJQUFJLENBQUNBLEtBQUssR0FBR0E7SUFDZjtJQUVBOzs7Ozs7Ozs7O0dBVUMsR0FDREcsVUFBVTtRQUNSLE1BQU1DLGVBQWVWLGdFQUFxQkEsQ0FBQyxJQUFJLENBQUNNLEtBQUs7UUFFckQseUJBQXlCO1FBQ3pCLElBQUlJLGlCQUFpQkMsYUFBYUQsaUJBQWlCUCx5REFBa0JBLENBQUNTLGNBQWMsRUFBRTtZQUNwRixPQUFPQyxXQUFXLElBQUksQ0FBQ1AsS0FBSztRQUM5QjtRQUVBLG1CQUFtQjtRQUNuQixJQUFJTCxvREFBU0EsQ0FBQyxJQUFJLENBQUNLLEtBQUssR0FBRztZQUN6QixPQUFPUSxPQUFPLElBQUksQ0FBQ1IsS0FBSztRQUMxQjtRQUVBLHdCQUF3QjtRQUN4QixNQUFNLElBQUlFLE1BQU0sc0NBQXNDLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQ0YsS0FBSyxDQUFDLFFBQVEsRUFBRUksYUFBYSxZQUFZLEVBQUVHLFdBQVcsSUFBSSxDQUFDUCxLQUFLLEVBQUUsQ0FBQztJQUM5STtJQUVBOztHQUVDLEdBQ0RTLFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQ1QsS0FBSztJQUNuQjtBQUtGO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxpQkFBaUJELEtBQUs7SUFDcEMsNkRBQTZEO0lBQzdELGFBQWE7SUFDYixPQUFPQSxTQUFTLE9BQU9BLFVBQVUsWUFBWUEsTUFBTUMsZ0JBQWdCLEtBQUssUUFBUTtBQUNsRjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNTLGlCQUFpQlYsS0FBSztJQUNwQyxJQUFJUCxtRUFBd0JBLENBQUNPLFFBQVEsSUFBSVcsTUFBTSxHQUFHLElBQUk7UUFDcEQsTUFBTSxJQUFJVCxNQUFNLG9HQUFvRyxDQUFDLFFBQVEsRUFBRUYsTUFBTSxDQUFDLENBQUM7SUFDekk7SUFDQSxJQUFJWSxNQUFNWixRQUFRO1FBQ2hCLE1BQU0sSUFBSUUsTUFBTTtJQUNsQjtJQUNBLElBQUksQ0FBQ1csU0FBU2IsUUFBUTtRQUNwQixNQUFNLElBQUlFLE1BQU0scUJBQXFCRjtJQUN2QztJQUNBLE9BQU8sSUFBSUYsZUFBZWdCLE9BQU9kO0FBQ25DLEVBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZGFwcC8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL0xvc3NsZXNzTnVtYmVyLmpzPzEwNzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzLCBnZXRVbnNhZmVOdW1iZXJSZWFzb24sIGlzSW50ZWdlciwgaXNOdW1iZXIsIFVuc2FmZU51bWJlclJlYXNvbiB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEEgbG9zc2xlc3MgbnVtYmVyLiBTdG9yZXMgaXRzIG51bWVyaWMgdmFsdWUgYXMgc3RyaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBMb3NzbGVzc051bWJlciB7XG4gIC8vIG51bWVyaWMgdmFsdWUgYXMgc3RyaW5nXG5cbiAgLy8gdHlwZSBpbmZvcm1hdGlvblxuICBpc0xvc3NsZXNzTnVtYmVyID0gdHJ1ZTtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciAodmFsdWU6IFwiJyArIHZhbHVlICsgJ1wiKScpO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgTG9zc2xlc3NOdW1iZXIgYXMgbnVtYmVyIG9yIGJpZ2ludC5cbiAgICpcbiAgICogLSBhIG51bWJlciBpcyByZXR1cm5lZCBmb3Igc2FmZSBudW1iZXJzIGFuZCBkZWNpbWFsIHZhbHVlcyB0aGF0IG9ubHkgbG9zZSBzb21lIGluc2lnbmlmaWNhbnQgZGlnaXRzXG4gICAqIC0gYSBiaWdpbnQgaXMgcmV0dXJuZWQgZm9yIGJpZyBpbnRlZ2VyIG51bWJlcnNcbiAgICogLSBhbiBFcnJvciBpcyB0aHJvd24gZm9yIHZhbHVlcyB0aGF0IHdpbGwgb3ZlcmZsb3cgb3IgdW5kZXJmbG93XG4gICAqXG4gICAqIE5vdGUgdGhhdCB5b3UgY2FuIGltcGxlbWVudCB5b3VyIG93biBzdHJhdGVneSBmb3IgY29udmVyc2lvbiBieSBqdXN0IGdldHRpbmcgdGhlIHZhbHVlIGFzIHN0cmluZ1xuICAgKiB2aWEgLnRvU3RyaW5nKCksIGFuZCB1c2luZyB1dGlsIGZ1bmN0aW9ucyBsaWtlIGlzSW50ZWdlciwgaXNTYWZlTnVtYmVyLCBnZXRVbnNhZmVOdW1iZXJSZWFzb24sXG4gICAqIGFuZCB0b1NhZmVOdW1iZXJPclRocm93IHRvIGNvbnZlcnQgaXQgdG8gYSBudW1lcmljIHZhbHVlLlxuICAgKi9cbiAgdmFsdWVPZigpIHtcbiAgICBjb25zdCB1bnNhZmVSZWFzb24gPSBnZXRVbnNhZmVOdW1iZXJSZWFzb24odGhpcy52YWx1ZSk7XG5cbiAgICAvLyBzYWZlIG9yIHRydW5jYXRlX2Zsb2F0XG4gICAgaWYgKHVuc2FmZVJlYXNvbiA9PT0gdW5kZWZpbmVkIHx8IHVuc2FmZVJlYXNvbiA9PT0gVW5zYWZlTnVtYmVyUmVhc29uLnRydW5jYXRlX2Zsb2F0KSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyB0cnVuY2F0ZV9pbnRlZ2VyXG4gICAgaWYgKGlzSW50ZWdlcih0aGlzLnZhbHVlKSkge1xuICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBvdmVyZmxvdyBvciB1bmRlcmZsb3dcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzYWZlbHkgY29udmVydCB0byBudW1iZXI6ICcgKyBgdGhlIHZhbHVlICcke3RoaXMudmFsdWV9JyB3b3VsZCAke3Vuc2FmZVJlYXNvbn0gYW5kIGJlY29tZSAke3BhcnNlRmxvYXQodGhpcy52YWx1ZSl9YCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgTG9zc2xlc3NOdW1iZXIgYXMgc3RyaW5nLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICAvLyBOb3RlOiB3ZSBkbyBOT1QgaW1wbGVtZW50IGEgLnRvSlNPTigpIG1ldGhvZCwgYW5kIHlvdSBzaG91bGQgbm90IGltcGxlbWVudFxuICAvLyBvciB1c2UgdGhhdCwgaXQgY2Fubm90IHNhZmVseSB0dXJuIHRoZSBudW1lcmljIHZhbHVlIGluIHRoZSBzdHJpbmcgaW50b1xuICAvLyBzdHJpbmdpZmllZCBKU09OIHNpbmNlIGl0IGhhcyB0byBiZSBwYXJzZWQgaW50byBhIG51bWJlciBmaXJzdC5cbn1cblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBhIExvc3NsZXNzTnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xvc3NsZXNzTnVtYmVyKHZhbHVlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5pc0xvc3NsZXNzTnVtYmVyID09PSB0cnVlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBudW1iZXIgaW50byBhIExvc3NsZXNzTnVtYmVyIGlmIHRoaXMgaXMgcG9zc2libGUgaW4gYSBzYWZlIHdheVxuICogSWYgdGhlIHZhbHVlIGhhcyB0b28gbWFueSBkaWdpdHMsIG9yIGlzIE5hTiBvciBJbmZpbml0eSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTG9zc2xlc3NOdW1iZXIodmFsdWUpIHtcbiAgaWYgKGV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyh2YWx1ZSArICcnKS5sZW5ndGggPiAxNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXI6IGNvbnRhaW5zIG1vcmUgdGhhbiAxNSBkaWdpdHMgYW5kIGlzIG1vc3QgbGlrZWx5IHRydW5jYXRlZCBhbmQgdW5zYWZlIGJ5IGl0c2VsZiAnICsgYCh2YWx1ZTogJHt2YWx1ZX0pYCk7XG4gIH1cbiAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXI6IE5hTicpO1xuICB9XG4gIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlcjogJyArIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gbmV3IExvc3NsZXNzTnVtYmVyKFN0cmluZyh2YWx1ZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9zc2xlc3NOdW1iZXIuanMubWFwIl0sIm5hbWVzIjpbImV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyIsImdldFVuc2FmZU51bWJlclJlYXNvbiIsImlzSW50ZWdlciIsImlzTnVtYmVyIiwiVW5zYWZlTnVtYmVyUmVhc29uIiwiTG9zc2xlc3NOdW1iZXIiLCJjb25zdHJ1Y3RvciIsInZhbHVlIiwiaXNMb3NzbGVzc051bWJlciIsIkVycm9yIiwidmFsdWVPZiIsInVuc2FmZVJlYXNvbiIsInVuZGVmaW5lZCIsInRydW5jYXRlX2Zsb2F0IiwicGFyc2VGbG9hdCIsIkJpZ0ludCIsInRvU3RyaW5nIiwidG9Mb3NzbGVzc051bWJlciIsImxlbmd0aCIsImlzTmFOIiwiaXNGaW5pdGUiLCJTdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/LosslessNumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/config.js":
/*!****************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/config.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config)\n/* harmony export */ });\n/**\n * Get and/or set configuration options\n * @deprecated There is no config anymore\n */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction config(options) {\n    // Backward compatibility warning for v1.x\n    throw new Error(\"config is deprecated, support for circularRefs is removed from the library. \" + \"If you encounter circular references in your data structures, \" + \"please rethink your datastructures: \" + \"better prevent circular references in the first place.\");\n} //# sourceMappingURL=config.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Q0FHQyxHQUNELDZEQUE2RDtBQUN0RCxTQUFTQSxPQUFPQyxPQUFPO0lBQzVCLDBDQUEwQztJQUMxQyxNQUFNLElBQUlDLE1BQU0saUZBQWlGLG1FQUFtRSx5Q0FBeUM7QUFDL00sRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1kYXBwLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vY29uZmlnLmpzPzM5YjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHZXQgYW5kL29yIHNldCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBkZXByZWNhdGVkIFRoZXJlIGlzIG5vIGNvbmZpZyBhbnltb3JlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmV4cG9ydCBmdW5jdGlvbiBjb25maWcob3B0aW9ucykge1xuICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdhcm5pbmcgZm9yIHYxLnhcbiAgdGhyb3cgbmV3IEVycm9yKCdjb25maWcgaXMgZGVwcmVjYXRlZCwgc3VwcG9ydCBmb3IgY2lyY3VsYXJSZWZzIGlzIHJlbW92ZWQgZnJvbSB0aGUgbGlicmFyeS4gJyArICdJZiB5b3UgZW5jb3VudGVyIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4geW91ciBkYXRhIHN0cnVjdHVyZXMsICcgKyAncGxlYXNlIHJldGhpbmsgeW91ciBkYXRhc3RydWN0dXJlczogJyArICdiZXR0ZXIgcHJldmVudCBjaXJjdWxhciByZWZlcmVuY2VzIGluIHRoZSBmaXJzdCBwbGFjZS4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOlsiY29uZmlnIiwib3B0aW9ucyIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LosslessNumber: () => (/* reexport safe */ _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__.LosslessNumber),\n/* harmony export */   UnsafeNumberReason: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.UnsafeNumberReason),\n/* harmony export */   config: () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_0__.config),\n/* harmony export */   getUnsafeNumberReason: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.getUnsafeNumberReason),\n/* harmony export */   isInteger: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.isInteger),\n/* harmony export */   isLosslessNumber: () => (/* reexport safe */ _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__.isLosslessNumber),\n/* harmony export */   isNumber: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.isNumber),\n/* harmony export */   isSafeNumber: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.isSafeNumber),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_1__.parse),\n/* harmony export */   parseLosslessNumber: () => (/* reexport safe */ _numberParsers_js__WEBPACK_IMPORTED_MODULE_5__.parseLosslessNumber),\n/* harmony export */   parseNumberAndBigInt: () => (/* reexport safe */ _numberParsers_js__WEBPACK_IMPORTED_MODULE_5__.parseNumberAndBigInt),\n/* harmony export */   reviveDate: () => (/* reexport safe */ _reviveDate_js__WEBPACK_IMPORTED_MODULE_4__.reviveDate),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_2__.stringify),\n/* harmony export */   toLosslessNumber: () => (/* reexport safe */ _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__.toLosslessNumber),\n/* harmony export */   toSafeNumberOrThrow: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.toSafeNumberOrThrow)\n/* harmony export */ });\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/config.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/stringify.js\");\n/* harmony import */ var _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LosslessNumber.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/LosslessNumber.js\");\n/* harmony import */ var _reviveDate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reviveDate.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/reviveDate.js\");\n/* harmony import */ var _numberParsers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./numberParsers.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/numberParsers.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/types.js\");\n\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNGO0FBQ1E7QUFDOEM7QUFDNUM7QUFDa0M7QUFDZ0Q7QUFDcEcsQ0FDM0IsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZGFwcC8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL2luZGV4LmpzP2NmYTgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgY29uZmlnIH0gZnJvbSAnLi9jb25maWcuanMnO1xuZXhwb3J0IHsgcGFyc2UgfSBmcm9tICcuL3BhcnNlLmpzJztcbmV4cG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IExvc3NsZXNzTnVtYmVyLCBpc0xvc3NsZXNzTnVtYmVyLCB0b0xvc3NsZXNzTnVtYmVyIH0gZnJvbSAnLi9Mb3NzbGVzc051bWJlci5qcyc7XG5leHBvcnQgeyByZXZpdmVEYXRlIH0gZnJvbSAnLi9yZXZpdmVEYXRlLmpzJztcbmV4cG9ydCB7IHBhcnNlTG9zc2xlc3NOdW1iZXIsIHBhcnNlTnVtYmVyQW5kQmlnSW50IH0gZnJvbSAnLi9udW1iZXJQYXJzZXJzLmpzJztcbmV4cG9ydCB7IFVuc2FmZU51bWJlclJlYXNvbiwgaXNJbnRlZ2VyLCBpc051bWJlciwgaXNTYWZlTnVtYmVyLCB0b1NhZmVOdW1iZXJPclRocm93LCBnZXRVbnNhZmVOdW1iZXJSZWFzb24gfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImNvbmZpZyIsInBhcnNlIiwic3RyaW5naWZ5IiwiTG9zc2xlc3NOdW1iZXIiLCJpc0xvc3NsZXNzTnVtYmVyIiwidG9Mb3NzbGVzc051bWJlciIsInJldml2ZURhdGUiLCJwYXJzZUxvc3NsZXNzTnVtYmVyIiwicGFyc2VOdW1iZXJBbmRCaWdJbnQiLCJVbnNhZmVOdW1iZXJSZWFzb24iLCJpc0ludGVnZXIiLCJpc051bWJlciIsImlzU2FmZU51bWJlciIsInRvU2FmZU51bWJlck9yVGhyb3ciLCJnZXRVbnNhZmVOdW1iZXJSZWFzb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/numberParsers.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/numberParsers.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseLosslessNumber: () => (/* binding */ parseLosslessNumber),\n/* harmony export */   parseNumberAndBigInt: () => (/* binding */ parseNumberAndBigInt)\n/* harmony export */ });\n/* harmony import */ var _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LosslessNumber.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/LosslessNumber.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js\");\n\n\nfunction parseLosslessNumber(value) {\n    return new _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__.LosslessNumber(value);\n}\nfunction parseNumberAndBigInt(value) {\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isInteger)(value) ? BigInt(value) : parseFloat(value);\n} //# sourceMappingURL=numberParsers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9udW1iZXJQYXJzZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBcUQ7QUFDZDtBQUNoQyxTQUFTRSxvQkFBb0JDLEtBQUs7SUFDdkMsT0FBTyxJQUFJSCw4REFBY0EsQ0FBQ0c7QUFDNUI7QUFDTyxTQUFTQyxxQkFBcUJELEtBQUs7SUFDeEMsT0FBT0Ysb0RBQVNBLENBQUNFLFNBQVNFLE9BQU9GLFNBQVNHLFdBQVdIO0FBQ3ZELEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZGFwcC8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL251bWJlclBhcnNlcnMuanM/YThiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb3NzbGVzc051bWJlciB9IGZyb20gJy4vTG9zc2xlc3NOdW1iZXIuanMnO1xuaW1wb3J0IHsgaXNJbnRlZ2VyIH0gZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VMb3NzbGVzc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gbmV3IExvc3NsZXNzTnVtYmVyKHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU51bWJlckFuZEJpZ0ludCh2YWx1ZSkge1xuICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSA/IEJpZ0ludCh2YWx1ZSkgOiBwYXJzZUZsb2F0KHZhbHVlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlclBhcnNlcnMuanMubWFwIl0sIm5hbWVzIjpbIkxvc3NsZXNzTnVtYmVyIiwiaXNJbnRlZ2VyIiwicGFyc2VMb3NzbGVzc051bWJlciIsInZhbHVlIiwicGFyc2VOdW1iZXJBbmRCaWdJbnQiLCJCaWdJbnQiLCJwYXJzZUZsb2F0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/numberParsers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/parse.js":
/*!***************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/parse.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codeLowercaseA: () => (/* binding */ codeLowercaseA),\n/* harmony export */   codeLowercaseE: () => (/* binding */ codeLowercaseE),\n/* harmony export */   codeLowercaseF: () => (/* binding */ codeLowercaseF),\n/* harmony export */   codeUppercaseA: () => (/* binding */ codeUppercaseA),\n/* harmony export */   codeUppercaseE: () => (/* binding */ codeUppercaseE),\n/* harmony export */   codeUppercaseF: () => (/* binding */ codeUppercaseF),\n/* harmony export */   isDeepEqual: () => (/* binding */ isDeepEqual),\n/* harmony export */   isValidStringCharacter: () => (/* binding */ isValidStringCharacter),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\n/* harmony import */ var _numberParsers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./numberParsers.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/numberParsers.js\");\n/* harmony import */ var _revive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./revive.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/revive.js\");\n\n\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * The parser is based on the parser of Tan Li Hou shared in\n * https://lihautan.com/json-parser-with-javascript/\n *\n * @param text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @param [parseNumber=parseLosslessNumber]\n * Pass a custom number parser. Input is a string, and the output can be unknown\n * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */ function parse(text, reviver) {\n    let parseNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _numberParsers_js__WEBPACK_IMPORTED_MODULE_0__.parseLosslessNumber;\n    let i = 0;\n    const value = parseValue();\n    expectValue(value);\n    expectEndOfInput();\n    return reviver ? (0,_revive_js__WEBPACK_IMPORTED_MODULE_1__.revive)(value, reviver) : value;\n    function parseObject() {\n        if (text.charCodeAt(i) === codeOpeningBrace) {\n            i++;\n            skipWhitespace();\n            const object = {};\n            let initial = true;\n            while(i < text.length && text.charCodeAt(i) !== codeClosingBrace){\n                if (!initial) {\n                    eatComma();\n                    skipWhitespace();\n                } else {\n                    initial = false;\n                }\n                const start = i;\n                const key = parseString();\n                if (key === undefined) {\n                    throwObjectKeyExpected();\n                    return; // To make TS happy\n                }\n                skipWhitespace();\n                eatColon();\n                const value = parseValue();\n                if (value === undefined) {\n                    throwObjectValueExpected();\n                    return; // To make TS happy\n                }\n                // TODO: test deep equal instead of strict equal\n                if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(value, object[key])) {\n                    // Note that we could also test `if(key in object) {...}`\n                    // or `if (object[key] !== 'undefined') {...}`, but that is slower.\n                    throwDuplicateKey(key, start + 1);\n                }\n                object[key] = value;\n            }\n            if (text.charCodeAt(i) !== codeClosingBrace) {\n                throwObjectKeyOrEndExpected();\n            }\n            i++;\n            return object;\n        }\n    }\n    function parseArray() {\n        if (text.charCodeAt(i) === codeOpeningBracket) {\n            i++;\n            skipWhitespace();\n            const array = [];\n            let initial = true;\n            while(i < text.length && text.charCodeAt(i) !== codeClosingBracket){\n                if (!initial) {\n                    eatComma();\n                } else {\n                    initial = false;\n                }\n                const value = parseValue();\n                expectArrayItem(value);\n                array.push(value);\n            }\n            if (text.charCodeAt(i) !== codeClosingBracket) {\n                throwArrayItemOrEndExpected();\n            }\n            i++;\n            return array;\n        }\n    }\n    function parseValue() {\n        skipWhitespace();\n        const value = parseString() ?? parseNumeric() ?? parseObject() ?? parseArray() ?? parseKeyword(\"true\", true) ?? parseKeyword(\"false\", false) ?? parseKeyword(\"null\", null);\n        skipWhitespace();\n        return value;\n    }\n    function parseKeyword(name, value) {\n        if (text.slice(i, i + name.length) === name) {\n            i += name.length;\n            return value;\n        }\n    }\n    function skipWhitespace() {\n        while(isWhitespace(text.charCodeAt(i))){\n            i++;\n        }\n    }\n    function parseString() {\n        if (text.charCodeAt(i) === codeDoubleQuote) {\n            i++;\n            let result = \"\";\n            while(i < text.length && text.charCodeAt(i) !== codeDoubleQuote){\n                if (text.charCodeAt(i) === codeBackslash) {\n                    const char = text[i + 1];\n                    const escapeChar = escapeCharacters[char];\n                    if (escapeChar !== undefined) {\n                        result += escapeChar;\n                        i++;\n                    } else if (char === \"u\") {\n                        if (isHex(text.charCodeAt(i + 2)) && isHex(text.charCodeAt(i + 3)) && isHex(text.charCodeAt(i + 4)) && isHex(text.charCodeAt(i + 5))) {\n                            result += String.fromCharCode(parseInt(text.slice(i + 2, i + 6), 16));\n                            i += 5;\n                        } else {\n                            throwInvalidUnicodeCharacter(i);\n                        }\n                    } else {\n                        throwInvalidEscapeCharacter(i);\n                    }\n                } else {\n                    if (isValidStringCharacter(text.charCodeAt(i))) {\n                        result += text[i];\n                    } else {\n                        throwInvalidCharacter(text[i]);\n                    }\n                }\n                i++;\n            }\n            expectEndOfString();\n            i++;\n            return result;\n        }\n    }\n    function parseNumeric() {\n        const start = i;\n        if (text.charCodeAt(i) === codeMinus) {\n            i++;\n            expectDigit(start);\n        }\n        if (text.charCodeAt(i) === codeZero) {\n            i++;\n        } else if (isNonZeroDigit(text.charCodeAt(i))) {\n            i++;\n            while(isDigit(text.charCodeAt(i))){\n                i++;\n            }\n        }\n        if (text.charCodeAt(i) === codeDot) {\n            i++;\n            expectDigit(start);\n            while(isDigit(text.charCodeAt(i))){\n                i++;\n            }\n        }\n        if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n            i++;\n            if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n                i++;\n            }\n            expectDigit(start);\n            while(isDigit(text.charCodeAt(i))){\n                i++;\n            }\n        }\n        if (i > start) {\n            return parseNumber(text.slice(start, i));\n        }\n    }\n    function eatComma() {\n        if (text.charCodeAt(i) !== codeComma) {\n            throw new SyntaxError(`Comma ',' expected after value ${gotAt()}`);\n        }\n        i++;\n    }\n    function eatColon() {\n        if (text.charCodeAt(i) !== codeColon) {\n            throw new SyntaxError(`Colon ':' expected after property name ${gotAt()}`);\n        }\n        i++;\n    }\n    function expectValue(value) {\n        if (value === undefined) {\n            throw new SyntaxError(`JSON value expected ${gotAt()}`);\n        }\n    }\n    function expectArrayItem(value) {\n        if (value === undefined) {\n            throw new SyntaxError(`Array item expected ${gotAt()}`);\n        }\n    }\n    function expectEndOfInput() {\n        if (i < text.length) {\n            throw new SyntaxError(`Expected end of input ${gotAt()}`);\n        }\n    }\n    function expectDigit(start) {\n        if (!isDigit(text.charCodeAt(i))) {\n            const numSoFar = text.slice(start, i);\n            throw new SyntaxError(`Invalid number '${numSoFar}', expecting a digit ${gotAt()}`);\n        }\n    }\n    function expectEndOfString() {\n        if (text.charCodeAt(i) !== codeDoubleQuote) {\n            throw new SyntaxError(`End of string '\"' expected ${gotAt()}`);\n        }\n    }\n    function throwObjectKeyExpected() {\n        throw new SyntaxError(`Quoted object key expected ${gotAt()}`);\n    }\n    function throwDuplicateKey(key, pos) {\n        throw new SyntaxError(`Duplicate key '${key}' encountered at position ${pos}`);\n    }\n    function throwObjectKeyOrEndExpected() {\n        throw new SyntaxError(`Quoted object key or end of object '}' expected ${gotAt()}`);\n    }\n    function throwArrayItemOrEndExpected() {\n        throw new SyntaxError(`Array item or end of array ']' expected ${gotAt()}`);\n    }\n    function throwInvalidCharacter(char) {\n        throw new SyntaxError(`Invalid character '${char}' ${pos()}`);\n    }\n    function throwInvalidEscapeCharacter(start) {\n        const chars = text.slice(start, start + 2);\n        throw new SyntaxError(`Invalid escape character '${chars}' ${pos()}`);\n    }\n    function throwObjectValueExpected() {\n        throw new SyntaxError(`Object value expected after ':' ${pos()}`);\n    }\n    function throwInvalidUnicodeCharacter(start) {\n        const chars = text.slice(start, start + 6);\n        throw new SyntaxError(`Invalid unicode character '${chars}' ${pos()}`);\n    }\n    // zero based character position\n    function pos() {\n        return `at position ${i}`;\n    }\n    function got() {\n        return i < text.length ? `but got '${text[i]}'` : \"but reached end of input\";\n    }\n    function gotAt() {\n        return got() + \" \" + pos();\n    }\n}\nfunction isWhitespace(code) {\n    return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;\n}\nfunction isHex(code) {\n    return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;\n}\nfunction isDigit(code) {\n    return code >= codeZero && code <= codeNine;\n}\nfunction isNonZeroDigit(code) {\n    return code >= codeOne && code <= codeNine;\n}\nfunction isValidStringCharacter(code) {\n    return code >= 0x20 && code <= 0x10ffff;\n}\nfunction isDeepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return a.length === b.length && a.every((item, index)=>isDeepEqual(item, b[index]));\n    }\n    if (isObject(a) && isObject(b)) {\n        const keys = [\n            ...new Set([\n                ...Object.keys(a),\n                ...Object.keys(b)\n            ])\n        ];\n        return keys.every((key)=>isDeepEqual(a[key], b[key]));\n    }\n    return false;\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n// map with all escape characters\nconst escapeCharacters = {\n    '\"': '\"',\n    \"\\\\\": \"\\\\\",\n    \"/\": \"/\",\n    b: \"\\b\",\n    f: \"\\f\",\n    n: \"\\n\",\n    r: \"\\r\",\n    t: \"\t\"\n};\nconst codeBackslash = 0x5c; // \"\\\"\nconst codeOpeningBrace = 0x7b; // \"{\"\nconst codeClosingBrace = 0x7d; // \"}\"\nconst codeOpeningBracket = 0x5b; // \"[\"\nconst codeClosingBracket = 0x5d; // \"]\"\nconst codeSpace = 0x20; // \" \"\nconst codeNewline = 0xa; // \"\\n\"\nconst codeTab = 0x9; // \"\\t\"\nconst codeReturn = 0xd; // \"\\r\"\nconst codeDoubleQuote = 0x0022; // \"\nconst codePlus = 0x2b; // \"+\"\nconst codeMinus = 0x2d; // \"-\"\nconst codeZero = 0x30;\nconst codeOne = 0x31;\nconst codeNine = 0x39;\nconst codeComma = 0x2c; // \",\"\nconst codeDot = 0x2e; // \".\" (dot, period)\nconst codeColon = 0x3a; // \":\"\nconst codeUppercaseA = 0x41; // \"A\"\nconst codeLowercaseA = 0x61; // \"a\"\nconst codeUppercaseE = 0x45; // \"E\"\nconst codeLowercaseE = 0x65; // \"e\"\nconst codeUppercaseF = 0x46; // \"F\"\nconst codeLowercaseF = 0x66; // \"f\"\n //# sourceMappingURL=parse.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF5RDtBQUNwQjtBQUNyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ00sU0FBU0UsTUFBTUMsSUFBSSxFQUFFQyxPQUFPO0lBQ2pDLElBQUlDLGNBQWNDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHTixrRUFBbUJBO0lBQ3pHLElBQUlTLElBQUk7SUFDUixNQUFNQyxRQUFRQztJQUNkQyxZQUFZRjtJQUNaRztJQUNBLE9BQU9ULFVBQVVILGtEQUFNQSxDQUFDUyxPQUFPTixXQUFXTTtJQUMxQyxTQUFTSTtRQUNQLElBQUlYLEtBQUtZLFVBQVUsQ0FBQ04sT0FBT08sa0JBQWtCO1lBQzNDUDtZQUNBUTtZQUNBLE1BQU1DLFNBQVMsQ0FBQztZQUNoQixJQUFJQyxVQUFVO1lBQ2QsTUFBT1YsSUFBSU4sS0FBS0ksTUFBTSxJQUFJSixLQUFLWSxVQUFVLENBQUNOLE9BQU9XLGlCQUFrQjtnQkFDakUsSUFBSSxDQUFDRCxTQUFTO29CQUNaRTtvQkFDQUo7Z0JBQ0YsT0FBTztvQkFDTEUsVUFBVTtnQkFDWjtnQkFDQSxNQUFNRyxRQUFRYjtnQkFDZCxNQUFNYyxNQUFNQztnQkFDWixJQUFJRCxRQUFRZixXQUFXO29CQUNyQmlCO29CQUNBLFFBQVEsbUJBQW1CO2dCQUM3QjtnQkFDQVI7Z0JBQ0FTO2dCQUNBLE1BQU1oQixRQUFRQztnQkFDZCxJQUFJRCxVQUFVRixXQUFXO29CQUN2Qm1CO29CQUNBLFFBQVEsbUJBQW1CO2dCQUM3QjtnQkFFQSxnREFBZ0Q7Z0JBQ2hELElBQUlDLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNiLFFBQVFLLFFBQVEsQ0FBQ1MsWUFBWXRCLE9BQU9R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SUFDSEMsR0FBRztBQUVMO0FBQ0EsTUFBTXRELGdCQUFnQixNQUFNLE1BQU07QUFDbEMsTUFBTWpDLG1CQUFtQixNQUFNLE1BQU07QUFDckMsTUFBTUksbUJBQW1CLE1BQU0sTUFBTTtBQUNyQyxNQUFNZ0IscUJBQXFCLE1BQU0sTUFBTTtBQUN2QyxNQUFNRSxxQkFBcUIsTUFBTSxNQUFNO0FBQ3ZDLE1BQU0wQyxZQUFZLE1BQU0sTUFBTTtBQUM5QixNQUFNQyxjQUFjLEtBQUssT0FBTztBQUNoQyxNQUFNQyxVQUFVLEtBQUssT0FBTztBQUM1QixNQUFNQyxhQUFhLEtBQUssT0FBTztBQUMvQixNQUFNcEMsa0JBQWtCLFFBQVEsSUFBSTtBQUNwQyxNQUFNdUIsV0FBVyxNQUFNLE1BQU07QUFDN0IsTUFBTVIsWUFBWSxNQUFNLE1BQU07QUFDOUIsTUFBTUUsV0FBVztBQUNqQixNQUFNeUIsVUFBVTtBQUNoQixNQUFNTCxXQUFXO0FBQ2pCLE1BQU1iLFlBQVksTUFBTSxNQUFNO0FBQzlCLE1BQU1KLFVBQVUsTUFBTSxvQkFBb0I7QUFDMUMsTUFBTU8sWUFBWSxNQUFNLE1BQU07QUFDdkIsTUFBTVcsaUJBQWlCLEtBQUssQ0FBQyxNQUFNO0FBQ25DLE1BQU1FLGlCQUFpQixLQUFLLENBQUMsTUFBTTtBQUNuQyxNQUFNbEIsaUJBQWlCLEtBQUssQ0FBQyxNQUFNO0FBQ25DLE1BQU1ELGlCQUFpQixLQUFLLENBQUMsTUFBTTtBQUNuQyxNQUFNa0IsaUJBQWlCLEtBQUssQ0FBQyxNQUFNO0FBQ25DLE1BQU1FLGlCQUFpQixLQUFLLENBQUMsTUFBTTtDQUMxQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1kYXBwLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vcGFyc2UuanM/OTEzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZUxvc3NsZXNzTnVtYmVyIH0gZnJvbSAnLi9udW1iZXJQYXJzZXJzLmpzJztcbmltcG9ydCB7IHJldml2ZSB9IGZyb20gJy4vcmV2aXZlLmpzJztcbi8qKlxuICogVGhlIExvc3NsZXNzSlNPTi5wYXJzZSgpIG1ldGhvZCBwYXJzZXMgYSBzdHJpbmcgYXMgSlNPTiwgb3B0aW9uYWxseSB0cmFuc2Zvcm1pbmdcbiAqIHRoZSB2YWx1ZSBwcm9kdWNlZCBieSBwYXJzaW5nLlxuICpcbiAqIFRoZSBwYXJzZXIgaXMgYmFzZWQgb24gdGhlIHBhcnNlciBvZiBUYW4gTGkgSG91IHNoYXJlZCBpblxuICogaHR0cHM6Ly9saWhhdXRhbi5jb20vanNvbi1wYXJzZXItd2l0aC1qYXZhc2NyaXB0L1xuICpcbiAqIEBwYXJhbSB0ZXh0XG4gKiBUaGUgc3RyaW5nIHRvIHBhcnNlIGFzIEpTT04uIFNlZSB0aGUgSlNPTiBvYmplY3QgZm9yIGEgZGVzY3JpcHRpb24gb2YgSlNPTiBzeW50YXguXG4gKlxuICogQHBhcmFtIFtyZXZpdmVyXVxuICogSWYgYSBmdW5jdGlvbiwgcHJlc2NyaWJlcyBob3cgdGhlIHZhbHVlIG9yaWdpbmFsbHkgcHJvZHVjZWQgYnkgcGFyc2luZyBpc1xuICogdHJhbnNmb3JtZWQsIGJlZm9yZSBiZWluZyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gW3BhcnNlTnVtYmVyPXBhcnNlTG9zc2xlc3NOdW1iZXJdXG4gKiBQYXNzIGEgY3VzdG9tIG51bWJlciBwYXJzZXIuIElucHV0IGlzIGEgc3RyaW5nLCBhbmQgdGhlIG91dHB1dCBjYW4gYmUgdW5rbm93blxuICogbnVtZXJpYyB2YWx1ZTogbnVtYmVyLCBiaWdpbnQsIExvc3NsZXNzTnVtYmVyLCBvciBhIGN1c3RvbSBCaWdOdW1iZXIgbGlicmFyeS5cbiAqXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBPYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gSlNPTiB0ZXh0LlxuICpcbiAqIEB0aHJvd3MgVGhyb3dzIGEgU3ludGF4RXJyb3IgZXhjZXB0aW9uIGlmIHRoZSBzdHJpbmcgdG8gcGFyc2UgaXMgbm90IHZhbGlkIEpTT04uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0ZXh0LCByZXZpdmVyKSB7XG4gIGxldCBwYXJzZU51bWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogcGFyc2VMb3NzbGVzc051bWJlcjtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCB2YWx1ZSA9IHBhcnNlVmFsdWUoKTtcbiAgZXhwZWN0VmFsdWUodmFsdWUpO1xuICBleHBlY3RFbmRPZklucHV0KCk7XG4gIHJldHVybiByZXZpdmVyID8gcmV2aXZlKHZhbHVlLCByZXZpdmVyKSA6IHZhbHVlO1xuICBmdW5jdGlvbiBwYXJzZU9iamVjdCgpIHtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlT3BlbmluZ0JyYWNlKSB7XG4gICAgICBpKys7XG4gICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICBsZXQgaW5pdGlhbCA9IHRydWU7XG4gICAgICB3aGlsZSAoaSA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNsb3NpbmdCcmFjZSkge1xuICAgICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgICBlYXRDb21tYSgpO1xuICAgICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VTdHJpbmcoKTtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3dPYmplY3RLZXlFeHBlY3RlZCgpO1xuICAgICAgICAgIHJldHVybjsgLy8gVG8gbWFrZSBUUyBoYXBweVxuICAgICAgICB9XG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIGVhdENvbG9uKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VWYWx1ZSgpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93T2JqZWN0VmFsdWVFeHBlY3RlZCgpO1xuICAgICAgICAgIHJldHVybjsgLy8gVG8gbWFrZSBUUyBoYXBweVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogdGVzdCBkZWVwIGVxdWFsIGluc3RlYWQgb2Ygc3RyaWN0IGVxdWFsXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmICFpc0RlZXBFcXVhbCh2YWx1ZSwgb2JqZWN0W2tleV0pKSB7XG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNvdWxkIGFsc28gdGVzdCBgaWYoa2V5IGluIG9iamVjdCkgey4uLn1gXG4gICAgICAgICAgLy8gb3IgYGlmIChvYmplY3Rba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHsuLi59YCwgYnV0IHRoYXQgaXMgc2xvd2VyLlxuICAgICAgICAgIHRocm93RHVwbGljYXRlS2V5KGtleSwgc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNsb3NpbmdCcmFjZSkge1xuICAgICAgICB0aHJvd09iamVjdEtleU9yRW5kRXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlQXJyYXkoKSB7XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA9PT0gY29kZU9wZW5pbmdCcmFja2V0KSB7XG4gICAgICBpKys7XG4gICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgIGxldCBpbml0aWFsID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChpIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KGkpICE9PSBjb2RlQ2xvc2luZ0JyYWNrZXQpIHtcbiAgICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgICAgZWF0Q29tbWEoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbml0aWFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZVZhbHVlKCk7XG4gICAgICAgIGV4cGVjdEFycmF5SXRlbSh2YWx1ZSk7XG4gICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNsb3NpbmdCcmFja2V0KSB7XG4gICAgICAgIHRocm93QXJyYXlJdGVtT3JFbmRFeHBlY3RlZCgpO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwYXJzZVZhbHVlKCkge1xuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZVN0cmluZygpID8/IHBhcnNlTnVtZXJpYygpID8/IHBhcnNlT2JqZWN0KCkgPz8gcGFyc2VBcnJheSgpID8/IHBhcnNlS2V5d29yZCgndHJ1ZScsIHRydWUpID8/IHBhcnNlS2V5d29yZCgnZmFsc2UnLCBmYWxzZSkgPz8gcGFyc2VLZXl3b3JkKCdudWxsJywgbnVsbCk7XG4gICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VLZXl3b3JkKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRleHQuc2xpY2UoaSwgaSArIG5hbWUubGVuZ3RoKSA9PT0gbmFtZSkge1xuICAgICAgaSArPSBuYW1lLmxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgd2hpbGUgKGlzV2hpdGVzcGFjZSh0ZXh0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKCkge1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVEb3VibGVRdW90ZSkge1xuICAgICAgaSsrO1xuICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgd2hpbGUgKGkgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQoaSkgIT09IGNvZGVEb3VibGVRdW90ZSkge1xuICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlQmFja3NsYXNoKSB7XG4gICAgICAgICAgY29uc3QgY2hhciA9IHRleHRbaSArIDFdO1xuICAgICAgICAgIGNvbnN0IGVzY2FwZUNoYXIgPSBlc2NhcGVDaGFyYWN0ZXJzW2NoYXJdO1xuICAgICAgICAgIGlmIChlc2NhcGVDaGFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVDaGFyO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ3UnKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXgodGV4dC5jaGFyQ29kZUF0KGkgKyAyKSkgJiYgaXNIZXgodGV4dC5jaGFyQ29kZUF0KGkgKyAzKSkgJiYgaXNIZXgodGV4dC5jaGFyQ29kZUF0KGkgKyA0KSkgJiYgaXNIZXgodGV4dC5jaGFyQ29kZUF0KGkgKyA1KSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQodGV4dC5zbGljZShpICsgMiwgaSArIDYpLCAxNikpO1xuICAgICAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvd0ludmFsaWRVbmljb2RlQ2hhcmFjdGVyKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0ludmFsaWRFc2NhcGVDaGFyYWN0ZXIoaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc1ZhbGlkU3RyaW5nQ2hhcmFjdGVyKHRleHQuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0W2ldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0ludmFsaWRDaGFyYWN0ZXIodGV4dFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIGV4cGVjdEVuZE9mU3RyaW5nKCk7XG4gICAgICBpKys7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwYXJzZU51bWVyaWMoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVNaW51cykge1xuICAgICAgaSsrO1xuICAgICAgZXhwZWN0RGlnaXQoc3RhcnQpO1xuICAgIH1cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlWmVybykge1xuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoaXNOb25aZXJvRGlnaXQodGV4dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVEb3QpIHtcbiAgICAgIGkrKztcbiAgICAgIGV4cGVjdERpZ2l0KHN0YXJ0KTtcbiAgICAgIHdoaWxlIChpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlTG93ZXJjYXNlRSB8fCB0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVVcHBlcmNhc2VFKSB7XG4gICAgICBpKys7XG4gICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlTWludXMgfHwgdGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlUGx1cykge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBleHBlY3REaWdpdChzdGFydCk7XG4gICAgICB3aGlsZSAoaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPiBzdGFydCkge1xuICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyKHRleHQuc2xpY2Uoc3RhcnQsIGkpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZWF0Q29tbWEoKSB7XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNvbW1hKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYENvbW1hICcsJyBleHBlY3RlZCBhZnRlciB2YWx1ZSAke2dvdEF0KCl9YCk7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICBmdW5jdGlvbiBlYXRDb2xvbigpIHtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpICE9PSBjb2RlQ29sb24pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgQ29sb24gJzonIGV4cGVjdGVkIGFmdGVyIHByb3BlcnR5IG5hbWUgJHtnb3RBdCgpfWApO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgZnVuY3Rpb24gZXhwZWN0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBKU09OIHZhbHVlIGV4cGVjdGVkICR7Z290QXQoKX1gKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXhwZWN0QXJyYXlJdGVtKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgQXJyYXkgaXRlbSBleHBlY3RlZCAke2dvdEF0KCl9YCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV4cGVjdEVuZE9mSW5wdXQoKSB7XG4gICAgaWYgKGkgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCBlbmQgb2YgaW5wdXQgJHtnb3RBdCgpfWApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHBlY3REaWdpdChzdGFydCkge1xuICAgIGlmICghaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICBjb25zdCBudW1Tb0ZhciA9IHRleHQuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIG51bWJlciAnJHtudW1Tb0Zhcn0nLCBleHBlY3RpbmcgYSBkaWdpdCAke2dvdEF0KCl9YCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV4cGVjdEVuZE9mU3RyaW5nKCkge1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgIT09IGNvZGVEb3VibGVRdW90ZSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFbmQgb2Ygc3RyaW5nICdcIicgZXhwZWN0ZWQgJHtnb3RBdCgpfWApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0aHJvd09iamVjdEtleUV4cGVjdGVkKCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgUXVvdGVkIG9iamVjdCBrZXkgZXhwZWN0ZWQgJHtnb3RBdCgpfWApO1xuICB9XG4gIGZ1bmN0aW9uIHRocm93RHVwbGljYXRlS2V5KGtleSwgcG9zKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBEdXBsaWNhdGUga2V5ICcke2tleX0nIGVuY291bnRlcmVkIGF0IHBvc2l0aW9uICR7cG9zfWApO1xuICB9XG4gIGZ1bmN0aW9uIHRocm93T2JqZWN0S2V5T3JFbmRFeHBlY3RlZCgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFF1b3RlZCBvYmplY3Qga2V5IG9yIGVuZCBvZiBvYmplY3QgJ30nIGV4cGVjdGVkICR7Z290QXQoKX1gKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd0FycmF5SXRlbU9yRW5kRXhwZWN0ZWQoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBBcnJheSBpdGVtIG9yIGVuZCBvZiBhcnJheSAnXScgZXhwZWN0ZWQgJHtnb3RBdCgpfWApO1xuICB9XG4gIGZ1bmN0aW9uIHRocm93SW52YWxpZENoYXJhY3RlcihjaGFyKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIGNoYXJhY3RlciAnJHtjaGFyfScgJHtwb3MoKX1gKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd0ludmFsaWRFc2NhcGVDaGFyYWN0ZXIoc3RhcnQpIHtcbiAgICBjb25zdCBjaGFycyA9IHRleHQuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgMik7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIGVzY2FwZSBjaGFyYWN0ZXIgJyR7Y2hhcnN9JyAke3BvcygpfWApO1xuICB9XG4gIGZ1bmN0aW9uIHRocm93T2JqZWN0VmFsdWVFeHBlY3RlZCgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE9iamVjdCB2YWx1ZSBleHBlY3RlZCBhZnRlciAnOicgJHtwb3MoKX1gKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd0ludmFsaWRVbmljb2RlQ2hhcmFjdGVyKHN0YXJ0KSB7XG4gICAgY29uc3QgY2hhcnMgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBzdGFydCArIDYpO1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCB1bmljb2RlIGNoYXJhY3RlciAnJHtjaGFyc30nICR7cG9zKCl9YCk7XG4gIH1cblxuICAvLyB6ZXJvIGJhc2VkIGNoYXJhY3RlciBwb3NpdGlvblxuICBmdW5jdGlvbiBwb3MoKSB7XG4gICAgcmV0dXJuIGBhdCBwb3NpdGlvbiAke2l9YDtcbiAgfVxuICBmdW5jdGlvbiBnb3QoKSB7XG4gICAgcmV0dXJuIGkgPCB0ZXh0Lmxlbmd0aCA/IGBidXQgZ290ICcke3RleHRbaV19J2AgOiAnYnV0IHJlYWNoZWQgZW5kIG9mIGlucHV0JztcbiAgfVxuICBmdW5jdGlvbiBnb3RBdCgpIHtcbiAgICByZXR1cm4gZ290KCkgKyAnICcgKyBwb3MoKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IGNvZGVTcGFjZSB8fCBjb2RlID09PSBjb2RlTmV3bGluZSB8fCBjb2RlID09PSBjb2RlVGFiIHx8IGNvZGUgPT09IGNvZGVSZXR1cm47XG59XG5mdW5jdGlvbiBpc0hleChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IGNvZGVaZXJvICYmIGNvZGUgPD0gY29kZU5pbmUgfHwgY29kZSA+PSBjb2RlVXBwZXJjYXNlQSAmJiBjb2RlIDw9IGNvZGVVcHBlcmNhc2VGIHx8IGNvZGUgPj0gY29kZUxvd2VyY2FzZUEgJiYgY29kZSA8PSBjb2RlTG93ZXJjYXNlRjtcbn1cbmZ1bmN0aW9uIGlzRGlnaXQoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSBjb2RlWmVybyAmJiBjb2RlIDw9IGNvZGVOaW5lO1xufVxuZnVuY3Rpb24gaXNOb25aZXJvRGlnaXQoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSBjb2RlT25lICYmIGNvZGUgPD0gY29kZU5pbmU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFN0cmluZ0NoYXJhY3Rlcihjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDB4MjAgJiYgY29kZSA8PSAweDEwZmZmZjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoaXRlbSwgaW5kZXgpID0+IGlzRGVlcEVxdWFsKGl0ZW0sIGJbaW5kZXhdKSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGEpICYmIGlzT2JqZWN0KGIpKSB7XG4gICAgY29uc3Qga2V5cyA9IFsuLi5uZXcgU2V0KFsuLi5PYmplY3Qua2V5cyhhKSwgLi4uT2JqZWN0LmtleXMoYildKV07XG4gICAgcmV0dXJuIGtleXMuZXZlcnkoa2V5ID0+IGlzRGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbi8vIG1hcCB3aXRoIGFsbCBlc2NhcGUgY2hhcmFjdGVyc1xuY29uc3QgZXNjYXBlQ2hhcmFjdGVycyA9IHtcbiAgJ1wiJzogJ1wiJyxcbiAgJ1xcXFwnOiAnXFxcXCcsXG4gICcvJzogJy8nLFxuICBiOiAnXFxiJyxcbiAgZjogJ1xcZicsXG4gIG46ICdcXG4nLFxuICByOiAnXFxyJyxcbiAgdDogJ1xcdCdcbiAgLy8gbm90ZSB0aGF0IFxcdSBpcyBoYW5kbGVkIHNlcGFyYXRlbHkgaW4gcGFyc2VTdHJpbmcoKVxufTtcbmNvbnN0IGNvZGVCYWNrc2xhc2ggPSAweDVjOyAvLyBcIlxcXCJcbmNvbnN0IGNvZGVPcGVuaW5nQnJhY2UgPSAweDdiOyAvLyBcIntcIlxuY29uc3QgY29kZUNsb3NpbmdCcmFjZSA9IDB4N2Q7IC8vIFwifVwiXG5jb25zdCBjb2RlT3BlbmluZ0JyYWNrZXQgPSAweDViOyAvLyBcIltcIlxuY29uc3QgY29kZUNsb3NpbmdCcmFja2V0ID0gMHg1ZDsgLy8gXCJdXCJcbmNvbnN0IGNvZGVTcGFjZSA9IDB4MjA7IC8vIFwiIFwiXG5jb25zdCBjb2RlTmV3bGluZSA9IDB4YTsgLy8gXCJcXG5cIlxuY29uc3QgY29kZVRhYiA9IDB4OTsgLy8gXCJcXHRcIlxuY29uc3QgY29kZVJldHVybiA9IDB4ZDsgLy8gXCJcXHJcIlxuY29uc3QgY29kZURvdWJsZVF1b3RlID0gMHgwMDIyOyAvLyBcIlxuY29uc3QgY29kZVBsdXMgPSAweDJiOyAvLyBcIitcIlxuY29uc3QgY29kZU1pbnVzID0gMHgyZDsgLy8gXCItXCJcbmNvbnN0IGNvZGVaZXJvID0gMHgzMDtcbmNvbnN0IGNvZGVPbmUgPSAweDMxO1xuY29uc3QgY29kZU5pbmUgPSAweDM5O1xuY29uc3QgY29kZUNvbW1hID0gMHgyYzsgLy8gXCIsXCJcbmNvbnN0IGNvZGVEb3QgPSAweDJlOyAvLyBcIi5cIiAoZG90LCBwZXJpb2QpXG5jb25zdCBjb2RlQ29sb24gPSAweDNhOyAvLyBcIjpcIlxuZXhwb3J0IGNvbnN0IGNvZGVVcHBlcmNhc2VBID0gMHg0MTsgLy8gXCJBXCJcbmV4cG9ydCBjb25zdCBjb2RlTG93ZXJjYXNlQSA9IDB4NjE7IC8vIFwiYVwiXG5leHBvcnQgY29uc3QgY29kZVVwcGVyY2FzZUUgPSAweDQ1OyAvLyBcIkVcIlxuZXhwb3J0IGNvbnN0IGNvZGVMb3dlcmNhc2VFID0gMHg2NTsgLy8gXCJlXCJcbmV4cG9ydCBjb25zdCBjb2RlVXBwZXJjYXNlRiA9IDB4NDY7IC8vIFwiRlwiXG5leHBvcnQgY29uc3QgY29kZUxvd2VyY2FzZUYgPSAweDY2OyAvLyBcImZcIlxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UuanMubWFwIl0sIm5hbWVzIjpbInBhcnNlTG9zc2xlc3NOdW1iZXIiLCJyZXZpdmUiLCJwYXJzZSIsInRleHQiLCJyZXZpdmVyIiwicGFyc2VOdW1iZXIiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJpIiwidmFsdWUiLCJwYXJzZVZhbHVlIiwiZXhwZWN0VmFsdWUiLCJleHBlY3RFbmRPZklucHV0IiwicGFyc2VPYmplY3QiLCJjaGFyQ29kZUF0IiwiY29kZU9wZW5pbmdCcmFjZSIsInNraXBXaGl0ZXNwYWNlIiwib2JqZWN0IiwiaW5pdGlhbCIsImNvZGVDbG9zaW5nQnJhY2UiLCJlYXRDb21tYSIsInN0YXJ0Iiwia2V5IiwicGFyc2VTdHJpbmciLCJ0aHJvd09iamVjdEtleUV4cGVjdGVkIiwiZWF0Q29sb24iLCJ0aHJvd09iamVjdFZhbHVlRXhwZWN0ZWQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpc0RlZXBFcXVhbCIsInRocm93RHVwbGljYXRlS2V5IiwidGhyb3dPYmplY3RLZXlPckVuZEV4cGVjdGVkIiwicGFyc2VBcnJheSIsImNvZGVPcGVuaW5nQnJhY2tldCIsImFycmF5IiwiY29kZUNsb3NpbmdCcmFja2V0IiwiZXhwZWN0QXJyYXlJdGVtIiwicHVzaCIsInRocm93QXJyYXlJdGVtT3JFbmRFeHBlY3RlZCIsInBhcnNlTnVtZXJpYyIsInBhcnNlS2V5d29yZCIsIm5hbWUiLCJzbGljZSIsImlzV2hpdGVzcGFjZSIsImNvZGVEb3VibGVRdW90ZSIsInJlc3VsdCIsImNvZGVCYWNrc2xhc2giLCJjaGFyIiwiZXNjYXBlQ2hhciIsImVzY2FwZUNoYXJhY3RlcnMiLCJpc0hleCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInBhcnNlSW50IiwidGhyb3dJbnZhbGlkVW5pY29kZUNoYXJhY3RlciIsInRocm93SW52YWxpZEVzY2FwZUNoYXJhY3RlciIsImlzVmFsaWRTdHJpbmdDaGFyYWN0ZXIiLCJ0aHJvd0ludmFsaWRDaGFyYWN0ZXIiLCJleHBlY3RFbmRPZlN0cmluZyIsImNvZGVNaW51cyIsImV4cGVjdERpZ2l0IiwiY29kZVplcm8iLCJpc05vblplcm9EaWdpdCIsImlzRGlnaXQiLCJjb2RlRG90IiwiY29kZUxvd2VyY2FzZUUiLCJjb2RlVXBwZXJjYXNlRSIsImNvZGVQbHVzIiwiY29kZUNvbW1hIiwiU3ludGF4RXJyb3IiLCJnb3RBdCIsImNvZGVDb2xvbiIsIm51bVNvRmFyIiwicG9zIiwiY2hhcnMiLCJnb3QiLCJjb2RlIiwiY29kZVNwYWNlIiwiY29kZU5ld2xpbmUiLCJjb2RlVGFiIiwiY29kZVJldHVybiIsImNvZGVOaW5lIiwiY29kZVVwcGVyY2FzZUEiLCJjb2RlVXBwZXJjYXNlRiIsImNvZGVMb3dlcmNhc2VBIiwiY29kZUxvd2VyY2FzZUYiLCJjb2RlT25lIiwiYSIsImIiLCJBcnJheSIsImlzQXJyYXkiLCJldmVyeSIsIml0ZW0iLCJpbmRleCIsImlzT2JqZWN0Iiwia2V5cyIsIlNldCIsImYiLCJuIiwiciIsInQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/revive.js":
/*!****************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/revive.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   revive: () => (/* binding */ revive)\n/* harmony export */ });\n/* harmony import */ var _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LosslessNumber.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/LosslessNumber.js\");\n\n/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param json   A JSON Object, Array, or value\n * @param reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n */ function revive(json, reviver) {\n    return reviveValue({\n        \"\": json\n    }, \"\", json, reviver);\n}\n/**\n * Revive a value\n */ function reviveValue(context, key, value, reviver) {\n    if (Array.isArray(value)) {\n        return reviver.call(context, key, reviveArray(value, reviver));\n    } else if (value && typeof value === \"object\" && !(0,_LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__.isLosslessNumber)(value)) {\n        // note the special case for LosslessNumber,\n        // we don't want to iterate over the internals of a LosslessNumber\n        return reviver.call(context, key, reviveObject(value, reviver));\n    } else {\n        return reviver.call(context, key, value);\n    }\n}\n/**\n * Revive the properties of an object\n */ function reviveObject(object, reviver) {\n    Object.keys(object).forEach((key)=>{\n        const value = reviveValue(object, key, object[key], reviver);\n        if (value !== undefined) {\n            object[key] = value;\n        } else {\n            delete object[key];\n        }\n    });\n    return object;\n}\n/**\n * Revive the properties of an Array\n */ function reviveArray(array, reviver) {\n    for(let i = 0; i < array.length; i++){\n        array[i] = reviveValue(array, i + \"\", array[i], reviver);\n    }\n    return array;\n} //# sourceMappingURL=revive.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9yZXZpdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUQ7QUFDdkQ7Ozs7Ozs7OztDQVNDLEdBQ00sU0FBU0MsT0FBT0MsSUFBSSxFQUFFQyxPQUFPO0lBQ2xDLE9BQU9DLFlBQVk7UUFDakIsSUFBSUY7SUFDTixHQUFHLElBQUlBLE1BQU1DO0FBQ2Y7QUFFQTs7Q0FFQyxHQUNELFNBQVNDLFlBQVlDLE9BQU8sRUFBRUMsR0FBRyxFQUFFQyxLQUFLLEVBQUVKLE9BQU87SUFDL0MsSUFBSUssTUFBTUMsT0FBTyxDQUFDRixRQUFRO1FBQ3hCLE9BQU9KLFFBQVFPLElBQUksQ0FBQ0wsU0FBU0MsS0FBS0ssWUFBWUosT0FBT0o7SUFDdkQsT0FBTyxJQUFJSSxTQUFTLE9BQU9BLFVBQVUsWUFBWSxDQUFDUCxvRUFBZ0JBLENBQUNPLFFBQVE7UUFDekUsNENBQTRDO1FBQzVDLGtFQUFrRTtRQUNsRSxPQUFPSixRQUFRTyxJQUFJLENBQUNMLFNBQVNDLEtBQUtNLGFBQWFMLE9BQU9KO0lBQ3hELE9BQU87UUFDTCxPQUFPQSxRQUFRTyxJQUFJLENBQUNMLFNBQVNDLEtBQUtDO0lBQ3BDO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELFNBQVNLLGFBQWFDLE1BQU0sRUFBRVYsT0FBTztJQUNuQ1csT0FBT0MsSUFBSSxDQUFDRixRQUFRRyxPQUFPLENBQUNWLENBQUFBO1FBQzFCLE1BQU1DLFFBQVFILFlBQVlTLFFBQVFQLEtBQUtPLE1BQU0sQ0FBQ1AsSUFBSSxFQUFFSDtRQUNwRCxJQUFJSSxVQUFVVSxXQUFXO1lBQ3ZCSixNQUFNLENBQUNQLElBQUksR0FBR0M7UUFDaEIsT0FBTztZQUNMLE9BQU9NLE1BQU0sQ0FBQ1AsSUFBSTtRQUNwQjtJQUNGO0lBQ0EsT0FBT087QUFDVDtBQUVBOztDQUVDLEdBQ0QsU0FBU0YsWUFBWU8sS0FBSyxFQUFFZixPQUFPO0lBQ2pDLElBQUssSUFBSWdCLElBQUksR0FBR0EsSUFBSUQsTUFBTUUsTUFBTSxFQUFFRCxJQUFLO1FBQ3JDRCxLQUFLLENBQUNDLEVBQUUsR0FBR2YsWUFBWWMsT0FBT0MsSUFBSSxJQUFJRCxLQUFLLENBQUNDLEVBQUUsRUFBRWhCO0lBQ2xEO0lBQ0EsT0FBT2U7QUFDVCxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWRhcHAvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9yZXZpdmUuanM/ZmEyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0xvc3NsZXNzTnVtYmVyIH0gZnJvbSAnLi9Mb3NzbGVzc051bWJlci5qcyc7XG4vKipcbiAqIFJldml2ZSBhIGpzb24gb2JqZWN0LlxuICogQXBwbGllcyB0aGUgcmV2aXZlciBmdW5jdGlvbiByZWN1cnNpdmVseSBvbiBhbGwgdmFsdWVzIGluIHRoZSBKU09OIG9iamVjdC5cbiAqIEBwYXJhbSBqc29uICAgQSBKU09OIE9iamVjdCwgQXJyYXksIG9yIHZhbHVlXG4gKiBAcGFyYW0gcmV2aXZlclxuICogICAgICAgICAgICAgIEEgcmV2aXZlciBmdW5jdGlvbiBpbnZva2VkIHdpdGggYXJndW1lbnRzIGBrZXlgIGFuZCBgdmFsdWVgLFxuICogICAgICAgICAgICAgIHdoaWNoIG11c3QgcmV0dXJuIGEgcmVwbGFjZW1lbnQgdmFsdWUuIFRoZSBmdW5jdGlvbiBjb250ZXh0XG4gKiAgICAgICAgICAgICAgKGB0aGlzYCkgaXMgdGhlIE9iamVjdCBvciBBcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBjdXJyZW50bHlcbiAqICAgICAgICAgICAgICBoYW5kbGVkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV2aXZlKGpzb24sIHJldml2ZXIpIHtcbiAgcmV0dXJuIHJldml2ZVZhbHVlKHtcbiAgICAnJzoganNvblxuICB9LCAnJywganNvbiwgcmV2aXZlcik7XG59XG5cbi8qKlxuICogUmV2aXZlIGEgdmFsdWVcbiAqL1xuZnVuY3Rpb24gcmV2aXZlVmFsdWUoY29udGV4dCwga2V5LCB2YWx1ZSwgcmV2aXZlcikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmV2aXZlci5jYWxsKGNvbnRleHQsIGtleSwgcmV2aXZlQXJyYXkodmFsdWUsIHJldml2ZXIpKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFpc0xvc3NsZXNzTnVtYmVyKHZhbHVlKSkge1xuICAgIC8vIG5vdGUgdGhlIHNwZWNpYWwgY2FzZSBmb3IgTG9zc2xlc3NOdW1iZXIsXG4gICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBpdGVyYXRlIG92ZXIgdGhlIGludGVybmFscyBvZiBhIExvc3NsZXNzTnVtYmVyXG4gICAgcmV0dXJuIHJldml2ZXIuY2FsbChjb250ZXh0LCBrZXksIHJldml2ZU9iamVjdCh2YWx1ZSwgcmV2aXZlcikpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXZpdmVyLmNhbGwoY29udGV4dCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXZpdmUgdGhlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHJldml2ZU9iamVjdChvYmplY3QsIHJldml2ZXIpIHtcbiAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSByZXZpdmVWYWx1ZShvYmplY3QsIGtleSwgb2JqZWN0W2tleV0sIHJldml2ZXIpO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgb2JqZWN0W2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBSZXZpdmUgdGhlIHByb3BlcnRpZXMgb2YgYW4gQXJyYXlcbiAqL1xuZnVuY3Rpb24gcmV2aXZlQXJyYXkoYXJyYXksIHJldml2ZXIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gcmV2aXZlVmFsdWUoYXJyYXksIGkgKyAnJywgYXJyYXlbaV0sIHJldml2ZXIpO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldml2ZS5qcy5tYXAiXSwibmFtZXMiOlsiaXNMb3NzbGVzc051bWJlciIsInJldml2ZSIsImpzb24iLCJyZXZpdmVyIiwicmV2aXZlVmFsdWUiLCJjb250ZXh0Iiwia2V5IiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJjYWxsIiwicmV2aXZlQXJyYXkiLCJyZXZpdmVPYmplY3QiLCJvYmplY3QiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInVuZGVmaW5lZCIsImFycmF5IiwiaSIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/revive.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/reviveDate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/reviveDate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reviveDate: () => (/* binding */ reviveDate)\n/* harmony export */ });\n/**\n * Revive a string containing an ISO 8601 date string into a JavaScript `Date` object\n */ function reviveDate(key, value) {\n    return typeof value === \"string\" && isoDateRegex.test(value) ? new Date(value) : value;\n}\n// Matches strings like \"2022-08-25T09:39:19.288Z\"\nconst isoDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/; //# sourceMappingURL=reviveDate.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9yZXZpdmVEYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Q0FFQyxHQUNNLFNBQVNBLFdBQVdDLEdBQUcsRUFBRUMsS0FBSztJQUNuQyxPQUFPLE9BQU9BLFVBQVUsWUFBWUMsYUFBYUMsSUFBSSxDQUFDRixTQUFTLElBQUlHLEtBQUtILFNBQVNBO0FBQ25GO0FBRUEsa0RBQWtEO0FBQ2xELE1BQU1DLGVBQWUsaURBQ3JCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWRhcHAvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9yZXZpdmVEYXRlLmpzP2ZiYjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXZpdmUgYSBzdHJpbmcgY29udGFpbmluZyBhbiBJU08gODYwMSBkYXRlIHN0cmluZyBpbnRvIGEgSmF2YVNjcmlwdCBgRGF0ZWAgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXZpdmVEYXRlKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgaXNvRGF0ZVJlZ2V4LnRlc3QodmFsdWUpID8gbmV3IERhdGUodmFsdWUpIDogdmFsdWU7XG59XG5cbi8vIE1hdGNoZXMgc3RyaW5ncyBsaWtlIFwiMjAyMi0wOC0yNVQwOTozOToxOS4yODhaXCJcbmNvbnN0IGlzb0RhdGVSZWdleCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn1cXC5cXGR7M31aJC87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXZpdmVEYXRlLmpzLm1hcCJdLCJuYW1lcyI6WyJyZXZpdmVEYXRlIiwia2V5IiwidmFsdWUiLCJpc29EYXRlUmVnZXgiLCJ0ZXN0IiwiRGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/reviveDate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/stringify.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/stringify.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js\");\n\n/**\n * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,\n * optionally replacing values if a replacer function is specified, or\n * optionally including only the specified properties if a replacer array is specified.\n *\n * @param value\n * The value to convert to a JSON string.\n *\n * @param [replacer]\n * A function that alters the behavior of the stringification process,\n * or an array of String and Number objects that serve as a whitelist for\n * selecting the properties of the value object to be included in the JSON string.\n * If this value is null or not provided, all properties of the object are\n * included in the resulting JSON string.\n *\n * @param [space]\n * A String or Number object that's used to insert white space into the output\n * JSON string for readability purposes. If this is a Number, it indicates the\n * number of space characters to use as white space; this number is capped at 10\n * if it's larger than that. Values less than 1 indicate that no space should be\n * used. If this is a String, the string (or the first 10 characters of the string,\n * if it's longer than that) is used as white space. If this parameter is not\n * provided (or is null), no white space is used.\n *\n * @param [numberStringifiers]\n * An optional list with additional number stringifiers, for example to serialize\n * a BigNumber. The output of the function must be valid stringified JSON.\n * When `undefined` is returned, the property will be deleted from the object.\n * The difference with using a `replacer` is that the output of a `replacer`\n * must be JSON and will be stringified afterwards, whereas the output of the\n * `numberStringifiers` is already stringified JSON.\n *\n * @returns Returns the string representation of the JSON object.\n */ function stringify(value, replacer, space, numberStringifiers) {\n    const resolvedSpace = resolveSpace(space);\n    const replacedValue = typeof replacer === \"function\" ? replacer.call({\n        \"\": value\n    }, \"\", value) : value;\n    return stringifyValue(replacedValue, \"\");\n    /**\n   * Stringify a value\n   */ function stringifyValue(value, indent) {\n        if (Array.isArray(numberStringifiers)) {\n            const stringifier = numberStringifiers.find((item)=>item.test(value));\n            if (stringifier) {\n                const str = stringifier.stringify(value);\n                if (typeof str !== \"string\" || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(str)) {\n                    throw new Error(\"Invalid JSON number: \" + \"output of a number stringifier must be a string containing a JSON number \" + `(output: ${str})`);\n                }\n                return str;\n            }\n        }\n        // boolean, null, number, string, or date\n        if (typeof value === \"boolean\" || typeof value === \"number\" || typeof value === \"string\" || value === null || value instanceof Date || value instanceof Boolean || value instanceof Number || value instanceof String) {\n            return JSON.stringify(value);\n        }\n        // lossless number, the secret ingredient :)\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        if (value && value.isLosslessNumber) {\n            return value.toString();\n        }\n        // BigInt\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        // Array\n        if (Array.isArray(value)) {\n            return stringifyArray(value, indent);\n        }\n        // Object (test lastly!)\n        if (value && typeof value === \"object\") {\n            return stringifyObject(value, indent);\n        }\n        return undefined;\n    }\n    /**\n   * Stringify an array\n   */ function stringifyArray(array, indent) {\n        if (array.length === 0) {\n            return \"[]\";\n        }\n        const childIndent = resolvedSpace ? indent + resolvedSpace : undefined;\n        let str = resolvedSpace ? \"[\\n\" : \"[\";\n        for(let i = 0; i < array.length; i++){\n            const item = typeof replacer === \"function\" ? replacer.call(array, String(i), array[i]) : array[i];\n            if (resolvedSpace) {\n                str += childIndent;\n            }\n            if (typeof item !== \"undefined\" && typeof item !== \"function\") {\n                str += stringifyValue(item, childIndent);\n            } else {\n                str += \"null\";\n            }\n            if (i < array.length - 1) {\n                str += resolvedSpace ? \",\\n\" : \",\";\n            }\n        }\n        str += resolvedSpace ? \"\\n\" + indent + \"]\" : \"]\";\n        return str;\n    }\n    /**\n   * Stringify an object\n   */ function stringifyObject(object, indent) {\n        if (typeof object.toJSON === \"function\") {\n            return stringify(object.toJSON(), replacer, space, undefined);\n        }\n        const keys = Array.isArray(replacer) ? replacer.map(String) : Object.keys(object);\n        if (keys.length === 0) {\n            return \"{}\";\n        }\n        const childIndent = resolvedSpace ? indent + resolvedSpace : undefined;\n        let first = true;\n        let str = resolvedSpace ? \"{\\n\" : \"{\";\n        keys.forEach((key)=>{\n            const value = typeof replacer === \"function\" ? replacer.call(object, key, object[key]) : object[key];\n            if (includeProperty(key, value)) {\n                if (first) {\n                    first = false;\n                } else {\n                    str += resolvedSpace ? \",\\n\" : \",\";\n                }\n                const keyStr = JSON.stringify(key);\n                str += resolvedSpace ? childIndent + keyStr + \": \" : keyStr + \":\";\n                str += stringifyValue(value, childIndent);\n            }\n        });\n        str += resolvedSpace ? \"\\n\" + indent + \"}\" : \"}\";\n        return str;\n    }\n    /**\n   * Test whether to include a property in a stringified object or not.\n   */ function includeProperty(key, value) {\n        return typeof value !== \"undefined\" && typeof value !== \"function\" && typeof value !== \"symbol\";\n    }\n}\n/**\n * Resolve a JSON stringify space:\n * replace a number with a string containing that number of spaces\n */ function resolveSpace(space) {\n    if (typeof space === \"number\") {\n        return \" \".repeat(space);\n    }\n    if (typeof space === \"string\" && space !== \"\") {\n        return space;\n    }\n    return undefined;\n} //# sourceMappingURL=stringify.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9zdHJpbmdpZnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFFdEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWlDQyxHQUNNLFNBQVNDLFVBQVVDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLGtCQUFrQjtJQUNsRSxNQUFNQyxnQkFBZ0JDLGFBQWFIO0lBQ25DLE1BQU1JLGdCQUFnQixPQUFPTCxhQUFhLGFBQWFBLFNBQVNNLElBQUksQ0FBQztRQUNuRSxJQUFJUDtJQUNOLEdBQUcsSUFBSUEsU0FBU0E7SUFDaEIsT0FBT1EsZUFBZUYsZUFBZTtJQUVyQzs7R0FFQyxHQUNELFNBQVNFLGVBQWVSLEtBQUssRUFBRVMsTUFBTTtRQUNuQyxJQUFJQyxNQUFNQyxPQUFPLENBQUNSLHFCQUFxQjtZQUNyQyxNQUFNUyxjQUFjVCxtQkFBbUJVLElBQUksQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS0MsSUFBSSxDQUFDZjtZQUM5RCxJQUFJWSxhQUFhO2dCQUNmLE1BQU1JLE1BQU1KLFlBQVliLFNBQVMsQ0FBQ0M7Z0JBQ2xDLElBQUksT0FBT2dCLFFBQVEsWUFBWSxDQUFDbEIsbURBQVFBLENBQUNrQixNQUFNO29CQUM3QyxNQUFNLElBQUlDLE1BQU0sMEJBQTBCLDhFQUE4RSxDQUFDLFNBQVMsRUFBRUQsSUFBSSxDQUFDLENBQUM7Z0JBQzVJO2dCQUNBLE9BQU9BO1lBQ1Q7UUFDRjtRQUVBLHlDQUF5QztRQUN6QyxJQUFJLE9BQU9oQixVQUFVLGFBQWEsT0FBT0EsVUFBVSxZQUFZLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRQSxpQkFBaUJrQixRQUFRbEIsaUJBQWlCbUIsV0FBV25CLGlCQUFpQm9CLFVBQVVwQixpQkFBaUJxQixRQUFRO1lBQ3JOLE9BQU9DLEtBQUt2QixTQUFTLENBQUNDO1FBQ3hCO1FBRUEsNENBQTRDO1FBQzVDLDZEQUE2RDtRQUM3RCxhQUFhO1FBQ2IsSUFBSUEsU0FBU0EsTUFBTXVCLGdCQUFnQixFQUFFO1lBQ25DLE9BQU92QixNQUFNd0IsUUFBUTtRQUN2QjtRQUVBLFNBQVM7UUFDVCxJQUFJLE9BQU94QixVQUFVLFVBQVU7WUFDN0IsT0FBT0EsTUFBTXdCLFFBQVE7UUFDdkI7UUFFQSxRQUFRO1FBQ1IsSUFBSWQsTUFBTUMsT0FBTyxDQUFDWCxRQUFRO1lBQ3hCLE9BQU95QixlQUFlekIsT0FBT1M7UUFDL0I7UUFFQSx3QkFBd0I7UUFDeEIsSUFBSVQsU0FBUyxPQUFPQSxVQUFVLFVBQVU7WUFDdEMsT0FBTzBCLGdCQUFnQjFCLE9BQU9TO1FBQ2hDO1FBQ0EsT0FBT2tCO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELFNBQVNGLGVBQWVHLEtBQUssRUFBRW5CLE1BQU07UUFDbkMsSUFBSW1CLE1BQU1DLE1BQU0sS0FBSyxHQUFHO1lBQ3RCLE9BQU87UUFDVDtRQUNBLE1BQU1DLGNBQWMxQixnQkFBZ0JLLFNBQVNMLGdCQUFnQnVCO1FBQzdELElBQUlYLE1BQU1aLGdCQUFnQixRQUFRO1FBQ2xDLElBQUssSUFBSTJCLElBQUksR0FBR0EsSUFBSUgsTUFBTUMsTUFBTSxFQUFFRSxJQUFLO1lBQ3JDLE1BQU1qQixPQUFPLE9BQU9iLGFBQWEsYUFBYUEsU0FBU00sSUFBSSxDQUFDcUIsT0FBT1AsT0FBT1UsSUFBSUgsS0FBSyxDQUFDRyxFQUFFLElBQUlILEtBQUssQ0FBQ0csRUFBRTtZQUNsRyxJQUFJM0IsZUFBZTtnQkFDakJZLE9BQU9jO1lBQ1Q7WUFDQSxJQUFJLE9BQU9oQixTQUFTLGVBQWUsT0FBT0EsU0FBUyxZQUFZO2dCQUM3REUsT0FBT1IsZUFBZU0sTUFBTWdCO1lBQzlCLE9BQU87Z0JBQ0xkLE9BQU87WUFDVDtZQUNBLElBQUllLElBQUlILE1BQU1DLE1BQU0sR0FBRyxHQUFHO2dCQUN4QmIsT0FBT1osZ0JBQWdCLFFBQVE7WUFDakM7UUFDRjtRQUNBWSxPQUFPWixnQkFBZ0IsT0FBT0ssU0FBUyxNQUFNO1FBQzdDLE9BQU9PO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELFNBQVNVLGdCQUFnQk0sTUFBTSxFQUFFdkIsTUFBTTtRQUNyQyxJQUFJLE9BQU91QixPQUFPQyxNQUFNLEtBQUssWUFBWTtZQUN2QyxPQUFPbEMsVUFBVWlDLE9BQU9DLE1BQU0sSUFBSWhDLFVBQVVDLE9BQU95QjtRQUNyRDtRQUNBLE1BQU1PLE9BQU94QixNQUFNQyxPQUFPLENBQUNWLFlBQVlBLFNBQVNrQyxHQUFHLENBQUNkLFVBQVVlLE9BQU9GLElBQUksQ0FBQ0Y7UUFDMUUsSUFBSUUsS0FBS0wsTUFBTSxLQUFLLEdBQUc7WUFDckIsT0FBTztRQUNUO1FBQ0EsTUFBTUMsY0FBYzFCLGdCQUFnQkssU0FBU0wsZ0JBQWdCdUI7UUFDN0QsSUFBSVUsUUFBUTtRQUNaLElBQUlyQixNQUFNWixnQkFBZ0IsUUFBUTtRQUNsQzhCLEtBQUtJLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDWCxNQUFNdkMsUUFBUSxPQUFPQyxhQUFhLGFBQWFBLFNBQVNNLElBQUksQ0FBQ3lCLFFBQVFPLEtBQUtQLE1BQU0sQ0FBQ08sSUFBSSxJQUFJUCxNQUFNLENBQUNPLElBQUk7WUFDcEcsSUFBSUMsZ0JBQWdCRCxLQUFLdkMsUUFBUTtnQkFDL0IsSUFBSXFDLE9BQU87b0JBQ1RBLFFBQVE7Z0JBQ1YsT0FBTztvQkFDTHJCLE9BQU9aLGdCQUFnQixRQUFRO2dCQUNqQztnQkFDQSxNQUFNcUMsU0FBU25CLEtBQUt2QixTQUFTLENBQUN3QztnQkFDOUJ2QixPQUFPWixnQkFBZ0IwQixjQUFjVyxTQUFTLE9BQU9BLFNBQVM7Z0JBQzlEekIsT0FBT1IsZUFBZVIsT0FBTzhCO1lBQy9CO1FBQ0Y7UUFDQWQsT0FBT1osZ0JBQWdCLE9BQU9LLFNBQVMsTUFBTTtRQUM3QyxPQUFPTztJQUNUO0lBRUE7O0dBRUMsR0FDRCxTQUFTd0IsZ0JBQWdCRCxHQUFHLEVBQUV2QyxLQUFLO1FBQ2pDLE9BQU8sT0FBT0EsVUFBVSxlQUFlLE9BQU9BLFVBQVUsY0FBYyxPQUFPQSxVQUFVO0lBQ3pGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTSyxhQUFhSCxLQUFLO0lBQ3pCLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzdCLE9BQU8sSUFBSXdDLE1BQU0sQ0FBQ3hDO0lBQ3BCO0lBQ0EsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsSUFBSTtRQUM3QyxPQUFPQTtJQUNUO0lBQ0EsT0FBT3lCO0FBQ1QsRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1kYXBwLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vc3RyaW5naWZ5LmpzPzM0M2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLyoqXG4gKiBUaGUgTG9zc2xlc3NKU09OLnN0cmluZ2lmeSgpIG1ldGhvZCBjb252ZXJ0cyBhIEphdmFTY3JpcHQgdmFsdWUgdG8gYSBKU09OIHN0cmluZyxcbiAqIG9wdGlvbmFsbHkgcmVwbGFjaW5nIHZhbHVlcyBpZiBhIHJlcGxhY2VyIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgb3JcbiAqIG9wdGlvbmFsbHkgaW5jbHVkaW5nIG9ubHkgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzIGlmIGEgcmVwbGFjZXIgYXJyYXkgaXMgc3BlY2lmaWVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICogVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBKU09OIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gW3JlcGxhY2VyXVxuICogQSBmdW5jdGlvbiB0aGF0IGFsdGVycyB0aGUgYmVoYXZpb3Igb2YgdGhlIHN0cmluZ2lmaWNhdGlvbiBwcm9jZXNzLFxuICogb3IgYW4gYXJyYXkgb2YgU3RyaW5nIGFuZCBOdW1iZXIgb2JqZWN0cyB0aGF0IHNlcnZlIGFzIGEgd2hpdGVsaXN0IGZvclxuICogc2VsZWN0aW5nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB2YWx1ZSBvYmplY3QgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIEpTT04gc3RyaW5nLlxuICogSWYgdGhpcyB2YWx1ZSBpcyBudWxsIG9yIG5vdCBwcm92aWRlZCwgYWxsIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBhcmVcbiAqIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgSlNPTiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIFtzcGFjZV1cbiAqIEEgU3RyaW5nIG9yIE51bWJlciBvYmplY3QgdGhhdCdzIHVzZWQgdG8gaW5zZXJ0IHdoaXRlIHNwYWNlIGludG8gdGhlIG91dHB1dFxuICogSlNPTiBzdHJpbmcgZm9yIHJlYWRhYmlsaXR5IHB1cnBvc2VzLiBJZiB0aGlzIGlzIGEgTnVtYmVyLCBpdCBpbmRpY2F0ZXMgdGhlXG4gKiBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycyB0byB1c2UgYXMgd2hpdGUgc3BhY2U7IHRoaXMgbnVtYmVyIGlzIGNhcHBlZCBhdCAxMFxuICogaWYgaXQncyBsYXJnZXIgdGhhbiB0aGF0LiBWYWx1ZXMgbGVzcyB0aGFuIDEgaW5kaWNhdGUgdGhhdCBubyBzcGFjZSBzaG91bGQgYmVcbiAqIHVzZWQuIElmIHRoaXMgaXMgYSBTdHJpbmcsIHRoZSBzdHJpbmcgKG9yIHRoZSBmaXJzdCAxMCBjaGFyYWN0ZXJzIG9mIHRoZSBzdHJpbmcsXG4gKiBpZiBpdCdzIGxvbmdlciB0aGFuIHRoYXQpIGlzIHVzZWQgYXMgd2hpdGUgc3BhY2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIG5vdFxuICogcHJvdmlkZWQgKG9yIGlzIG51bGwpLCBubyB3aGl0ZSBzcGFjZSBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBbbnVtYmVyU3RyaW5naWZpZXJzXVxuICogQW4gb3B0aW9uYWwgbGlzdCB3aXRoIGFkZGl0aW9uYWwgbnVtYmVyIHN0cmluZ2lmaWVycywgZm9yIGV4YW1wbGUgdG8gc2VyaWFsaXplXG4gKiBhIEJpZ051bWJlci4gVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb24gbXVzdCBiZSB2YWxpZCBzdHJpbmdpZmllZCBKU09OLlxuICogV2hlbiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCwgdGhlIHByb3BlcnR5IHdpbGwgYmUgZGVsZXRlZCBmcm9tIHRoZSBvYmplY3QuXG4gKiBUaGUgZGlmZmVyZW5jZSB3aXRoIHVzaW5nIGEgYHJlcGxhY2VyYCBpcyB0aGF0IHRoZSBvdXRwdXQgb2YgYSBgcmVwbGFjZXJgXG4gKiBtdXN0IGJlIEpTT04gYW5kIHdpbGwgYmUgc3RyaW5naWZpZWQgYWZ0ZXJ3YXJkcywgd2hlcmVhcyB0aGUgb3V0cHV0IG9mIHRoZVxuICogYG51bWJlclN0cmluZ2lmaWVyc2AgaXMgYWxyZWFkeSBzdHJpbmdpZmllZCBKU09OLlxuICpcbiAqIEByZXR1cm5zIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgSlNPTiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgbnVtYmVyU3RyaW5naWZpZXJzKSB7XG4gIGNvbnN0IHJlc29sdmVkU3BhY2UgPSByZXNvbHZlU3BhY2Uoc3BhY2UpO1xuICBjb25zdCByZXBsYWNlZFZhbHVlID0gdHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nID8gcmVwbGFjZXIuY2FsbCh7XG4gICAgJyc6IHZhbHVlXG4gIH0sICcnLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgcmV0dXJuIHN0cmluZ2lmeVZhbHVlKHJlcGxhY2VkVmFsdWUsICcnKTtcblxuICAvKipcbiAgICogU3RyaW5naWZ5IGEgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVZhbHVlKHZhbHVlLCBpbmRlbnQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShudW1iZXJTdHJpbmdpZmllcnMpKSB7XG4gICAgICBjb25zdCBzdHJpbmdpZmllciA9IG51bWJlclN0cmluZ2lmaWVycy5maW5kKGl0ZW0gPT4gaXRlbS50ZXN0KHZhbHVlKSk7XG4gICAgICBpZiAoc3RyaW5naWZpZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gc3RyaW5naWZpZXIuc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8ICFpc051bWJlcihzdHIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gbnVtYmVyOiAnICsgJ291dHB1dCBvZiBhIG51bWJlciBzdHJpbmdpZmllciBtdXN0IGJlIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBKU09OIG51bWJlciAnICsgYChvdXRwdXQ6ICR7c3RyfSlgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJvb2xlYW4sIG51bGwsIG51bWJlciwgc3RyaW5nLCBvciBkYXRlXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIGxvc3NsZXNzIG51bWJlciwgdGhlIHNlY3JldCBpbmdyZWRpZW50IDopXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuaXNMb3NzbGVzc051bWJlcikge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLy8gQmlnSW50XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIC8vIEFycmF5XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUsIGluZGVudCk7XG4gICAgfVxuXG4gICAgLy8gT2JqZWN0ICh0ZXN0IGxhc3RseSEpXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUsIGluZGVudCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU3RyaW5naWZ5IGFuIGFycmF5XG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdpZnlBcnJheShhcnJheSwgaW5kZW50KSB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICdbXSc7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkSW5kZW50ID0gcmVzb2x2ZWRTcGFjZSA/IGluZGVudCArIHJlc29sdmVkU3BhY2UgOiB1bmRlZmluZWQ7XG4gICAgbGV0IHN0ciA9IHJlc29sdmVkU3BhY2UgPyAnW1xcbicgOiAnWyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJyA/IHJlcGxhY2VyLmNhbGwoYXJyYXksIFN0cmluZyhpKSwgYXJyYXlbaV0pIDogYXJyYXlbaV07XG4gICAgICBpZiAocmVzb2x2ZWRTcGFjZSkge1xuICAgICAgICBzdHIgKz0gY2hpbGRJbmRlbnQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpdGVtICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0ciArPSBzdHJpbmdpZnlWYWx1ZShpdGVtLCBjaGlsZEluZGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gJ251bGwnO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCBhcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHN0ciArPSByZXNvbHZlZFNwYWNlID8gJyxcXG4nIDogJywnO1xuICAgICAgfVxuICAgIH1cbiAgICBzdHIgKz0gcmVzb2x2ZWRTcGFjZSA/ICdcXG4nICsgaW5kZW50ICsgJ10nIDogJ10nO1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICAvKipcbiAgICogU3RyaW5naWZ5IGFuIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0KG9iamVjdCwgaW5kZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5KG9iamVjdC50b0pTT04oKSwgcmVwbGFjZXIsIHNwYWNlLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShyZXBsYWNlcikgPyByZXBsYWNlci5tYXAoU3RyaW5nKSA6IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJ3t9JztcbiAgICB9XG4gICAgY29uc3QgY2hpbGRJbmRlbnQgPSByZXNvbHZlZFNwYWNlID8gaW5kZW50ICsgcmVzb2x2ZWRTcGFjZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGxldCBzdHIgPSByZXNvbHZlZFNwYWNlID8gJ3tcXG4nIDogJ3snO1xuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgPyByZXBsYWNlci5jYWxsKG9iamVjdCwga2V5LCBvYmplY3Rba2V5XSkgOiBvYmplY3Rba2V5XTtcbiAgICAgIGlmIChpbmNsdWRlUHJvcGVydHkoa2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgKz0gcmVzb2x2ZWRTcGFjZSA/ICcsXFxuJyA6ICcsJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgICAgICBzdHIgKz0gcmVzb2x2ZWRTcGFjZSA/IGNoaWxkSW5kZW50ICsga2V5U3RyICsgJzogJyA6IGtleVN0ciArICc6JztcbiAgICAgICAgc3RyICs9IHN0cmluZ2lmeVZhbHVlKHZhbHVlLCBjaGlsZEluZGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc3RyICs9IHJlc29sdmVkU3BhY2UgPyAnXFxuJyArIGluZGVudCArICd9JyA6ICd9JztcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB0byBpbmNsdWRlIGEgcHJvcGVydHkgaW4gYSBzdHJpbmdpZmllZCBvYmplY3Qgb3Igbm90LlxuICAgKi9cbiAgZnVuY3Rpb24gaW5jbHVkZVByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJztcbiAgfVxufVxuXG4vKipcbiAqIFJlc29sdmUgYSBKU09OIHN0cmluZ2lmeSBzcGFjZTpcbiAqIHJlcGxhY2UgYSBudW1iZXIgd2l0aCBhIHN0cmluZyBjb250YWluaW5nIHRoYXQgbnVtYmVyIG9mIHNwYWNlc1xuICovXG5mdW5jdGlvbiByZXNvbHZlU3BhY2Uoc3BhY2UpIHtcbiAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gJyAnLnJlcGVhdChzcGFjZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycgJiYgc3BhY2UgIT09ICcnKSB7XG4gICAgcmV0dXJuIHNwYWNlO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdpZnkuanMubWFwIl0sIm5hbWVzIjpbImlzTnVtYmVyIiwic3RyaW5naWZ5IiwidmFsdWUiLCJyZXBsYWNlciIsInNwYWNlIiwibnVtYmVyU3RyaW5naWZpZXJzIiwicmVzb2x2ZWRTcGFjZSIsInJlc29sdmVTcGFjZSIsInJlcGxhY2VkVmFsdWUiLCJjYWxsIiwic3RyaW5naWZ5VmFsdWUiLCJpbmRlbnQiLCJBcnJheSIsImlzQXJyYXkiLCJzdHJpbmdpZmllciIsImZpbmQiLCJpdGVtIiwidGVzdCIsInN0ciIsIkVycm9yIiwiRGF0ZSIsIkJvb2xlYW4iLCJOdW1iZXIiLCJTdHJpbmciLCJKU09OIiwiaXNMb3NzbGVzc051bWJlciIsInRvU3RyaW5nIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJ1bmRlZmluZWQiLCJhcnJheSIsImxlbmd0aCIsImNoaWxkSW5kZW50IiwiaSIsIm9iamVjdCIsInRvSlNPTiIsImtleXMiLCJtYXAiLCJPYmplY3QiLCJmaXJzdCIsImZvckVhY2giLCJrZXkiLCJpbmNsdWRlUHJvcGVydHkiLCJrZXlTdHIiLCJyZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/stringify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/types.js":
/*!***************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/types.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVUsQ0FDVixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1kYXBwLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vdHlwZXMuanM/ZGU1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnsafeNumberReason: () => (/* binding */ UnsafeNumberReason),\n/* harmony export */   extractSignificantDigits: () => (/* binding */ extractSignificantDigits),\n/* harmony export */   getUnsafeNumberReason: () => (/* binding */ getUnsafeNumberReason),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isSafeNumber: () => (/* binding */ isSafeNumber),\n/* harmony export */   toSafeNumberOrThrow: () => (/* binding */ toSafeNumberOrThrow)\n/* harmony export */ });\n/**\n * Test whether a string contains an integer number\n */ function isInteger(value) {\n    return INTEGER_REGEX.test(value);\n}\nconst INTEGER_REGEX = /^-?[0-9]+$/;\n/**\n * Test whether a string contains a number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n */ function isNumber(value) {\n    return NUMBER_REGEX.test(value);\n}\nconst NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/;\n/**\n * Test whether a string can be safely represented with a number\n * without information loss.\n *\n * When approx is true, floating point numbers that lose a few digits but\n * are still approximately equal in value are considered safe too.\n * Integer numbers must still be exactly equal.\n */ function isSafeNumber(value, config) {\n    const num = parseFloat(value);\n    const str = String(num);\n    const v = extractSignificantDigits(value);\n    const s = extractSignificantDigits(str);\n    if (v === s) {\n        return true;\n    }\n    if (config?.approx === true) {\n        // A value is approximately equal when:\n        // 1. it is a floating point number, not an integer\n        // 2. it has at least 14 digits\n        // 3. the first 14 digits are equal\n        const requiredDigits = 14;\n        if (!isInteger(value) && s.length >= requiredDigits && v.startsWith(s.substring(0, requiredDigits))) {\n            return true;\n        }\n    }\n    return false;\n}\nlet UnsafeNumberReason = /*#__PURE__*/ function(UnsafeNumberReason) {\n    UnsafeNumberReason[\"underflow\"] = \"underflow\";\n    UnsafeNumberReason[\"overflow\"] = \"overflow\";\n    UnsafeNumberReason[\"truncate_integer\"] = \"truncate_integer\";\n    UnsafeNumberReason[\"truncate_float\"] = \"truncate_float\";\n    return UnsafeNumberReason;\n}({});\n/**\n * When the provided value is an unsafe number, describe what the reason is:\n * overflow, underflow, truncate_integer, or truncate_float.\n * Returns undefined when the value is safe.\n */ function getUnsafeNumberReason(value) {\n    if (isSafeNumber(value, {\n        approx: false\n    })) {\n        return undefined;\n    }\n    if (isInteger(value)) {\n        return UnsafeNumberReason.truncate_integer;\n    }\n    const num = parseFloat(value);\n    if (!isFinite(num)) {\n        return UnsafeNumberReason.overflow;\n    }\n    if (num === 0) {\n        return UnsafeNumberReason.underflow;\n    }\n    return UnsafeNumberReason.truncate_float;\n}\n/**\n * Convert a string into a number when it is safe to do so.\n * Throws an error otherwise, explaining the reason.\n */ function toSafeNumberOrThrow(value, config) {\n    const number = parseFloat(value);\n    const unsafeReason = getUnsafeNumberReason(value);\n    if (config?.approx === true ? unsafeReason && unsafeReason !== UnsafeNumberReason.truncate_float : unsafeReason) {\n        const unsafeReasonText = unsafeReason?.replace(/_\\w+$/, \"\");\n        throw new Error(\"Cannot safely convert to number: \" + `the value '${value}' would ${unsafeReasonText} and become ${number}`);\n    }\n    return number;\n}\n/**\n * Get the significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.003400' returns '34'\n *   '120.5e+30' returns '1205'\n **/ function extractSignificantDigits(value) {\n    return value// from \"-0.250e+30\" to \"-0.250\"\n    .replace(EXPONENTIAL_PART_REGEX, \"\")// from \"-0.250\" to \"-0250\"\n    .replace(DOT_REGEX, \"\")// from \"-0250\" to \"-025\"\n    .replace(TRAILING_ZEROS_REGEX, \"\")// from \"-025\" to \"25\"\n    .replace(LEADING_MINUS_AND_ZEROS_REGEX, \"\");\n}\nconst EXPONENTIAL_PART_REGEX = /[eE][+-]?\\d+$/;\nconst LEADING_MINUS_AND_ZEROS_REGEX = /^-?(0*)?/;\nconst DOT_REGEX = /\\./;\nconst TRAILING_ZEROS_REGEX = /0+$/; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDTSxTQUFTQSxVQUFVQyxLQUFLO0lBQzdCLE9BQU9DLGNBQWNDLElBQUksQ0FBQ0Y7QUFDNUI7QUFDQSxNQUFNQyxnQkFBZ0I7QUFFdEI7OztDQUdDLEdBQ00sU0FBU0UsU0FBU0gsS0FBSztJQUM1QixPQUFPSSxhQUFhRixJQUFJLENBQUNGO0FBQzNCO0FBQ0EsTUFBTUksZUFBZTtBQUVyQjs7Ozs7OztDQU9DLEdBQ00sU0FBU0MsYUFBYUwsS0FBSyxFQUFFTSxNQUFNO0lBQ3hDLE1BQU1DLE1BQU1DLFdBQVdSO0lBQ3ZCLE1BQU1TLE1BQU1DLE9BQU9IO0lBQ25CLE1BQU1JLElBQUlDLHlCQUF5Qlo7SUFDbkMsTUFBTWEsSUFBSUQseUJBQXlCSDtJQUNuQyxJQUFJRSxNQUFNRSxHQUFHO1FBQ1gsT0FBTztJQUNUO0lBQ0EsSUFBSVAsUUFBUVEsV0FBVyxNQUFNO1FBQzNCLHVDQUF1QztRQUN2QyxtREFBbUQ7UUFDbkQsK0JBQStCO1FBQy9CLG1DQUFtQztRQUNuQyxNQUFNQyxpQkFBaUI7UUFDdkIsSUFBSSxDQUFDaEIsVUFBVUMsVUFBVWEsRUFBRUcsTUFBTSxJQUFJRCxrQkFBa0JKLEVBQUVNLFVBQVUsQ0FBQ0osRUFBRUssU0FBUyxDQUFDLEdBQUdILGtCQUFrQjtZQUNuRyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNPLElBQUlJLHFCQUFxQixXQUFXLEdBQUUsU0FBVUEsa0JBQWtCO0lBQ3ZFQSxrQkFBa0IsQ0FBQyxZQUFZLEdBQUc7SUFDbENBLGtCQUFrQixDQUFDLFdBQVcsR0FBRztJQUNqQ0Esa0JBQWtCLENBQUMsbUJBQW1CLEdBQUc7SUFDekNBLGtCQUFrQixDQUFDLGlCQUFpQixHQUFHO0lBQ3ZDLE9BQU9BO0FBQ1QsRUFBRSxDQUFDLEdBQUc7QUFFTjs7OztDQUlDLEdBQ00sU0FBU0Msc0JBQXNCcEIsS0FBSztJQUN6QyxJQUFJSyxhQUFhTCxPQUFPO1FBQ3RCYyxRQUFRO0lBQ1YsSUFBSTtRQUNGLE9BQU9PO0lBQ1Q7SUFDQSxJQUFJdEIsVUFBVUMsUUFBUTtRQUNwQixPQUFPbUIsbUJBQW1CRyxnQkFBZ0I7SUFDNUM7SUFDQSxNQUFNZixNQUFNQyxXQUFXUjtJQUN2QixJQUFJLENBQUN1QixTQUFTaEIsTUFBTTtRQUNsQixPQUFPWSxtQkFBbUJLLFFBQVE7SUFDcEM7SUFDQSxJQUFJakIsUUFBUSxHQUFHO1FBQ2IsT0FBT1ksbUJBQW1CTSxTQUFTO0lBQ3JDO0lBQ0EsT0FBT04sbUJBQW1CTyxjQUFjO0FBQzFDO0FBRUE7OztDQUdDLEdBQ00sU0FBU0Msb0JBQW9CM0IsS0FBSyxFQUFFTSxNQUFNO0lBQy9DLE1BQU1zQixTQUFTcEIsV0FBV1I7SUFDMUIsTUFBTTZCLGVBQWVULHNCQUFzQnBCO0lBQzNDLElBQUlNLFFBQVFRLFdBQVcsT0FBT2UsZ0JBQWdCQSxpQkFBaUJWLG1CQUFtQk8sY0FBYyxHQUFHRyxjQUFjO1FBQy9HLE1BQU1DLG1CQUFtQkQsY0FBY0UsUUFBUSxTQUFTO1FBQ3hELE1BQU0sSUFBSUMsTUFBTSxzQ0FBc0MsQ0FBQyxXQUFXLEVBQUVoQyxNQUFNLFFBQVEsRUFBRThCLGlCQUFpQixZQUFZLEVBQUVGLE9BQU8sQ0FBQztJQUM3SDtJQUNBLE9BQU9BO0FBQ1Q7QUFFQTs7Ozs7Ozs7RUFRRSxHQUNLLFNBQVNoQix5QkFBeUJaLEtBQUs7SUFDNUMsT0FBT0EsS0FDUCxnQ0FBZ0M7S0FDL0IrQixPQUFPLENBQUNFLHdCQUF3QixHQUVqQywyQkFBMkI7S0FDMUJGLE9BQU8sQ0FBQ0csV0FBVyxHQUVwQix5QkFBeUI7S0FDeEJILE9BQU8sQ0FBQ0ksc0JBQXNCLEdBRS9CLHNCQUFzQjtLQUNyQkosT0FBTyxDQUFDSywrQkFBK0I7QUFDMUM7QUFDQSxNQUFNSCx5QkFBeUI7QUFDL0IsTUFBTUcsZ0NBQWdDO0FBQ3RDLE1BQU1GLFlBQVk7QUFDbEIsTUFBTUMsdUJBQXVCLE9BQzdCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWRhcHAvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS91dGlscy5qcz83YTE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdCB3aGV0aGVyIGEgc3RyaW5nIGNvbnRhaW5zIGFuIGludGVnZXIgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgcmV0dXJuIElOVEVHRVJfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5jb25zdCBJTlRFR0VSX1JFR0VYID0gL14tP1swLTldKyQvO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIHN0cmluZyBjb250YWlucyBhIG51bWJlclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM0MDcxNy9qc29uLW51bWJlcnMtcmVndWxhci1leHByZXNzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gTlVNQkVSX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuY29uc3QgTlVNQkVSX1JFR0VYID0gL14tPyg/OjB8WzEtOV1cXGQqKSg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPyQvO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIHN0cmluZyBjYW4gYmUgc2FmZWx5IHJlcHJlc2VudGVkIHdpdGggYSBudW1iZXJcbiAqIHdpdGhvdXQgaW5mb3JtYXRpb24gbG9zcy5cbiAqXG4gKiBXaGVuIGFwcHJveCBpcyB0cnVlLCBmbG9hdGluZyBwb2ludCBudW1iZXJzIHRoYXQgbG9zZSBhIGZldyBkaWdpdHMgYnV0XG4gKiBhcmUgc3RpbGwgYXBwcm94aW1hdGVseSBlcXVhbCBpbiB2YWx1ZSBhcmUgY29uc2lkZXJlZCBzYWZlIHRvby5cbiAqIEludGVnZXIgbnVtYmVycyBtdXN0IHN0aWxsIGJlIGV4YWN0bHkgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmVOdW1iZXIodmFsdWUsIGNvbmZpZykge1xuICBjb25zdCBudW0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgY29uc3Qgc3RyID0gU3RyaW5nKG51bSk7XG4gIGNvbnN0IHYgPSBleHRyYWN0U2lnbmlmaWNhbnREaWdpdHModmFsdWUpO1xuICBjb25zdCBzID0gZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKHN0cik7XG4gIGlmICh2ID09PSBzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNvbmZpZz8uYXBwcm94ID09PSB0cnVlKSB7XG4gICAgLy8gQSB2YWx1ZSBpcyBhcHByb3hpbWF0ZWx5IGVxdWFsIHdoZW46XG4gICAgLy8gMS4gaXQgaXMgYSBmbG9hdGluZyBwb2ludCBudW1iZXIsIG5vdCBhbiBpbnRlZ2VyXG4gICAgLy8gMi4gaXQgaGFzIGF0IGxlYXN0IDE0IGRpZ2l0c1xuICAgIC8vIDMuIHRoZSBmaXJzdCAxNCBkaWdpdHMgYXJlIGVxdWFsXG4gICAgY29uc3QgcmVxdWlyZWREaWdpdHMgPSAxNDtcbiAgICBpZiAoIWlzSW50ZWdlcih2YWx1ZSkgJiYgcy5sZW5ndGggPj0gcmVxdWlyZWREaWdpdHMgJiYgdi5zdGFydHNXaXRoKHMuc3Vic3RyaW5nKDAsIHJlcXVpcmVkRGlnaXRzKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgbGV0IFVuc2FmZU51bWJlclJlYXNvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoVW5zYWZlTnVtYmVyUmVhc29uKSB7XG4gIFVuc2FmZU51bWJlclJlYXNvbltcInVuZGVyZmxvd1wiXSA9IFwidW5kZXJmbG93XCI7XG4gIFVuc2FmZU51bWJlclJlYXNvbltcIm92ZXJmbG93XCJdID0gXCJvdmVyZmxvd1wiO1xuICBVbnNhZmVOdW1iZXJSZWFzb25bXCJ0cnVuY2F0ZV9pbnRlZ2VyXCJdID0gXCJ0cnVuY2F0ZV9pbnRlZ2VyXCI7XG4gIFVuc2FmZU51bWJlclJlYXNvbltcInRydW5jYXRlX2Zsb2F0XCJdID0gXCJ0cnVuY2F0ZV9mbG9hdFwiO1xuICByZXR1cm4gVW5zYWZlTnVtYmVyUmVhc29uO1xufSh7fSk7XG5cbi8qKlxuICogV2hlbiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYW4gdW5zYWZlIG51bWJlciwgZGVzY3JpYmUgd2hhdCB0aGUgcmVhc29uIGlzOlxuICogb3ZlcmZsb3csIHVuZGVyZmxvdywgdHJ1bmNhdGVfaW50ZWdlciwgb3IgdHJ1bmNhdGVfZmxvYXQuXG4gKiBSZXR1cm5zIHVuZGVmaW5lZCB3aGVuIHRoZSB2YWx1ZSBpcyBzYWZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5zYWZlTnVtYmVyUmVhc29uKHZhbHVlKSB7XG4gIGlmIChpc1NhZmVOdW1iZXIodmFsdWUsIHtcbiAgICBhcHByb3g6IGZhbHNlXG4gIH0pKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgIHJldHVybiBVbnNhZmVOdW1iZXJSZWFzb24udHJ1bmNhdGVfaW50ZWdlcjtcbiAgfVxuICBjb25zdCBudW0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgaWYgKCFpc0Zpbml0ZShudW0pKSB7XG4gICAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi5vdmVyZmxvdztcbiAgfVxuICBpZiAobnVtID09PSAwKSB7XG4gICAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi51bmRlcmZsb3c7XG4gIH1cbiAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi50cnVuY2F0ZV9mbG9hdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGludG8gYSBudW1iZXIgd2hlbiBpdCBpcyBzYWZlIHRvIGRvIHNvLlxuICogVGhyb3dzIGFuIGVycm9yIG90aGVyd2lzZSwgZXhwbGFpbmluZyB0aGUgcmVhc29uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TYWZlTnVtYmVyT3JUaHJvdyh2YWx1ZSwgY29uZmlnKSB7XG4gIGNvbnN0IG51bWJlciA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICBjb25zdCB1bnNhZmVSZWFzb24gPSBnZXRVbnNhZmVOdW1iZXJSZWFzb24odmFsdWUpO1xuICBpZiAoY29uZmlnPy5hcHByb3ggPT09IHRydWUgPyB1bnNhZmVSZWFzb24gJiYgdW5zYWZlUmVhc29uICE9PSBVbnNhZmVOdW1iZXJSZWFzb24udHJ1bmNhdGVfZmxvYXQgOiB1bnNhZmVSZWFzb24pIHtcbiAgICBjb25zdCB1bnNhZmVSZWFzb25UZXh0ID0gdW5zYWZlUmVhc29uPy5yZXBsYWNlKC9fXFx3KyQvLCAnJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2FmZWx5IGNvbnZlcnQgdG8gbnVtYmVyOiAnICsgYHRoZSB2YWx1ZSAnJHt2YWx1ZX0nIHdvdWxkICR7dW5zYWZlUmVhc29uVGV4dH0gYW5kIGJlY29tZSAke251bWJlcn1gKTtcbiAgfVxuICByZXR1cm4gbnVtYmVyO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2lnbmlmaWNhbnQgZGlnaXRzIG9mIGEgbnVtYmVyLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICogICAnMi4zNCcgcmV0dXJucyAnMjM0J1xuICogICAnLTc3JyByZXR1cm5zICc3NydcbiAqICAgJzAuMDAzNDAwJyByZXR1cm5zICczNCdcbiAqICAgJzEyMC41ZSszMCcgcmV0dXJucyAnMTIwNSdcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0U2lnbmlmaWNhbnREaWdpdHModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlXG4gIC8vIGZyb20gXCItMC4yNTBlKzMwXCIgdG8gXCItMC4yNTBcIlxuICAucmVwbGFjZShFWFBPTkVOVElBTF9QQVJUX1JFR0VYLCAnJylcblxuICAvLyBmcm9tIFwiLTAuMjUwXCIgdG8gXCItMDI1MFwiXG4gIC5yZXBsYWNlKERPVF9SRUdFWCwgJycpXG5cbiAgLy8gZnJvbSBcIi0wMjUwXCIgdG8gXCItMDI1XCJcbiAgLnJlcGxhY2UoVFJBSUxJTkdfWkVST1NfUkVHRVgsICcnKVxuXG4gIC8vIGZyb20gXCItMDI1XCIgdG8gXCIyNVwiXG4gIC5yZXBsYWNlKExFQURJTkdfTUlOVVNfQU5EX1pFUk9TX1JFR0VYLCAnJyk7XG59XG5jb25zdCBFWFBPTkVOVElBTF9QQVJUX1JFR0VYID0gL1tlRV1bKy1dP1xcZCskLztcbmNvbnN0IExFQURJTkdfTUlOVVNfQU5EX1pFUk9TX1JFR0VYID0gL14tPygwKik/LztcbmNvbnN0IERPVF9SRUdFWCA9IC9cXC4vO1xuY29uc3QgVFJBSUxJTkdfWkVST1NfUkVHRVggPSAvMCskLztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJpc0ludGVnZXIiLCJ2YWx1ZSIsIklOVEVHRVJfUkVHRVgiLCJ0ZXN0IiwiaXNOdW1iZXIiLCJOVU1CRVJfUkVHRVgiLCJpc1NhZmVOdW1iZXIiLCJjb25maWciLCJudW0iLCJwYXJzZUZsb2F0Iiwic3RyIiwiU3RyaW5nIiwidiIsImV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyIsInMiLCJhcHByb3giLCJyZXF1aXJlZERpZ2l0cyIsImxlbmd0aCIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJVbnNhZmVOdW1iZXJSZWFzb24iLCJnZXRVbnNhZmVOdW1iZXJSZWFzb24iLCJ1bmRlZmluZWQiLCJ0cnVuY2F0ZV9pbnRlZ2VyIiwiaXNGaW5pdGUiLCJvdmVyZmxvdyIsInVuZGVyZmxvdyIsInRydW5jYXRlX2Zsb2F0IiwidG9TYWZlTnVtYmVyT3JUaHJvdyIsIm51bWJlciIsInVuc2FmZVJlYXNvbiIsInVuc2FmZVJlYXNvblRleHQiLCJyZXBsYWNlIiwiRXJyb3IiLCJFWFBPTkVOVElBTF9QQVJUX1JFR0VYIiwiRE9UX1JFR0VYIiwiVFJBSUxJTkdfWkVST1NfUkVHRVgiLCJMRUFESU5HX01JTlVTX0FORF9aRVJPU19SRUdFWCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js\n");

/***/ })

};
;