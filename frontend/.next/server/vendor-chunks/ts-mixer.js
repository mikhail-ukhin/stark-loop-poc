"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ts-mixer";
exports.ids = ["vendor-chunks/ts-mixer"];
exports.modules = {

/***/ "(ssr)/./node_modules/ts-mixer/dist/esm/index.js":
/*!*************************************************!*\
  !*** ./node_modules/ts-mixer/dist/esm/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mixin: () => (/* binding */ Mixin),\n/* harmony export */   decorate: () => (/* binding */ decorate),\n/* harmony export */   hasMixin: () => (/* binding */ hasMixin),\n/* harmony export */   mix: () => (/* binding */ mix),\n/* harmony export */   settings: () => (/* binding */ settings)\n/* harmony export */ });\n/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */ const copyProps = (dest, src, exclude = [])=>{\n    const props = Object.getOwnPropertyDescriptors(src);\n    for (let prop of exclude)delete props[prop];\n    Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */ const protoChain = (obj, currentChain = [\n    obj\n])=>{\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null) return currentChain;\n    return protoChain(proto, [\n        ...currentChain,\n        proto\n    ]);\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */ const nearestCommonProto = (...objs)=>{\n    if (objs.length === 0) return undefined;\n    let commonProto = undefined;\n    const protoChains = objs.map((obj)=>protoChain(obj));\n    while(protoChains.every((protoChain)=>protoChain.length > 0)){\n        const protos = protoChains.map((protoChain)=>protoChain.pop());\n        const potentialCommonProto = protos[0];\n        if (protos.every((proto)=>proto === potentialCommonProto)) commonProto = potentialCommonProto;\n        else break;\n    }\n    return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */ const hardMixProtos = (ingredients, constructor, exclude = [])=>{\n    var _a;\n    const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;\n    const mixedProto = Object.create(base);\n    // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n    // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n    // when they will already be accessible via prototype access.\n    const visitedProtos = protoChain(base);\n    for (let prototype of ingredients){\n        let protos = protoChain(prototype);\n        // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n        for(let i = protos.length - 1; i >= 0; i--){\n            let newProto = protos[i];\n            if (visitedProtos.indexOf(newProto) === -1) {\n                copyProps(mixedProto, newProto, [\n                    \"constructor\",\n                    ...exclude\n                ]);\n                visitedProtos.push(newProto);\n            }\n        }\n    }\n    mixedProto.constructor = constructor;\n    return mixedProto;\n};\nconst unique = (arr)=>arr.filter((e, i)=>arr.indexOf(e) == i);\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */ const getIngredientWithProp = (prop, ingredients)=>{\n    const protoChains = ingredients.map((ingredient)=>protoChain(ingredient));\n    // since we search breadth-first, we need to keep track of our depth in the prototype chains\n    let protoDepth = 0;\n    // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n    // prototype chains has an object at this depth\n    let protosAreLeftToSearch = true;\n    while(protosAreLeftToSearch){\n        // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n        protosAreLeftToSearch = false;\n        // scan through the ingredients right to left\n        for(let i = ingredients.length - 1; i >= 0; i--){\n            const searchTarget = protoChains[i][protoDepth];\n            if (searchTarget !== undefined && searchTarget !== null) {\n                // if we find something, this is proof that this horizontal slice potentially more objects to search\n                protosAreLeftToSearch = true;\n                // eureka, we found it\n                if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n                    return protoChains[i][0];\n                }\n            }\n        }\n        protoDepth++;\n    }\n    return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */ const proxyMix = (ingredients, prototype = Object.prototype)=>new Proxy({}, {\n        getPrototypeOf () {\n            return prototype;\n        },\n        setPrototypeOf () {\n            throw Error(\"Cannot set prototype of Proxies created by ts-mixer\");\n        },\n        getOwnPropertyDescriptor (_, prop) {\n            return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n        },\n        defineProperty () {\n            throw new Error(\"Cannot define new properties on Proxies created by ts-mixer\");\n        },\n        has (_, prop) {\n            return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n        },\n        get (_, prop) {\n            return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n        },\n        set (_, prop, val) {\n            const ingredientWithProp = getIngredientWithProp(prop, ingredients);\n            if (ingredientWithProp === undefined) throw new Error(\"Cannot set new properties on Proxies created by ts-mixer\");\n            ingredientWithProp[prop] = val;\n            return true;\n        },\n        deleteProperty () {\n            throw new Error(\"Cannot delete properties on Proxies created by ts-mixer\");\n        },\n        ownKeys () {\n            return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr)=>curr.concat(prev.filter((key)=>curr.indexOf(key) < 0)));\n        }\n    });\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */ const softMixProtos = (ingredients, constructor)=>proxyMix([\n        ...ingredients,\n        {\n            constructor\n        }\n    ]);\nconst settings = {\n    initFunction: null,\n    staticsStrategy: \"copy\",\n    prototypeStrategy: \"copy\",\n    decoratorInheritance: \"deep\"\n};\n// Keeps track of constituent classes for every mixin class created by ts-mixer.\nconst mixins = new WeakMap();\nconst getMixinsForClass = (clazz)=>mixins.get(clazz);\nconst registerMixins = (mixedClass, constituents)=>mixins.set(mixedClass, constituents);\nconst hasMixin = (instance, mixin)=>{\n    if (instance instanceof mixin) return true;\n    const constructor = instance.constructor;\n    const visited = new Set();\n    let frontier = new Set();\n    frontier.add(constructor);\n    while(frontier.size > 0){\n        // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n        if (frontier.has(mixin)) return true;\n        frontier.forEach((item)=>visited.add(item));\n        // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n        const newFrontier = new Set();\n        frontier.forEach((item)=>{\n            var _a;\n            const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map((proto)=>proto.constructor).filter((item)=>item !== null);\n            if (itemConstituents) itemConstituents.forEach((constituent)=>{\n                if (!visited.has(constituent) && !frontier.has(constituent)) newFrontier.add(constituent);\n            });\n        });\n        // we have a new frontier, now search again\n        frontier = newFrontier;\n    }\n    // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n    return false;\n};\nconst mergeObjectsOfDecorators = (o1, o2)=>{\n    var _a, _b;\n    const allKeys = unique([\n        ...Object.getOwnPropertyNames(o1),\n        ...Object.getOwnPropertyNames(o2)\n    ]);\n    const mergedObject = {};\n    for (let key of allKeys)mergedObject[key] = unique([\n        ...(_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : [],\n        ...(_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : []\n    ]);\n    return mergedObject;\n};\nconst mergePropertyAndMethodDecorators = (d1, d2)=>{\n    var _a, _b, _c, _d;\n    return {\n        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})\n    };\n};\nconst mergeDecorators = (d1, d2)=>{\n    var _a, _b, _c, _d, _e, _f;\n    return {\n        class: unique([\n            ...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [],\n            ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []\n        ]),\n        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})\n    };\n};\nconst decorators = new Map();\nconst findAllConstituentClasses = (...classes)=>{\n    var _a;\n    const allClasses = new Set();\n    const frontier = new Set([\n        ...classes\n    ]);\n    while(frontier.size > 0){\n        for (let clazz of frontier){\n            const protoChainClasses = protoChain(clazz.prototype).map((proto)=>proto.constructor);\n            const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n            const potentiallyNewClasses = [\n                ...protoChainClasses,\n                ...mixinClasses\n            ];\n            const newClasses = potentiallyNewClasses.filter((c)=>!allClasses.has(c));\n            for (let newClass of newClasses)frontier.add(newClass);\n            allClasses.add(clazz);\n            frontier.delete(clazz);\n        }\n    }\n    return [\n        ...allClasses\n    ];\n};\nconst deepDecoratorSearch = (...classes)=>{\n    const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz)=>decorators.get(clazz)).filter((decorators)=>!!decorators);\n    if (decoratorsForClassChain.length == 0) return {};\n    if (decoratorsForClassChain.length == 1) return decoratorsForClassChain[0];\n    return decoratorsForClassChain.reduce((d1, d2)=>mergeDecorators(d1, d2));\n};\nconst directDecoratorSearch = (...classes)=>{\n    const classDecorators = classes.map((clazz)=>getDecoratorsForClass(clazz));\n    if (classDecorators.length === 0) return {};\n    if (classDecorators.length === 1) return classDecorators[0];\n    return classDecorators.reduce((d1, d2)=>mergeDecorators(d1, d2));\n};\nconst getDecoratorsForClass = (clazz)=>{\n    let decoratorsForClass = decorators.get(clazz);\n    if (!decoratorsForClass) {\n        decoratorsForClass = {};\n        decorators.set(clazz, decoratorsForClass);\n    }\n    return decoratorsForClass;\n};\nconst decorateClass = (decorator)=>(clazz)=>{\n        const decoratorsForClass = getDecoratorsForClass(clazz);\n        let classDecorators = decoratorsForClass.class;\n        if (!classDecorators) {\n            classDecorators = [];\n            decoratorsForClass.class = classDecorators;\n        }\n        classDecorators.push(decorator);\n        return decorator(clazz);\n    };\nconst decorateMember = (decorator)=>(object, key, ...otherArgs)=>{\n        var _a, _b, _c;\n        const decoratorTargetType = typeof object === \"function\" ? \"static\" : \"instance\";\n        const decoratorType = typeof object[key] === \"function\" ? \"method\" : \"property\";\n        const clazz = decoratorTargetType === \"static\" ? object : object.constructor;\n        const decoratorsForClass = getDecoratorsForClass(clazz);\n        const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};\n        decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n        let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};\n        decoratorsForTargetType[decoratorType] = decoratorsForType;\n        let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];\n        decoratorsForType[key] = decoratorsForKey;\n        // @ts-ignore: array is type `A[] | B[]` and item is type `A | B`, so technically a type error, but it's fine\n        decoratorsForKey.push(decorator);\n        // @ts-ignore\n        return decorator(object, key, ...otherArgs);\n    };\nconst decorate = (decorator)=>(...args)=>{\n        if (args.length === 1) return decorateClass(decorator)(args[0]);\n        return decorateMember(decorator)(...args);\n    };\nfunction Mixin(...constructors) {\n    var _a, _b, _c;\n    const prototypes = constructors.map((constructor)=>constructor.prototype);\n    // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n    // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n    // similarly to constructors -- not methods, which simply override each other.\n    const initFunctionName = settings.initFunction;\n    if (initFunctionName !== null) {\n        const initFunctions = prototypes.map((proto)=>proto[initFunctionName]).filter((func)=>typeof func === \"function\");\n        const combinedInitFunction = function(...args) {\n            for (let initFunction of initFunctions)initFunction.apply(this, args);\n        };\n        const extraProto = {\n            [initFunctionName]: combinedInitFunction\n        };\n        prototypes.push(extraProto);\n    }\n    function MixedClass(...args) {\n        for (const constructor of constructors)// @ts-ignore: potentially abstract class\n        copyProps(this, new constructor(...args));\n        if (initFunctionName !== null && typeof this[initFunctionName] === \"function\") this[initFunctionName].apply(this, args);\n    }\n    MixedClass.prototype = settings.prototypeStrategy === \"copy\" ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);\n    Object.setPrototypeOf(MixedClass, settings.staticsStrategy === \"copy\" ? hardMixProtos(constructors, null, [\n        \"prototype\"\n    ]) : proxyMix(constructors, Function.prototype));\n    let DecoratedMixedClass = MixedClass;\n    if (settings.decoratorInheritance !== \"none\") {\n        const classDecorators = settings.decoratorInheritance === \"deep\" ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);\n        for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []){\n            const result = decorator(DecoratedMixedClass);\n            if (result) {\n                DecoratedMixedClass = result;\n            }\n        }\n        applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n        applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n    }\n    registerMixins(DecoratedMixedClass, constructors);\n    return DecoratedMixedClass;\n}\nconst applyPropAndMethodDecorators = (propAndMethodDecorators, target)=>{\n    const propDecorators = propAndMethodDecorators.property;\n    const methodDecorators = propAndMethodDecorators.method;\n    if (propDecorators) for(let key in propDecorators)for (let decorator of propDecorators[key])decorator(target, key);\n    if (methodDecorators) for(let key in methodDecorators)for (let decorator of methodDecorators[key])decorator(target, key, Object.getOwnPropertyDescriptor(target, key));\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */ const mix = (...ingredients)=>(decoratedClass)=>{\n        // @ts-ignore\n        const mixedClass = Mixin(...ingredients.concat([\n            decoratedClass\n        ]));\n        Object.defineProperty(mixedClass, \"name\", {\n            value: decoratedClass.name,\n            writable: false\n        });\n        return mixedClass;\n    };\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHMtbWl4ZXIvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxNQUFNQSxZQUFZLENBQUNDLE1BQU1DLEtBQUtDLFVBQVUsRUFBRTtJQUN0QyxNQUFNQyxRQUFRQyxPQUFPQyx5QkFBeUIsQ0FBQ0o7SUFDL0MsS0FBSyxJQUFJSyxRQUFRSixRQUNiLE9BQU9DLEtBQUssQ0FBQ0csS0FBSztJQUN0QkYsT0FBT0csZ0JBQWdCLENBQUNQLE1BQU1HO0FBQ2xDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUssYUFBYSxDQUFDQyxLQUFLQyxlQUFlO0lBQUNEO0NBQUk7SUFDekMsTUFBTUUsUUFBUVAsT0FBT1EsY0FBYyxDQUFDSDtJQUNwQyxJQUFJRSxVQUFVLE1BQ1YsT0FBT0Q7SUFDWCxPQUFPRixXQUFXRyxPQUFPO1dBQUlEO1FBQWNDO0tBQU07QUFDckQ7QUFDQTs7O0NBR0MsR0FDRCxNQUFNRSxxQkFBcUIsQ0FBQyxHQUFHQztJQUMzQixJQUFJQSxLQUFLQyxNQUFNLEtBQUssR0FDaEIsT0FBT0M7SUFDWCxJQUFJQyxjQUFjRDtJQUNsQixNQUFNRSxjQUFjSixLQUFLSyxHQUFHLENBQUNWLENBQUFBLE1BQU9ELFdBQVdDO0lBQy9DLE1BQU9TLFlBQVlFLEtBQUssQ0FBQ1osQ0FBQUEsYUFBY0EsV0FBV08sTUFBTSxHQUFHLEdBQUk7UUFDM0QsTUFBTU0sU0FBU0gsWUFBWUMsR0FBRyxDQUFDWCxDQUFBQSxhQUFjQSxXQUFXYyxHQUFHO1FBQzNELE1BQU1DLHVCQUF1QkYsTUFBTSxDQUFDLEVBQUU7UUFDdEMsSUFBSUEsT0FBT0QsS0FBSyxDQUFDVCxDQUFBQSxRQUFTQSxVQUFVWSx1QkFDaENOLGNBQWNNO2FBRWQ7SUFDUjtJQUNBLE9BQU9OO0FBQ1g7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNELE1BQU1PLGdCQUFnQixDQUFDQyxhQUFhQyxhQUFheEIsVUFBVSxFQUFFO0lBQ3pELElB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T1U7QUFDWDtBQUNBLE1BQU1FLCtCQUErQixDQUFDQyx5QkFBeUJDO0lBQzNELE1BQU1DLGlCQUFpQkYsd0JBQXdCbkQsUUFBUTtJQUN2RCxNQUFNc0QsbUJBQW1CSCx3QkFBd0JsRCxNQUFNO0lBQ3ZELElBQUlvRCxnQkFDQSxJQUFLLElBQUkzRixPQUFPMkYsZUFDWixLQUFLLElBQUkzQixhQUFhMkIsY0FBYyxDQUFDM0YsSUFBSSxDQUNyQ2dFLFVBQVUwQixRQUFRMUY7SUFDOUIsSUFBSTRGLGtCQUNBLElBQUssSUFBSTVGLE9BQU80RixpQkFDWixLQUFLLElBQUk1QixhQUFhNEIsZ0JBQWdCLENBQUM1RixJQUFJLENBQ3ZDZ0UsVUFBVTBCLFFBQVExRixLQUFLN0QsT0FBTzBDLHdCQUF3QixDQUFDNkcsUUFBUTFGO0FBQy9FO0FBQ0E7O0NBRUMsR0FDRCxNQUFNNkYsTUFBTSxDQUFDLEdBQUdySSxjQUFnQnNJLENBQUFBO1FBQzVCLGFBQWE7UUFDYixNQUFNbEYsYUFBYStELFNBQVNuSCxZQUFZdUMsTUFBTSxDQUFDO1lBQUMrRjtTQUFlO1FBQy9EM0osT0FBT2dELGNBQWMsQ0FBQ3lCLFlBQVksUUFBUTtZQUN0Q21GLE9BQU9ELGVBQWVFLElBQUk7WUFDMUJDLFVBQVU7UUFDZDtRQUNBLE9BQU9yRjtJQUNYO0FBRW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktZGFwcC8uL25vZGVfbW9kdWxlcy90cy1taXhlci9kaXN0L2VzbS9pbmRleC5qcz8yOTg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IHdvcmtzIGxpa2UgYE9iamVjdC5hcHBseWAsIGJ1dCBjb3BpZXMgZ2V0dGVycyBhbmQgc2V0dGVycyBwcm9wZXJseSBhcyB3ZWxsLiAgQWRkaXRpb25hbGx5IGdpdmVzXG4gKiB0aGUgb3B0aW9uIHRvIGV4Y2x1ZGUgcHJvcGVydGllcyBieSBuYW1lLlxuICovXG5jb25zdCBjb3B5UHJvcHMgPSAoZGVzdCwgc3JjLCBleGNsdWRlID0gW10pID0+IHtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNyYyk7XG4gICAgZm9yIChsZXQgcHJvcCBvZiBleGNsdWRlKVxuICAgICAgICBkZWxldGUgcHJvcHNbcHJvcF07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGVzdCwgcHJvcHMpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZnVsbCBjaGFpbiBvZiBwcm90b3R5cGVzIHVwIHVudGlsIE9iamVjdC5wcm90b3R5cGUgZ2l2ZW4gYSBzdGFydGluZyBvYmplY3QuICBUaGUgb3JkZXIgb2YgcHJvdG90eXBlcyB3aWxsXG4gKiBiZSBjbG9zZXN0IHRvIGZhcnRoZXN0IGluIHRoZSBjaGFpbi5cbiAqL1xuY29uc3QgcHJvdG9DaGFpbiA9IChvYmosIGN1cnJlbnRDaGFpbiA9IFtvYmpdKSA9PiB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgICAgIHJldHVybiBjdXJyZW50Q2hhaW47XG4gICAgcmV0dXJuIHByb3RvQ2hhaW4ocHJvdG8sIFsuLi5jdXJyZW50Q2hhaW4sIHByb3RvXSk7XG59O1xuLyoqXG4gKiBJZGVudGlmaWVzIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGNvbW1vbiB0byBhbGwgdGhlIGdpdmVuIG9iamVjdHMgaW4gdGhlaXIgcHJvdG90eXBlIGNoYWlucy4gIEZvciBtb3N0IHVucmVsYXRlZFxuICogb2JqZWN0cywgdGhpcyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuXG4gKi9cbmNvbnN0IG5lYXJlc3RDb21tb25Qcm90byA9ICguLi5vYmpzKSA9PiB7XG4gICAgaWYgKG9ianMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBjb21tb25Qcm90byA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcm90b0NoYWlucyA9IG9ianMubWFwKG9iaiA9PiBwcm90b0NoYWluKG9iaikpO1xuICAgIHdoaWxlIChwcm90b0NoYWlucy5ldmVyeShwcm90b0NoYWluID0+IHByb3RvQ2hhaW4ubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgY29uc3QgcHJvdG9zID0gcHJvdG9DaGFpbnMubWFwKHByb3RvQ2hhaW4gPT4gcHJvdG9DaGFpbi5wb3AoKSk7XG4gICAgICAgIGNvbnN0IHBvdGVudGlhbENvbW1vblByb3RvID0gcHJvdG9zWzBdO1xuICAgICAgICBpZiAocHJvdG9zLmV2ZXJ5KHByb3RvID0+IHByb3RvID09PSBwb3RlbnRpYWxDb21tb25Qcm90bykpXG4gICAgICAgICAgICBjb21tb25Qcm90byA9IHBvdGVudGlhbENvbW1vblByb3RvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1vblByb3RvO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBwcm90b3R5cGUgb2JqZWN0IHRoYXQgaXMgYSBtaXh0dXJlIG9mIHRoZSBnaXZlbiBwcm90b3R5cGVzLiAgVGhlIG1peGluZyBpcyBhY2hpZXZlZCBieSBmaXJzdFxuICogaWRlbnRpZnlpbmcgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGFuZCB1c2luZyBpdCBhcyB0aGUgcHJvdG90eXBlIGZvciBhIG5ldyBvYmplY3QuICBUaGVuIGFsbCBwcm9wZXJ0aWVzL21ldGhvZHNcbiAqIGRvd25zdHJlYW0gb2YgdGhpcyBwcm90b3R5cGUgKE9OTFkgZG93bnN0cmVhbSkgYXJlIGNvcGllZCBpbnRvIHRoZSBuZXcgb2JqZWN0LlxuICpcbiAqIFRoZSByZXN1bHRpbmcgcHJvdG90eXBlIGlzIG1vcmUgcGVyZm9ybWFudCB0aGFuIHNvZnRNaXhQcm90b3MoLi4uKSwgYXMgd2VsbCBhcyBFUzUgY29tcGF0aWJsZS4gIEhvd2V2ZXIsIGl0J3Mgbm90IGFzXG4gKiBmbGV4aWJsZSBhcyB1cGRhdGVzIHRvIHRoZSBzb3VyY2UgcHJvdG90eXBlcyBhcmVuJ3QgY2FwdHVyZWQgYnkgdGhlIG1peGVkIHJlc3VsdC4gIFNlZSBzb2Z0TWl4UHJvdG9zIGZvciB3aHkgeW91IG1heVxuICogd2FudCB0byB1c2UgdGhhdCBpbnN0ZWFkLlxuICovXG5jb25zdCBoYXJkTWl4UHJvdG9zID0gKGluZ3JlZGllbnRzLCBjb25zdHJ1Y3RvciwgZXhjbHVkZSA9IFtdKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGJhc2UgPSAoX2EgPSBuZWFyZXN0Q29tbW9uUHJvdG8oLi4uaW5ncmVkaWVudHMpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBPYmplY3QucHJvdG90eXBlO1xuICAgIGNvbnN0IG1peGVkUHJvdG8gPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xuICAgIC8vIEtlZXBzIHRyYWNrIG9mIHByb3RvdHlwZXMgd2UndmUgYWxyZWFkeSB2aXNpdGVkIHRvIGF2b2lkIGNvcHlpbmcgdGhlIHNhbWUgcHJvcGVydGllcyBtdWx0aXBsZSB0aW1lcy4gIFdlIGluaXQgdGhlXG4gICAgLy8gbGlzdCB3aXRoIHRoZSBwcm90byBjaGFpbiBiZWxvdyB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGFueSBvZiB0aG9zZSBtZXRob2RzIG1peGVkIGluXG4gICAgLy8gd2hlbiB0aGV5IHdpbGwgYWxyZWFkeSBiZSBhY2Nlc3NpYmxlIHZpYSBwcm90b3R5cGUgYWNjZXNzLlxuICAgIGNvbnN0IHZpc2l0ZWRQcm90b3MgPSBwcm90b0NoYWluKGJhc2UpO1xuICAgIGZvciAobGV0IHByb3RvdHlwZSBvZiBpbmdyZWRpZW50cykge1xuICAgICAgICBsZXQgcHJvdG9zID0gcHJvdG9DaGFpbihwcm90b3R5cGUpO1xuICAgICAgICAvLyBBcHBseSB0aGUgcHJvdG90eXBlIGNoYWluIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCBvbGQgbWV0aG9kcyBkb24ndCBvdmVycmlkZSBuZXdlciBvbmVzLlxuICAgICAgICBmb3IgKGxldCBpID0gcHJvdG9zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbmV3UHJvdG8gPSBwcm90b3NbaV07XG4gICAgICAgICAgICBpZiAodmlzaXRlZFByb3Rvcy5pbmRleE9mKG5ld1Byb3RvKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb3B5UHJvcHMobWl4ZWRQcm90bywgbmV3UHJvdG8sIFsnY29uc3RydWN0b3InLCAuLi5leGNsdWRlXSk7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFByb3Rvcy5wdXNoKG5ld1Byb3RvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtaXhlZFByb3RvLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIG1peGVkUHJvdG87XG59O1xuY29uc3QgdW5pcXVlID0gKGFycikgPT4gYXJyLmZpbHRlcigoZSwgaSkgPT4gYXJyLmluZGV4T2YoZSkgPT0gaSk7XG5cbi8qKlxuICogRmluZHMgdGhlIGluZ3JlZGllbnQgd2l0aCB0aGUgZ2l2ZW4gcHJvcCwgc2VhcmNoaW5nIGluIHJldmVyc2Ugb3JkZXIgYW5kIGJyZWFkdGgtZmlyc3QgaWYgc2VhcmNoaW5nIGluZ3JlZGllbnRcbiAqIHByb3RvdHlwZXMgaXMgcmVxdWlyZWQuXG4gKi9cbmNvbnN0IGdldEluZ3JlZGllbnRXaXRoUHJvcCA9IChwcm9wLCBpbmdyZWRpZW50cykgPT4ge1xuICAgIGNvbnN0IHByb3RvQ2hhaW5zID0gaW5ncmVkaWVudHMubWFwKGluZ3JlZGllbnQgPT4gcHJvdG9DaGFpbihpbmdyZWRpZW50KSk7XG4gICAgLy8gc2luY2Ugd2Ugc2VhcmNoIGJyZWFkdGgtZmlyc3QsIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBvdXIgZGVwdGggaW4gdGhlIHByb3RvdHlwZSBjaGFpbnNcbiAgICBsZXQgcHJvdG9EZXB0aCA9IDA7XG4gICAgLy8gbm90IGFsbCBwcm90b3R5cGUgY2hhaW5zIGFyZSB0aGUgc2FtZSBkZXB0aCwgc28gdGhpcyByZW1haW5zIHRydWUgYXMgbG9uZyBhcyBhdCBsZWFzdCBvbmUgb2YgdGhlIGluZ3JlZGllbnRzJ1xuICAgIC8vIHByb3RvdHlwZSBjaGFpbnMgaGFzIGFuIG9iamVjdCBhdCB0aGlzIGRlcHRoXG4gICAgbGV0IHByb3Rvc0FyZUxlZnRUb1NlYXJjaCA9IHRydWU7XG4gICAgd2hpbGUgKHByb3Rvc0FyZUxlZnRUb1NlYXJjaCkge1xuICAgICAgICAvLyB3aXRoIHRoZSBzdGFydCBvZiBlYWNoIGhvcml6b250YWwgc2xpY2UsIHdlIGFzc3VtZSB0aGlzIGlzIHRoZSBvbmUgdGhhdCdzIGRlZXBlciB0aGFuIGFueSBvZiB0aGUgcHJvdG8gY2hhaW5zXG4gICAgICAgIHByb3Rvc0FyZUxlZnRUb1NlYXJjaCA9IGZhbHNlO1xuICAgICAgICAvLyBzY2FuIHRocm91Z2ggdGhlIGluZ3JlZGllbnRzIHJpZ2h0IHRvIGxlZnRcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZ3JlZGllbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hUYXJnZXQgPSBwcm90b0NoYWluc1tpXVtwcm90b0RlcHRoXTtcbiAgICAgICAgICAgIGlmIChzZWFyY2hUYXJnZXQgIT09IHVuZGVmaW5lZCAmJiBzZWFyY2hUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIHNvbWV0aGluZywgdGhpcyBpcyBwcm9vZiB0aGF0IHRoaXMgaG9yaXpvbnRhbCBzbGljZSBwb3RlbnRpYWxseSBtb3JlIG9iamVjdHMgdG8gc2VhcmNoXG4gICAgICAgICAgICAgICAgcHJvdG9zQXJlTGVmdFRvU2VhcmNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBldXJla2EsIHdlIGZvdW5kIGl0XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2VhcmNoVGFyZ2V0LCBwcm9wKSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvQ2hhaW5zW2ldWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm90b0RlcHRoKys7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuLyoqXG4gKiBcIk1peGVzXCIgaW5ncmVkaWVudHMgYnkgd3JhcHBpbmcgdGhlbSBpbiBhIFByb3h5LiAgVGhlIG9wdGlvbmFsIHByb3RvdHlwZSBhcmd1bWVudCBhbGxvd3MgdGhlIG1peGVkIG9iamVjdCB0byBzaXRcbiAqIGRvd25zdHJlYW0gb2YgYW4gZXhpc3RpbmcgcHJvdG90eXBlIGNoYWluLiAgTm90ZSB0aGF0IFwicHJvcGVydGllc1wiIGNhbm5vdCBiZSBhZGRlZCwgZGVsZXRlZCwgb3IgbW9kaWZpZWQuXG4gKi9cbmNvbnN0IHByb3h5TWl4ID0gKGluZ3JlZGllbnRzLCBwcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlKSA9PiBuZXcgUHJveHkoe30sIHtcbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZTtcbiAgICB9LFxuICAgIHNldFByb3RvdHlwZU9mKCkge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IHNldCBwcm90b3R5cGUgb2YgUHJveGllcyBjcmVhdGVkIGJ5IHRzLW1peGVyJyk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXywgcHJvcCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihnZXRJbmdyZWRpZW50V2l0aFByb3AocHJvcCwgaW5ncmVkaWVudHMpIHx8IHt9LCBwcm9wKTtcbiAgICB9LFxuICAgIGRlZmluZVByb3BlcnR5KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWZpbmUgbmV3IHByb3BlcnRpZXMgb24gUHJveGllcyBjcmVhdGVkIGJ5IHRzLW1peGVyJyk7XG4gICAgfSxcbiAgICBoYXMoXywgcHJvcCkge1xuICAgICAgICByZXR1cm4gZ2V0SW5ncmVkaWVudFdpdGhQcm9wKHByb3AsIGluZ3JlZGllbnRzKSAhPT0gdW5kZWZpbmVkIHx8IHByb3RvdHlwZVtwcm9wXSAhPT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZ2V0KF8sIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIChnZXRJbmdyZWRpZW50V2l0aFByb3AocHJvcCwgaW5ncmVkaWVudHMpIHx8IHByb3RvdHlwZSlbcHJvcF07XG4gICAgfSxcbiAgICBzZXQoXywgcHJvcCwgdmFsKSB7XG4gICAgICAgIGNvbnN0IGluZ3JlZGllbnRXaXRoUHJvcCA9IGdldEluZ3JlZGllbnRXaXRoUHJvcChwcm9wLCBpbmdyZWRpZW50cyk7XG4gICAgICAgIGlmIChpbmdyZWRpZW50V2l0aFByb3AgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBuZXcgcHJvcGVydGllcyBvbiBQcm94aWVzIGNyZWF0ZWQgYnkgdHMtbWl4ZXInKTtcbiAgICAgICAgaW5ncmVkaWVudFdpdGhQcm9wW3Byb3BdID0gdmFsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWxldGUgcHJvcGVydGllcyBvbiBQcm94aWVzIGNyZWF0ZWQgYnkgdHMtbWl4ZXInKTtcbiAgICB9LFxuICAgIG93bktleXMoKSB7XG4gICAgICAgIHJldHVybiBpbmdyZWRpZW50c1xuICAgICAgICAgICAgLm1hcChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcylcbiAgICAgICAgICAgIC5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IGN1cnIuY29uY2F0KHByZXYuZmlsdGVyKGtleSA9PiBjdXJyLmluZGV4T2Yoa2V5KSA8IDApKSk7XG4gICAgfSxcbn0pO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHByb3h5LXByb3RvdHlwZSBvYmplY3QgdGhhdCBpcyBhIFwic29mdFwiIG1peHR1cmUgb2YgdGhlIGdpdmVuIHByb3RvdHlwZXMuICBUaGUgbWl4aW5nIGlzIGFjaGlldmVkIGJ5XG4gKiBwcm94eWluZyBhbGwgcHJvcGVydHkgYWNjZXNzIHRvIHRoZSBpbmdyZWRpZW50cy4gIFRoaXMgaXMgbm90IEVTNSBjb21wYXRpYmxlIGFuZCBsZXNzIHBlcmZvcm1hbnQuICBIb3dldmVyLCBhbnlcbiAqIGNoYW5nZXMgbWFkZSB0byB0aGUgc291cmNlIHByb3RvdHlwZXMgd2lsbCBiZSByZWZsZWN0ZWQgaW4gdGhlIHByb3h5LXByb3RvdHlwZSwgd2hpY2ggbWF5IGJlIGRlc2lyYWJsZS5cbiAqL1xuY29uc3Qgc29mdE1peFByb3RvcyA9IChpbmdyZWRpZW50cywgY29uc3RydWN0b3IpID0+IHByb3h5TWl4KFsuLi5pbmdyZWRpZW50cywgeyBjb25zdHJ1Y3RvciB9XSk7XG5cbmNvbnN0IHNldHRpbmdzID0ge1xuICAgIGluaXRGdW5jdGlvbjogbnVsbCxcbiAgICBzdGF0aWNzU3RyYXRlZ3k6ICdjb3B5JyxcbiAgICBwcm90b3R5cGVTdHJhdGVneTogJ2NvcHknLFxuICAgIGRlY29yYXRvckluaGVyaXRhbmNlOiAnZGVlcCcsXG59O1xuXG4vLyBLZWVwcyB0cmFjayBvZiBjb25zdGl0dWVudCBjbGFzc2VzIGZvciBldmVyeSBtaXhpbiBjbGFzcyBjcmVhdGVkIGJ5IHRzLW1peGVyLlxuY29uc3QgbWl4aW5zID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGdldE1peGluc0ZvckNsYXNzID0gKGNsYXp6KSA9PiBtaXhpbnMuZ2V0KGNsYXp6KTtcbmNvbnN0IHJlZ2lzdGVyTWl4aW5zID0gKG1peGVkQ2xhc3MsIGNvbnN0aXR1ZW50cykgPT4gbWl4aW5zLnNldChtaXhlZENsYXNzLCBjb25zdGl0dWVudHMpO1xuY29uc3QgaGFzTWl4aW4gPSAoaW5zdGFuY2UsIG1peGluKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgbWl4aW4pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gaW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICBsZXQgZnJvbnRpZXIgPSBuZXcgU2V0KCk7XG4gICAgZnJvbnRpZXIuYWRkKGNvbnN0cnVjdG9yKTtcbiAgICB3aGlsZSAoZnJvbnRpZXIuc2l6ZSA+IDApIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZyb250aWVyIGhhcyB0aGUgbWl4aW4gd2UncmUgbG9va2luZyBmb3IuICBpZiBub3QsIHdlIGNhbiBzYXkgd2UgdmlzaXRlZCBldmVyeSBpdGVtIGluIHRoZSBmcm9udGllclxuICAgICAgICBpZiAoZnJvbnRpZXIuaGFzKG1peGluKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmcm9udGllci5mb3JFYWNoKChpdGVtKSA9PiB2aXNpdGVkLmFkZChpdGVtKSk7XG4gICAgICAgIC8vIGJ1aWxkIGEgbmV3IGZyb250aWVyIGJhc2VkIG9uIHRoZSBhc3NvY2lhdGVkIG1peGluIGNsYXNzZXMgYW5kIHByb3RvdHlwZSBjaGFpbnMgb2YgZWFjaCBmcm9udGllciBpdGVtXG4gICAgICAgIGNvbnN0IG5ld0Zyb250aWVyID0gbmV3IFNldCgpO1xuICAgICAgICBmcm9udGllci5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBpdGVtQ29uc3RpdHVlbnRzID0gKF9hID0gbWl4aW5zLmdldChpdGVtKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcHJvdG9DaGFpbihpdGVtLnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICAubWFwKChwcm90bykgPT4gcHJvdG8uY29uc3RydWN0b3IpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAoaXRlbUNvbnN0aXR1ZW50cylcbiAgICAgICAgICAgICAgICBpdGVtQ29uc3RpdHVlbnRzLmZvckVhY2goKGNvbnN0aXR1ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZC5oYXMoY29uc3RpdHVlbnQpICYmICFmcm9udGllci5oYXMoY29uc3RpdHVlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RnJvbnRpZXIuYWRkKGNvbnN0aXR1ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHdlIGhhdmUgYSBuZXcgZnJvbnRpZXIsIG5vdyBzZWFyY2ggYWdhaW5cbiAgICAgICAgZnJvbnRpZXIgPSBuZXdGcm9udGllcjtcbiAgICB9XG4gICAgLy8gaWYgd2UgZ2V0IGhlcmUsIHdlIGNvdWxkbid0IGZpbmQgdGhlIG1peGluIGFueXdoZXJlIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gb3IgYXNzb2NpYXRlZCBtaXhpbiBjbGFzc2VzXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgbWVyZ2VPYmplY3RzT2ZEZWNvcmF0b3JzID0gKG8xLCBvMikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgYWxsS2V5cyA9IHVuaXF1ZShbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobzEpLCAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvMildKTtcbiAgICBjb25zdCBtZXJnZWRPYmplY3QgPSB7fTtcbiAgICBmb3IgKGxldCBrZXkgb2YgYWxsS2V5cylcbiAgICAgICAgbWVyZ2VkT2JqZWN0W2tleV0gPSB1bmlxdWUoWy4uLigoX2EgPSBvMSA9PT0gbnVsbCB8fCBvMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbzFba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLCAuLi4oKF9iID0gbzIgPT09IG51bGwgfHwgbzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG8yW2tleV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKV0pO1xuICAgIHJldHVybiBtZXJnZWRPYmplY3Q7XG59O1xuY29uc3QgbWVyZ2VQcm9wZXJ0eUFuZE1ldGhvZERlY29yYXRvcnMgPSAoZDEsIGQyKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHJldHVybiAoe1xuICAgICAgICBwcm9wZXJ0eTogbWVyZ2VPYmplY3RzT2ZEZWNvcmF0b3JzKChfYSA9IGQxID09PSBudWxsIHx8IGQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMS5wcm9wZXJ0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sIChfYiA9IGQyID09PSBudWxsIHx8IGQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMi5wcm9wZXJ0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pLFxuICAgICAgICBtZXRob2Q6IG1lcmdlT2JqZWN0c09mRGVjb3JhdG9ycygoX2MgPSBkMSA9PT0gbnVsbCB8fCBkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDEubWV0aG9kKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSwgKF9kID0gZDIgPT09IG51bGwgfHwgZDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQyLm1ldGhvZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDoge30pLFxuICAgIH0pO1xufTtcbmNvbnN0IG1lcmdlRGVjb3JhdG9ycyA9IChkMSwgZDIpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICByZXR1cm4gKHtcbiAgICAgICAgY2xhc3M6IHVuaXF1ZShbLi4uKF9hID0gZDEgPT09IG51bGwgfHwgZDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQxLmNsYXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSwgLi4uKF9iID0gZDIgPT09IG51bGwgfHwgZDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQyLmNsYXNzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXV0pLFxuICAgICAgICBzdGF0aWM6IG1lcmdlUHJvcGVydHlBbmRNZXRob2REZWNvcmF0b3JzKChfYyA9IGQxID09PSBudWxsIHx8IGQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMS5zdGF0aWMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LCAoX2QgPSBkMiA9PT0gbnVsbCB8fCBkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDIuc3RhdGljKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB7fSksXG4gICAgICAgIGluc3RhbmNlOiBtZXJnZVByb3BlcnR5QW5kTWV0aG9kRGVjb3JhdG9ycygoX2UgPSBkMSA9PT0gbnVsbCB8fCBkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDEuaW5zdGFuY2UpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHt9LCAoX2YgPSBkMiA9PT0gbnVsbCB8fCBkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDIuaW5zdGFuY2UpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHt9KSxcbiAgICB9KTtcbn07XG5jb25zdCBkZWNvcmF0b3JzID0gbmV3IE1hcCgpO1xuY29uc3QgZmluZEFsbENvbnN0aXR1ZW50Q2xhc3NlcyA9ICguLi5jbGFzc2VzKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZnJvbnRpZXIgPSBuZXcgU2V0KFsuLi5jbGFzc2VzXSk7XG4gICAgd2hpbGUgKGZyb250aWVyLnNpemUgPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGNsYXp6IG9mIGZyb250aWVyKSB7XG4gICAgICAgICAgICBjb25zdCBwcm90b0NoYWluQ2xhc3NlcyA9IHByb3RvQ2hhaW4oY2xhenoucHJvdG90eXBlKS5tYXAocHJvdG8gPT4gcHJvdG8uY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgbWl4aW5DbGFzc2VzID0gKF9hID0gZ2V0TWl4aW5zRm9yQ2xhc3MoY2xhenopKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IHBvdGVudGlhbGx5TmV3Q2xhc3NlcyA9IFsuLi5wcm90b0NoYWluQ2xhc3NlcywgLi4ubWl4aW5DbGFzc2VzXTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBwb3RlbnRpYWxseU5ld0NsYXNzZXMuZmlsdGVyKGMgPT4gIWFsbENsYXNzZXMuaGFzKGMpKTtcbiAgICAgICAgICAgIGZvciAobGV0IG5ld0NsYXNzIG9mIG5ld0NsYXNzZXMpXG4gICAgICAgICAgICAgICAgZnJvbnRpZXIuYWRkKG5ld0NsYXNzKTtcbiAgICAgICAgICAgIGFsbENsYXNzZXMuYWRkKGNsYXp6KTtcbiAgICAgICAgICAgIGZyb250aWVyLmRlbGV0ZShjbGF6eik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsuLi5hbGxDbGFzc2VzXTtcbn07XG5jb25zdCBkZWVwRGVjb3JhdG9yU2VhcmNoID0gKC4uLmNsYXNzZXMpID0+IHtcbiAgICBjb25zdCBkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbiA9IGZpbmRBbGxDb25zdGl0dWVudENsYXNzZXMoLi4uY2xhc3NlcylcbiAgICAgICAgLm1hcChjbGF6eiA9PiBkZWNvcmF0b3JzLmdldChjbGF6eikpXG4gICAgICAgIC5maWx0ZXIoZGVjb3JhdG9ycyA9PiAhIWRlY29yYXRvcnMpO1xuICAgIGlmIChkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbi5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGlmIChkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbi5sZW5ndGggPT0gMSlcbiAgICAgICAgcmV0dXJuIGRlY29yYXRvcnNGb3JDbGFzc0NoYWluWzBdO1xuICAgIHJldHVybiBkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbi5yZWR1Y2UoKGQxLCBkMikgPT4gbWVyZ2VEZWNvcmF0b3JzKGQxLCBkMikpO1xufTtcbmNvbnN0IGRpcmVjdERlY29yYXRvclNlYXJjaCA9ICguLi5jbGFzc2VzKSA9PiB7XG4gICAgY29uc3QgY2xhc3NEZWNvcmF0b3JzID0gY2xhc3Nlcy5tYXAoY2xhenogPT4gZ2V0RGVjb3JhdG9yc0ZvckNsYXNzKGNsYXp6KSk7XG4gICAgaWYgKGNsYXNzRGVjb3JhdG9ycy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBpZiAoY2xhc3NEZWNvcmF0b3JzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGNsYXNzRGVjb3JhdG9yc1swXTtcbiAgICByZXR1cm4gY2xhc3NEZWNvcmF0b3JzLnJlZHVjZSgoZDEsIGQyKSA9PiBtZXJnZURlY29yYXRvcnMoZDEsIGQyKSk7XG59O1xuY29uc3QgZ2V0RGVjb3JhdG9yc0ZvckNsYXNzID0gKGNsYXp6KSA9PiB7XG4gICAgbGV0IGRlY29yYXRvcnNGb3JDbGFzcyA9IGRlY29yYXRvcnMuZ2V0KGNsYXp6KTtcbiAgICBpZiAoIWRlY29yYXRvcnNGb3JDbGFzcykge1xuICAgICAgICBkZWNvcmF0b3JzRm9yQ2xhc3MgPSB7fTtcbiAgICAgICAgZGVjb3JhdG9ycy5zZXQoY2xhenosIGRlY29yYXRvcnNGb3JDbGFzcyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvcmF0b3JzRm9yQ2xhc3M7XG59O1xuY29uc3QgZGVjb3JhdGVDbGFzcyA9IChkZWNvcmF0b3IpID0+ICgoY2xhenopID0+IHtcbiAgICBjb25zdCBkZWNvcmF0b3JzRm9yQ2xhc3MgPSBnZXREZWNvcmF0b3JzRm9yQ2xhc3MoY2xhenopO1xuICAgIGxldCBjbGFzc0RlY29yYXRvcnMgPSBkZWNvcmF0b3JzRm9yQ2xhc3MuY2xhc3M7XG4gICAgaWYgKCFjbGFzc0RlY29yYXRvcnMpIHtcbiAgICAgICAgY2xhc3NEZWNvcmF0b3JzID0gW107XG4gICAgICAgIGRlY29yYXRvcnNGb3JDbGFzcy5jbGFzcyA9IGNsYXNzRGVjb3JhdG9ycztcbiAgICB9XG4gICAgY2xhc3NEZWNvcmF0b3JzLnB1c2goZGVjb3JhdG9yKTtcbiAgICByZXR1cm4gZGVjb3JhdG9yKGNsYXp6KTtcbn0pO1xuY29uc3QgZGVjb3JhdGVNZW1iZXIgPSAoZGVjb3JhdG9yKSA9PiAoKG9iamVjdCwga2V5LCAuLi5vdGhlckFyZ3MpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBkZWNvcmF0b3JUYXJnZXRUeXBlID0gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJyA/ICdzdGF0aWMnIDogJ2luc3RhbmNlJztcbiAgICBjb25zdCBkZWNvcmF0b3JUeXBlID0gdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nID8gJ21ldGhvZCcgOiAncHJvcGVydHknO1xuICAgIGNvbnN0IGNsYXp6ID0gZGVjb3JhdG9yVGFyZ2V0VHlwZSA9PT0gJ3N0YXRpYycgPyBvYmplY3QgOiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgY29uc3QgZGVjb3JhdG9yc0ZvckNsYXNzID0gZ2V0RGVjb3JhdG9yc0ZvckNsYXNzKGNsYXp6KTtcbiAgICBjb25zdCBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZSA9IChfYSA9IGRlY29yYXRvcnNGb3JDbGFzcyA9PT0gbnVsbCB8fCBkZWNvcmF0b3JzRm9yQ2xhc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29yYXRvcnNGb3JDbGFzc1tkZWNvcmF0b3JUYXJnZXRUeXBlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgZGVjb3JhdG9yc0ZvckNsYXNzW2RlY29yYXRvclRhcmdldFR5cGVdID0gZGVjb3JhdG9yc0ZvclRhcmdldFR5cGU7XG4gICAgbGV0IGRlY29yYXRvcnNGb3JUeXBlID0gKF9iID0gZGVjb3JhdG9yc0ZvclRhcmdldFR5cGUgPT09IG51bGwgfHwgZGVjb3JhdG9yc0ZvclRhcmdldFR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29yYXRvcnNGb3JUYXJnZXRUeXBlW2RlY29yYXRvclR5cGVdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcbiAgICBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZVtkZWNvcmF0b3JUeXBlXSA9IGRlY29yYXRvcnNGb3JUeXBlO1xuICAgIGxldCBkZWNvcmF0b3JzRm9yS2V5ID0gKF9jID0gZGVjb3JhdG9yc0ZvclR5cGUgPT09IG51bGwgfHwgZGVjb3JhdG9yc0ZvclR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29yYXRvcnNGb3JUeXBlW2tleV0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xuICAgIGRlY29yYXRvcnNGb3JUeXBlW2tleV0gPSBkZWNvcmF0b3JzRm9yS2V5O1xuICAgIC8vIEB0cy1pZ25vcmU6IGFycmF5IGlzIHR5cGUgYEFbXSB8IEJbXWAgYW5kIGl0ZW0gaXMgdHlwZSBgQSB8IEJgLCBzbyB0ZWNobmljYWxseSBhIHR5cGUgZXJyb3IsIGJ1dCBpdCdzIGZpbmVcbiAgICBkZWNvcmF0b3JzRm9yS2V5LnB1c2goZGVjb3JhdG9yKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGRlY29yYXRvcihvYmplY3QsIGtleSwgLi4ub3RoZXJBcmdzKTtcbn0pO1xuY29uc3QgZGVjb3JhdGUgPSAoZGVjb3JhdG9yKSA9PiAoKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBkZWNvcmF0ZUNsYXNzKGRlY29yYXRvcikoYXJnc1swXSk7XG4gICAgcmV0dXJuIGRlY29yYXRlTWVtYmVyKGRlY29yYXRvcikoLi4uYXJncyk7XG59KTtcblxuZnVuY3Rpb24gTWl4aW4oLi4uY29uc3RydWN0b3JzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgcHJvdG90eXBlcyA9IGNvbnN0cnVjdG9ycy5tYXAoY29uc3RydWN0b3IgPT4gY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAvLyBIZXJlIHdlIGdhdGhlciB1cCB0aGUgaW5pdCBmdW5jdGlvbnMgb2YgdGhlIGluZ3JlZGllbnQgcHJvdG90eXBlcywgY29tYmluZSB0aGVtIGludG8gb25lIGluaXQgZnVuY3Rpb24sIGFuZFxuICAgIC8vIGF0dGFjaCBpdCB0byB0aGUgbWl4ZWQgY2xhc3MgcHJvdG90eXBlLiAgVGhlIHJlYXNvbiB3ZSBkbyB0aGlzIGlzIGJlY2F1c2Ugd2Ugd2FudCB0aGUgaW5pdCBmdW5jdGlvbnMgdG8gbWl4XG4gICAgLy8gc2ltaWxhcmx5IHRvIGNvbnN0cnVjdG9ycyAtLSBub3QgbWV0aG9kcywgd2hpY2ggc2ltcGx5IG92ZXJyaWRlIGVhY2ggb3RoZXIuXG4gICAgY29uc3QgaW5pdEZ1bmN0aW9uTmFtZSA9IHNldHRpbmdzLmluaXRGdW5jdGlvbjtcbiAgICBpZiAoaW5pdEZ1bmN0aW9uTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBpbml0RnVuY3Rpb25zID0gcHJvdG90eXBlc1xuICAgICAgICAgICAgLm1hcChwcm90byA9PiBwcm90b1tpbml0RnVuY3Rpb25OYW1lXSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuYyA9PiB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkSW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGluaXRGdW5jdGlvbiBvZiBpbml0RnVuY3Rpb25zKVxuICAgICAgICAgICAgICAgIGluaXRGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXh0cmFQcm90byA9IHsgW2luaXRGdW5jdGlvbk5hbWVdOiBjb21iaW5lZEluaXRGdW5jdGlvbiB9O1xuICAgICAgICBwcm90b3R5cGVzLnB1c2goZXh0cmFQcm90byk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1peGVkQ2xhc3MoLi4uYXJncykge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnN0cnVjdG9yIG9mIGNvbnN0cnVjdG9ycylcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IHBvdGVudGlhbGx5IGFic3RyYWN0IGNsYXNzXG4gICAgICAgICAgICBjb3B5UHJvcHModGhpcywgbmV3IGNvbnN0cnVjdG9yKC4uLmFyZ3MpKTtcbiAgICAgICAgaWYgKGluaXRGdW5jdGlvbk5hbWUgIT09IG51bGwgJiYgdHlwZW9mIHRoaXNbaW5pdEZ1bmN0aW9uTmFtZV0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aGlzW2luaXRGdW5jdGlvbk5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBNaXhlZENsYXNzLnByb3RvdHlwZSA9IHNldHRpbmdzLnByb3RvdHlwZVN0cmF0ZWd5ID09PSAnY29weSdcbiAgICAgICAgPyBoYXJkTWl4UHJvdG9zKHByb3RvdHlwZXMsIE1peGVkQ2xhc3MpXG4gICAgICAgIDogc29mdE1peFByb3Rvcyhwcm90b3R5cGVzLCBNaXhlZENsYXNzKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoTWl4ZWRDbGFzcywgc2V0dGluZ3Muc3RhdGljc1N0cmF0ZWd5ID09PSAnY29weSdcbiAgICAgICAgPyBoYXJkTWl4UHJvdG9zKGNvbnN0cnVjdG9ycywgbnVsbCwgWydwcm90b3R5cGUnXSlcbiAgICAgICAgOiBwcm94eU1peChjb25zdHJ1Y3RvcnMsIEZ1bmN0aW9uLnByb3RvdHlwZSkpO1xuICAgIGxldCBEZWNvcmF0ZWRNaXhlZENsYXNzID0gTWl4ZWRDbGFzcztcbiAgICBpZiAoc2V0dGluZ3MuZGVjb3JhdG9ySW5oZXJpdGFuY2UgIT09ICdub25lJykge1xuICAgICAgICBjb25zdCBjbGFzc0RlY29yYXRvcnMgPSBzZXR0aW5ncy5kZWNvcmF0b3JJbmhlcml0YW5jZSA9PT0gJ2RlZXAnXG4gICAgICAgICAgICA/IGRlZXBEZWNvcmF0b3JTZWFyY2goLi4uY29uc3RydWN0b3JzKVxuICAgICAgICAgICAgOiBkaXJlY3REZWNvcmF0b3JTZWFyY2goLi4uY29uc3RydWN0b3JzKTtcbiAgICAgICAgZm9yIChsZXQgZGVjb3JhdG9yIG9mIChfYSA9IGNsYXNzRGVjb3JhdG9ycyA9PT0gbnVsbCB8fCBjbGFzc0RlY29yYXRvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsYXNzRGVjb3JhdG9ycy5jbGFzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlY29yYXRvcihEZWNvcmF0ZWRNaXhlZENsYXNzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBEZWNvcmF0ZWRNaXhlZENsYXNzID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGx5UHJvcEFuZE1ldGhvZERlY29yYXRvcnMoKF9iID0gY2xhc3NEZWNvcmF0b3JzID09PSBudWxsIHx8IGNsYXNzRGVjb3JhdG9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xhc3NEZWNvcmF0b3JzLnN0YXRpYykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30sIERlY29yYXRlZE1peGVkQ2xhc3MpO1xuICAgICAgICBhcHBseVByb3BBbmRNZXRob2REZWNvcmF0b3JzKChfYyA9IGNsYXNzRGVjb3JhdG9ycyA9PT0gbnVsbCB8fCBjbGFzc0RlY29yYXRvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsYXNzRGVjb3JhdG9ycy5pbnN0YW5jZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sIERlY29yYXRlZE1peGVkQ2xhc3MucHJvdG90eXBlKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJNaXhpbnMoRGVjb3JhdGVkTWl4ZWRDbGFzcywgY29uc3RydWN0b3JzKTtcbiAgICByZXR1cm4gRGVjb3JhdGVkTWl4ZWRDbGFzcztcbn1cbmNvbnN0IGFwcGx5UHJvcEFuZE1ldGhvZERlY29yYXRvcnMgPSAocHJvcEFuZE1ldGhvZERlY29yYXRvcnMsIHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHByb3BEZWNvcmF0b3JzID0gcHJvcEFuZE1ldGhvZERlY29yYXRvcnMucHJvcGVydHk7XG4gICAgY29uc3QgbWV0aG9kRGVjb3JhdG9ycyA9IHByb3BBbmRNZXRob2REZWNvcmF0b3JzLm1ldGhvZDtcbiAgICBpZiAocHJvcERlY29yYXRvcnMpXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBwcm9wRGVjb3JhdG9ycylcbiAgICAgICAgICAgIGZvciAobGV0IGRlY29yYXRvciBvZiBwcm9wRGVjb3JhdG9yc1trZXldKVxuICAgICAgICAgICAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSk7XG4gICAgaWYgKG1ldGhvZERlY29yYXRvcnMpXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBtZXRob2REZWNvcmF0b3JzKVxuICAgICAgICAgICAgZm9yIChsZXQgZGVjb3JhdG9yIG9mIG1ldGhvZERlY29yYXRvcnNba2V5XSlcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpKTtcbn07XG4vKipcbiAqIEEgZGVjb3JhdG9yIHZlcnNpb24gb2YgdGhlIGBNaXhpbmAgZnVuY3Rpb24uICBZb3UnbGwgd2FudCB0byB1c2UgdGhpcyBpbnN0ZWFkIG9mIGBNaXhpbmAgZm9yIG1peGluZyBnZW5lcmljIGNsYXNzZXMuXG4gKi9cbmNvbnN0IG1peCA9ICguLi5pbmdyZWRpZW50cykgPT4gZGVjb3JhdGVkQ2xhc3MgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBtaXhlZENsYXNzID0gTWl4aW4oLi4uaW5ncmVkaWVudHMuY29uY2F0KFtkZWNvcmF0ZWRDbGFzc10pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWl4ZWRDbGFzcywgJ25hbWUnLCB7XG4gICAgICAgIHZhbHVlOiBkZWNvcmF0ZWRDbGFzcy5uYW1lLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSk7XG4gICAgcmV0dXJuIG1peGVkQ2xhc3M7XG59O1xuXG5leHBvcnQgeyBNaXhpbiwgZGVjb3JhdGUsIGhhc01peGluLCBtaXgsIHNldHRpbmdzIH07XG4iXSwibmFtZXMiOlsiY29weVByb3BzIiwiZGVzdCIsInNyYyIsImV4Y2x1ZGUiLCJwcm9wcyIsIk9iamVjdCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJwcm9wIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvQ2hhaW4iLCJvYmoiLCJjdXJyZW50Q2hhaW4iLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwibmVhcmVzdENvbW1vblByb3RvIiwib2JqcyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImNvbW1vblByb3RvIiwicHJvdG9DaGFpbnMiLCJtYXAiLCJldmVyeSIsInByb3RvcyIsInBvcCIsInBvdGVudGlhbENvbW1vblByb3RvIiwiaGFyZE1peFByb3RvcyIsImluZ3JlZGllbnRzIiwiY29uc3RydWN0b3IiLCJfYSIsImJhc2UiLCJwcm90b3R5cGUiLCJtaXhlZFByb3RvIiwiY3JlYXRlIiwidmlzaXRlZFByb3RvcyIsImkiLCJuZXdQcm90byIsImluZGV4T2YiLCJwdXNoIiwidW5pcXVlIiwiYXJyIiwiZmlsdGVyIiwiZSIsImdldEluZ3JlZGllbnRXaXRoUHJvcCIsImluZ3JlZGllbnQiLCJwcm90b0RlcHRoIiwicHJvdG9zQXJlTGVmdFRvU2VhcmNoIiwic2VhcmNoVGFyZ2V0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHJveHlNaXgiLCJQcm94eSIsInNldFByb3RvdHlwZU9mIiwiRXJyb3IiLCJfIiwiZGVmaW5lUHJvcGVydHkiLCJoYXMiLCJnZXQiLCJzZXQiLCJ2YWwiLCJpbmdyZWRpZW50V2l0aFByb3AiLCJkZWxldGVQcm9wZXJ0eSIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicmVkdWNlIiwicHJldiIsImN1cnIiLCJjb25jYXQiLCJrZXkiLCJzb2Z0TWl4UHJvdG9zIiwic2V0dGluZ3MiLCJpbml0RnVuY3Rpb24iLCJzdGF0aWNzU3RyYXRlZ3kiLCJwcm90b3R5cGVTdHJhdGVneSIsImRlY29yYXRvckluaGVyaXRhbmNlIiwibWl4aW5zIiwiV2Vha01hcCIsImdldE1peGluc0ZvckNsYXNzIiwiY2xhenoiLCJyZWdpc3Rlck1peGlucyIsIm1peGVkQ2xhc3MiLCJjb25zdGl0dWVudHMiLCJoYXNNaXhpbiIsImluc3RhbmNlIiwibWl4aW4iLCJ2aXNpdGVkIiwiU2V0IiwiZnJvbnRpZXIiLCJhZGQiLCJzaXplIiwiZm9yRWFjaCIsIml0ZW0iLCJuZXdGcm9udGllciIsIml0ZW1Db25zdGl0dWVudHMiLCJjb25zdGl0dWVudCIsIm1lcmdlT2JqZWN0c09mRGVjb3JhdG9ycyIsIm8xIiwibzIiLCJfYiIsImFsbEtleXMiLCJtZXJnZWRPYmplY3QiLCJtZXJnZVByb3BlcnR5QW5kTWV0aG9kRGVjb3JhdG9ycyIsImQxIiwiZDIiLCJfYyIsIl9kIiwicHJvcGVydHkiLCJtZXRob2QiLCJtZXJnZURlY29yYXRvcnMiLCJfZSIsIl9mIiwiY2xhc3MiLCJzdGF0aWMiLCJkZWNvcmF0b3JzIiwiTWFwIiwiZmluZEFsbENvbnN0aXR1ZW50Q2xhc3NlcyIsImNsYXNzZXMiLCJhbGxDbGFzc2VzIiwicHJvdG9DaGFpbkNsYXNzZXMiLCJtaXhpbkNsYXNzZXMiLCJwb3RlbnRpYWxseU5ld0NsYXNzZXMiLCJuZXdDbGFzc2VzIiwiYyIsIm5ld0NsYXNzIiwiZGVsZXRlIiwiZGVlcERlY29yYXRvclNlYXJjaCIsImRlY29yYXRvcnNGb3JDbGFzc0NoYWluIiwiZGlyZWN0RGVjb3JhdG9yU2VhcmNoIiwiY2xhc3NEZWNvcmF0b3JzIiwiZ2V0RGVjb3JhdG9yc0ZvckNsYXNzIiwiZGVjb3JhdG9yc0ZvckNsYXNzIiwiZGVjb3JhdGVDbGFzcyIsImRlY29yYXRvciIsImRlY29yYXRlTWVtYmVyIiwib2JqZWN0Iiwib3RoZXJBcmdzIiwiZGVjb3JhdG9yVGFyZ2V0VHlwZSIsImRlY29yYXRvclR5cGUiLCJkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZSIsImRlY29yYXRvcnNGb3JUeXBlIiwiZGVjb3JhdG9yc0ZvcktleSIsImRlY29yYXRlIiwiYXJncyIsIk1peGluIiwiY29uc3RydWN0b3JzIiwicHJvdG90eXBlcyIsImluaXRGdW5jdGlvbk5hbWUiLCJpbml0RnVuY3Rpb25zIiwiZnVuYyIsImNvbWJpbmVkSW5pdEZ1bmN0aW9uIiwiYXBwbHkiLCJleHRyYVByb3RvIiwiTWl4ZWRDbGFzcyIsIkZ1bmN0aW9uIiwiRGVjb3JhdGVkTWl4ZWRDbGFzcyIsInJlc3VsdCIsImFwcGx5UHJvcEFuZE1ldGhvZERlY29yYXRvcnMiLCJwcm9wQW5kTWV0aG9kRGVjb3JhdG9ycyIsInRhcmdldCIsInByb3BEZWNvcmF0b3JzIiwibWV0aG9kRGVjb3JhdG9ycyIsIm1peCIsImRlY29yYXRlZENsYXNzIiwidmFsdWUiLCJuYW1lIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ts-mixer/dist/esm/index.js\n");

/***/ })

};
;