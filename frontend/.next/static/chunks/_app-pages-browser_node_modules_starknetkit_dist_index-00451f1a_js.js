"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_starknetkit_dist_index-00451f1a_js"],{

/***/ "(app-pages-browser)/./node_modules/starknetkit/dist/index-00451f1a.js":
/*!*********************************************************!*\
  !*** ./node_modules/starknetkit/dist/index-00451f1a.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getStarknetWindowObject: function() { return /* binding */ Y_; }\n/* harmony export */ });\n/* harmony import */ var _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lastConnected-b964dc30.js */ \"(app-pages-browser)/./node_modules/starknetkit/dist/lastConnected-b964dc30.js\");\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! starknet */ \"(app-pages-browser)/./node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _index_70f373da_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-70f373da.js */ \"(app-pages-browser)/./node_modules/starknetkit/dist/index-70f373da.js\");\n/* harmony import */ var _publicRcpNodes_be041588_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./publicRcpNodes-be041588.js */ \"(app-pages-browser)/./node_modules/starknetkit/dist/publicRcpNodes-be041588.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar Au = Object.defineProperty;\nvar Tu = (i, e, t) => e in i ? Au(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;\nvar we = (i, e, t) => (Tu(i, typeof e != \"symbol\" ? e + \"\" : e, t), t);\n\n\n\n\nvar sn = { exports: {} }, $i = typeof Reflect == \"object\" ? Reflect : null, Bn = $i && typeof $i.apply == \"function\" ? $i.apply : function(e, t, s) {\n  return Function.prototype.apply.call(e, t, s);\n}, qs;\n$i && typeof $i.ownKeys == \"function\" ? qs = $i.ownKeys : Object.getOwnPropertySymbols ? qs = function(e) {\n  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));\n} : qs = function(e) {\n  return Object.getOwnPropertyNames(e);\n};\nfunction Lu(i) {\n  console && console.warn && console.warn(i);\n}\nvar Ya = Number.isNaN || function(e) {\n  return e !== e;\n};\nfunction Oe() {\n  Oe.init.call(this);\n}\nsn.exports = Oe;\nsn.exports.once = zu;\nOe.EventEmitter = Oe;\nOe.prototype._events = void 0;\nOe.prototype._eventsCount = 0;\nOe.prototype._maxListeners = void 0;\nvar kn = 10;\nfunction tr(i) {\n  if (typeof i != \"function\")\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof i);\n}\nObject.defineProperty(Oe, \"defaultMaxListeners\", {\n  enumerable: !0,\n  get: function() {\n    return kn;\n  },\n  set: function(i) {\n    if (typeof i != \"number\" || i < 0 || Ya(i))\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + i + \".\");\n    kn = i;\n  }\n});\nOe.init = function() {\n  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;\n};\nOe.prototype.setMaxListeners = function(e) {\n  if (typeof e != \"number\" || e < 0 || Ya(e))\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + e + \".\");\n  return this._maxListeners = e, this;\n};\nfunction Ja(i) {\n  return i._maxListeners === void 0 ? Oe.defaultMaxListeners : i._maxListeners;\n}\nOe.prototype.getMaxListeners = function() {\n  return Ja(this);\n};\nOe.prototype.emit = function(e) {\n  for (var t = [], s = 1; s < arguments.length; s++)\n    t.push(arguments[s]);\n  var r = e === \"error\", n = this._events;\n  if (n !== void 0)\n    r = r && n.error === void 0;\n  else if (!r)\n    return !1;\n  if (r) {\n    var o;\n    if (t.length > 0 && (o = t[0]), o instanceof Error)\n      throw o;\n    var c = new Error(\"Unhandled error.\" + (o ? \" (\" + o.message + \")\" : \"\"));\n    throw c.context = o, c;\n  }\n  var u = n[e];\n  if (u === void 0)\n    return !1;\n  if (typeof u == \"function\")\n    Bn(u, this, t);\n  else\n    for (var d = u.length, p = tc(u, d), s = 0; s < d; ++s)\n      Bn(p[s], this, t);\n  return !0;\n};\nfunction Qa(i, e, t, s) {\n  var r, n, o;\n  if (tr(t), n = i._events, n === void 0 ? (n = i._events = /* @__PURE__ */ Object.create(null), i._eventsCount = 0) : (n.newListener !== void 0 && (i.emit(\n    \"newListener\",\n    e,\n    t.listener ? t.listener : t\n  ), n = i._events), o = n[e]), o === void 0)\n    o = n[e] = t, ++i._eventsCount;\n  else if (typeof o == \"function\" ? o = n[e] = s ? [t, o] : [o, t] : s ? o.unshift(t) : o.push(t), r = Ja(i), r > 0 && o.length > r && !o.warned) {\n    o.warned = !0;\n    var c = new Error(\"Possible EventEmitter memory leak detected. \" + o.length + \" \" + String(e) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n    c.name = \"MaxListenersExceededWarning\", c.emitter = i, c.type = e, c.count = o.length, Lu(c);\n  }\n  return i;\n}\nOe.prototype.addListener = function(e, t) {\n  return Qa(this, e, t, !1);\n};\nOe.prototype.on = Oe.prototype.addListener;\nOe.prototype.prependListener = function(e, t) {\n  return Qa(this, e, t, !0);\n};\nfunction Mu() {\n  if (!this.fired)\n    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);\n}\nfunction Xa(i, e, t) {\n  var s = { fired: !1, wrapFn: void 0, target: i, type: e, listener: t }, r = Mu.bind(s);\n  return r.listener = t, s.wrapFn = r, r;\n}\nOe.prototype.once = function(e, t) {\n  return tr(t), this.on(e, Xa(this, e, t)), this;\n};\nOe.prototype.prependOnceListener = function(e, t) {\n  return tr(t), this.prependListener(e, Xa(this, e, t)), this;\n};\nOe.prototype.removeListener = function(e, t) {\n  var s, r, n, o, c;\n  if (tr(t), r = this._events, r === void 0)\n    return this;\n  if (s = r[e], s === void 0)\n    return this;\n  if (s === t || s.listener === t)\n    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete r[e], r.removeListener && this.emit(\"removeListener\", e, s.listener || t));\n  else if (typeof s != \"function\") {\n    for (n = -1, o = s.length - 1; o >= 0; o--)\n      if (s[o] === t || s[o].listener === t) {\n        c = s[o].listener, n = o;\n        break;\n      }\n    if (n < 0)\n      return this;\n    n === 0 ? s.shift() : qu(s, n), s.length === 1 && (r[e] = s[0]), r.removeListener !== void 0 && this.emit(\"removeListener\", e, c || t);\n  }\n  return this;\n};\nOe.prototype.off = Oe.prototype.removeListener;\nOe.prototype.removeAllListeners = function(e) {\n  var t, s, r;\n  if (s = this._events, s === void 0)\n    return this;\n  if (s.removeListener === void 0)\n    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : s[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete s[e]), this;\n  if (arguments.length === 0) {\n    var n = Object.keys(s), o;\n    for (r = 0; r < n.length; ++r)\n      o = n[r], o !== \"removeListener\" && this.removeAllListeners(o);\n    return this.removeAllListeners(\"removeListener\"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;\n  }\n  if (t = s[e], typeof t == \"function\")\n    this.removeListener(e, t);\n  else if (t !== void 0)\n    for (r = t.length - 1; r >= 0; r--)\n      this.removeListener(e, t[r]);\n  return this;\n};\nfunction Za(i, e, t) {\n  var s = i._events;\n  if (s === void 0)\n    return [];\n  var r = s[e];\n  return r === void 0 ? [] : typeof r == \"function\" ? t ? [r.listener || r] : [r] : t ? ju(r) : tc(r, r.length);\n}\nOe.prototype.listeners = function(e) {\n  return Za(this, e, !0);\n};\nOe.prototype.rawListeners = function(e) {\n  return Za(this, e, !1);\n};\nOe.listenerCount = function(i, e) {\n  return typeof i.listenerCount == \"function\" ? i.listenerCount(e) : ec.call(i, e);\n};\nOe.prototype.listenerCount = ec;\nfunction ec(i) {\n  var e = this._events;\n  if (e !== void 0) {\n    var t = e[i];\n    if (typeof t == \"function\")\n      return 1;\n    if (t !== void 0)\n      return t.length;\n  }\n  return 0;\n}\nOe.prototype.eventNames = function() {\n  return this._eventsCount > 0 ? qs(this._events) : [];\n};\nfunction tc(i, e) {\n  for (var t = new Array(e), s = 0; s < e; ++s)\n    t[s] = i[s];\n  return t;\n}\nfunction qu(i, e) {\n  for (; e + 1 < i.length; e++)\n    i[e] = i[e + 1];\n  i.pop();\n}\nfunction ju(i) {\n  for (var e = new Array(i.length), t = 0; t < e.length; ++t)\n    e[t] = i[t].listener || i[t];\n  return e;\n}\nfunction zu(i, e) {\n  return new Promise(function(t, s) {\n    function r(o) {\n      i.removeListener(e, n), s(o);\n    }\n    function n() {\n      typeof i.removeListener == \"function\" && i.removeListener(\"error\", r), t([].slice.call(arguments));\n    }\n    ic(i, e, n, { once: !0 }), e !== \"error\" && Ku(i, r, { once: !0 });\n  });\n}\nfunction Ku(i, e, t) {\n  typeof i.on == \"function\" && ic(i, \"error\", e, t);\n}\nfunction ic(i, e, t, s) {\n  if (typeof i.on == \"function\")\n    s.once ? i.once(e, t) : i.on(e, t);\n  else if (typeof i.addEventListener == \"function\")\n    i.addEventListener(e, function r(n) {\n      s.once && i.removeEventListener(e, r), t(n);\n    });\n  else\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof i);\n}\nvar We = sn.exports;\nconst ir = /* @__PURE__ */ (0,_lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.e)(We);\nvar sr = {}, sc = { exports: {} };\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n(function(i) {\n  var e, t, s, r, n, o, c, u, d, p, b, x, O, _, C, F, K, I, D, y, w, f, a;\n  (function(l) {\n    var L = typeof _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c == \"object\" ? _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c : typeof self == \"object\" ? self : typeof this == \"object\" ? this : {};\n    l(v(L, v(i.exports)));\n    function v(R, $) {\n      return R !== L && (typeof Object.create == \"function\" ? Object.defineProperty(R, \"__esModule\", { value: !0 }) : R.__esModule = !0), function(q, m) {\n        return R[q] = $ ? $(q, m) : m;\n      };\n    }\n  })(function(l) {\n    var L = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, R) {\n      v.__proto__ = R;\n    } || function(v, R) {\n      for (var $ in R)\n        R.hasOwnProperty($) && (v[$] = R[$]);\n    };\n    e = function(v, R) {\n      L(v, R);\n      function $() {\n        this.constructor = v;\n      }\n      v.prototype = R === null ? Object.create(R) : ($.prototype = R.prototype, new $());\n    }, t = Object.assign || function(v) {\n      for (var R, $ = 1, q = arguments.length; $ < q; $++) {\n        R = arguments[$];\n        for (var m in R)\n          Object.prototype.hasOwnProperty.call(R, m) && (v[m] = R[m]);\n      }\n      return v;\n    }, s = function(v, R) {\n      var $ = {};\n      for (var q in v)\n        Object.prototype.hasOwnProperty.call(v, q) && R.indexOf(q) < 0 && ($[q] = v[q]);\n      if (v != null && typeof Object.getOwnPropertySymbols == \"function\")\n        for (var m = 0, q = Object.getOwnPropertySymbols(v); m < q.length; m++)\n          R.indexOf(q[m]) < 0 && Object.prototype.propertyIsEnumerable.call(v, q[m]) && ($[q[m]] = v[q[m]]);\n      return $;\n    }, r = function(v, R, $, q) {\n      var m = arguments.length, E = m < 3 ? R : q === null ? q = Object.getOwnPropertyDescriptor(R, $) : q, B;\n      if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n        E = Reflect.decorate(v, R, $, q);\n      else\n        for (var z = v.length - 1; z >= 0; z--)\n          (B = v[z]) && (E = (m < 3 ? B(E) : m > 3 ? B(R, $, E) : B(R, $)) || E);\n      return m > 3 && E && Object.defineProperty(R, $, E), E;\n    }, n = function(v, R) {\n      return function($, q) {\n        R($, q, v);\n      };\n    }, o = function(v, R) {\n      if (typeof Reflect == \"object\" && typeof Reflect.metadata == \"function\")\n        return Reflect.metadata(v, R);\n    }, c = function(v, R, $, q) {\n      function m(E) {\n        return E instanceof $ ? E : new $(function(B) {\n          B(E);\n        });\n      }\n      return new ($ || ($ = Promise))(function(E, B) {\n        function z(M) {\n          try {\n            U(q.next(M));\n          } catch (H) {\n            B(H);\n          }\n        }\n        function j(M) {\n          try {\n            U(q.throw(M));\n          } catch (H) {\n            B(H);\n          }\n        }\n        function U(M) {\n          M.done ? E(M.value) : m(M.value).then(z, j);\n        }\n        U((q = q.apply(v, R || [])).next());\n      });\n    }, u = function(v, R) {\n      var $ = { label: 0, sent: function() {\n        if (E[0] & 1)\n          throw E[1];\n        return E[1];\n      }, trys: [], ops: [] }, q, m, E, B;\n      return B = { next: z(0), throw: z(1), return: z(2) }, typeof Symbol == \"function\" && (B[Symbol.iterator] = function() {\n        return this;\n      }), B;\n      function z(U) {\n        return function(M) {\n          return j([U, M]);\n        };\n      }\n      function j(U) {\n        if (q)\n          throw new TypeError(\"Generator is already executing.\");\n        for (; $; )\n          try {\n            if (q = 1, m && (E = U[0] & 2 ? m.return : U[0] ? m.throw || ((E = m.return) && E.call(m), 0) : m.next) && !(E = E.call(m, U[1])).done)\n              return E;\n            switch (m = 0, E && (U = [U[0] & 2, E.value]), U[0]) {\n              case 0:\n              case 1:\n                E = U;\n                break;\n              case 4:\n                return $.label++, { value: U[1], done: !1 };\n              case 5:\n                $.label++, m = U[1], U = [0];\n                continue;\n              case 7:\n                U = $.ops.pop(), $.trys.pop();\n                continue;\n              default:\n                if (E = $.trys, !(E = E.length > 0 && E[E.length - 1]) && (U[0] === 6 || U[0] === 2)) {\n                  $ = 0;\n                  continue;\n                }\n                if (U[0] === 3 && (!E || U[1] > E[0] && U[1] < E[3])) {\n                  $.label = U[1];\n                  break;\n                }\n                if (U[0] === 6 && $.label < E[1]) {\n                  $.label = E[1], E = U;\n                  break;\n                }\n                if (E && $.label < E[2]) {\n                  $.label = E[2], $.ops.push(U);\n                  break;\n                }\n                E[2] && $.ops.pop(), $.trys.pop();\n                continue;\n            }\n            U = R.call(v, $);\n          } catch (M) {\n            U = [6, M], m = 0;\n          } finally {\n            q = E = 0;\n          }\n        if (U[0] & 5)\n          throw U[1];\n        return { value: U[0] ? U[1] : void 0, done: !0 };\n      }\n    }, a = function(v, R, $, q) {\n      q === void 0 && (q = $), v[q] = R[$];\n    }, d = function(v, R) {\n      for (var $ in v)\n        $ !== \"default\" && !R.hasOwnProperty($) && (R[$] = v[$]);\n    }, p = function(v) {\n      var R = typeof Symbol == \"function\" && Symbol.iterator, $ = R && v[R], q = 0;\n      if ($)\n        return $.call(v);\n      if (v && typeof v.length == \"number\")\n        return {\n          next: function() {\n            return v && q >= v.length && (v = void 0), { value: v && v[q++], done: !v };\n          }\n        };\n      throw new TypeError(R ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    }, b = function(v, R) {\n      var $ = typeof Symbol == \"function\" && v[Symbol.iterator];\n      if (!$)\n        return v;\n      var q = $.call(v), m, E = [], B;\n      try {\n        for (; (R === void 0 || R-- > 0) && !(m = q.next()).done; )\n          E.push(m.value);\n      } catch (z) {\n        B = { error: z };\n      } finally {\n        try {\n          m && !m.done && ($ = q.return) && $.call(q);\n        } finally {\n          if (B)\n            throw B.error;\n        }\n      }\n      return E;\n    }, x = function() {\n      for (var v = [], R = 0; R < arguments.length; R++)\n        v = v.concat(b(arguments[R]));\n      return v;\n    }, O = function() {\n      for (var v = 0, R = 0, $ = arguments.length; R < $; R++)\n        v += arguments[R].length;\n      for (var q = Array(v), m = 0, R = 0; R < $; R++)\n        for (var E = arguments[R], B = 0, z = E.length; B < z; B++, m++)\n          q[m] = E[B];\n      return q;\n    }, _ = function(v) {\n      return this instanceof _ ? (this.v = v, this) : new _(v);\n    }, C = function(v, R, $) {\n      if (!Symbol.asyncIterator)\n        throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n      var q = $.apply(v, R || []), m, E = [];\n      return m = {}, B(\"next\"), B(\"throw\"), B(\"return\"), m[Symbol.asyncIterator] = function() {\n        return this;\n      }, m;\n      function B(te) {\n        q[te] && (m[te] = function(G) {\n          return new Promise(function(ie, Q) {\n            E.push([te, G, ie, Q]) > 1 || z(te, G);\n          });\n        });\n      }\n      function z(te, G) {\n        try {\n          j(q[te](G));\n        } catch (ie) {\n          H(E[0][3], ie);\n        }\n      }\n      function j(te) {\n        te.value instanceof _ ? Promise.resolve(te.value.v).then(U, M) : H(E[0][2], te);\n      }\n      function U(te) {\n        z(\"next\", te);\n      }\n      function M(te) {\n        z(\"throw\", te);\n      }\n      function H(te, G) {\n        te(G), E.shift(), E.length && z(E[0][0], E[0][1]);\n      }\n    }, F = function(v) {\n      var R, $;\n      return R = {}, q(\"next\"), q(\"throw\", function(m) {\n        throw m;\n      }), q(\"return\"), R[Symbol.iterator] = function() {\n        return this;\n      }, R;\n      function q(m, E) {\n        R[m] = v[m] ? function(B) {\n          return ($ = !$) ? { value: _(v[m](B)), done: m === \"return\" } : E ? E(B) : B;\n        } : E;\n      }\n    }, K = function(v) {\n      if (!Symbol.asyncIterator)\n        throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n      var R = v[Symbol.asyncIterator], $;\n      return R ? R.call(v) : (v = typeof p == \"function\" ? p(v) : v[Symbol.iterator](), $ = {}, q(\"next\"), q(\"throw\"), q(\"return\"), $[Symbol.asyncIterator] = function() {\n        return this;\n      }, $);\n      function q(E) {\n        $[E] = v[E] && function(B) {\n          return new Promise(function(z, j) {\n            B = v[E](B), m(z, j, B.done, B.value);\n          });\n        };\n      }\n      function m(E, B, z, j) {\n        Promise.resolve(j).then(function(U) {\n          E({ value: U, done: z });\n        }, B);\n      }\n    }, I = function(v, R) {\n      return Object.defineProperty ? Object.defineProperty(v, \"raw\", { value: R }) : v.raw = R, v;\n    }, D = function(v) {\n      if (v && v.__esModule)\n        return v;\n      var R = {};\n      if (v != null)\n        for (var $ in v)\n          Object.hasOwnProperty.call(v, $) && (R[$] = v[$]);\n      return R.default = v, R;\n    }, y = function(v) {\n      return v && v.__esModule ? v : { default: v };\n    }, w = function(v, R) {\n      if (!R.has(v))\n        throw new TypeError(\"attempted to get private field on non-instance\");\n      return R.get(v);\n    }, f = function(v, R, $) {\n      if (!R.has(v))\n        throw new TypeError(\"attempted to set private field on non-instance\");\n      return R.set(v, $), $;\n    }, l(\"__extends\", e), l(\"__assign\", t), l(\"__rest\", s), l(\"__decorate\", r), l(\"__param\", n), l(\"__metadata\", o), l(\"__awaiter\", c), l(\"__generator\", u), l(\"__exportStar\", d), l(\"__createBinding\", a), l(\"__values\", p), l(\"__read\", b), l(\"__spread\", x), l(\"__spreadArrays\", O), l(\"__await\", _), l(\"__asyncGenerator\", C), l(\"__asyncDelegator\", F), l(\"__asyncValues\", K), l(\"__makeTemplateObject\", I), l(\"__importStar\", D), l(\"__importDefault\", y), l(\"__classPrivateFieldGet\", w), l(\"__classPrivateFieldSet\", f);\n  });\n})(sc);\nvar Ft = sc.exports, fs = {};\nObject.defineProperty(fs, \"__esModule\", { value: !0 });\nfunction Vu(i) {\n  if (typeof i != \"string\")\n    throw new Error(`Cannot safe json parse value of type ${typeof i}`);\n  try {\n    return JSON.parse(i);\n  } catch {\n    return i;\n  }\n}\nfs.safeJsonParse = Vu;\nfunction Bu(i) {\n  return typeof i == \"string\" ? i : JSON.stringify(i, (e, t) => typeof t > \"u\" ? null : t);\n}\nfs.safeJsonStringify = Bu;\nvar ki = { exports: {} }, Hn;\nfunction ku() {\n  return Hn || (Hn = 1, function() {\n    let i;\n    function e() {\n    }\n    i = e, i.prototype.getItem = function(t) {\n      return this.hasOwnProperty(t) ? String(this[t]) : null;\n    }, i.prototype.setItem = function(t, s) {\n      this[t] = String(s);\n    }, i.prototype.removeItem = function(t) {\n      delete this[t];\n    }, i.prototype.clear = function() {\n      const t = this;\n      Object.keys(t).forEach(function(s) {\n        t[s] = void 0, delete t[s];\n      });\n    }, i.prototype.key = function(t) {\n      return t = t || 0, Object.keys(this)[t];\n    }, i.prototype.__defineGetter__(\"length\", function() {\n      return Object.keys(this).length;\n    }), typeof _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c < \"u\" && _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c.localStorage ? ki.exports = _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c.localStorage : typeof window < \"u\" && window.localStorage ? ki.exports = window.localStorage : ki.exports = new e();\n  }()), ki.exports;\n}\nvar yr = {}, Hi = {}, Gn;\nfunction Hu() {\n  if (Gn)\n    return Hi;\n  Gn = 1, Object.defineProperty(Hi, \"__esModule\", { value: !0 }), Hi.IKeyValueStorage = void 0;\n  class i {\n  }\n  return Hi.IKeyValueStorage = i, Hi;\n}\nvar Gi = {}, Wn;\nfunction Gu() {\n  if (Wn)\n    return Gi;\n  Wn = 1, Object.defineProperty(Gi, \"__esModule\", { value: !0 }), Gi.parseEntry = void 0;\n  const i = fs;\n  function e(t) {\n    var s;\n    return [t[0], i.safeJsonParse((s = t[1]) !== null && s !== void 0 ? s : \"\")];\n  }\n  return Gi.parseEntry = e, Gi;\n}\nvar Yn;\nfunction Wu() {\n  return Yn || (Yn = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 });\n    const e = Ft;\n    e.__exportStar(Hu(), i), e.__exportStar(Gu(), i);\n  }(yr)), yr;\n}\nObject.defineProperty(sr, \"__esModule\", { value: !0 });\nsr.KeyValueStorage = void 0;\nconst Ci = Ft, Jn = fs, Yu = Ci.__importDefault(ku()), Ju = Wu();\nclass rc {\n  constructor() {\n    this.localStorage = Yu.default;\n  }\n  getKeys() {\n    return Ci.__awaiter(this, void 0, void 0, function* () {\n      return Object.keys(this.localStorage);\n    });\n  }\n  getEntries() {\n    return Ci.__awaiter(this, void 0, void 0, function* () {\n      return Object.entries(this.localStorage).map(Ju.parseEntry);\n    });\n  }\n  getItem(e) {\n    return Ci.__awaiter(this, void 0, void 0, function* () {\n      const t = this.localStorage.getItem(e);\n      if (t !== null)\n        return Jn.safeJsonParse(t);\n    });\n  }\n  setItem(e, t) {\n    return Ci.__awaiter(this, void 0, void 0, function* () {\n      this.localStorage.setItem(e, Jn.safeJsonStringify(t));\n    });\n  }\n  removeItem(e) {\n    return Ci.__awaiter(this, void 0, void 0, function* () {\n      this.localStorage.removeItem(e);\n    });\n  }\n}\nsr.KeyValueStorage = rc;\nvar nc = sr.default = rc, Wt = {}, Wi = {}, V = {}, mr = {}, Yi = {}, Qn;\nfunction Qu() {\n  if (Qn)\n    return Yi;\n  Qn = 1, Object.defineProperty(Yi, \"__esModule\", { value: !0 }), Yi.delay = void 0;\n  function i(e) {\n    return new Promise((t) => {\n      setTimeout(() => {\n        t(!0);\n      }, e);\n    });\n  }\n  return Yi.delay = i, Yi;\n}\nvar mi = {}, br = {}, bi = {}, Xn;\nfunction Xu() {\n  return Xn || (Xn = 1, Object.defineProperty(bi, \"__esModule\", { value: !0 }), bi.ONE_THOUSAND = bi.ONE_HUNDRED = void 0, bi.ONE_HUNDRED = 100, bi.ONE_THOUSAND = 1e3), bi;\n}\nvar wr = {}, Zn;\nfunction Zu() {\n  return Zn || (Zn = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 }), i.ONE_YEAR = i.FOUR_WEEKS = i.THREE_WEEKS = i.TWO_WEEKS = i.ONE_WEEK = i.THIRTY_DAYS = i.SEVEN_DAYS = i.FIVE_DAYS = i.THREE_DAYS = i.ONE_DAY = i.TWENTY_FOUR_HOURS = i.TWELVE_HOURS = i.SIX_HOURS = i.THREE_HOURS = i.ONE_HOUR = i.SIXTY_MINUTES = i.THIRTY_MINUTES = i.TEN_MINUTES = i.FIVE_MINUTES = i.ONE_MINUTE = i.SIXTY_SECONDS = i.THIRTY_SECONDS = i.TEN_SECONDS = i.FIVE_SECONDS = i.ONE_SECOND = void 0, i.ONE_SECOND = 1, i.FIVE_SECONDS = 5, i.TEN_SECONDS = 10, i.THIRTY_SECONDS = 30, i.SIXTY_SECONDS = 60, i.ONE_MINUTE = i.SIXTY_SECONDS, i.FIVE_MINUTES = i.ONE_MINUTE * 5, i.TEN_MINUTES = i.ONE_MINUTE * 10, i.THIRTY_MINUTES = i.ONE_MINUTE * 30, i.SIXTY_MINUTES = i.ONE_MINUTE * 60, i.ONE_HOUR = i.SIXTY_MINUTES, i.THREE_HOURS = i.ONE_HOUR * 3, i.SIX_HOURS = i.ONE_HOUR * 6, i.TWELVE_HOURS = i.ONE_HOUR * 12, i.TWENTY_FOUR_HOURS = i.ONE_HOUR * 24, i.ONE_DAY = i.TWENTY_FOUR_HOURS, i.THREE_DAYS = i.ONE_DAY * 3, i.FIVE_DAYS = i.ONE_DAY * 5, i.SEVEN_DAYS = i.ONE_DAY * 7, i.THIRTY_DAYS = i.ONE_DAY * 30, i.ONE_WEEK = i.SEVEN_DAYS, i.TWO_WEEKS = i.ONE_WEEK * 2, i.THREE_WEEKS = i.ONE_WEEK * 3, i.FOUR_WEEKS = i.ONE_WEEK * 4, i.ONE_YEAR = i.ONE_DAY * 365;\n  }(wr)), wr;\n}\nvar eo;\nfunction oc() {\n  return eo || (eo = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 });\n    const e = Ft;\n    e.__exportStar(Xu(), i), e.__exportStar(Zu(), i);\n  }(br)), br;\n}\nvar to;\nfunction el() {\n  if (to)\n    return mi;\n  to = 1, Object.defineProperty(mi, \"__esModule\", { value: !0 }), mi.fromMiliseconds = mi.toMiliseconds = void 0;\n  const i = oc();\n  function e(s) {\n    return s * i.ONE_THOUSAND;\n  }\n  mi.toMiliseconds = e;\n  function t(s) {\n    return Math.floor(s / i.ONE_THOUSAND);\n  }\n  return mi.fromMiliseconds = t, mi;\n}\nvar io;\nfunction tl() {\n  return io || (io = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 });\n    const e = Ft;\n    e.__exportStar(Qu(), i), e.__exportStar(el(), i);\n  }(mr)), mr;\n}\nvar Ri = {}, so;\nfunction il() {\n  if (so)\n    return Ri;\n  so = 1, Object.defineProperty(Ri, \"__esModule\", { value: !0 }), Ri.Watch = void 0;\n  class i {\n    constructor() {\n      this.timestamps = /* @__PURE__ */ new Map();\n    }\n    start(t) {\n      if (this.timestamps.has(t))\n        throw new Error(`Watch already started for label: ${t}`);\n      this.timestamps.set(t, { started: Date.now() });\n    }\n    stop(t) {\n      const s = this.get(t);\n      if (typeof s.elapsed < \"u\")\n        throw new Error(`Watch already stopped for label: ${t}`);\n      const r = Date.now() - s.started;\n      this.timestamps.set(t, { started: s.started, elapsed: r });\n    }\n    get(t) {\n      const s = this.timestamps.get(t);\n      if (typeof s > \"u\")\n        throw new Error(`No timestamp found for label: ${t}`);\n      return s;\n    }\n    elapsed(t) {\n      const s = this.get(t);\n      return s.elapsed || Date.now() - s.started;\n    }\n  }\n  return Ri.Watch = i, Ri.default = i, Ri;\n}\nvar vr = {}, Ji = {}, ro;\nfunction sl() {\n  if (ro)\n    return Ji;\n  ro = 1, Object.defineProperty(Ji, \"__esModule\", { value: !0 }), Ji.IWatch = void 0;\n  class i {\n  }\n  return Ji.IWatch = i, Ji;\n}\nvar no;\nfunction rl() {\n  return no || (no = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 }), Ft.__exportStar(sl(), i);\n  }(vr)), vr;\n}\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  const e = Ft;\n  e.__exportStar(tl(), i), e.__exportStar(il(), i), e.__exportStar(rl(), i), e.__exportStar(oc(), i);\n})(V);\nvar _r = {}, Qi = {};\nlet Nt = class {\n};\nconst nl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  IEvents: Nt\n}, Symbol.toStringTag, { value: \"Module\" })), ol = /* @__PURE__ */ (0,_lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.g)(nl);\nvar oo;\nfunction al() {\n  if (oo)\n    return Qi;\n  oo = 1, Object.defineProperty(Qi, \"__esModule\", { value: !0 }), Qi.IHeartBeat = void 0;\n  const i = ol;\n  class e extends i.IEvents {\n    constructor(s) {\n      super();\n    }\n  }\n  return Qi.IHeartBeat = e, Qi;\n}\nvar ao;\nfunction ac() {\n  return ao || (ao = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 }), Ft.__exportStar(al(), i);\n  }(_r)), _r;\n}\nvar Er = {}, wi = {}, co;\nfunction cl() {\n  if (co)\n    return wi;\n  co = 1, Object.defineProperty(wi, \"__esModule\", { value: !0 }), wi.HEARTBEAT_EVENTS = wi.HEARTBEAT_INTERVAL = void 0;\n  const i = V;\n  return wi.HEARTBEAT_INTERVAL = i.FIVE_SECONDS, wi.HEARTBEAT_EVENTS = {\n    pulse: \"heartbeat_pulse\"\n  }, wi;\n}\nvar ho;\nfunction cc() {\n  return ho || (ho = 1, function(i) {\n    Object.defineProperty(i, \"__esModule\", { value: !0 }), Ft.__exportStar(cl(), i);\n  }(Er)), Er;\n}\nvar uo;\nfunction hl() {\n  if (uo)\n    return Wi;\n  uo = 1, Object.defineProperty(Wi, \"__esModule\", { value: !0 }), Wi.HeartBeat = void 0;\n  const i = Ft, e = We, t = V, s = ac(), r = cc();\n  class n extends s.IHeartBeat {\n    constructor(c) {\n      super(c), this.events = new e.EventEmitter(), this.interval = r.HEARTBEAT_INTERVAL, this.interval = c?.interval || r.HEARTBEAT_INTERVAL;\n    }\n    static init(c) {\n      return i.__awaiter(this, void 0, void 0, function* () {\n        const u = new n(c);\n        return yield u.init(), u;\n      });\n    }\n    init() {\n      return i.__awaiter(this, void 0, void 0, function* () {\n        yield this.initialize();\n      });\n    }\n    stop() {\n      clearInterval(this.intervalRef);\n    }\n    on(c, u) {\n      this.events.on(c, u);\n    }\n    once(c, u) {\n      this.events.once(c, u);\n    }\n    off(c, u) {\n      this.events.off(c, u);\n    }\n    removeListener(c, u) {\n      this.events.removeListener(c, u);\n    }\n    initialize() {\n      return i.__awaiter(this, void 0, void 0, function* () {\n        this.intervalRef = setInterval(() => this.pulse(), t.toMiliseconds(this.interval));\n      });\n    }\n    pulse() {\n      this.events.emit(r.HEARTBEAT_EVENTS.pulse);\n    }\n  }\n  return Wi.HeartBeat = n, Wi;\n}\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  const e = Ft;\n  e.__exportStar(hl(), i), e.__exportStar(ac(), i), e.__exportStar(cc(), i);\n})(Wt);\nvar ee = {}, Sr, lo;\nfunction ul() {\n  if (lo)\n    return Sr;\n  lo = 1;\n  function i(t) {\n    try {\n      return JSON.stringify(t);\n    } catch {\n      return '\"[Circular]\"';\n    }\n  }\n  Sr = e;\n  function e(t, s, r) {\n    var n = r && r.stringify || i, o = 1;\n    if (typeof t == \"object\" && t !== null) {\n      var c = s.length + o;\n      if (c === 1)\n        return t;\n      var u = new Array(c);\n      u[0] = n(t);\n      for (var d = 1; d < c; d++)\n        u[d] = n(s[d]);\n      return u.join(\" \");\n    }\n    if (typeof t != \"string\")\n      return t;\n    var p = s.length;\n    if (p === 0)\n      return t;\n    for (var b = \"\", x = 1 - o, O = -1, _ = t && t.length || 0, C = 0; C < _; ) {\n      if (t.charCodeAt(C) === 37 && C + 1 < _) {\n        switch (O = O > -1 ? O : 0, t.charCodeAt(C + 1)) {\n          case 100:\n          case 102:\n            if (x >= p || s[x] == null)\n              break;\n            O < C && (b += t.slice(O, C)), b += Number(s[x]), O = C + 2, C++;\n            break;\n          case 105:\n            if (x >= p || s[x] == null)\n              break;\n            O < C && (b += t.slice(O, C)), b += Math.floor(Number(s[x])), O = C + 2, C++;\n            break;\n          case 79:\n          case 111:\n          case 106:\n            if (x >= p || s[x] === void 0)\n              break;\n            O < C && (b += t.slice(O, C));\n            var F = typeof s[x];\n            if (F === \"string\") {\n              b += \"'\" + s[x] + \"'\", O = C + 2, C++;\n              break;\n            }\n            if (F === \"function\") {\n              b += s[x].name || \"<anonymous>\", O = C + 2, C++;\n              break;\n            }\n            b += n(s[x]), O = C + 2, C++;\n            break;\n          case 115:\n            if (x >= p)\n              break;\n            O < C && (b += t.slice(O, C)), b += String(s[x]), O = C + 2, C++;\n            break;\n          case 37:\n            O < C && (b += t.slice(O, C)), b += \"%\", O = C + 2, C++, x--;\n            break;\n        }\n        ++x;\n      }\n      ++C;\n    }\n    return O === -1 ? t : (O < _ && (b += t.slice(O)), b);\n  }\n  return Sr;\n}\nvar Ir, fo;\nfunction ll() {\n  if (fo)\n    return Ir;\n  fo = 1;\n  const i = ul();\n  Ir = r;\n  const e = w().console || {}, t = {\n    mapHttpRequest: _,\n    mapHttpResponse: _,\n    wrapRequestSerializer: C,\n    wrapResponseSerializer: C,\n    wrapErrorSerializer: C,\n    req: _,\n    res: _,\n    err: x\n  };\n  function s(f, a) {\n    return Array.isArray(f) ? f.filter(function(L) {\n      return L !== \"!stdSerializers.err\";\n    }) : f === !0 ? Object.keys(a) : !1;\n  }\n  function r(f) {\n    f = f || {}, f.browser = f.browser || {};\n    const a = f.browser.transmit;\n    if (a && typeof a.send != \"function\")\n      throw Error(\"pino: transmit option must have a send function\");\n    const l = f.browser.write || e;\n    f.browser.write && (f.browser.asObject = !0);\n    const L = f.serializers || {}, v = s(f.browser.serialize, L);\n    let R = f.browser.serialize;\n    Array.isArray(f.browser.serialize) && f.browser.serialize.indexOf(\"!stdSerializers.err\") > -1 && (R = !1);\n    const $ = [\"error\", \"fatal\", \"warn\", \"info\", \"debug\", \"trace\"];\n    typeof l == \"function\" && (l.error = l.fatal = l.warn = l.info = l.debug = l.trace = l), f.enabled === !1 && (f.level = \"silent\");\n    const q = f.level || \"info\", m = Object.create(l);\n    m.log || (m.log = F), Object.defineProperty(m, \"levelVal\", {\n      get: B\n    }), Object.defineProperty(m, \"level\", {\n      get: z,\n      set: j\n    });\n    const E = {\n      transmit: a,\n      serialize: v,\n      asObject: f.browser.asObject,\n      levels: $,\n      timestamp: O(f)\n    };\n    m.levels = r.levels, m.level = q, m.setMaxListeners = m.getMaxListeners = m.emit = m.addListener = m.on = m.prependListener = m.once = m.prependOnceListener = m.removeListener = m.removeAllListeners = m.listeners = m.listenerCount = m.eventNames = m.write = m.flush = F, m.serializers = L, m._serialize = v, m._stdErrSerialize = R, m.child = U, a && (m._logEvent = b());\n    function B() {\n      return this.level === \"silent\" ? 1 / 0 : this.levels.values[this.level];\n    }\n    function z() {\n      return this._level;\n    }\n    function j(M) {\n      if (M !== \"silent\" && !this.levels.values[M])\n        throw Error(\"unknown level \" + M);\n      this._level = M, n(E, m, \"error\", \"log\"), n(E, m, \"fatal\", \"error\"), n(E, m, \"warn\", \"error\"), n(E, m, \"info\", \"log\"), n(E, m, \"debug\", \"log\"), n(E, m, \"trace\", \"log\");\n    }\n    function U(M, H) {\n      if (!M)\n        throw new Error(\"missing bindings for child Pino\");\n      H = H || {}, v && M.serializers && (H.serializers = M.serializers);\n      const te = H.serializers;\n      if (v && te) {\n        var G = Object.assign({}, L, te), ie = f.browser.serialize === !0 ? Object.keys(G) : v;\n        delete M.serializers, u([M], ie, G, this._stdErrSerialize);\n      }\n      function Q(se) {\n        this._childLevel = (se._childLevel | 0) + 1, this.error = d(se, M, \"error\"), this.fatal = d(se, M, \"fatal\"), this.warn = d(se, M, \"warn\"), this.info = d(se, M, \"info\"), this.debug = d(se, M, \"debug\"), this.trace = d(se, M, \"trace\"), G && (this.serializers = G, this._serialize = ie), a && (this._logEvent = b(\n          [].concat(se._logEvent.bindings, M)\n        ));\n      }\n      return Q.prototype = this, new Q(this);\n    }\n    return m;\n  }\n  r.levels = {\n    values: {\n      fatal: 60,\n      error: 50,\n      warn: 40,\n      info: 30,\n      debug: 20,\n      trace: 10\n    },\n    labels: {\n      10: \"trace\",\n      20: \"debug\",\n      30: \"info\",\n      40: \"warn\",\n      50: \"error\",\n      60: \"fatal\"\n    }\n  }, r.stdSerializers = t, r.stdTimeFunctions = Object.assign({}, { nullTime: K, epochTime: I, unixTime: D, isoTime: y });\n  function n(f, a, l, L) {\n    const v = Object.getPrototypeOf(a);\n    a[l] = a.levelVal > a.levels.values[l] ? F : v[l] ? v[l] : e[l] || e[L] || F, o(f, a, l);\n  }\n  function o(f, a, l) {\n    !f.transmit && a[l] === F || (a[l] = function(L) {\n      return function() {\n        const R = f.timestamp(), $ = new Array(arguments.length), q = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;\n        for (var m = 0; m < $.length; m++)\n          $[m] = arguments[m];\n        if (f.serialize && !f.asObject && u($, this._serialize, this.serializers, this._stdErrSerialize), f.asObject ? L.call(q, c(this, l, $, R)) : L.apply(q, $), f.transmit) {\n          const E = f.transmit.level || a.level, B = r.levels.values[E], z = r.levels.values[l];\n          if (z < B)\n            return;\n          p(this, {\n            ts: R,\n            methodLevel: l,\n            methodValue: z,\n            transmitLevel: E,\n            transmitValue: r.levels.values[f.transmit.level || a.level],\n            send: f.transmit.send,\n            val: a.levelVal\n          }, $);\n        }\n      };\n    }(a[l]));\n  }\n  function c(f, a, l, L) {\n    f._serialize && u(l, f._serialize, f.serializers, f._stdErrSerialize);\n    const v = l.slice();\n    let R = v[0];\n    const $ = {};\n    L && ($.time = L), $.level = r.levels.values[a];\n    let q = (f._childLevel | 0) + 1;\n    if (q < 1 && (q = 1), R !== null && typeof R == \"object\") {\n      for (; q-- && typeof v[0] == \"object\"; )\n        Object.assign($, v.shift());\n      R = v.length ? i(v.shift(), v) : void 0;\n    } else\n      typeof R == \"string\" && (R = i(v.shift(), v));\n    return R !== void 0 && ($.msg = R), $;\n  }\n  function u(f, a, l, L) {\n    for (const v in f)\n      if (L && f[v] instanceof Error)\n        f[v] = r.stdSerializers.err(f[v]);\n      else if (typeof f[v] == \"object\" && !Array.isArray(f[v]))\n        for (const R in f[v])\n          a && a.indexOf(R) > -1 && R in l && (f[v][R] = l[R](f[v][R]));\n  }\n  function d(f, a, l) {\n    return function() {\n      const L = new Array(1 + arguments.length);\n      L[0] = a;\n      for (var v = 1; v < L.length; v++)\n        L[v] = arguments[v - 1];\n      return f[l].apply(this, L);\n    };\n  }\n  function p(f, a, l) {\n    const L = a.send, v = a.ts, R = a.methodLevel, $ = a.methodValue, q = a.val, m = f._logEvent.bindings;\n    u(\n      l,\n      f._serialize || Object.keys(f.serializers),\n      f.serializers,\n      f._stdErrSerialize === void 0 ? !0 : f._stdErrSerialize\n    ), f._logEvent.ts = v, f._logEvent.messages = l.filter(function(E) {\n      return m.indexOf(E) === -1;\n    }), f._logEvent.level.label = R, f._logEvent.level.value = $, L(R, f._logEvent, q), f._logEvent = b(m);\n  }\n  function b(f) {\n    return {\n      ts: 0,\n      messages: [],\n      bindings: f || [],\n      level: { label: \"\", value: 0 }\n    };\n  }\n  function x(f) {\n    const a = {\n      type: f.constructor.name,\n      msg: f.message,\n      stack: f.stack\n    };\n    for (const l in f)\n      a[l] === void 0 && (a[l] = f[l]);\n    return a;\n  }\n  function O(f) {\n    return typeof f.timestamp == \"function\" ? f.timestamp : f.timestamp === !1 ? K : I;\n  }\n  function _() {\n    return {};\n  }\n  function C(f) {\n    return f;\n  }\n  function F() {\n  }\n  function K() {\n    return !1;\n  }\n  function I() {\n    return Date.now();\n  }\n  function D() {\n    return Math.round(Date.now() / 1e3);\n  }\n  function y() {\n    return new Date(Date.now()).toISOString();\n  }\n  function w() {\n    function f(a) {\n      return typeof a < \"u\" && a;\n    }\n    try {\n      return typeof globalThis < \"u\" || Object.defineProperty(Object.prototype, \"globalThis\", {\n        get: function() {\n          return delete Object.prototype.globalThis, this.globalThis = this;\n        },\n        configurable: !0\n      }), globalThis;\n    } catch {\n      return f(self) || f(window) || f(this) || {};\n    }\n  }\n  return Ir;\n}\nvar vi = {}, po;\nfunction hc() {\n  return po || (po = 1, Object.defineProperty(vi, \"__esModule\", { value: !0 }), vi.PINO_CUSTOM_CONTEXT_KEY = vi.PINO_LOGGER_DEFAULTS = void 0, vi.PINO_LOGGER_DEFAULTS = {\n    level: \"info\"\n  }, vi.PINO_CUSTOM_CONTEXT_KEY = \"custom_context\"), vi;\n}\nvar yt = {}, go;\nfunction dl() {\n  if (go)\n    return yt;\n  go = 1, Object.defineProperty(yt, \"__esModule\", { value: !0 }), yt.generateChildLogger = yt.formatChildLoggerContext = yt.getLoggerContext = yt.setBrowserLoggerContext = yt.getBrowserLoggerContext = yt.getDefaultLoggerOptions = void 0;\n  const i = hc();\n  function e(c) {\n    return Object.assign(Object.assign({}, c), { level: c?.level || i.PINO_LOGGER_DEFAULTS.level });\n  }\n  yt.getDefaultLoggerOptions = e;\n  function t(c, u = i.PINO_CUSTOM_CONTEXT_KEY) {\n    return c[u] || \"\";\n  }\n  yt.getBrowserLoggerContext = t;\n  function s(c, u, d = i.PINO_CUSTOM_CONTEXT_KEY) {\n    return c[d] = u, c;\n  }\n  yt.setBrowserLoggerContext = s;\n  function r(c, u = i.PINO_CUSTOM_CONTEXT_KEY) {\n    let d = \"\";\n    return typeof c.bindings > \"u\" ? d = t(c, u) : d = c.bindings().context || \"\", d;\n  }\n  yt.getLoggerContext = r;\n  function n(c, u, d = i.PINO_CUSTOM_CONTEXT_KEY) {\n    const p = r(c, d);\n    return p.trim() ? `${p}/${u}` : u;\n  }\n  yt.formatChildLoggerContext = n;\n  function o(c, u, d = i.PINO_CUSTOM_CONTEXT_KEY) {\n    const p = n(c, u, d), b = c.child({ context: p });\n    return s(b, p, d);\n  }\n  return yt.generateChildLogger = o, yt;\n}\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 }), i.pino = void 0;\n  const e = Ft, t = e.__importDefault(ll());\n  Object.defineProperty(i, \"pino\", { enumerable: !0, get: function() {\n    return t.default;\n  } }), e.__exportStar(hc(), i), e.__exportStar(dl(), i);\n})(ee);\nlet fl = class extends Nt {\n  constructor(e) {\n    super(), this.opts = e, this.protocol = \"wc\", this.version = 2;\n  }\n}, pl = class extends Nt {\n  constructor(e, t) {\n    super(), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map();\n  }\n}, gl = class {\n  constructor(e, t) {\n    this.logger = e, this.core = t;\n  }\n}, yl = class extends Nt {\n  constructor(e, t) {\n    super(), this.relayer = e, this.logger = t;\n  }\n}, ml = class extends Nt {\n  constructor(e) {\n    super();\n  }\n}, bl = class {\n  constructor(e, t, s, r) {\n    this.core = e, this.logger = t, this.name = s;\n  }\n}, wl = class extends Nt {\n  constructor(e, t) {\n    super(), this.relayer = e, this.logger = t;\n  }\n}, vl = class extends Nt {\n  constructor(e, t) {\n    super(), this.core = e, this.logger = t;\n  }\n}, _l = class {\n  constructor(e, t) {\n    this.projectId = e, this.logger = t;\n  }\n}, El = class {\n  constructor(e) {\n    this.opts = e, this.protocol = \"wc\", this.version = 2;\n  }\n}, Sl = class {\n  constructor(e) {\n    this.client = e;\n  }\n};\nconst Il = (i) => JSON.stringify(i, (e, t) => typeof t == \"bigint\" ? t.toString() + \"n\" : t), Dl = (i) => {\n  const e = /([\\[:])?(\\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\\}\\]])/g, t = i.replace(e, '$1\"$2n\"$3');\n  return JSON.parse(t, (s, r) => typeof r == \"string\" && r.match(/^\\d+n$/) ? BigInt(r.substring(0, r.length - 1)) : r);\n};\nfunction rn(i) {\n  if (typeof i != \"string\")\n    throw new Error(`Cannot safe json parse value of type ${typeof i}`);\n  try {\n    return Dl(i);\n  } catch {\n    return i;\n  }\n}\nfunction rr(i) {\n  return typeof i == \"string\" ? i : Il(i) || \"\";\n}\nvar nn = {}, li = {}, nr = {}, or = {};\nObject.defineProperty(or, \"__esModule\", { value: !0 });\nor.BrowserRandomSource = void 0;\nconst yo = 65536;\nclass xl {\n  constructor() {\n    this.isAvailable = !1, this.isInstantiated = !1;\n    const e = typeof self < \"u\" ? self.crypto || self.msCrypto : null;\n    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);\n  }\n  randomBytes(e) {\n    if (!this.isAvailable || !this._crypto)\n      throw new Error(\"Browser random byte generator is not available.\");\n    const t = new Uint8Array(e);\n    for (let s = 0; s < t.length; s += yo)\n      this._crypto.getRandomValues(t.subarray(s, s + Math.min(t.length - s, yo)));\n    return t;\n  }\n}\nor.BrowserRandomSource = xl;\nfunction Ol(i) {\n  throw new Error('Could not dynamically require \"' + i + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar ar = {}, Pt = {};\nObject.defineProperty(Pt, \"__esModule\", { value: !0 });\nfunction Nl(i) {\n  for (var e = 0; e < i.length; e++)\n    i[e] = 0;\n  return i;\n}\nPt.wipe = Nl;\nconst Pl = {}, Rl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: Pl\n}, Symbol.toStringTag, { value: \"Module\" })), Cl = /* @__PURE__ */ (0,_lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.g)(Rl);\nObject.defineProperty(ar, \"__esModule\", { value: !0 });\nar.NodeRandomSource = void 0;\nconst Al = Pt;\nclass Tl {\n  constructor() {\n    if (this.isAvailable = !1, this.isInstantiated = !1, typeof Ol < \"u\") {\n      const e = Cl;\n      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);\n    }\n  }\n  randomBytes(e) {\n    if (!this.isAvailable || !this._crypto)\n      throw new Error(\"Node.js random byte generator is not available.\");\n    let t = this._crypto.randomBytes(e);\n    if (t.length !== e)\n      throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n    const s = new Uint8Array(e);\n    for (let r = 0; r < s.length; r++)\n      s[r] = t[r];\n    return (0, Al.wipe)(t), s;\n  }\n}\nar.NodeRandomSource = Tl;\nObject.defineProperty(nr, \"__esModule\", { value: !0 });\nnr.SystemRandomSource = void 0;\nconst $l = or, Fl = ar;\nclass Ul {\n  constructor() {\n    if (this.isAvailable = !1, this.name = \"\", this._source = new $l.BrowserRandomSource(), this._source.isAvailable) {\n      this.isAvailable = !0, this.name = \"Browser\";\n      return;\n    }\n    if (this._source = new Fl.NodeRandomSource(), this._source.isAvailable) {\n      this.isAvailable = !0, this.name = \"Node\";\n      return;\n    }\n  }\n  randomBytes(e) {\n    if (!this.isAvailable)\n      throw new Error(\"System random byte generator is not available.\");\n    return this._source.randomBytes(e);\n  }\n}\nnr.SystemRandomSource = Ul;\nvar oe = {}, uc = {};\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  function e(c, u) {\n    var d = c >>> 16 & 65535, p = c & 65535, b = u >>> 16 & 65535, x = u & 65535;\n    return p * x + (d * x + p * b << 16 >>> 0) | 0;\n  }\n  i.mul = Math.imul || e;\n  function t(c, u) {\n    return c + u | 0;\n  }\n  i.add = t;\n  function s(c, u) {\n    return c - u | 0;\n  }\n  i.sub = s;\n  function r(c, u) {\n    return c << u | c >>> 32 - u;\n  }\n  i.rotl = r;\n  function n(c, u) {\n    return c << 32 - u | c >>> u;\n  }\n  i.rotr = n;\n  function o(c) {\n    return typeof c == \"number\" && isFinite(c) && Math.floor(c) === c;\n  }\n  i.isInteger = Number.isInteger || o, i.MAX_SAFE_INTEGER = 9007199254740991, i.isSafeInteger = function(c) {\n    return i.isInteger(c) && c >= -i.MAX_SAFE_INTEGER && c <= i.MAX_SAFE_INTEGER;\n  };\n})(uc);\nObject.defineProperty(oe, \"__esModule\", { value: !0 });\nvar lc = uc;\nfunction Ll(i, e) {\n  return e === void 0 && (e = 0), (i[e + 0] << 8 | i[e + 1]) << 16 >> 16;\n}\noe.readInt16BE = Ll;\nfunction Ml(i, e) {\n  return e === void 0 && (e = 0), (i[e + 0] << 8 | i[e + 1]) >>> 0;\n}\noe.readUint16BE = Ml;\nfunction ql(i, e) {\n  return e === void 0 && (e = 0), (i[e + 1] << 8 | i[e]) << 16 >> 16;\n}\noe.readInt16LE = ql;\nfunction jl(i, e) {\n  return e === void 0 && (e = 0), (i[e + 1] << 8 | i[e]) >>> 0;\n}\noe.readUint16LE = jl;\nfunction dc(i, e, t) {\n  return e === void 0 && (e = new Uint8Array(2)), t === void 0 && (t = 0), e[t + 0] = i >>> 8, e[t + 1] = i >>> 0, e;\n}\noe.writeUint16BE = dc;\noe.writeInt16BE = dc;\nfunction fc(i, e, t) {\n  return e === void 0 && (e = new Uint8Array(2)), t === void 0 && (t = 0), e[t + 0] = i >>> 0, e[t + 1] = i >>> 8, e;\n}\noe.writeUint16LE = fc;\noe.writeInt16LE = fc;\nfunction Mr(i, e) {\n  return e === void 0 && (e = 0), i[e] << 24 | i[e + 1] << 16 | i[e + 2] << 8 | i[e + 3];\n}\noe.readInt32BE = Mr;\nfunction qr(i, e) {\n  return e === void 0 && (e = 0), (i[e] << 24 | i[e + 1] << 16 | i[e + 2] << 8 | i[e + 3]) >>> 0;\n}\noe.readUint32BE = qr;\nfunction jr(i, e) {\n  return e === void 0 && (e = 0), i[e + 3] << 24 | i[e + 2] << 16 | i[e + 1] << 8 | i[e];\n}\noe.readInt32LE = jr;\nfunction zr(i, e) {\n  return e === void 0 && (e = 0), (i[e + 3] << 24 | i[e + 2] << 16 | i[e + 1] << 8 | i[e]) >>> 0;\n}\noe.readUint32LE = zr;\nfunction ks(i, e, t) {\n  return e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0), e[t + 0] = i >>> 24, e[t + 1] = i >>> 16, e[t + 2] = i >>> 8, e[t + 3] = i >>> 0, e;\n}\noe.writeUint32BE = ks;\noe.writeInt32BE = ks;\nfunction Hs(i, e, t) {\n  return e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0), e[t + 0] = i >>> 0, e[t + 1] = i >>> 8, e[t + 2] = i >>> 16, e[t + 3] = i >>> 24, e;\n}\noe.writeUint32LE = Hs;\noe.writeInt32LE = Hs;\nfunction zl(i, e) {\n  e === void 0 && (e = 0);\n  var t = Mr(i, e), s = Mr(i, e + 4);\n  return t * 4294967296 + s - (s >> 31) * 4294967296;\n}\noe.readInt64BE = zl;\nfunction Kl(i, e) {\n  e === void 0 && (e = 0);\n  var t = qr(i, e), s = qr(i, e + 4);\n  return t * 4294967296 + s;\n}\noe.readUint64BE = Kl;\nfunction Vl(i, e) {\n  e === void 0 && (e = 0);\n  var t = jr(i, e), s = jr(i, e + 4);\n  return s * 4294967296 + t - (t >> 31) * 4294967296;\n}\noe.readInt64LE = Vl;\nfunction Bl(i, e) {\n  e === void 0 && (e = 0);\n  var t = zr(i, e), s = zr(i, e + 4);\n  return s * 4294967296 + t;\n}\noe.readUint64LE = Bl;\nfunction pc(i, e, t) {\n  return e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0), ks(i / 4294967296 >>> 0, e, t), ks(i >>> 0, e, t + 4), e;\n}\noe.writeUint64BE = pc;\noe.writeInt64BE = pc;\nfunction gc(i, e, t) {\n  return e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0), Hs(i >>> 0, e, t), Hs(i / 4294967296 >>> 0, e, t + 4), e;\n}\noe.writeUint64LE = gc;\noe.writeInt64LE = gc;\nfunction kl(i, e, t) {\n  if (t === void 0 && (t = 0), i % 8 !== 0)\n    throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n  if (i / 8 > e.length - t)\n    throw new Error(\"readUintBE: array is too short for the given bitLength\");\n  for (var s = 0, r = 1, n = i / 8 + t - 1; n >= t; n--)\n    s += e[n] * r, r *= 256;\n  return s;\n}\noe.readUintBE = kl;\nfunction Hl(i, e, t) {\n  if (t === void 0 && (t = 0), i % 8 !== 0)\n    throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n  if (i / 8 > e.length - t)\n    throw new Error(\"readUintLE: array is too short for the given bitLength\");\n  for (var s = 0, r = 1, n = t; n < t + i / 8; n++)\n    s += e[n] * r, r *= 256;\n  return s;\n}\noe.readUintLE = Hl;\nfunction Gl(i, e, t, s) {\n  if (t === void 0 && (t = new Uint8Array(i / 8)), s === void 0 && (s = 0), i % 8 !== 0)\n    throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n  if (!lc.isSafeInteger(e))\n    throw new Error(\"writeUintBE value must be an integer\");\n  for (var r = 1, n = i / 8 + s - 1; n >= s; n--)\n    t[n] = e / r & 255, r *= 256;\n  return t;\n}\noe.writeUintBE = Gl;\nfunction Wl(i, e, t, s) {\n  if (t === void 0 && (t = new Uint8Array(i / 8)), s === void 0 && (s = 0), i % 8 !== 0)\n    throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n  if (!lc.isSafeInteger(e))\n    throw new Error(\"writeUintLE value must be an integer\");\n  for (var r = 1, n = s; n < s + i / 8; n++)\n    t[n] = e / r & 255, r *= 256;\n  return t;\n}\noe.writeUintLE = Wl;\nfunction Yl(i, e) {\n  e === void 0 && (e = 0);\n  var t = new DataView(i.buffer, i.byteOffset, i.byteLength);\n  return t.getFloat32(e);\n}\noe.readFloat32BE = Yl;\nfunction Jl(i, e) {\n  e === void 0 && (e = 0);\n  var t = new DataView(i.buffer, i.byteOffset, i.byteLength);\n  return t.getFloat32(e, !0);\n}\noe.readFloat32LE = Jl;\nfunction Ql(i, e) {\n  e === void 0 && (e = 0);\n  var t = new DataView(i.buffer, i.byteOffset, i.byteLength);\n  return t.getFloat64(e);\n}\noe.readFloat64BE = Ql;\nfunction Xl(i, e) {\n  e === void 0 && (e = 0);\n  var t = new DataView(i.buffer, i.byteOffset, i.byteLength);\n  return t.getFloat64(e, !0);\n}\noe.readFloat64LE = Xl;\nfunction Zl(i, e, t) {\n  e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0);\n  var s = new DataView(e.buffer, e.byteOffset, e.byteLength);\n  return s.setFloat32(t, i), e;\n}\noe.writeFloat32BE = Zl;\nfunction ed(i, e, t) {\n  e === void 0 && (e = new Uint8Array(4)), t === void 0 && (t = 0);\n  var s = new DataView(e.buffer, e.byteOffset, e.byteLength);\n  return s.setFloat32(t, i, !0), e;\n}\noe.writeFloat32LE = ed;\nfunction td(i, e, t) {\n  e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0);\n  var s = new DataView(e.buffer, e.byteOffset, e.byteLength);\n  return s.setFloat64(t, i), e;\n}\noe.writeFloat64BE = td;\nfunction id(i, e, t) {\n  e === void 0 && (e = new Uint8Array(8)), t === void 0 && (t = 0);\n  var s = new DataView(e.buffer, e.byteOffset, e.byteLength);\n  return s.setFloat64(t, i, !0), e;\n}\noe.writeFloat64LE = id;\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 }), i.randomStringForEntropy = i.randomString = i.randomUint32 = i.randomBytes = i.defaultRandomSource = void 0;\n  const e = nr, t = oe, s = Pt;\n  i.defaultRandomSource = new e.SystemRandomSource();\n  function r(d, p = i.defaultRandomSource) {\n    return p.randomBytes(d);\n  }\n  i.randomBytes = r;\n  function n(d = i.defaultRandomSource) {\n    const p = r(4, d), b = (0, t.readUint32LE)(p);\n    return (0, s.wipe)(p), b;\n  }\n  i.randomUint32 = n;\n  const o = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  function c(d, p = o, b = i.defaultRandomSource) {\n    if (p.length < 2)\n      throw new Error(\"randomString charset is too short\");\n    if (p.length > 256)\n      throw new Error(\"randomString charset is too long\");\n    let x = \"\";\n    const O = p.length, _ = 256 - 256 % O;\n    for (; d > 0; ) {\n      const C = r(Math.ceil(d * 256 / _), b);\n      for (let F = 0; F < C.length && d > 0; F++) {\n        const K = C[F];\n        K < _ && (x += p.charAt(K % O), d--);\n      }\n      (0, s.wipe)(C);\n    }\n    return x;\n  }\n  i.randomString = c;\n  function u(d, p = o, b = i.defaultRandomSource) {\n    const x = Math.ceil(d / (Math.log(p.length) / Math.LN2));\n    return c(x, p, b);\n  }\n  i.randomStringForEntropy = u;\n})(li);\nvar yc = {};\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  var e = oe, t = Pt;\n  i.DIGEST_LENGTH = 64, i.BLOCK_SIZE = 128;\n  var s = (\n    /** @class */\n    function() {\n      function c() {\n        this.digestLength = i.DIGEST_LENGTH, this.blockSize = i.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();\n      }\n      return c.prototype._initState = function() {\n        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;\n      }, c.prototype.reset = function() {\n        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;\n      }, c.prototype.clean = function() {\n        t.wipe(this._buffer), t.wipe(this._tempHi), t.wipe(this._tempLo), this.reset();\n      }, c.prototype.update = function(u, d) {\n        if (d === void 0 && (d = u.length), this._finished)\n          throw new Error(\"SHA512: can't update because hash was finished.\");\n        var p = 0;\n        if (this._bytesHashed += d, this._bufferLength > 0) {\n          for (; this._bufferLength < i.BLOCK_SIZE && d > 0; )\n            this._buffer[this._bufferLength++] = u[p++], d--;\n          this._bufferLength === this.blockSize && (n(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);\n        }\n        for (d >= this.blockSize && (p = n(this._tempHi, this._tempLo, this._stateHi, this._stateLo, u, p, d), d %= this.blockSize); d > 0; )\n          this._buffer[this._bufferLength++] = u[p++], d--;\n        return this;\n      }, c.prototype.finish = function(u) {\n        if (!this._finished) {\n          var d = this._bytesHashed, p = this._bufferLength, b = d / 536870912 | 0, x = d << 3, O = d % 128 < 112 ? 128 : 256;\n          this._buffer[p] = 128;\n          for (var _ = p + 1; _ < O - 8; _++)\n            this._buffer[_] = 0;\n          e.writeUint32BE(b, this._buffer, O - 8), e.writeUint32BE(x, this._buffer, O - 4), n(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, O), this._finished = !0;\n        }\n        for (var _ = 0; _ < this.digestLength / 8; _++)\n          e.writeUint32BE(this._stateHi[_], u, _ * 8), e.writeUint32BE(this._stateLo[_], u, _ * 8 + 4);\n        return this;\n      }, c.prototype.digest = function() {\n        var u = new Uint8Array(this.digestLength);\n        return this.finish(u), u;\n      }, c.prototype.saveState = function() {\n        if (this._finished)\n          throw new Error(\"SHA256: cannot save finished state\");\n        return {\n          stateHi: new Int32Array(this._stateHi),\n          stateLo: new Int32Array(this._stateLo),\n          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,\n          bufferLength: this._bufferLength,\n          bytesHashed: this._bytesHashed\n        };\n      }, c.prototype.restoreState = function(u) {\n        return this._stateHi.set(u.stateHi), this._stateLo.set(u.stateLo), this._bufferLength = u.bufferLength, u.buffer && this._buffer.set(u.buffer), this._bytesHashed = u.bytesHashed, this._finished = !1, this;\n      }, c.prototype.cleanSavedState = function(u) {\n        t.wipe(u.stateHi), t.wipe(u.stateLo), u.buffer && t.wipe(u.buffer), u.bufferLength = 0, u.bytesHashed = 0;\n      }, c;\n    }()\n  );\n  i.SHA512 = s;\n  var r = new Int32Array([\n    1116352408,\n    3609767458,\n    1899447441,\n    602891725,\n    3049323471,\n    3964484399,\n    3921009573,\n    2173295548,\n    961987163,\n    4081628472,\n    1508970993,\n    3053834265,\n    2453635748,\n    2937671579,\n    2870763221,\n    3664609560,\n    3624381080,\n    2734883394,\n    310598401,\n    1164996542,\n    607225278,\n    1323610764,\n    1426881987,\n    3590304994,\n    1925078388,\n    4068182383,\n    2162078206,\n    991336113,\n    2614888103,\n    633803317,\n    3248222580,\n    3479774868,\n    3835390401,\n    2666613458,\n    4022224774,\n    944711139,\n    264347078,\n    2341262773,\n    604807628,\n    2007800933,\n    770255983,\n    1495990901,\n    1249150122,\n    1856431235,\n    1555081692,\n    3175218132,\n    1996064986,\n    2198950837,\n    2554220882,\n    3999719339,\n    2821834349,\n    766784016,\n    2952996808,\n    2566594879,\n    3210313671,\n    3203337956,\n    3336571891,\n    1034457026,\n    3584528711,\n    2466948901,\n    113926993,\n    3758326383,\n    338241895,\n    168717936,\n    666307205,\n    1188179964,\n    773529912,\n    1546045734,\n    1294757372,\n    1522805485,\n    1396182291,\n    2643833823,\n    1695183700,\n    2343527390,\n    1986661051,\n    1014477480,\n    2177026350,\n    1206759142,\n    2456956037,\n    344077627,\n    2730485921,\n    1290863460,\n    2820302411,\n    3158454273,\n    3259730800,\n    3505952657,\n    3345764771,\n    106217008,\n    3516065817,\n    3606008344,\n    3600352804,\n    1432725776,\n    4094571909,\n    1467031594,\n    275423344,\n    851169720,\n    430227734,\n    3100823752,\n    506948616,\n    1363258195,\n    659060556,\n    3750685593,\n    883997877,\n    3785050280,\n    958139571,\n    3318307427,\n    1322822218,\n    3812723403,\n    1537002063,\n    2003034995,\n    1747873779,\n    3602036899,\n    1955562222,\n    1575990012,\n    2024104815,\n    1125592928,\n    2227730452,\n    2716904306,\n    2361852424,\n    442776044,\n    2428436474,\n    593698344,\n    2756734187,\n    3733110249,\n    3204031479,\n    2999351573,\n    3329325298,\n    3815920427,\n    3391569614,\n    3928383900,\n    3515267271,\n    566280711,\n    3940187606,\n    3454069534,\n    4118630271,\n    4000239992,\n    116418474,\n    1914138554,\n    174292421,\n    2731055270,\n    289380356,\n    3203993006,\n    460393269,\n    320620315,\n    685471733,\n    587496836,\n    852142971,\n    1086792851,\n    1017036298,\n    365543100,\n    1126000580,\n    2618297676,\n    1288033470,\n    3409855158,\n    1501505948,\n    4234509866,\n    1607167915,\n    987167468,\n    1816402316,\n    1246189591\n  ]);\n  function n(c, u, d, p, b, x, O) {\n    for (var _ = d[0], C = d[1], F = d[2], K = d[3], I = d[4], D = d[5], y = d[6], w = d[7], f = p[0], a = p[1], l = p[2], L = p[3], v = p[4], R = p[5], $ = p[6], q = p[7], m, E, B, z, j, U, M, H; O >= 128; ) {\n      for (var te = 0; te < 16; te++) {\n        var G = 8 * te + x;\n        c[te] = e.readUint32BE(b, G), u[te] = e.readUint32BE(b, G + 4);\n      }\n      for (var te = 0; te < 80; te++) {\n        var ie = _, Q = C, se = F, T = K, A = I, N = D, h = y, S = w, W = f, X = a, fe = l, ve = L, ge = v, Se = R, Me = $, $e = q;\n        if (m = w, E = q, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = (I >>> 14 | v << 32 - 14) ^ (I >>> 18 | v << 32 - 18) ^ (v >>> 41 - 32 | I << 32 - (41 - 32)), E = (v >>> 14 | I << 32 - 14) ^ (v >>> 18 | I << 32 - 18) ^ (I >>> 41 - 32 | v << 32 - (41 - 32)), j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, m = I & D ^ ~I & y, E = v & R ^ ~v & $, j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, m = r[te * 2], E = r[te * 2 + 1], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, m = c[te % 16], E = u[te % 16], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, B = M & 65535 | H << 16, z = j & 65535 | U << 16, m = B, E = z, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = (_ >>> 28 | f << 32 - 28) ^ (f >>> 34 - 32 | _ << 32 - (34 - 32)) ^ (f >>> 39 - 32 | _ << 32 - (39 - 32)), E = (f >>> 28 | _ << 32 - 28) ^ (_ >>> 34 - 32 | f << 32 - (34 - 32)) ^ (_ >>> 39 - 32 | f << 32 - (39 - 32)), j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, m = _ & C ^ _ & F ^ C & F, E = f & a ^ f & l ^ a & l, j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, S = M & 65535 | H << 16, $e = j & 65535 | U << 16, m = T, E = ve, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = B, E = z, j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, T = M & 65535 | H << 16, ve = j & 65535 | U << 16, C = ie, F = Q, K = se, I = T, D = A, y = N, w = h, _ = S, a = W, l = X, L = fe, v = ve, R = ge, $ = Se, q = Me, f = $e, te % 16 === 15)\n          for (var G = 0; G < 16; G++)\n            m = c[G], E = u[G], j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = c[(G + 9) % 16], E = u[(G + 9) % 16], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, B = c[(G + 1) % 16], z = u[(G + 1) % 16], m = (B >>> 1 | z << 32 - 1) ^ (B >>> 8 | z << 32 - 8) ^ B >>> 7, E = (z >>> 1 | B << 32 - 1) ^ (z >>> 8 | B << 32 - 8) ^ (z >>> 7 | B << 32 - 7), j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, B = c[(G + 14) % 16], z = u[(G + 14) % 16], m = (B >>> 19 | z << 32 - 19) ^ (z >>> 61 - 32 | B << 32 - (61 - 32)) ^ B >>> 6, E = (z >>> 19 | B << 32 - 19) ^ (B >>> 61 - 32 | z << 32 - (61 - 32)) ^ (z >>> 6 | B << 32 - 6), j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, c[G] = M & 65535 | H << 16, u[G] = j & 65535 | U << 16;\n      }\n      m = _, E = f, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[0], E = p[0], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[0] = _ = M & 65535 | H << 16, p[0] = f = j & 65535 | U << 16, m = C, E = a, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[1], E = p[1], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[1] = C = M & 65535 | H << 16, p[1] = a = j & 65535 | U << 16, m = F, E = l, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[2], E = p[2], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[2] = F = M & 65535 | H << 16, p[2] = l = j & 65535 | U << 16, m = K, E = L, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[3], E = p[3], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[3] = K = M & 65535 | H << 16, p[3] = L = j & 65535 | U << 16, m = I, E = v, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[4], E = p[4], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[4] = I = M & 65535 | H << 16, p[4] = v = j & 65535 | U << 16, m = D, E = R, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[5], E = p[5], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[5] = D = M & 65535 | H << 16, p[5] = R = j & 65535 | U << 16, m = y, E = $, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[6], E = p[6], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[6] = y = M & 65535 | H << 16, p[6] = $ = j & 65535 | U << 16, m = w, E = q, j = E & 65535, U = E >>> 16, M = m & 65535, H = m >>> 16, m = d[7], E = p[7], j += E & 65535, U += E >>> 16, M += m & 65535, H += m >>> 16, U += j >>> 16, M += U >>> 16, H += M >>> 16, d[7] = w = M & 65535 | H << 16, p[7] = q = j & 65535 | U << 16, x += 128, O -= 128;\n    }\n    return x;\n  }\n  function o(c) {\n    var u = new s();\n    u.update(c);\n    var d = u.digest();\n    return u.clean(), d;\n  }\n  i.hash = o;\n})(yc);\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 }), i.convertSecretKeyToX25519 = i.convertPublicKeyToX25519 = i.verify = i.sign = i.extractPublicKeyFromSecretKey = i.generateKeyPair = i.generateKeyPairFromSeed = i.SEED_LENGTH = i.SECRET_KEY_LENGTH = i.PUBLIC_KEY_LENGTH = i.SIGNATURE_LENGTH = void 0;\n  const e = li, t = yc, s = Pt;\n  i.SIGNATURE_LENGTH = 64, i.PUBLIC_KEY_LENGTH = 32, i.SECRET_KEY_LENGTH = 64, i.SEED_LENGTH = 32;\n  function r(T) {\n    const A = new Float64Array(16);\n    if (T)\n      for (let N = 0; N < T.length; N++)\n        A[N] = T[N];\n    return A;\n  }\n  const n = new Uint8Array(32);\n  n[0] = 9;\n  const o = r(), c = r([1]), u = r([\n    30883,\n    4953,\n    19914,\n    30187,\n    55467,\n    16705,\n    2637,\n    112,\n    59544,\n    30585,\n    16505,\n    36039,\n    65139,\n    11119,\n    27886,\n    20995\n  ]), d = r([\n    61785,\n    9906,\n    39828,\n    60374,\n    45398,\n    33411,\n    5274,\n    224,\n    53552,\n    61171,\n    33010,\n    6542,\n    64743,\n    22239,\n    55772,\n    9222\n  ]), p = r([\n    54554,\n    36645,\n    11616,\n    51542,\n    42930,\n    38181,\n    51040,\n    26924,\n    56412,\n    64982,\n    57905,\n    49316,\n    21502,\n    52590,\n    14035,\n    8553\n  ]), b = r([\n    26200,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214,\n    26214\n  ]), x = r([\n    41136,\n    18958,\n    6951,\n    50414,\n    58488,\n    44335,\n    6150,\n    12099,\n    55207,\n    15867,\n    153,\n    11085,\n    57099,\n    20417,\n    9344,\n    11139\n  ]);\n  function O(T, A) {\n    for (let N = 0; N < 16; N++)\n      T[N] = A[N] | 0;\n  }\n  function _(T) {\n    let A = 1;\n    for (let N = 0; N < 16; N++) {\n      let h = T[N] + A + 65535;\n      A = Math.floor(h / 65536), T[N] = h - A * 65536;\n    }\n    T[0] += A - 1 + 37 * (A - 1);\n  }\n  function C(T, A, N) {\n    const h = ~(N - 1);\n    for (let S = 0; S < 16; S++) {\n      const W = h & (T[S] ^ A[S]);\n      T[S] ^= W, A[S] ^= W;\n    }\n  }\n  function F(T, A) {\n    const N = r(), h = r();\n    for (let S = 0; S < 16; S++)\n      h[S] = A[S];\n    _(h), _(h), _(h);\n    for (let S = 0; S < 2; S++) {\n      N[0] = h[0] - 65517;\n      for (let X = 1; X < 15; X++)\n        N[X] = h[X] - 65535 - (N[X - 1] >> 16 & 1), N[X - 1] &= 65535;\n      N[15] = h[15] - 32767 - (N[14] >> 16 & 1);\n      const W = N[15] >> 16 & 1;\n      N[14] &= 65535, C(h, N, 1 - W);\n    }\n    for (let S = 0; S < 16; S++)\n      T[2 * S] = h[S] & 255, T[2 * S + 1] = h[S] >> 8;\n  }\n  function K(T, A) {\n    let N = 0;\n    for (let h = 0; h < 32; h++)\n      N |= T[h] ^ A[h];\n    return (1 & N - 1 >>> 8) - 1;\n  }\n  function I(T, A) {\n    const N = new Uint8Array(32), h = new Uint8Array(32);\n    return F(N, T), F(h, A), K(N, h);\n  }\n  function D(T) {\n    const A = new Uint8Array(32);\n    return F(A, T), A[0] & 1;\n  }\n  function y(T, A) {\n    for (let N = 0; N < 16; N++)\n      T[N] = A[2 * N] + (A[2 * N + 1] << 8);\n    T[15] &= 32767;\n  }\n  function w(T, A, N) {\n    for (let h = 0; h < 16; h++)\n      T[h] = A[h] + N[h];\n  }\n  function f(T, A, N) {\n    for (let h = 0; h < 16; h++)\n      T[h] = A[h] - N[h];\n  }\n  function a(T, A, N) {\n    let h, S, W = 0, X = 0, fe = 0, ve = 0, ge = 0, Se = 0, Me = 0, $e = 0, be = 0, ye = 0, pe = 0, le = 0, ue = 0, he = 0, ce = 0, re = 0, de = 0, me = 0, ne = 0, _e = 0, Ee = 0, De = 0, xe = 0, Ie = 0, Ut = 0, qt = 0, si = 0, Dt = 0, fi = 0, Ki = 0, Os = 0, qe = N[0], Fe = N[1], je = N[2], ze = N[3], Ke = N[4], Ue = N[5], Qe = N[6], Xe = N[7], Ze = N[8], et = N[9], tt = N[10], Ye = N[11], Ve = N[12], Ae = N[13], it = N[14], st = N[15];\n    h = A[0], W += h * qe, X += h * Fe, fe += h * je, ve += h * ze, ge += h * Ke, Se += h * Ue, Me += h * Qe, $e += h * Xe, be += h * Ze, ye += h * et, pe += h * tt, le += h * Ye, ue += h * Ve, he += h * Ae, ce += h * it, re += h * st, h = A[1], X += h * qe, fe += h * Fe, ve += h * je, ge += h * ze, Se += h * Ke, Me += h * Ue, $e += h * Qe, be += h * Xe, ye += h * Ze, pe += h * et, le += h * tt, ue += h * Ye, he += h * Ve, ce += h * Ae, re += h * it, de += h * st, h = A[2], fe += h * qe, ve += h * Fe, ge += h * je, Se += h * ze, Me += h * Ke, $e += h * Ue, be += h * Qe, ye += h * Xe, pe += h * Ze, le += h * et, ue += h * tt, he += h * Ye, ce += h * Ve, re += h * Ae, de += h * it, me += h * st, h = A[3], ve += h * qe, ge += h * Fe, Se += h * je, Me += h * ze, $e += h * Ke, be += h * Ue, ye += h * Qe, pe += h * Xe, le += h * Ze, ue += h * et, he += h * tt, ce += h * Ye, re += h * Ve, de += h * Ae, me += h * it, ne += h * st, h = A[4], ge += h * qe, Se += h * Fe, Me += h * je, $e += h * ze, be += h * Ke, ye += h * Ue, pe += h * Qe, le += h * Xe, ue += h * Ze, he += h * et, ce += h * tt, re += h * Ye, de += h * Ve, me += h * Ae, ne += h * it, _e += h * st, h = A[5], Se += h * qe, Me += h * Fe, $e += h * je, be += h * ze, ye += h * Ke, pe += h * Ue, le += h * Qe, ue += h * Xe, he += h * Ze, ce += h * et, re += h * tt, de += h * Ye, me += h * Ve, ne += h * Ae, _e += h * it, Ee += h * st, h = A[6], Me += h * qe, $e += h * Fe, be += h * je, ye += h * ze, pe += h * Ke, le += h * Ue, ue += h * Qe, he += h * Xe, ce += h * Ze, re += h * et, de += h * tt, me += h * Ye, ne += h * Ve, _e += h * Ae, Ee += h * it, De += h * st, h = A[7], $e += h * qe, be += h * Fe, ye += h * je, pe += h * ze, le += h * Ke, ue += h * Ue, he += h * Qe, ce += h * Xe, re += h * Ze, de += h * et, me += h * tt, ne += h * Ye, _e += h * Ve, Ee += h * Ae, De += h * it, xe += h * st, h = A[8], be += h * qe, ye += h * Fe, pe += h * je, le += h * ze, ue += h * Ke, he += h * Ue, ce += h * Qe, re += h * Xe, de += h * Ze, me += h * et, ne += h * tt, _e += h * Ye, Ee += h * Ve, De += h * Ae, xe += h * it, Ie += h * st, h = A[9], ye += h * qe, pe += h * Fe, le += h * je, ue += h * ze, he += h * Ke, ce += h * Ue, re += h * Qe, de += h * Xe, me += h * Ze, ne += h * et, _e += h * tt, Ee += h * Ye, De += h * Ve, xe += h * Ae, Ie += h * it, Ut += h * st, h = A[10], pe += h * qe, le += h * Fe, ue += h * je, he += h * ze, ce += h * Ke, re += h * Ue, de += h * Qe, me += h * Xe, ne += h * Ze, _e += h * et, Ee += h * tt, De += h * Ye, xe += h * Ve, Ie += h * Ae, Ut += h * it, qt += h * st, h = A[11], le += h * qe, ue += h * Fe, he += h * je, ce += h * ze, re += h * Ke, de += h * Ue, me += h * Qe, ne += h * Xe, _e += h * Ze, Ee += h * et, De += h * tt, xe += h * Ye, Ie += h * Ve, Ut += h * Ae, qt += h * it, si += h * st, h = A[12], ue += h * qe, he += h * Fe, ce += h * je, re += h * ze, de += h * Ke, me += h * Ue, ne += h * Qe, _e += h * Xe, Ee += h * Ze, De += h * et, xe += h * tt, Ie += h * Ye, Ut += h * Ve, qt += h * Ae, si += h * it, Dt += h * st, h = A[13], he += h * qe, ce += h * Fe, re += h * je, de += h * ze, me += h * Ke, ne += h * Ue, _e += h * Qe, Ee += h * Xe, De += h * Ze, xe += h * et, Ie += h * tt, Ut += h * Ye, qt += h * Ve, si += h * Ae, Dt += h * it, fi += h * st, h = A[14], ce += h * qe, re += h * Fe, de += h * je, me += h * ze, ne += h * Ke, _e += h * Ue, Ee += h * Qe, De += h * Xe, xe += h * Ze, Ie += h * et, Ut += h * tt, qt += h * Ye, si += h * Ve, Dt += h * Ae, fi += h * it, Ki += h * st, h = A[15], re += h * qe, de += h * Fe, me += h * je, ne += h * ze, _e += h * Ke, Ee += h * Ue, De += h * Qe, xe += h * Xe, Ie += h * Ze, Ut += h * et, qt += h * tt, si += h * Ye, Dt += h * Ve, fi += h * Ae, Ki += h * it, Os += h * st, W += 38 * de, X += 38 * me, fe += 38 * ne, ve += 38 * _e, ge += 38 * Ee, Se += 38 * De, Me += 38 * xe, $e += 38 * Ie, be += 38 * Ut, ye += 38 * qt, pe += 38 * si, le += 38 * Dt, ue += 38 * fi, he += 38 * Ki, ce += 38 * Os, S = 1, h = W + S + 65535, S = Math.floor(h / 65536), W = h - S * 65536, h = X + S + 65535, S = Math.floor(h / 65536), X = h - S * 65536, h = fe + S + 65535, S = Math.floor(h / 65536), fe = h - S * 65536, h = ve + S + 65535, S = Math.floor(h / 65536), ve = h - S * 65536, h = ge + S + 65535, S = Math.floor(h / 65536), ge = h - S * 65536, h = Se + S + 65535, S = Math.floor(h / 65536), Se = h - S * 65536, h = Me + S + 65535, S = Math.floor(h / 65536), Me = h - S * 65536, h = $e + S + 65535, S = Math.floor(h / 65536), $e = h - S * 65536, h = be + S + 65535, S = Math.floor(h / 65536), be = h - S * 65536, h = ye + S + 65535, S = Math.floor(h / 65536), ye = h - S * 65536, h = pe + S + 65535, S = Math.floor(h / 65536), pe = h - S * 65536, h = le + S + 65535, S = Math.floor(h / 65536), le = h - S * 65536, h = ue + S + 65535, S = Math.floor(h / 65536), ue = h - S * 65536, h = he + S + 65535, S = Math.floor(h / 65536), he = h - S * 65536, h = ce + S + 65535, S = Math.floor(h / 65536), ce = h - S * 65536, h = re + S + 65535, S = Math.floor(h / 65536), re = h - S * 65536, W += S - 1 + 37 * (S - 1), S = 1, h = W + S + 65535, S = Math.floor(h / 65536), W = h - S * 65536, h = X + S + 65535, S = Math.floor(h / 65536), X = h - S * 65536, h = fe + S + 65535, S = Math.floor(h / 65536), fe = h - S * 65536, h = ve + S + 65535, S = Math.floor(h / 65536), ve = h - S * 65536, h = ge + S + 65535, S = Math.floor(h / 65536), ge = h - S * 65536, h = Se + S + 65535, S = Math.floor(h / 65536), Se = h - S * 65536, h = Me + S + 65535, S = Math.floor(h / 65536), Me = h - S * 65536, h = $e + S + 65535, S = Math.floor(h / 65536), $e = h - S * 65536, h = be + S + 65535, S = Math.floor(h / 65536), be = h - S * 65536, h = ye + S + 65535, S = Math.floor(h / 65536), ye = h - S * 65536, h = pe + S + 65535, S = Math.floor(h / 65536), pe = h - S * 65536, h = le + S + 65535, S = Math.floor(h / 65536), le = h - S * 65536, h = ue + S + 65535, S = Math.floor(h / 65536), ue = h - S * 65536, h = he + S + 65535, S = Math.floor(h / 65536), he = h - S * 65536, h = ce + S + 65535, S = Math.floor(h / 65536), ce = h - S * 65536, h = re + S + 65535, S = Math.floor(h / 65536), re = h - S * 65536, W += S - 1 + 37 * (S - 1), T[0] = W, T[1] = X, T[2] = fe, T[3] = ve, T[4] = ge, T[5] = Se, T[6] = Me, T[7] = $e, T[8] = be, T[9] = ye, T[10] = pe, T[11] = le, T[12] = ue, T[13] = he, T[14] = ce, T[15] = re;\n  }\n  function l(T, A) {\n    a(T, A, A);\n  }\n  function L(T, A) {\n    const N = r();\n    let h;\n    for (h = 0; h < 16; h++)\n      N[h] = A[h];\n    for (h = 253; h >= 0; h--)\n      l(N, N), h !== 2 && h !== 4 && a(N, N, A);\n    for (h = 0; h < 16; h++)\n      T[h] = N[h];\n  }\n  function v(T, A) {\n    const N = r();\n    let h;\n    for (h = 0; h < 16; h++)\n      N[h] = A[h];\n    for (h = 250; h >= 0; h--)\n      l(N, N), h !== 1 && a(N, N, A);\n    for (h = 0; h < 16; h++)\n      T[h] = N[h];\n  }\n  function R(T, A) {\n    const N = r(), h = r(), S = r(), W = r(), X = r(), fe = r(), ve = r(), ge = r(), Se = r();\n    f(N, T[1], T[0]), f(Se, A[1], A[0]), a(N, N, Se), w(h, T[0], T[1]), w(Se, A[0], A[1]), a(h, h, Se), a(S, T[3], A[3]), a(S, S, d), a(W, T[2], A[2]), w(W, W, W), f(X, h, N), f(fe, W, S), w(ve, W, S), w(ge, h, N), a(T[0], X, fe), a(T[1], ge, ve), a(T[2], ve, fe), a(T[3], X, ge);\n  }\n  function $(T, A, N) {\n    for (let h = 0; h < 4; h++)\n      C(T[h], A[h], N);\n  }\n  function q(T, A) {\n    const N = r(), h = r(), S = r();\n    L(S, A[2]), a(N, A[0], S), a(h, A[1], S), F(T, h), T[31] ^= D(N) << 7;\n  }\n  function m(T, A, N) {\n    O(T[0], o), O(T[1], c), O(T[2], c), O(T[3], o);\n    for (let h = 255; h >= 0; --h) {\n      const S = N[h / 8 | 0] >> (h & 7) & 1;\n      $(T, A, S), R(A, T), R(T, T), $(T, A, S);\n    }\n  }\n  function E(T, A) {\n    const N = [r(), r(), r(), r()];\n    O(N[0], p), O(N[1], b), O(N[2], c), a(N[3], p, b), m(T, N, A);\n  }\n  function B(T) {\n    if (T.length !== i.SEED_LENGTH)\n      throw new Error(`ed25519: seed must be ${i.SEED_LENGTH} bytes`);\n    const A = (0, t.hash)(T);\n    A[0] &= 248, A[31] &= 127, A[31] |= 64;\n    const N = new Uint8Array(32), h = [r(), r(), r(), r()];\n    E(h, A), q(N, h);\n    const S = new Uint8Array(64);\n    return S.set(T), S.set(N, 32), {\n      publicKey: N,\n      secretKey: S\n    };\n  }\n  i.generateKeyPairFromSeed = B;\n  function z(T) {\n    const A = (0, e.randomBytes)(32, T), N = B(A);\n    return (0, s.wipe)(A), N;\n  }\n  i.generateKeyPair = z;\n  function j(T) {\n    if (T.length !== i.SECRET_KEY_LENGTH)\n      throw new Error(`ed25519: secret key must be ${i.SECRET_KEY_LENGTH} bytes`);\n    return new Uint8Array(T.subarray(32));\n  }\n  i.extractPublicKeyFromSecretKey = j;\n  const U = new Float64Array([\n    237,\n    211,\n    245,\n    92,\n    26,\n    99,\n    18,\n    88,\n    214,\n    156,\n    247,\n    162,\n    222,\n    249,\n    222,\n    20,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    16\n  ]);\n  function M(T, A) {\n    let N, h, S, W;\n    for (h = 63; h >= 32; --h) {\n      for (N = 0, S = h - 32, W = h - 12; S < W; ++S)\n        A[S] += N - 16 * A[h] * U[S - (h - 32)], N = Math.floor((A[S] + 128) / 256), A[S] -= N * 256;\n      A[S] += N, A[h] = 0;\n    }\n    for (N = 0, S = 0; S < 32; S++)\n      A[S] += N - (A[31] >> 4) * U[S], N = A[S] >> 8, A[S] &= 255;\n    for (S = 0; S < 32; S++)\n      A[S] -= N * U[S];\n    for (h = 0; h < 32; h++)\n      A[h + 1] += A[h] >> 8, T[h] = A[h] & 255;\n  }\n  function H(T) {\n    const A = new Float64Array(64);\n    for (let N = 0; N < 64; N++)\n      A[N] = T[N];\n    for (let N = 0; N < 64; N++)\n      T[N] = 0;\n    M(T, A);\n  }\n  function te(T, A) {\n    const N = new Float64Array(64), h = [r(), r(), r(), r()], S = (0, t.hash)(T.subarray(0, 32));\n    S[0] &= 248, S[31] &= 127, S[31] |= 64;\n    const W = new Uint8Array(64);\n    W.set(S.subarray(32), 32);\n    const X = new t.SHA512();\n    X.update(W.subarray(32)), X.update(A);\n    const fe = X.digest();\n    X.clean(), H(fe), E(h, fe), q(W, h), X.reset(), X.update(W.subarray(0, 32)), X.update(T.subarray(32)), X.update(A);\n    const ve = X.digest();\n    H(ve);\n    for (let ge = 0; ge < 32; ge++)\n      N[ge] = fe[ge];\n    for (let ge = 0; ge < 32; ge++)\n      for (let Se = 0; Se < 32; Se++)\n        N[ge + Se] += ve[ge] * S[Se];\n    return M(W.subarray(32), N), W;\n  }\n  i.sign = te;\n  function G(T, A) {\n    const N = r(), h = r(), S = r(), W = r(), X = r(), fe = r(), ve = r();\n    return O(T[2], c), y(T[1], A), l(S, T[1]), a(W, S, u), f(S, S, T[2]), w(W, T[2], W), l(X, W), l(fe, X), a(ve, fe, X), a(N, ve, S), a(N, N, W), v(N, N), a(N, N, S), a(N, N, W), a(N, N, W), a(T[0], N, W), l(h, T[0]), a(h, h, W), I(h, S) && a(T[0], T[0], x), l(h, T[0]), a(h, h, W), I(h, S) ? -1 : (D(T[0]) === A[31] >> 7 && f(T[0], o, T[0]), a(T[3], T[0], T[1]), 0);\n  }\n  function ie(T, A, N) {\n    const h = new Uint8Array(32), S = [r(), r(), r(), r()], W = [r(), r(), r(), r()];\n    if (N.length !== i.SIGNATURE_LENGTH)\n      throw new Error(`ed25519: signature must be ${i.SIGNATURE_LENGTH} bytes`);\n    if (G(W, T))\n      return !1;\n    const X = new t.SHA512();\n    X.update(N.subarray(0, 32)), X.update(T), X.update(A);\n    const fe = X.digest();\n    return H(fe), m(S, W, fe), E(W, N.subarray(32)), R(S, W), q(h, S), !K(N, h);\n  }\n  i.verify = ie;\n  function Q(T) {\n    let A = [r(), r(), r(), r()];\n    if (G(A, T))\n      throw new Error(\"Ed25519: invalid public key\");\n    let N = r(), h = r(), S = A[1];\n    w(N, c, S), f(h, c, S), L(h, h), a(N, N, h);\n    let W = new Uint8Array(32);\n    return F(W, N), W;\n  }\n  i.convertPublicKeyToX25519 = Q;\n  function se(T) {\n    const A = (0, t.hash)(T.subarray(0, 32));\n    A[0] &= 248, A[31] &= 127, A[31] |= 64;\n    const N = new Uint8Array(A.subarray(0, 32));\n    return (0, s.wipe)(A), N;\n  }\n  i.convertSecretKeyToX25519 = se;\n})(nn);\nconst sd = \"EdDSA\", rd = \"JWT\", mc = \".\", bc = \"base64url\", nd = \"utf8\", od = \"utf8\", ad = \":\", cd = \"did\", hd = \"key\", mo = \"base58btc\", ud = \"z\", ld = \"K36\", dd = 32;\nfunction on(i) {\n  return globalThis.Buffer != null ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : i;\n}\nfunction wc(i = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? on(globalThis.Buffer.allocUnsafe(i)) : new Uint8Array(i);\n}\nfunction ls(i, e) {\n  e || (e = i.reduce((r, n) => r + n.length, 0));\n  const t = wc(e);\n  let s = 0;\n  for (const r of i)\n    t.set(r, s), s += r.length;\n  return on(t);\n}\nfunction fd(i, e) {\n  if (i.length >= 255)\n    throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), s = 0; s < t.length; s++)\n    t[s] = 255;\n  for (var r = 0; r < i.length; r++) {\n    var n = i.charAt(r), o = n.charCodeAt(0);\n    if (t[o] !== 255)\n      throw new TypeError(n + \" is ambiguous\");\n    t[o] = r;\n  }\n  var c = i.length, u = i.charAt(0), d = Math.log(c) / Math.log(256), p = Math.log(256) / Math.log(c);\n  function b(_) {\n    if (_ instanceof Uint8Array || (ArrayBuffer.isView(_) ? _ = new Uint8Array(_.buffer, _.byteOffset, _.byteLength) : Array.isArray(_) && (_ = Uint8Array.from(_))), !(_ instanceof Uint8Array))\n      throw new TypeError(\"Expected Uint8Array\");\n    if (_.length === 0)\n      return \"\";\n    for (var C = 0, F = 0, K = 0, I = _.length; K !== I && _[K] === 0; )\n      K++, C++;\n    for (var D = (I - K) * p + 1 >>> 0, y = new Uint8Array(D); K !== I; ) {\n      for (var w = _[K], f = 0, a = D - 1; (w !== 0 || f < F) && a !== -1; a--, f++)\n        w += 256 * y[a] >>> 0, y[a] = w % c >>> 0, w = w / c >>> 0;\n      if (w !== 0)\n        throw new Error(\"Non-zero carry\");\n      F = f, K++;\n    }\n    for (var l = D - F; l !== D && y[l] === 0; )\n      l++;\n    for (var L = u.repeat(C); l < D; ++l)\n      L += i.charAt(y[l]);\n    return L;\n  }\n  function x(_) {\n    if (typeof _ != \"string\")\n      throw new TypeError(\"Expected String\");\n    if (_.length === 0)\n      return new Uint8Array();\n    var C = 0;\n    if (_[C] !== \" \") {\n      for (var F = 0, K = 0; _[C] === u; )\n        F++, C++;\n      for (var I = (_.length - C) * d + 1 >>> 0, D = new Uint8Array(I); _[C]; ) {\n        var y = t[_.charCodeAt(C)];\n        if (y === 255)\n          return;\n        for (var w = 0, f = I - 1; (y !== 0 || w < K) && f !== -1; f--, w++)\n          y += c * D[f] >>> 0, D[f] = y % 256 >>> 0, y = y / 256 >>> 0;\n        if (y !== 0)\n          throw new Error(\"Non-zero carry\");\n        K = w, C++;\n      }\n      if (_[C] !== \" \") {\n        for (var a = I - K; a !== I && D[a] === 0; )\n          a++;\n        for (var l = new Uint8Array(F + (I - a)), L = F; a !== I; )\n          l[L++] = D[a++];\n        return l;\n      }\n    }\n  }\n  function O(_) {\n    var C = x(_);\n    if (C)\n      return C;\n    throw new Error(`Non-${e} character`);\n  }\n  return {\n    encode: b,\n    decodeUnsafe: x,\n    decode: O\n  };\n}\nvar pd = fd, gd = pd;\nconst yd = (i) => {\n  if (i instanceof Uint8Array && i.constructor.name === \"Uint8Array\")\n    return i;\n  if (i instanceof ArrayBuffer)\n    return new Uint8Array(i);\n  if (ArrayBuffer.isView(i))\n    return new Uint8Array(i.buffer, i.byteOffset, i.byteLength);\n  throw new Error(\"Unknown type, must be binary type\");\n}, md = (i) => new TextEncoder().encode(i), bd = (i) => new TextDecoder().decode(i);\nclass wd {\n  constructor(e, t, s) {\n    this.name = e, this.prefix = t, this.baseEncode = s;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array)\n      return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass vd {\n  constructor(e, t, s) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)\n      throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint)\n        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else\n      throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return vc(this, e);\n  }\n}\nclass _d {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return vc(this, e);\n  }\n  decode(e) {\n    const t = e[0], s = this.decoders[t];\n    if (s)\n      return s.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst vc = (i, e) => new _d({\n  ...i.decoders || { [i.prefix]: i },\n  ...e.decoders || { [e.prefix]: e }\n});\nclass Ed {\n  constructor(e, t, s, r) {\n    this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = r, this.encoder = new wd(e, t, s), this.decoder = new vd(e, t, r);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst cr = ({ name: i, prefix: e, encode: t, decode: s }) => new Ed(i, e, t, s), ps = ({ prefix: i, name: e, alphabet: t }) => {\n  const { encode: s, decode: r } = gd(t, e);\n  return cr({\n    prefix: i,\n    name: e,\n    encode: s,\n    decode: (n) => yd(r(n))\n  });\n}, Sd = (i, e, t, s) => {\n  const r = {};\n  for (let p = 0; p < e.length; ++p)\n    r[e[p]] = p;\n  let n = i.length;\n  for (; i[n - 1] === \"=\"; )\n    --n;\n  const o = new Uint8Array(n * t / 8 | 0);\n  let c = 0, u = 0, d = 0;\n  for (let p = 0; p < n; ++p) {\n    const b = r[i[p]];\n    if (b === void 0)\n      throw new SyntaxError(`Non-${s} character`);\n    u = u << t | b, c += t, c >= 8 && (c -= 8, o[d++] = 255 & u >> c);\n  }\n  if (c >= t || 255 & u << 8 - c)\n    throw new SyntaxError(\"Unexpected end of data\");\n  return o;\n}, Id = (i, e, t) => {\n  const s = e[e.length - 1] === \"=\", r = (1 << t) - 1;\n  let n = \"\", o = 0, c = 0;\n  for (let u = 0; u < i.length; ++u)\n    for (c = c << 8 | i[u], o += 8; o > t; )\n      o -= t, n += e[r & c >> o];\n  if (o && (n += e[r & c << t - o]), s)\n    for (; n.length * t & 7; )\n      n += \"=\";\n  return n;\n}, ut = ({ name: i, prefix: e, bitsPerChar: t, alphabet: s }) => cr({\n  prefix: e,\n  name: i,\n  encode(r) {\n    return Id(r, s, t);\n  },\n  decode(r) {\n    return Sd(r, s, t, i);\n  }\n}), Dd = cr({\n  prefix: \"\\0\",\n  name: \"identity\",\n  encode: (i) => bd(i),\n  decode: (i) => md(i)\n}), xd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  identity: Dd\n}, Symbol.toStringTag, { value: \"Module\" })), Od = ut({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n}), Nd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base2: Od\n}, Symbol.toStringTag, { value: \"Module\" })), Pd = ut({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n}), Rd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base8: Pd\n}, Symbol.toStringTag, { value: \"Module\" })), Cd = ps({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n}), Ad = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base10: Cd\n}, Symbol.toStringTag, { value: \"Module\" })), Td = ut({\n  prefix: \"f\",\n  name: \"base16\",\n  alphabet: \"0123456789abcdef\",\n  bitsPerChar: 4\n}), $d = ut({\n  prefix: \"F\",\n  name: \"base16upper\",\n  alphabet: \"0123456789ABCDEF\",\n  bitsPerChar: 4\n}), Fd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base16: Td,\n  base16upper: $d\n}, Symbol.toStringTag, { value: \"Module\" })), Ud = ut({\n  prefix: \"b\",\n  name: \"base32\",\n  alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n  bitsPerChar: 5\n}), Ld = ut({\n  prefix: \"B\",\n  name: \"base32upper\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  bitsPerChar: 5\n}), Md = ut({\n  prefix: \"c\",\n  name: \"base32pad\",\n  alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n  bitsPerChar: 5\n}), qd = ut({\n  prefix: \"C\",\n  name: \"base32padupper\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n  bitsPerChar: 5\n}), jd = ut({\n  prefix: \"v\",\n  name: \"base32hex\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n  bitsPerChar: 5\n}), zd = ut({\n  prefix: \"V\",\n  name: \"base32hexupper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  bitsPerChar: 5\n}), Kd = ut({\n  prefix: \"t\",\n  name: \"base32hexpad\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n  bitsPerChar: 5\n}), Vd = ut({\n  prefix: \"T\",\n  name: \"base32hexpadupper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n  bitsPerChar: 5\n}), Bd = ut({\n  prefix: \"h\",\n  name: \"base32z\",\n  alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n  bitsPerChar: 5\n}), kd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base32: Ud,\n  base32hex: jd,\n  base32hexpad: Kd,\n  base32hexpadupper: Vd,\n  base32hexupper: zd,\n  base32pad: Md,\n  base32padupper: qd,\n  base32upper: Ld,\n  base32z: Bd\n}, Symbol.toStringTag, { value: \"Module\" })), Hd = ps({\n  prefix: \"k\",\n  name: \"base36\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n}), Gd = ps({\n  prefix: \"K\",\n  name: \"base36upper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n}), Wd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base36: Hd,\n  base36upper: Gd\n}, Symbol.toStringTag, { value: \"Module\" })), Yd = ps({\n  name: \"base58btc\",\n  prefix: \"z\",\n  alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n}), Jd = ps({\n  name: \"base58flickr\",\n  prefix: \"Z\",\n  alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n}), Qd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base58btc: Yd,\n  base58flickr: Jd\n}, Symbol.toStringTag, { value: \"Module\" })), Xd = ut({\n  prefix: \"m\",\n  name: \"base64\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n  bitsPerChar: 6\n}), Zd = ut({\n  prefix: \"M\",\n  name: \"base64pad\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n  bitsPerChar: 6\n}), ef = ut({\n  prefix: \"u\",\n  name: \"base64url\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n  bitsPerChar: 6\n}), tf = ut({\n  prefix: \"U\",\n  name: \"base64urlpad\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n  bitsPerChar: 6\n}), sf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base64: Xd,\n  base64pad: Zd,\n  base64url: ef,\n  base64urlpad: tf\n}, Symbol.toStringTag, { value: \"Module\" })), _c = Array.from(\"🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂\"), rf = _c.reduce((i, e, t) => (i[t] = e, i), []), nf = _c.reduce((i, e, t) => (i[e.codePointAt(0)] = t, i), []);\nfunction of(i) {\n  return i.reduce((e, t) => (e += rf[t], e), \"\");\n}\nfunction af(i) {\n  const e = [];\n  for (const t of i) {\n    const s = nf[t.codePointAt(0)];\n    if (s === void 0)\n      throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(s);\n  }\n  return new Uint8Array(e);\n}\nconst cf = cr({\n  prefix: \"🚀\",\n  name: \"base256emoji\",\n  encode: of,\n  decode: af\n}), hf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  base256emoji: cf\n}, Symbol.toStringTag, { value: \"Module\" }));\nnew TextEncoder();\nnew TextDecoder();\nconst bo = {\n  ...xd,\n  ...Nd,\n  ...Rd,\n  ...Ad,\n  ...Fd,\n  ...kd,\n  ...Wd,\n  ...Qd,\n  ...sf,\n  ...hf\n};\nfunction Ec(i, e, t, s) {\n  return {\n    name: i,\n    prefix: e,\n    encoder: {\n      name: i,\n      prefix: e,\n      encode: t\n    },\n    decoder: { decode: s }\n  };\n}\nconst wo = Ec(\"utf8\", \"u\", (i) => \"u\" + new TextDecoder(\"utf8\").decode(i), (i) => new TextEncoder().encode(i.substring(1))), Dr = Ec(\"ascii\", \"a\", (i) => {\n  let e = \"a\";\n  for (let t = 0; t < i.length; t++)\n    e += String.fromCharCode(i[t]);\n  return e;\n}, (i) => {\n  i = i.substring(1);\n  const e = wc(i.length);\n  for (let t = 0; t < i.length; t++)\n    e[t] = i.charCodeAt(t);\n  return e;\n}), Sc = {\n  utf8: wo,\n  \"utf-8\": wo,\n  hex: bo.base16,\n  latin1: Dr,\n  ascii: Dr,\n  binary: Dr,\n  ...bo\n};\nfunction Ne(i, e = \"utf8\") {\n  const t = Sc[e];\n  if (!t)\n    throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(i.buffer, i.byteOffset, i.byteLength).toString(\"utf8\") : t.encoder.encode(i).substring(1);\n}\nfunction Ce(i, e = \"utf8\") {\n  const t = Sc[e];\n  if (!t)\n    throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? on(globalThis.Buffer.from(i, \"utf-8\")) : t.decoder.decode(`${t.prefix}${i}`);\n}\nfunction Gs(i) {\n  return Ne(Ce(rr(i), nd), bc);\n}\nfunction an(i) {\n  const e = Ce(ld, mo), t = ud + Ne(ls([e, i]), mo);\n  return [cd, hd, t].join(ad);\n}\nfunction uf(i) {\n  return Ne(i, bc);\n}\nfunction lf(i) {\n  return Ce([Gs(i.header), Gs(i.payload)].join(mc), od);\n}\nfunction df(i) {\n  return [\n    Gs(i.header),\n    Gs(i.payload),\n    uf(i.signature)\n  ].join(mc);\n}\nfunction Ws(i = li.randomBytes(dd)) {\n  return nn.generateKeyPairFromSeed(i);\n}\nasync function Ic(i, e, t, s, r = V.fromMiliseconds(Date.now())) {\n  const n = { alg: sd, typ: rd }, o = an(s.publicKey), c = r + t, u = { iss: o, sub: i, aud: e, iat: r, exp: c }, d = lf({ header: n, payload: u }), p = nn.sign(s.secretKey, d);\n  return df({ header: n, payload: u, signature: p });\n}\nvar gs = {}, hr = {};\nObject.defineProperty(hr, \"__esModule\", { value: !0 });\nvar pt = oe, Kr = Pt, ff = 20;\nfunction pf(i, e, t) {\n  for (var s = 1634760805, r = 857760878, n = 2036477234, o = 1797285236, c = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], u = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], d = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], p = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], b = t[19] << 24 | t[18] << 16 | t[17] << 8 | t[16], x = t[23] << 24 | t[22] << 16 | t[21] << 8 | t[20], O = t[27] << 24 | t[26] << 16 | t[25] << 8 | t[24], _ = t[31] << 24 | t[30] << 16 | t[29] << 8 | t[28], C = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], F = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], K = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], I = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], D = s, y = r, w = n, f = o, a = c, l = u, L = d, v = p, R = b, $ = x, q = O, m = _, E = C, B = F, z = K, j = I, U = 0; U < ff; U += 2)\n    D = D + a | 0, E ^= D, E = E >>> 32 - 16 | E << 16, R = R + E | 0, a ^= R, a = a >>> 32 - 12 | a << 12, y = y + l | 0, B ^= y, B = B >>> 32 - 16 | B << 16, $ = $ + B | 0, l ^= $, l = l >>> 32 - 12 | l << 12, w = w + L | 0, z ^= w, z = z >>> 32 - 16 | z << 16, q = q + z | 0, L ^= q, L = L >>> 32 - 12 | L << 12, f = f + v | 0, j ^= f, j = j >>> 32 - 16 | j << 16, m = m + j | 0, v ^= m, v = v >>> 32 - 12 | v << 12, w = w + L | 0, z ^= w, z = z >>> 32 - 8 | z << 8, q = q + z | 0, L ^= q, L = L >>> 32 - 7 | L << 7, f = f + v | 0, j ^= f, j = j >>> 32 - 8 | j << 8, m = m + j | 0, v ^= m, v = v >>> 32 - 7 | v << 7, y = y + l | 0, B ^= y, B = B >>> 32 - 8 | B << 8, $ = $ + B | 0, l ^= $, l = l >>> 32 - 7 | l << 7, D = D + a | 0, E ^= D, E = E >>> 32 - 8 | E << 8, R = R + E | 0, a ^= R, a = a >>> 32 - 7 | a << 7, D = D + l | 0, j ^= D, j = j >>> 32 - 16 | j << 16, q = q + j | 0, l ^= q, l = l >>> 32 - 12 | l << 12, y = y + L | 0, E ^= y, E = E >>> 32 - 16 | E << 16, m = m + E | 0, L ^= m, L = L >>> 32 - 12 | L << 12, w = w + v | 0, B ^= w, B = B >>> 32 - 16 | B << 16, R = R + B | 0, v ^= R, v = v >>> 32 - 12 | v << 12, f = f + a | 0, z ^= f, z = z >>> 32 - 16 | z << 16, $ = $ + z | 0, a ^= $, a = a >>> 32 - 12 | a << 12, w = w + v | 0, B ^= w, B = B >>> 32 - 8 | B << 8, R = R + B | 0, v ^= R, v = v >>> 32 - 7 | v << 7, f = f + a | 0, z ^= f, z = z >>> 32 - 8 | z << 8, $ = $ + z | 0, a ^= $, a = a >>> 32 - 7 | a << 7, y = y + L | 0, E ^= y, E = E >>> 32 - 8 | E << 8, m = m + E | 0, L ^= m, L = L >>> 32 - 7 | L << 7, D = D + l | 0, j ^= D, j = j >>> 32 - 8 | j << 8, q = q + j | 0, l ^= q, l = l >>> 32 - 7 | l << 7;\n  pt.writeUint32LE(D + s | 0, i, 0), pt.writeUint32LE(y + r | 0, i, 4), pt.writeUint32LE(w + n | 0, i, 8), pt.writeUint32LE(f + o | 0, i, 12), pt.writeUint32LE(a + c | 0, i, 16), pt.writeUint32LE(l + u | 0, i, 20), pt.writeUint32LE(L + d | 0, i, 24), pt.writeUint32LE(v + p | 0, i, 28), pt.writeUint32LE(R + b | 0, i, 32), pt.writeUint32LE($ + x | 0, i, 36), pt.writeUint32LE(q + O | 0, i, 40), pt.writeUint32LE(m + _ | 0, i, 44), pt.writeUint32LE(E + C | 0, i, 48), pt.writeUint32LE(B + F | 0, i, 52), pt.writeUint32LE(z + K | 0, i, 56), pt.writeUint32LE(j + I | 0, i, 60);\n}\nfunction Dc(i, e, t, s, r) {\n  if (r === void 0 && (r = 0), i.length !== 32)\n    throw new Error(\"ChaCha: key size must be 32 bytes\");\n  if (s.length < t.length)\n    throw new Error(\"ChaCha: destination is shorter than source\");\n  var n, o;\n  if (r === 0) {\n    if (e.length !== 8 && e.length !== 12)\n      throw new Error(\"ChaCha nonce must be 8 or 12 bytes\");\n    n = new Uint8Array(16), o = n.length - e.length, n.set(e, o);\n  } else {\n    if (e.length !== 16)\n      throw new Error(\"ChaCha nonce with counter must be 16 bytes\");\n    n = e, o = r;\n  }\n  for (var c = new Uint8Array(64), u = 0; u < t.length; u += 64) {\n    pf(c, n, i);\n    for (var d = u; d < u + 64 && d < t.length; d++)\n      s[d] = t[d] ^ c[d - u];\n    yf(n, 0, o);\n  }\n  return Kr.wipe(c), r === 0 && Kr.wipe(n), s;\n}\nhr.streamXOR = Dc;\nfunction gf(i, e, t, s) {\n  return s === void 0 && (s = 0), Kr.wipe(t), Dc(i, e, t, t, s);\n}\nhr.stream = gf;\nfunction yf(i, e, t) {\n  for (var s = 1; t--; )\n    s = s + (i[e] & 255) | 0, i[e] = s & 255, s >>>= 8, e++;\n  if (s > 0)\n    throw new Error(\"ChaCha: counter overflow\");\n}\nvar xc = {}, di = {};\nObject.defineProperty(di, \"__esModule\", { value: !0 });\nfunction mf(i, e, t) {\n  return ~(i - 1) & e | i - 1 & t;\n}\ndi.select = mf;\nfunction bf(i, e) {\n  return (i | 0) - (e | 0) - 1 >>> 31 & 1;\n}\ndi.lessOrEqual = bf;\nfunction Oc(i, e) {\n  if (i.length !== e.length)\n    return 0;\n  for (var t = 0, s = 0; s < i.length; s++)\n    t |= i[s] ^ e[s];\n  return 1 & t - 1 >>> 8;\n}\ndi.compare = Oc;\nfunction wf(i, e) {\n  return i.length === 0 || e.length === 0 ? !1 : Oc(i, e) !== 0;\n}\ndi.equal = wf;\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  var e = di, t = Pt;\n  i.DIGEST_LENGTH = 16;\n  var s = (\n    /** @class */\n    function() {\n      function o(c) {\n        this.digestLength = i.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;\n        var u = c[0] | c[1] << 8;\n        this._r[0] = u & 8191;\n        var d = c[2] | c[3] << 8;\n        this._r[1] = (u >>> 13 | d << 3) & 8191;\n        var p = c[4] | c[5] << 8;\n        this._r[2] = (d >>> 10 | p << 6) & 7939;\n        var b = c[6] | c[7] << 8;\n        this._r[3] = (p >>> 7 | b << 9) & 8191;\n        var x = c[8] | c[9] << 8;\n        this._r[4] = (b >>> 4 | x << 12) & 255, this._r[5] = x >>> 1 & 8190;\n        var O = c[10] | c[11] << 8;\n        this._r[6] = (x >>> 14 | O << 2) & 8191;\n        var _ = c[12] | c[13] << 8;\n        this._r[7] = (O >>> 11 | _ << 5) & 8065;\n        var C = c[14] | c[15] << 8;\n        this._r[8] = (_ >>> 8 | C << 8) & 8191, this._r[9] = C >>> 5 & 127, this._pad[0] = c[16] | c[17] << 8, this._pad[1] = c[18] | c[19] << 8, this._pad[2] = c[20] | c[21] << 8, this._pad[3] = c[22] | c[23] << 8, this._pad[4] = c[24] | c[25] << 8, this._pad[5] = c[26] | c[27] << 8, this._pad[6] = c[28] | c[29] << 8, this._pad[7] = c[30] | c[31] << 8;\n      }\n      return o.prototype._blocks = function(c, u, d) {\n        for (var p = this._fin ? 0 : 2048, b = this._h[0], x = this._h[1], O = this._h[2], _ = this._h[3], C = this._h[4], F = this._h[5], K = this._h[6], I = this._h[7], D = this._h[8], y = this._h[9], w = this._r[0], f = this._r[1], a = this._r[2], l = this._r[3], L = this._r[4], v = this._r[5], R = this._r[6], $ = this._r[7], q = this._r[8], m = this._r[9]; d >= 16; ) {\n          var E = c[u + 0] | c[u + 1] << 8;\n          b += E & 8191;\n          var B = c[u + 2] | c[u + 3] << 8;\n          x += (E >>> 13 | B << 3) & 8191;\n          var z = c[u + 4] | c[u + 5] << 8;\n          O += (B >>> 10 | z << 6) & 8191;\n          var j = c[u + 6] | c[u + 7] << 8;\n          _ += (z >>> 7 | j << 9) & 8191;\n          var U = c[u + 8] | c[u + 9] << 8;\n          C += (j >>> 4 | U << 12) & 8191, F += U >>> 1 & 8191;\n          var M = c[u + 10] | c[u + 11] << 8;\n          K += (U >>> 14 | M << 2) & 8191;\n          var H = c[u + 12] | c[u + 13] << 8;\n          I += (M >>> 11 | H << 5) & 8191;\n          var te = c[u + 14] | c[u + 15] << 8;\n          D += (H >>> 8 | te << 8) & 8191, y += te >>> 5 | p;\n          var G = 0, ie = G;\n          ie += b * w, ie += x * (5 * m), ie += O * (5 * q), ie += _ * (5 * $), ie += C * (5 * R), G = ie >>> 13, ie &= 8191, ie += F * (5 * v), ie += K * (5 * L), ie += I * (5 * l), ie += D * (5 * a), ie += y * (5 * f), G += ie >>> 13, ie &= 8191;\n          var Q = G;\n          Q += b * f, Q += x * w, Q += O * (5 * m), Q += _ * (5 * q), Q += C * (5 * $), G = Q >>> 13, Q &= 8191, Q += F * (5 * R), Q += K * (5 * v), Q += I * (5 * L), Q += D * (5 * l), Q += y * (5 * a), G += Q >>> 13, Q &= 8191;\n          var se = G;\n          se += b * a, se += x * f, se += O * w, se += _ * (5 * m), se += C * (5 * q), G = se >>> 13, se &= 8191, se += F * (5 * $), se += K * (5 * R), se += I * (5 * v), se += D * (5 * L), se += y * (5 * l), G += se >>> 13, se &= 8191;\n          var T = G;\n          T += b * l, T += x * a, T += O * f, T += _ * w, T += C * (5 * m), G = T >>> 13, T &= 8191, T += F * (5 * q), T += K * (5 * $), T += I * (5 * R), T += D * (5 * v), T += y * (5 * L), G += T >>> 13, T &= 8191;\n          var A = G;\n          A += b * L, A += x * l, A += O * a, A += _ * f, A += C * w, G = A >>> 13, A &= 8191, A += F * (5 * m), A += K * (5 * q), A += I * (5 * $), A += D * (5 * R), A += y * (5 * v), G += A >>> 13, A &= 8191;\n          var N = G;\n          N += b * v, N += x * L, N += O * l, N += _ * a, N += C * f, G = N >>> 13, N &= 8191, N += F * w, N += K * (5 * m), N += I * (5 * q), N += D * (5 * $), N += y * (5 * R), G += N >>> 13, N &= 8191;\n          var h = G;\n          h += b * R, h += x * v, h += O * L, h += _ * l, h += C * a, G = h >>> 13, h &= 8191, h += F * f, h += K * w, h += I * (5 * m), h += D * (5 * q), h += y * (5 * $), G += h >>> 13, h &= 8191;\n          var S = G;\n          S += b * $, S += x * R, S += O * v, S += _ * L, S += C * l, G = S >>> 13, S &= 8191, S += F * a, S += K * f, S += I * w, S += D * (5 * m), S += y * (5 * q), G += S >>> 13, S &= 8191;\n          var W = G;\n          W += b * q, W += x * $, W += O * R, W += _ * v, W += C * L, G = W >>> 13, W &= 8191, W += F * l, W += K * a, W += I * f, W += D * w, W += y * (5 * m), G += W >>> 13, W &= 8191;\n          var X = G;\n          X += b * m, X += x * q, X += O * $, X += _ * R, X += C * v, G = X >>> 13, X &= 8191, X += F * L, X += K * l, X += I * a, X += D * f, X += y * w, G += X >>> 13, X &= 8191, G = (G << 2) + G | 0, G = G + ie | 0, ie = G & 8191, G = G >>> 13, Q += G, b = ie, x = Q, O = se, _ = T, C = A, F = N, K = h, I = S, D = W, y = X, u += 16, d -= 16;\n        }\n        this._h[0] = b, this._h[1] = x, this._h[2] = O, this._h[3] = _, this._h[4] = C, this._h[5] = F, this._h[6] = K, this._h[7] = I, this._h[8] = D, this._h[9] = y;\n      }, o.prototype.finish = function(c, u) {\n        u === void 0 && (u = 0);\n        var d = new Uint16Array(10), p, b, x, O;\n        if (this._leftover) {\n          for (O = this._leftover, this._buffer[O++] = 1; O < 16; O++)\n            this._buffer[O] = 0;\n          this._fin = 1, this._blocks(this._buffer, 0, 16);\n        }\n        for (p = this._h[1] >>> 13, this._h[1] &= 8191, O = 2; O < 10; O++)\n          this._h[O] += p, p = this._h[O] >>> 13, this._h[O] &= 8191;\n        for (this._h[0] += p * 5, p = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += p, p = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += p, d[0] = this._h[0] + 5, p = d[0] >>> 13, d[0] &= 8191, O = 1; O < 10; O++)\n          d[O] = this._h[O] + p, p = d[O] >>> 13, d[O] &= 8191;\n        for (d[9] -= 8192, b = (p ^ 1) - 1, O = 0; O < 10; O++)\n          d[O] &= b;\n        for (b = ~b, O = 0; O < 10; O++)\n          this._h[O] = this._h[O] & b | d[O];\n        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, x = this._h[0] + this._pad[0], this._h[0] = x & 65535, O = 1; O < 8; O++)\n          x = (this._h[O] + this._pad[O] | 0) + (x >>> 16) | 0, this._h[O] = x & 65535;\n        return c[u + 0] = this._h[0] >>> 0, c[u + 1] = this._h[0] >>> 8, c[u + 2] = this._h[1] >>> 0, c[u + 3] = this._h[1] >>> 8, c[u + 4] = this._h[2] >>> 0, c[u + 5] = this._h[2] >>> 8, c[u + 6] = this._h[3] >>> 0, c[u + 7] = this._h[3] >>> 8, c[u + 8] = this._h[4] >>> 0, c[u + 9] = this._h[4] >>> 8, c[u + 10] = this._h[5] >>> 0, c[u + 11] = this._h[5] >>> 8, c[u + 12] = this._h[6] >>> 0, c[u + 13] = this._h[6] >>> 8, c[u + 14] = this._h[7] >>> 0, c[u + 15] = this._h[7] >>> 8, this._finished = !0, this;\n      }, o.prototype.update = function(c) {\n        var u = 0, d = c.length, p;\n        if (this._leftover) {\n          p = 16 - this._leftover, p > d && (p = d);\n          for (var b = 0; b < p; b++)\n            this._buffer[this._leftover + b] = c[u + b];\n          if (d -= p, u += p, this._leftover += p, this._leftover < 16)\n            return this;\n          this._blocks(this._buffer, 0, 16), this._leftover = 0;\n        }\n        if (d >= 16 && (p = d - d % 16, this._blocks(c, u, p), u += p, d -= p), d) {\n          for (var b = 0; b < d; b++)\n            this._buffer[this._leftover + b] = c[u + b];\n          this._leftover += d;\n        }\n        return this;\n      }, o.prototype.digest = function() {\n        if (this._finished)\n          throw new Error(\"Poly1305 was finished\");\n        var c = new Uint8Array(16);\n        return this.finish(c), c;\n      }, o.prototype.clean = function() {\n        return t.wipe(this._buffer), t.wipe(this._r), t.wipe(this._h), t.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;\n      }, o;\n    }()\n  );\n  i.Poly1305 = s;\n  function r(o, c) {\n    var u = new s(o);\n    u.update(c);\n    var d = u.digest();\n    return u.clean(), d;\n  }\n  i.oneTimeAuth = r;\n  function n(o, c) {\n    return o.length !== i.DIGEST_LENGTH || c.length !== i.DIGEST_LENGTH ? !1 : e.equal(o, c);\n  }\n  i.equal = n;\n})(xc);\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  var e = hr, t = xc, s = Pt, r = oe, n = di;\n  i.KEY_LENGTH = 32, i.NONCE_LENGTH = 12, i.TAG_LENGTH = 16;\n  var o = new Uint8Array(16), c = (\n    /** @class */\n    function() {\n      function u(d) {\n        if (this.nonceLength = i.NONCE_LENGTH, this.tagLength = i.TAG_LENGTH, d.length !== i.KEY_LENGTH)\n          throw new Error(\"ChaCha20Poly1305 needs 32-byte key\");\n        this._key = new Uint8Array(d);\n      }\n      return u.prototype.seal = function(d, p, b, x) {\n        if (d.length > 16)\n          throw new Error(\"ChaCha20Poly1305: incorrect nonce length\");\n        var O = new Uint8Array(16);\n        O.set(d, O.length - d.length);\n        var _ = new Uint8Array(32);\n        e.stream(this._key, O, _, 4);\n        var C = p.length + this.tagLength, F;\n        if (x) {\n          if (x.length !== C)\n            throw new Error(\"ChaCha20Poly1305: incorrect destination length\");\n          F = x;\n        } else\n          F = new Uint8Array(C);\n        return e.streamXOR(this._key, O, p, F, 4), this._authenticate(F.subarray(F.length - this.tagLength, F.length), _, F.subarray(0, F.length - this.tagLength), b), s.wipe(O), F;\n      }, u.prototype.open = function(d, p, b, x) {\n        if (d.length > 16)\n          throw new Error(\"ChaCha20Poly1305: incorrect nonce length\");\n        if (p.length < this.tagLength)\n          return null;\n        var O = new Uint8Array(16);\n        O.set(d, O.length - d.length);\n        var _ = new Uint8Array(32);\n        e.stream(this._key, O, _, 4);\n        var C = new Uint8Array(this.tagLength);\n        if (this._authenticate(C, _, p.subarray(0, p.length - this.tagLength), b), !n.equal(C, p.subarray(p.length - this.tagLength, p.length)))\n          return null;\n        var F = p.length - this.tagLength, K;\n        if (x) {\n          if (x.length !== F)\n            throw new Error(\"ChaCha20Poly1305: incorrect destination length\");\n          K = x;\n        } else\n          K = new Uint8Array(F);\n        return e.streamXOR(this._key, O, p.subarray(0, p.length - this.tagLength), K, 4), s.wipe(O), K;\n      }, u.prototype.clean = function() {\n        return s.wipe(this._key), this;\n      }, u.prototype._authenticate = function(d, p, b, x) {\n        var O = new t.Poly1305(p);\n        x && (O.update(x), x.length % 16 > 0 && O.update(o.subarray(x.length % 16))), O.update(b), b.length % 16 > 0 && O.update(o.subarray(b.length % 16));\n        var _ = new Uint8Array(8);\n        x && r.writeUint64LE(x.length, _), O.update(_), r.writeUint64LE(b.length, _), O.update(_);\n        for (var C = O.digest(), F = 0; F < C.length; F++)\n          d[F] = C[F];\n        O.clean(), s.wipe(C), s.wipe(_);\n      }, u;\n    }()\n  );\n  i.ChaCha20Poly1305 = c;\n})(gs);\nvar Nc = {}, ys = {}, cn = {};\nObject.defineProperty(cn, \"__esModule\", { value: !0 });\nfunction vf(i) {\n  return typeof i.saveState < \"u\" && typeof i.restoreState < \"u\" && typeof i.cleanSavedState < \"u\";\n}\ncn.isSerializableHash = vf;\nObject.defineProperty(ys, \"__esModule\", { value: !0 });\nvar jt = cn, _f = di, Ef = Pt, Pc = (\n  /** @class */\n  function() {\n    function i(e, t) {\n      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;\n      var s = new Uint8Array(this.blockSize);\n      t.length > this.blockSize ? this._inner.update(t).finish(s).clean() : s.set(t);\n      for (var r = 0; r < s.length; r++)\n        s[r] ^= 54;\n      this._inner.update(s);\n      for (var r = 0; r < s.length; r++)\n        s[r] ^= 106;\n      this._outer.update(s), jt.isSerializableHash(this._inner) && jt.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), Ef.wipe(s);\n    }\n    return i.prototype.reset = function() {\n      if (!jt.isSerializableHash(this._inner) || !jt.isSerializableHash(this._outer))\n        throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;\n    }, i.prototype.clean = function() {\n      jt.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), jt.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();\n    }, i.prototype.update = function(e) {\n      return this._inner.update(e), this;\n    }, i.prototype.finish = function(e) {\n      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);\n    }, i.prototype.digest = function() {\n      var e = new Uint8Array(this.digestLength);\n      return this.finish(e), e;\n    }, i.prototype.saveState = function() {\n      if (!jt.isSerializableHash(this._inner))\n        throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n      return this._inner.saveState();\n    }, i.prototype.restoreState = function(e) {\n      if (!jt.isSerializableHash(this._inner) || !jt.isSerializableHash(this._outer))\n        throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;\n    }, i.prototype.cleanSavedState = function(e) {\n      if (!jt.isSerializableHash(this._inner))\n        throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n      this._inner.cleanSavedState(e);\n    }, i;\n  }()\n);\nys.HMAC = Pc;\nfunction Sf(i, e, t) {\n  var s = new Pc(i, e);\n  s.update(t);\n  var r = s.digest();\n  return s.clean(), r;\n}\nys.hmac = Sf;\nys.equal = _f.equal;\nObject.defineProperty(Nc, \"__esModule\", { value: !0 });\nvar vo = ys, _o = Pt, If = (\n  /** @class */\n  function() {\n    function i(e, t, s, r) {\n      s === void 0 && (s = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = r;\n      var n = vo.hmac(this._hash, s, t);\n      this._hmac = new vo.HMAC(e, n), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;\n    }\n    return i.prototype._fillBuffer = function() {\n      this._counter[0]++;\n      var e = this._counter[0];\n      if (e === 0)\n        throw new Error(\"hkdf: cannot expand more\");\n      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;\n    }, i.prototype.expand = function(e) {\n      for (var t = new Uint8Array(e), s = 0; s < t.length; s++)\n        this._bufpos === this._buffer.length && this._fillBuffer(), t[s] = this._buffer[this._bufpos++];\n      return t;\n    }, i.prototype.clean = function() {\n      this._hmac.clean(), _o.wipe(this._buffer), _o.wipe(this._counter), this._bufpos = 0;\n    }, i;\n  }()\n), Rc = Nc.HKDF = If, Si = {};\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  var e = oe, t = Pt;\n  i.DIGEST_LENGTH = 32, i.BLOCK_SIZE = 64;\n  var s = (\n    /** @class */\n    function() {\n      function c() {\n        this.digestLength = i.DIGEST_LENGTH, this.blockSize = i.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();\n      }\n      return c.prototype._initState = function() {\n        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;\n      }, c.prototype.reset = function() {\n        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;\n      }, c.prototype.clean = function() {\n        t.wipe(this._buffer), t.wipe(this._temp), this.reset();\n      }, c.prototype.update = function(u, d) {\n        if (d === void 0 && (d = u.length), this._finished)\n          throw new Error(\"SHA256: can't update because hash was finished.\");\n        var p = 0;\n        if (this._bytesHashed += d, this._bufferLength > 0) {\n          for (; this._bufferLength < this.blockSize && d > 0; )\n            this._buffer[this._bufferLength++] = u[p++], d--;\n          this._bufferLength === this.blockSize && (n(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);\n        }\n        for (d >= this.blockSize && (p = n(this._temp, this._state, u, p, d), d %= this.blockSize); d > 0; )\n          this._buffer[this._bufferLength++] = u[p++], d--;\n        return this;\n      }, c.prototype.finish = function(u) {\n        if (!this._finished) {\n          var d = this._bytesHashed, p = this._bufferLength, b = d / 536870912 | 0, x = d << 3, O = d % 64 < 56 ? 64 : 128;\n          this._buffer[p] = 128;\n          for (var _ = p + 1; _ < O - 8; _++)\n            this._buffer[_] = 0;\n          e.writeUint32BE(b, this._buffer, O - 8), e.writeUint32BE(x, this._buffer, O - 4), n(this._temp, this._state, this._buffer, 0, O), this._finished = !0;\n        }\n        for (var _ = 0; _ < this.digestLength / 4; _++)\n          e.writeUint32BE(this._state[_], u, _ * 4);\n        return this;\n      }, c.prototype.digest = function() {\n        var u = new Uint8Array(this.digestLength);\n        return this.finish(u), u;\n      }, c.prototype.saveState = function() {\n        if (this._finished)\n          throw new Error(\"SHA256: cannot save finished state\");\n        return {\n          state: new Int32Array(this._state),\n          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,\n          bufferLength: this._bufferLength,\n          bytesHashed: this._bytesHashed\n        };\n      }, c.prototype.restoreState = function(u) {\n        return this._state.set(u.state), this._bufferLength = u.bufferLength, u.buffer && this._buffer.set(u.buffer), this._bytesHashed = u.bytesHashed, this._finished = !1, this;\n      }, c.prototype.cleanSavedState = function(u) {\n        t.wipe(u.state), u.buffer && t.wipe(u.buffer), u.bufferLength = 0, u.bytesHashed = 0;\n      }, c;\n    }()\n  );\n  i.SHA256 = s;\n  var r = new Int32Array([\n    1116352408,\n    1899447441,\n    3049323471,\n    3921009573,\n    961987163,\n    1508970993,\n    2453635748,\n    2870763221,\n    3624381080,\n    310598401,\n    607225278,\n    1426881987,\n    1925078388,\n    2162078206,\n    2614888103,\n    3248222580,\n    3835390401,\n    4022224774,\n    264347078,\n    604807628,\n    770255983,\n    1249150122,\n    1555081692,\n    1996064986,\n    2554220882,\n    2821834349,\n    2952996808,\n    3210313671,\n    3336571891,\n    3584528711,\n    113926993,\n    338241895,\n    666307205,\n    773529912,\n    1294757372,\n    1396182291,\n    1695183700,\n    1986661051,\n    2177026350,\n    2456956037,\n    2730485921,\n    2820302411,\n    3259730800,\n    3345764771,\n    3516065817,\n    3600352804,\n    4094571909,\n    275423344,\n    430227734,\n    506948616,\n    659060556,\n    883997877,\n    958139571,\n    1322822218,\n    1537002063,\n    1747873779,\n    1955562222,\n    2024104815,\n    2227730452,\n    2361852424,\n    2428436474,\n    2756734187,\n    3204031479,\n    3329325298\n  ]);\n  function n(c, u, d, p, b) {\n    for (; b >= 64; ) {\n      for (var x = u[0], O = u[1], _ = u[2], C = u[3], F = u[4], K = u[5], I = u[6], D = u[7], y = 0; y < 16; y++) {\n        var w = p + y * 4;\n        c[y] = e.readUint32BE(d, w);\n      }\n      for (var y = 16; y < 64; y++) {\n        var f = c[y - 2], a = (f >>> 17 | f << 32 - 17) ^ (f >>> 19 | f << 32 - 19) ^ f >>> 10;\n        f = c[y - 15];\n        var l = (f >>> 7 | f << 32 - 7) ^ (f >>> 18 | f << 32 - 18) ^ f >>> 3;\n        c[y] = (a + c[y - 7] | 0) + (l + c[y - 16] | 0);\n      }\n      for (var y = 0; y < 64; y++) {\n        var a = (((F >>> 6 | F << 26) ^ (F >>> 11 | F << 21) ^ (F >>> 25 | F << 7)) + (F & K ^ ~F & I) | 0) + (D + (r[y] + c[y] | 0) | 0) | 0, l = ((x >>> 2 | x << 32 - 2) ^ (x >>> 13 | x << 32 - 13) ^ (x >>> 22 | x << 32 - 22)) + (x & O ^ x & _ ^ O & _) | 0;\n        D = I, I = K, K = F, F = C + a | 0, C = _, _ = O, O = x, x = a + l | 0;\n      }\n      u[0] += x, u[1] += O, u[2] += _, u[3] += C, u[4] += F, u[5] += K, u[6] += I, u[7] += D, p += 64, b -= 64;\n    }\n    return p;\n  }\n  function o(c) {\n    var u = new s();\n    u.update(c);\n    var d = u.digest();\n    return u.clean(), d;\n  }\n  i.hash = o;\n})(Si);\nvar ms = {};\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 }), i.sharedKey = i.generateKeyPair = i.generateKeyPairFromSeed = i.scalarMultBase = i.scalarMult = i.SHARED_KEY_LENGTH = i.SECRET_KEY_LENGTH = i.PUBLIC_KEY_LENGTH = void 0;\n  const e = li, t = Pt;\n  i.PUBLIC_KEY_LENGTH = 32, i.SECRET_KEY_LENGTH = 32, i.SHARED_KEY_LENGTH = 32;\n  function s(y) {\n    const w = new Float64Array(16);\n    if (y)\n      for (let f = 0; f < y.length; f++)\n        w[f] = y[f];\n    return w;\n  }\n  const r = new Uint8Array(32);\n  r[0] = 9;\n  const n = s([56129, 1]);\n  function o(y) {\n    let w = 1;\n    for (let f = 0; f < 16; f++) {\n      let a = y[f] + w + 65535;\n      w = Math.floor(a / 65536), y[f] = a - w * 65536;\n    }\n    y[0] += w - 1 + 37 * (w - 1);\n  }\n  function c(y, w, f) {\n    const a = ~(f - 1);\n    for (let l = 0; l < 16; l++) {\n      const L = a & (y[l] ^ w[l]);\n      y[l] ^= L, w[l] ^= L;\n    }\n  }\n  function u(y, w) {\n    const f = s(), a = s();\n    for (let l = 0; l < 16; l++)\n      a[l] = w[l];\n    o(a), o(a), o(a);\n    for (let l = 0; l < 2; l++) {\n      f[0] = a[0] - 65517;\n      for (let v = 1; v < 15; v++)\n        f[v] = a[v] - 65535 - (f[v - 1] >> 16 & 1), f[v - 1] &= 65535;\n      f[15] = a[15] - 32767 - (f[14] >> 16 & 1);\n      const L = f[15] >> 16 & 1;\n      f[14] &= 65535, c(a, f, 1 - L);\n    }\n    for (let l = 0; l < 16; l++)\n      y[2 * l] = a[l] & 255, y[2 * l + 1] = a[l] >> 8;\n  }\n  function d(y, w) {\n    for (let f = 0; f < 16; f++)\n      y[f] = w[2 * f] + (w[2 * f + 1] << 8);\n    y[15] &= 32767;\n  }\n  function p(y, w, f) {\n    for (let a = 0; a < 16; a++)\n      y[a] = w[a] + f[a];\n  }\n  function b(y, w, f) {\n    for (let a = 0; a < 16; a++)\n      y[a] = w[a] - f[a];\n  }\n  function x(y, w, f) {\n    let a, l, L = 0, v = 0, R = 0, $ = 0, q = 0, m = 0, E = 0, B = 0, z = 0, j = 0, U = 0, M = 0, H = 0, te = 0, G = 0, ie = 0, Q = 0, se = 0, T = 0, A = 0, N = 0, h = 0, S = 0, W = 0, X = 0, fe = 0, ve = 0, ge = 0, Se = 0, Me = 0, $e = 0, be = f[0], ye = f[1], pe = f[2], le = f[3], ue = f[4], he = f[5], ce = f[6], re = f[7], de = f[8], me = f[9], ne = f[10], _e = f[11], Ee = f[12], De = f[13], xe = f[14], Ie = f[15];\n    a = w[0], L += a * be, v += a * ye, R += a * pe, $ += a * le, q += a * ue, m += a * he, E += a * ce, B += a * re, z += a * de, j += a * me, U += a * ne, M += a * _e, H += a * Ee, te += a * De, G += a * xe, ie += a * Ie, a = w[1], v += a * be, R += a * ye, $ += a * pe, q += a * le, m += a * ue, E += a * he, B += a * ce, z += a * re, j += a * de, U += a * me, M += a * ne, H += a * _e, te += a * Ee, G += a * De, ie += a * xe, Q += a * Ie, a = w[2], R += a * be, $ += a * ye, q += a * pe, m += a * le, E += a * ue, B += a * he, z += a * ce, j += a * re, U += a * de, M += a * me, H += a * ne, te += a * _e, G += a * Ee, ie += a * De, Q += a * xe, se += a * Ie, a = w[3], $ += a * be, q += a * ye, m += a * pe, E += a * le, B += a * ue, z += a * he, j += a * ce, U += a * re, M += a * de, H += a * me, te += a * ne, G += a * _e, ie += a * Ee, Q += a * De, se += a * xe, T += a * Ie, a = w[4], q += a * be, m += a * ye, E += a * pe, B += a * le, z += a * ue, j += a * he, U += a * ce, M += a * re, H += a * de, te += a * me, G += a * ne, ie += a * _e, Q += a * Ee, se += a * De, T += a * xe, A += a * Ie, a = w[5], m += a * be, E += a * ye, B += a * pe, z += a * le, j += a * ue, U += a * he, M += a * ce, H += a * re, te += a * de, G += a * me, ie += a * ne, Q += a * _e, se += a * Ee, T += a * De, A += a * xe, N += a * Ie, a = w[6], E += a * be, B += a * ye, z += a * pe, j += a * le, U += a * ue, M += a * he, H += a * ce, te += a * re, G += a * de, ie += a * me, Q += a * ne, se += a * _e, T += a * Ee, A += a * De, N += a * xe, h += a * Ie, a = w[7], B += a * be, z += a * ye, j += a * pe, U += a * le, M += a * ue, H += a * he, te += a * ce, G += a * re, ie += a * de, Q += a * me, se += a * ne, T += a * _e, A += a * Ee, N += a * De, h += a * xe, S += a * Ie, a = w[8], z += a * be, j += a * ye, U += a * pe, M += a * le, H += a * ue, te += a * he, G += a * ce, ie += a * re, Q += a * de, se += a * me, T += a * ne, A += a * _e, N += a * Ee, h += a * De, S += a * xe, W += a * Ie, a = w[9], j += a * be, U += a * ye, M += a * pe, H += a * le, te += a * ue, G += a * he, ie += a * ce, Q += a * re, se += a * de, T += a * me, A += a * ne, N += a * _e, h += a * Ee, S += a * De, W += a * xe, X += a * Ie, a = w[10], U += a * be, M += a * ye, H += a * pe, te += a * le, G += a * ue, ie += a * he, Q += a * ce, se += a * re, T += a * de, A += a * me, N += a * ne, h += a * _e, S += a * Ee, W += a * De, X += a * xe, fe += a * Ie, a = w[11], M += a * be, H += a * ye, te += a * pe, G += a * le, ie += a * ue, Q += a * he, se += a * ce, T += a * re, A += a * de, N += a * me, h += a * ne, S += a * _e, W += a * Ee, X += a * De, fe += a * xe, ve += a * Ie, a = w[12], H += a * be, te += a * ye, G += a * pe, ie += a * le, Q += a * ue, se += a * he, T += a * ce, A += a * re, N += a * de, h += a * me, S += a * ne, W += a * _e, X += a * Ee, fe += a * De, ve += a * xe, ge += a * Ie, a = w[13], te += a * be, G += a * ye, ie += a * pe, Q += a * le, se += a * ue, T += a * he, A += a * ce, N += a * re, h += a * de, S += a * me, W += a * ne, X += a * _e, fe += a * Ee, ve += a * De, ge += a * xe, Se += a * Ie, a = w[14], G += a * be, ie += a * ye, Q += a * pe, se += a * le, T += a * ue, A += a * he, N += a * ce, h += a * re, S += a * de, W += a * me, X += a * ne, fe += a * _e, ve += a * Ee, ge += a * De, Se += a * xe, Me += a * Ie, a = w[15], ie += a * be, Q += a * ye, se += a * pe, T += a * le, A += a * ue, N += a * he, h += a * ce, S += a * re, W += a * de, X += a * me, fe += a * ne, ve += a * _e, ge += a * Ee, Se += a * De, Me += a * xe, $e += a * Ie, L += 38 * Q, v += 38 * se, R += 38 * T, $ += 38 * A, q += 38 * N, m += 38 * h, E += 38 * S, B += 38 * W, z += 38 * X, j += 38 * fe, U += 38 * ve, M += 38 * ge, H += 38 * Se, te += 38 * Me, G += 38 * $e, l = 1, a = L + l + 65535, l = Math.floor(a / 65536), L = a - l * 65536, a = v + l + 65535, l = Math.floor(a / 65536), v = a - l * 65536, a = R + l + 65535, l = Math.floor(a / 65536), R = a - l * 65536, a = $ + l + 65535, l = Math.floor(a / 65536), $ = a - l * 65536, a = q + l + 65535, l = Math.floor(a / 65536), q = a - l * 65536, a = m + l + 65535, l = Math.floor(a / 65536), m = a - l * 65536, a = E + l + 65535, l = Math.floor(a / 65536), E = a - l * 65536, a = B + l + 65535, l = Math.floor(a / 65536), B = a - l * 65536, a = z + l + 65535, l = Math.floor(a / 65536), z = a - l * 65536, a = j + l + 65535, l = Math.floor(a / 65536), j = a - l * 65536, a = U + l + 65535, l = Math.floor(a / 65536), U = a - l * 65536, a = M + l + 65535, l = Math.floor(a / 65536), M = a - l * 65536, a = H + l + 65535, l = Math.floor(a / 65536), H = a - l * 65536, a = te + l + 65535, l = Math.floor(a / 65536), te = a - l * 65536, a = G + l + 65535, l = Math.floor(a / 65536), G = a - l * 65536, a = ie + l + 65535, l = Math.floor(a / 65536), ie = a - l * 65536, L += l - 1 + 37 * (l - 1), l = 1, a = L + l + 65535, l = Math.floor(a / 65536), L = a - l * 65536, a = v + l + 65535, l = Math.floor(a / 65536), v = a - l * 65536, a = R + l + 65535, l = Math.floor(a / 65536), R = a - l * 65536, a = $ + l + 65535, l = Math.floor(a / 65536), $ = a - l * 65536, a = q + l + 65535, l = Math.floor(a / 65536), q = a - l * 65536, a = m + l + 65535, l = Math.floor(a / 65536), m = a - l * 65536, a = E + l + 65535, l = Math.floor(a / 65536), E = a - l * 65536, a = B + l + 65535, l = Math.floor(a / 65536), B = a - l * 65536, a = z + l + 65535, l = Math.floor(a / 65536), z = a - l * 65536, a = j + l + 65535, l = Math.floor(a / 65536), j = a - l * 65536, a = U + l + 65535, l = Math.floor(a / 65536), U = a - l * 65536, a = M + l + 65535, l = Math.floor(a / 65536), M = a - l * 65536, a = H + l + 65535, l = Math.floor(a / 65536), H = a - l * 65536, a = te + l + 65535, l = Math.floor(a / 65536), te = a - l * 65536, a = G + l + 65535, l = Math.floor(a / 65536), G = a - l * 65536, a = ie + l + 65535, l = Math.floor(a / 65536), ie = a - l * 65536, L += l - 1 + 37 * (l - 1), y[0] = L, y[1] = v, y[2] = R, y[3] = $, y[4] = q, y[5] = m, y[6] = E, y[7] = B, y[8] = z, y[9] = j, y[10] = U, y[11] = M, y[12] = H, y[13] = te, y[14] = G, y[15] = ie;\n  }\n  function O(y, w) {\n    x(y, w, w);\n  }\n  function _(y, w) {\n    const f = s();\n    for (let a = 0; a < 16; a++)\n      f[a] = w[a];\n    for (let a = 253; a >= 0; a--)\n      O(f, f), a !== 2 && a !== 4 && x(f, f, w);\n    for (let a = 0; a < 16; a++)\n      y[a] = f[a];\n  }\n  function C(y, w) {\n    const f = new Uint8Array(32), a = new Float64Array(80), l = s(), L = s(), v = s(), R = s(), $ = s(), q = s();\n    for (let z = 0; z < 31; z++)\n      f[z] = y[z];\n    f[31] = y[31] & 127 | 64, f[0] &= 248, d(a, w);\n    for (let z = 0; z < 16; z++)\n      L[z] = a[z];\n    l[0] = R[0] = 1;\n    for (let z = 254; z >= 0; --z) {\n      const j = f[z >>> 3] >>> (z & 7) & 1;\n      c(l, L, j), c(v, R, j), p($, l, v), b(l, l, v), p(v, L, R), b(L, L, R), O(R, $), O(q, l), x(l, v, l), x(v, L, $), p($, l, v), b(l, l, v), O(L, l), b(v, R, q), x(l, v, n), p(l, l, R), x(v, v, l), x(l, R, q), x(R, L, a), O(L, $), c(l, L, j), c(v, R, j);\n    }\n    for (let z = 0; z < 16; z++)\n      a[z + 16] = l[z], a[z + 32] = v[z], a[z + 48] = L[z], a[z + 64] = R[z];\n    const m = a.subarray(32), E = a.subarray(16);\n    _(m, m), x(E, E, m);\n    const B = new Uint8Array(32);\n    return u(B, E), B;\n  }\n  i.scalarMult = C;\n  function F(y) {\n    return C(y, r);\n  }\n  i.scalarMultBase = F;\n  function K(y) {\n    if (y.length !== i.SECRET_KEY_LENGTH)\n      throw new Error(`x25519: seed must be ${i.SECRET_KEY_LENGTH} bytes`);\n    const w = new Uint8Array(y);\n    return {\n      publicKey: F(w),\n      secretKey: w\n    };\n  }\n  i.generateKeyPairFromSeed = K;\n  function I(y) {\n    const w = (0, e.randomBytes)(32, y), f = K(w);\n    return (0, t.wipe)(w), f;\n  }\n  i.generateKeyPair = I;\n  function D(y, w, f = !1) {\n    if (y.length !== i.PUBLIC_KEY_LENGTH)\n      throw new Error(\"X25519: incorrect secret key length\");\n    if (w.length !== i.PUBLIC_KEY_LENGTH)\n      throw new Error(\"X25519: incorrect public key length\");\n    const a = C(y, w);\n    if (f) {\n      let l = 0;\n      for (let L = 0; L < a.length; L++)\n        l |= a[L];\n      if (l === 0)\n        throw new Error(\"X25519: invalid shared key\");\n    }\n    return a;\n  }\n  i.sharedKey = D;\n})(ms);\nvar Eo = globalThis && globalThis.__spreadArray || function(i, e, t) {\n  if (t || arguments.length === 2)\n    for (var s = 0, r = e.length, n; s < r; s++)\n      (n || !(s in e)) && (n || (n = Array.prototype.slice.call(e, 0, s)), n[s] = e[s]);\n  return i.concat(n || Array.prototype.slice.call(e));\n}, Df = (\n  /** @class */\n  function() {\n    function i(e, t, s) {\n      this.name = e, this.version = t, this.os = s, this.type = \"browser\";\n    }\n    return i;\n  }()\n), xf = (\n  /** @class */\n  function() {\n    function i(e) {\n      this.version = e, this.type = \"node\", this.name = \"node\", this.os = process.platform;\n    }\n    return i;\n  }()\n), Of = (\n  /** @class */\n  function() {\n    function i(e, t, s, r) {\n      this.name = e, this.version = t, this.os = s, this.bot = r, this.type = \"bot-device\";\n    }\n    return i;\n  }()\n), Nf = (\n  /** @class */\n  function() {\n    function i() {\n      this.type = \"bot\", this.bot = !0, this.name = \"bot\", this.version = null, this.os = null;\n    }\n    return i;\n  }()\n), Pf = (\n  /** @class */\n  function() {\n    function i() {\n      this.type = \"react-native\", this.name = \"react-native\", this.version = null, this.os = null;\n    }\n    return i;\n  }()\n), Rf = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, Cf = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\\ Jeeves\\/Teoma|ia_archiver)/, So = 3, Af = [\n  [\"aol\", /AOLShield\\/([0-9\\._]+)/],\n  [\"edge\", /Edge\\/([0-9\\._]+)/],\n  [\"edge-ios\", /EdgiOS\\/([0-9\\._]+)/],\n  [\"yandexbrowser\", /YaBrowser\\/([0-9\\._]+)/],\n  [\"kakaotalk\", /KAKAOTALK\\s([0-9\\.]+)/],\n  [\"samsung\", /SamsungBrowser\\/([0-9\\.]+)/],\n  [\"silk\", /\\bSilk\\/([0-9._-]+)\\b/],\n  [\"miui\", /MiuiBrowser\\/([0-9\\.]+)$/],\n  [\"beaker\", /BeakerBrowser\\/([0-9\\.]+)/],\n  [\"edge-chromium\", /EdgA?\\/([0-9\\.]+)/],\n  [\n    \"chromium-webview\",\n    /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/\n  ],\n  [\"chrome\", /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"phantomjs\", /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"crios\", /CriOS\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"firefox\", /Firefox\\/([0-9\\.]+)(?:\\s|$)/],\n  [\"fxios\", /FxiOS\\/([0-9\\.]+)/],\n  [\"opera-mini\", /Opera Mini.*Version\\/([0-9\\.]+)/],\n  [\"opera\", /Opera\\/([0-9\\.]+)(?:\\s|$)/],\n  [\"opera\", /OPR\\/([0-9\\.]+)(:?\\s|$)/],\n  [\"pie\", /^Microsoft Pocket Internet Explorer\\/(\\d+\\.\\d+)$/],\n  [\"pie\", /^Mozilla\\/\\d\\.\\d+\\s\\(compatible;\\s(?:MSP?IE|MSInternet Explorer) (\\d+\\.\\d+);.*Windows CE.*\\)$/],\n  [\"netfront\", /^Mozilla\\/\\d\\.\\d+.*NetFront\\/(\\d.\\d)/],\n  [\"ie\", /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/],\n  [\"ie\", /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/],\n  [\"ie\", /MSIE\\s(7\\.0)/],\n  [\"bb10\", /BB10;\\sTouch.*Version\\/([0-9\\.]+)/],\n  [\"android\", /Android\\s([0-9\\.]+)/],\n  [\"ios\", /Version\\/([0-9\\._]+).*Mobile.*Safari.*/],\n  [\"safari\", /Version\\/([0-9\\._]+).*Safari/],\n  [\"facebook\", /FB[AS]V\\/([0-9\\.]+)/],\n  [\"instagram\", /Instagram\\s([0-9\\.]+)/],\n  [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Mobile/],\n  [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/],\n  [\"curl\", /^curl\\/([0-9\\.]+)$/],\n  [\"searchbot\", Rf]\n], Io = [\n  [\"iOS\", /iP(hone|od|ad)/],\n  [\"Android OS\", /Android/],\n  [\"BlackBerry OS\", /BlackBerry|BB10/],\n  [\"Windows Mobile\", /IEMobile/],\n  [\"Amazon OS\", /Kindle/],\n  [\"Windows 3.11\", /Win16/],\n  [\"Windows 95\", /(Windows 95)|(Win95)|(Windows_95)/],\n  [\"Windows 98\", /(Windows 98)|(Win98)/],\n  [\"Windows 2000\", /(Windows NT 5.0)|(Windows 2000)/],\n  [\"Windows XP\", /(Windows NT 5.1)|(Windows XP)/],\n  [\"Windows Server 2003\", /(Windows NT 5.2)/],\n  [\"Windows Vista\", /(Windows NT 6.0)/],\n  [\"Windows 7\", /(Windows NT 6.1)/],\n  [\"Windows 8\", /(Windows NT 6.2)/],\n  [\"Windows 8.1\", /(Windows NT 6.3)/],\n  [\"Windows 10\", /(Windows NT 10.0)/],\n  [\"Windows ME\", /Windows ME/],\n  [\"Windows CE\", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],\n  [\"Open BSD\", /OpenBSD/],\n  [\"Sun OS\", /SunOS/],\n  [\"Chrome OS\", /CrOS/],\n  [\"Linux\", /(Linux)|(X11)/],\n  [\"Mac OS\", /(Mac_PowerPC)|(Macintosh)/],\n  [\"QNX\", /QNX/],\n  [\"BeOS\", /BeOS/],\n  [\"OS/2\", /OS\\/2/]\n];\nfunction hn(i) {\n  return i ? Do(i) : typeof document > \"u\" && typeof navigator < \"u\" && navigator.product === \"ReactNative\" ? new Pf() : typeof navigator < \"u\" ? Do(navigator.userAgent) : Ff();\n}\nfunction Tf(i) {\n  return i !== \"\" && Af.reduce(function(e, t) {\n    var s = t[0], r = t[1];\n    if (e)\n      return e;\n    var n = r.exec(i);\n    return !!n && [s, n];\n  }, !1);\n}\nfunction Do(i) {\n  var e = Tf(i);\n  if (!e)\n    return null;\n  var t = e[0], s = e[1];\n  if (t === \"searchbot\")\n    return new Nf();\n  var r = s[1] && s[1].split(\".\").join(\"_\").split(\"_\").slice(0, 3);\n  r ? r.length < So && (r = Eo(Eo([], r, !0), Uf(So - r.length), !0)) : r = [];\n  var n = r.join(\".\"), o = $f(i), c = Cf.exec(i);\n  return c && c[1] ? new Of(t, n, o, c[1]) : new Df(t, n, o);\n}\nfunction $f(i) {\n  for (var e = 0, t = Io.length; e < t; e++) {\n    var s = Io[e], r = s[0], n = s[1], o = n.exec(i);\n    if (o)\n      return r;\n  }\n  return null;\n}\nfunction Ff() {\n  var i = typeof process < \"u\" && process.version;\n  return i ? new xf(process.version.slice(1)) : null;\n}\nfunction Uf(i) {\n  for (var e = [], t = 0; t < i; t++)\n    e.push(\"0\");\n  return e;\n}\nvar Pe = {};\nObject.defineProperty(Pe, \"__esModule\", { value: !0 });\nPe.getLocalStorage = Pe.getLocalStorageOrThrow = Pe.getCrypto = Pe.getCryptoOrThrow = ln = Pe.getLocation = Pe.getLocationOrThrow = bs = Pe.getNavigator = Pe.getNavigatorOrThrow = un = Pe.getDocument = Pe.getDocumentOrThrow = Pe.getFromWindowOrThrow = Pe.getFromWindow = void 0;\nfunction Ii(i) {\n  let e;\n  return typeof window < \"u\" && typeof window[i] < \"u\" && (e = window[i]), e;\n}\nPe.getFromWindow = Ii;\nfunction Li(i) {\n  const e = Ii(i);\n  if (!e)\n    throw new Error(`${i} is not defined in Window`);\n  return e;\n}\nPe.getFromWindowOrThrow = Li;\nfunction Lf() {\n  return Li(\"document\");\n}\nPe.getDocumentOrThrow = Lf;\nfunction Mf() {\n  return Ii(\"document\");\n}\nvar un = Pe.getDocument = Mf;\nfunction qf() {\n  return Li(\"navigator\");\n}\nPe.getNavigatorOrThrow = qf;\nfunction jf() {\n  return Ii(\"navigator\");\n}\nvar bs = Pe.getNavigator = jf;\nfunction zf() {\n  return Li(\"location\");\n}\nPe.getLocationOrThrow = zf;\nfunction Kf() {\n  return Ii(\"location\");\n}\nvar ln = Pe.getLocation = Kf;\nfunction Vf() {\n  return Li(\"crypto\");\n}\nPe.getCryptoOrThrow = Vf;\nfunction Bf() {\n  return Ii(\"crypto\");\n}\nPe.getCrypto = Bf;\nfunction kf() {\n  return Li(\"localStorage\");\n}\nPe.getLocalStorageOrThrow = kf;\nfunction Hf() {\n  return Ii(\"localStorage\");\n}\nPe.getLocalStorage = Hf;\nvar dn = {};\nObject.defineProperty(dn, \"__esModule\", { value: !0 });\nvar fn = dn.getWindowMetadata = void 0;\nconst xo = Pe;\nfunction Gf() {\n  let i, e;\n  try {\n    i = xo.getDocumentOrThrow(), e = xo.getLocationOrThrow();\n  } catch {\n    return null;\n  }\n  function t() {\n    const b = i.getElementsByTagName(\"link\"), x = [];\n    for (let O = 0; O < b.length; O++) {\n      const _ = b[O], C = _.getAttribute(\"rel\");\n      if (C && C.toLowerCase().indexOf(\"icon\") > -1) {\n        const F = _.getAttribute(\"href\");\n        if (F)\n          if (F.toLowerCase().indexOf(\"https:\") === -1 && F.toLowerCase().indexOf(\"http:\") === -1 && F.indexOf(\"//\") !== 0) {\n            let K = e.protocol + \"//\" + e.host;\n            if (F.indexOf(\"/\") === 0)\n              K += F;\n            else {\n              const I = e.pathname.split(\"/\");\n              I.pop();\n              const D = I.join(\"/\");\n              K += D + \"/\" + F;\n            }\n            x.push(K);\n          } else if (F.indexOf(\"//\") === 0) {\n            const K = e.protocol + F;\n            x.push(K);\n          } else\n            x.push(F);\n      }\n    }\n    return x;\n  }\n  function s(...b) {\n    const x = i.getElementsByTagName(\"meta\");\n    for (let O = 0; O < x.length; O++) {\n      const _ = x[O], C = [\"itemprop\", \"property\", \"name\"].map((F) => _.getAttribute(F)).filter((F) => F ? b.includes(F) : !1);\n      if (C.length && C) {\n        const F = _.getAttribute(\"content\");\n        if (F)\n          return F;\n      }\n    }\n    return \"\";\n  }\n  function r() {\n    let b = s(\"name\", \"og:site_name\", \"og:title\", \"twitter:title\");\n    return b || (b = i.title), b;\n  }\n  function n() {\n    return s(\"description\", \"og:description\", \"twitter:description\", \"keywords\");\n  }\n  const o = r(), c = n(), u = e.origin, d = t();\n  return {\n    description: c,\n    url: u,\n    icons: d,\n    name: o\n  };\n}\nfn = dn.getWindowMetadata = Gf;\nvar ii = {}, Wf = (i) => encodeURIComponent(i).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), Cc = \"%[a-f0-9]{2}\", Oo = new RegExp(\"(\" + Cc + \")|([^%]+?)\", \"gi\"), No = new RegExp(\"(\" + Cc + \")+\", \"gi\");\nfunction Vr(i, e) {\n  try {\n    return [decodeURIComponent(i.join(\"\"))];\n  } catch {\n  }\n  if (i.length === 1)\n    return i;\n  e = e || 1;\n  var t = i.slice(0, e), s = i.slice(e);\n  return Array.prototype.concat.call([], Vr(t), Vr(s));\n}\nfunction Yf(i) {\n  try {\n    return decodeURIComponent(i);\n  } catch {\n    for (var e = i.match(Oo) || [], t = 1; t < e.length; t++)\n      i = Vr(e, t).join(\"\"), e = i.match(Oo) || [];\n    return i;\n  }\n}\nfunction Jf(i) {\n  for (var e = {\n    \"%FE%FF\": \"��\",\n    \"%FF%FE\": \"��\"\n  }, t = No.exec(i); t; ) {\n    try {\n      e[t[0]] = decodeURIComponent(t[0]);\n    } catch {\n      var s = Yf(t[0]);\n      s !== t[0] && (e[t[0]] = s);\n    }\n    t = No.exec(i);\n  }\n  e[\"%C2\"] = \"�\";\n  for (var r = Object.keys(e), n = 0; n < r.length; n++) {\n    var o = r[n];\n    i = i.replace(new RegExp(o, \"g\"), e[o]);\n  }\n  return i;\n}\nvar Qf = function(i) {\n  if (typeof i != \"string\")\n    throw new TypeError(\"Expected `encodedURI` to be of type `string`, got `\" + typeof i + \"`\");\n  try {\n    return i = i.replace(/\\+/g, \" \"), decodeURIComponent(i);\n  } catch {\n    return Jf(i);\n  }\n}, Xf = (i, e) => {\n  if (!(typeof i == \"string\" && typeof e == \"string\"))\n    throw new TypeError(\"Expected the arguments to be of type `string`\");\n  if (e === \"\")\n    return [i];\n  const t = i.indexOf(e);\n  return t === -1 ? [i] : [\n    i.slice(0, t),\n    i.slice(t + e.length)\n  ];\n}, Zf = function(i, e) {\n  for (var t = {}, s = Object.keys(i), r = Array.isArray(e), n = 0; n < s.length; n++) {\n    var o = s[n], c = i[o];\n    (r ? e.indexOf(o) !== -1 : e(o, c, i)) && (t[o] = c);\n  }\n  return t;\n};\n(function(i) {\n  const e = Wf, t = Qf, s = Xf, r = Zf, n = (I) => I == null, o = Symbol(\"encodeFragmentIdentifier\");\n  function c(I) {\n    switch (I.arrayFormat) {\n      case \"index\":\n        return (D) => (y, w) => {\n          const f = y.length;\n          return w === void 0 || I.skipNull && w === null || I.skipEmptyString && w === \"\" ? y : w === null ? [...y, [p(D, I), \"[\", f, \"]\"].join(\"\")] : [\n            ...y,\n            [p(D, I), \"[\", p(f, I), \"]=\", p(w, I)].join(\"\")\n          ];\n        };\n      case \"bracket\":\n        return (D) => (y, w) => w === void 0 || I.skipNull && w === null || I.skipEmptyString && w === \"\" ? y : w === null ? [...y, [p(D, I), \"[]\"].join(\"\")] : [...y, [p(D, I), \"[]=\", p(w, I)].join(\"\")];\n      case \"colon-list-separator\":\n        return (D) => (y, w) => w === void 0 || I.skipNull && w === null || I.skipEmptyString && w === \"\" ? y : w === null ? [...y, [p(D, I), \":list=\"].join(\"\")] : [...y, [p(D, I), \":list=\", p(w, I)].join(\"\")];\n      case \"comma\":\n      case \"separator\":\n      case \"bracket-separator\": {\n        const D = I.arrayFormat === \"bracket-separator\" ? \"[]=\" : \"=\";\n        return (y) => (w, f) => f === void 0 || I.skipNull && f === null || I.skipEmptyString && f === \"\" ? w : (f = f === null ? \"\" : f, w.length === 0 ? [[p(y, I), D, p(f, I)].join(\"\")] : [[w, p(f, I)].join(I.arrayFormatSeparator)]);\n      }\n      default:\n        return (D) => (y, w) => w === void 0 || I.skipNull && w === null || I.skipEmptyString && w === \"\" ? y : w === null ? [...y, p(D, I)] : [...y, [p(D, I), \"=\", p(w, I)].join(\"\")];\n    }\n  }\n  function u(I) {\n    let D;\n    switch (I.arrayFormat) {\n      case \"index\":\n        return (y, w, f) => {\n          if (D = /\\[(\\d*)\\]$/.exec(y), y = y.replace(/\\[\\d*\\]$/, \"\"), !D) {\n            f[y] = w;\n            return;\n          }\n          f[y] === void 0 && (f[y] = {}), f[y][D[1]] = w;\n        };\n      case \"bracket\":\n        return (y, w, f) => {\n          if (D = /(\\[\\])$/.exec(y), y = y.replace(/\\[\\]$/, \"\"), !D) {\n            f[y] = w;\n            return;\n          }\n          if (f[y] === void 0) {\n            f[y] = [w];\n            return;\n          }\n          f[y] = [].concat(f[y], w);\n        };\n      case \"colon-list-separator\":\n        return (y, w, f) => {\n          if (D = /(:list)$/.exec(y), y = y.replace(/:list$/, \"\"), !D) {\n            f[y] = w;\n            return;\n          }\n          if (f[y] === void 0) {\n            f[y] = [w];\n            return;\n          }\n          f[y] = [].concat(f[y], w);\n        };\n      case \"comma\":\n      case \"separator\":\n        return (y, w, f) => {\n          const a = typeof w == \"string\" && w.includes(I.arrayFormatSeparator), l = typeof w == \"string\" && !a && b(w, I).includes(I.arrayFormatSeparator);\n          w = l ? b(w, I) : w;\n          const L = a || l ? w.split(I.arrayFormatSeparator).map((v) => b(v, I)) : w === null ? w : b(w, I);\n          f[y] = L;\n        };\n      case \"bracket-separator\":\n        return (y, w, f) => {\n          const a = /(\\[\\])$/.test(y);\n          if (y = y.replace(/\\[\\]$/, \"\"), !a) {\n            f[y] = w && b(w, I);\n            return;\n          }\n          const l = w === null ? [] : w.split(I.arrayFormatSeparator).map((L) => b(L, I));\n          if (f[y] === void 0) {\n            f[y] = l;\n            return;\n          }\n          f[y] = [].concat(f[y], l);\n        };\n      default:\n        return (y, w, f) => {\n          if (f[y] === void 0) {\n            f[y] = w;\n            return;\n          }\n          f[y] = [].concat(f[y], w);\n        };\n    }\n  }\n  function d(I) {\n    if (typeof I != \"string\" || I.length !== 1)\n      throw new TypeError(\"arrayFormatSeparator must be single character string\");\n  }\n  function p(I, D) {\n    return D.encode ? D.strict ? e(I) : encodeURIComponent(I) : I;\n  }\n  function b(I, D) {\n    return D.decode ? t(I) : I;\n  }\n  function x(I) {\n    return Array.isArray(I) ? I.sort() : typeof I == \"object\" ? x(Object.keys(I)).sort((D, y) => Number(D) - Number(y)).map((D) => I[D]) : I;\n  }\n  function O(I) {\n    const D = I.indexOf(\"#\");\n    return D !== -1 && (I = I.slice(0, D)), I;\n  }\n  function _(I) {\n    let D = \"\";\n    const y = I.indexOf(\"#\");\n    return y !== -1 && (D = I.slice(y)), D;\n  }\n  function C(I) {\n    I = O(I);\n    const D = I.indexOf(\"?\");\n    return D === -1 ? \"\" : I.slice(D + 1);\n  }\n  function F(I, D) {\n    return D.parseNumbers && !Number.isNaN(Number(I)) && typeof I == \"string\" && I.trim() !== \"\" ? I = Number(I) : D.parseBooleans && I !== null && (I.toLowerCase() === \"true\" || I.toLowerCase() === \"false\") && (I = I.toLowerCase() === \"true\"), I;\n  }\n  function K(I, D) {\n    D = Object.assign({\n      decode: !0,\n      sort: !0,\n      arrayFormat: \"none\",\n      arrayFormatSeparator: \",\",\n      parseNumbers: !1,\n      parseBooleans: !1\n    }, D), d(D.arrayFormatSeparator);\n    const y = u(D), w = /* @__PURE__ */ Object.create(null);\n    if (typeof I != \"string\" || (I = I.trim().replace(/^[?#&]/, \"\"), !I))\n      return w;\n    for (const f of I.split(\"&\")) {\n      if (f === \"\")\n        continue;\n      let [a, l] = s(D.decode ? f.replace(/\\+/g, \" \") : f, \"=\");\n      l = l === void 0 ? null : [\"comma\", \"separator\", \"bracket-separator\"].includes(D.arrayFormat) ? l : b(l, D), y(b(a, D), l, w);\n    }\n    for (const f of Object.keys(w)) {\n      const a = w[f];\n      if (typeof a == \"object\" && a !== null)\n        for (const l of Object.keys(a))\n          a[l] = F(a[l], D);\n      else\n        w[f] = F(a, D);\n    }\n    return D.sort === !1 ? w : (D.sort === !0 ? Object.keys(w).sort() : Object.keys(w).sort(D.sort)).reduce((f, a) => {\n      const l = w[a];\n      return l && typeof l == \"object\" && !Array.isArray(l) ? f[a] = x(l) : f[a] = l, f;\n    }, /* @__PURE__ */ Object.create(null));\n  }\n  i.extract = C, i.parse = K, i.stringify = (I, D) => {\n    if (!I)\n      return \"\";\n    D = Object.assign({\n      encode: !0,\n      strict: !0,\n      arrayFormat: \"none\",\n      arrayFormatSeparator: \",\"\n    }, D), d(D.arrayFormatSeparator);\n    const y = (l) => D.skipNull && n(I[l]) || D.skipEmptyString && I[l] === \"\", w = c(D), f = {};\n    for (const l of Object.keys(I))\n      y(l) || (f[l] = I[l]);\n    const a = Object.keys(f);\n    return D.sort !== !1 && a.sort(D.sort), a.map((l) => {\n      const L = I[l];\n      return L === void 0 ? \"\" : L === null ? p(l, D) : Array.isArray(L) ? L.length === 0 && D.arrayFormat === \"bracket-separator\" ? p(l, D) + \"[]\" : L.reduce(w(l), []).join(\"&\") : p(l, D) + \"=\" + p(L, D);\n    }).filter((l) => l.length > 0).join(\"&\");\n  }, i.parseUrl = (I, D) => {\n    D = Object.assign({\n      decode: !0\n    }, D);\n    const [y, w] = s(I, \"#\");\n    return Object.assign(\n      {\n        url: y.split(\"?\")[0] || \"\",\n        query: K(C(I), D)\n      },\n      D && D.parseFragmentIdentifier && w ? { fragmentIdentifier: b(w, D) } : {}\n    );\n  }, i.stringifyUrl = (I, D) => {\n    D = Object.assign({\n      encode: !0,\n      strict: !0,\n      [o]: !0\n    }, D);\n    const y = O(I.url).split(\"?\")[0] || \"\", w = i.extract(I.url), f = i.parse(w, { sort: !1 }), a = Object.assign(f, I.query);\n    let l = i.stringify(a, D);\n    l && (l = `?${l}`);\n    let L = _(I.url);\n    return I.fragmentIdentifier && (L = `#${D[o] ? p(I.fragmentIdentifier, D) : I.fragmentIdentifier}`), `${y}${l}${L}`;\n  }, i.pick = (I, D, y) => {\n    y = Object.assign({\n      parseFragmentIdentifier: !0,\n      [o]: !1\n    }, y);\n    const { url: w, query: f, fragmentIdentifier: a } = i.parseUrl(I, y);\n    return i.stringifyUrl({\n      url: w,\n      query: r(f, D),\n      fragmentIdentifier: a\n    }, y);\n  }, i.exclude = (I, D, y) => {\n    const w = Array.isArray(D) ? (f) => !D.includes(f) : (f, a) => !D(f, a);\n    return i.pick(I, w, y);\n  };\n})(ii);\nconst Ac = {\n  waku: {\n    publish: \"waku_publish\",\n    batchPublish: \"waku_batchPublish\",\n    subscribe: \"waku_subscribe\",\n    batchSubscribe: \"waku_batchSubscribe\",\n    subscription: \"waku_subscription\",\n    unsubscribe: \"waku_unsubscribe\",\n    batchUnsubscribe: \"waku_batchUnsubscribe\"\n  },\n  irn: {\n    publish: \"irn_publish\",\n    batchPublish: \"irn_batchPublish\",\n    subscribe: \"irn_subscribe\",\n    batchSubscribe: \"irn_batchSubscribe\",\n    subscription: \"irn_subscription\",\n    unsubscribe: \"irn_unsubscribe\",\n    batchUnsubscribe: \"irn_batchUnsubscribe\"\n  },\n  iridium: {\n    publish: \"iridium_publish\",\n    batchPublish: \"iridium_batchPublish\",\n    subscribe: \"iridium_subscribe\",\n    batchSubscribe: \"iridium_batchSubscribe\",\n    subscription: \"iridium_subscription\",\n    unsubscribe: \"iridium_unsubscribe\",\n    batchUnsubscribe: \"iridium_batchUnsubscribe\"\n  }\n};\nfunction Tc(i, e) {\n  return i.includes(\":\") ? [i] : e.chains || [];\n}\nconst $c = \"base10\", vt = \"base16\", Br = \"base64pad\", pn = \"utf8\", Fc = 0, Di = 1, ep = 0, Po = 1, kr = 12, gn = 32;\nfunction tp() {\n  const i = ms.generateKeyPair();\n  return { privateKey: Ne(i.secretKey, vt), publicKey: Ne(i.publicKey, vt) };\n}\nfunction Hr() {\n  const i = li.randomBytes(gn);\n  return Ne(i, vt);\n}\nfunction ip(i, e) {\n  const t = ms.sharedKey(Ce(i, vt), Ce(e, vt), !0), s = new Rc(Si.SHA256, t).expand(gn);\n  return Ne(s, vt);\n}\nfunction sp(i) {\n  const e = Si.hash(Ce(i, vt));\n  return Ne(e, vt);\n}\nfunction Fi(i) {\n  const e = Si.hash(Ce(i, pn));\n  return Ne(e, vt);\n}\nfunction rp(i) {\n  return Ce(`${i}`, $c);\n}\nfunction ws(i) {\n  return Number(Ne(i, $c));\n}\nfunction np(i) {\n  const e = rp(typeof i.type < \"u\" ? i.type : Fc);\n  if (ws(e) === Di && typeof i.senderPublicKey > \"u\")\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof i.senderPublicKey < \"u\" ? Ce(i.senderPublicKey, vt) : void 0, s = typeof i.iv < \"u\" ? Ce(i.iv, vt) : li.randomBytes(kr), r = new gs.ChaCha20Poly1305(Ce(i.symKey, vt)).seal(s, Ce(i.message, pn));\n  return ap({ type: e, sealed: r, iv: s, senderPublicKey: t });\n}\nfunction op(i) {\n  const e = new gs.ChaCha20Poly1305(Ce(i.symKey, vt)), { sealed: t, iv: s } = Ys(i.encoded), r = e.open(s, t);\n  if (r === null)\n    throw new Error(\"Failed to decrypt\");\n  return Ne(r, pn);\n}\nfunction ap(i) {\n  if (ws(i.type) === Di) {\n    if (typeof i.senderPublicKey > \"u\")\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    return Ne(ls([i.type, i.senderPublicKey, i.iv, i.sealed]), Br);\n  }\n  return Ne(ls([i.type, i.iv, i.sealed]), Br);\n}\nfunction Ys(i) {\n  const e = Ce(i, Br), t = e.slice(ep, Po), s = Po;\n  if (ws(t) === Di) {\n    const c = s + gn, u = c + kr, d = e.slice(s, c), p = e.slice(c, u), b = e.slice(u);\n    return { type: t, sealed: b, iv: p, senderPublicKey: d };\n  }\n  const r = s + kr, n = e.slice(s, r), o = e.slice(r);\n  return { type: t, sealed: o, iv: n };\n}\nfunction cp(i, e) {\n  const t = Ys(i);\n  return Uc({ type: ws(t.type), senderPublicKey: typeof t.senderPublicKey < \"u\" ? Ne(t.senderPublicKey, vt) : void 0, receiverPublicKey: e?.receiverPublicKey });\n}\nfunction Uc(i) {\n  const e = i?.type || Fc;\n  if (e === Di) {\n    if (typeof i?.senderPublicKey > \"u\")\n      throw new Error(\"missing sender public key\");\n    if (typeof i?.receiverPublicKey > \"u\")\n      throw new Error(\"missing receiver public key\");\n  }\n  return { type: e, senderPublicKey: i?.senderPublicKey, receiverPublicKey: i?.receiverPublicKey };\n}\nfunction Ro(i) {\n  return i.type === Di && typeof i.senderPublicKey == \"string\" && typeof i.receiverPublicKey == \"string\";\n}\nvar hp = Object.defineProperty, Co = Object.getOwnPropertySymbols, up = Object.prototype.hasOwnProperty, lp = Object.prototype.propertyIsEnumerable, Ao = (i, e, t) => e in i ? hp(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, To = (i, e) => {\n  for (var t in e || (e = {}))\n    up.call(e, t) && Ao(i, t, e[t]);\n  if (Co)\n    for (var t of Co(e))\n      lp.call(e, t) && Ao(i, t, e[t]);\n  return i;\n};\nconst dp = \"ReactNative\", Ot = { reactNative: \"react-native\", node: \"node\", browser: \"browser\", unknown: \"unknown\" }, fp = \"js\";\nfunction yn() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction ur() {\n  return !un() && !!bs() && navigator.product === dp;\n}\nfunction vs() {\n  return !yn() && !!bs();\n}\nfunction _s() {\n  return ur() ? Ot.reactNative : yn() ? Ot.node : vs() ? Ot.browser : Ot.unknown;\n}\nfunction pp(i, e) {\n  let t = ii.parse(i);\n  return t = To(To({}, t), e), i = ii.stringify(t), i;\n}\nfunction gp() {\n  return fn() || { name: \"\", description: \"\", url: \"\", icons: [\"\"] };\n}\nfunction yp() {\n  if (_s() === Ot.reactNative && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\") {\n    const { OS: t, Version: s } = global.Platform;\n    return [t, s].join(\"-\");\n  }\n  const i = hn();\n  if (i === null)\n    return \"unknown\";\n  const e = i.os ? i.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return i.type === \"browser\" ? [e, i.name, i.version].join(\"-\") : [e, i.version].join(\"-\");\n}\nfunction mp() {\n  var i;\n  const e = _s();\n  return e === Ot.browser ? [e, ((i = ln()) == null ? void 0 : i.host) || \"unknown\"].join(\":\") : e;\n}\nfunction bp(i, e, t) {\n  const s = yp(), r = mp();\n  return [[i, e].join(\"-\"), [fp, t].join(\"-\"), s, r].join(\"/\");\n}\nfunction wp({ protocol: i, version: e, relayUrl: t, sdkVersion: s, auth: r, projectId: n, useOnCloseEvent: o }) {\n  const c = t.split(\"?\"), u = bp(i, e, s), d = { auth: r, ua: u, projectId: n, useOnCloseEvent: o || void 0 }, p = pp(c[1] || \"\", d);\n  return c[0] + \"?\" + p;\n}\nfunction _i(i, e) {\n  return i.filter((t) => e.includes(t)).length === i.length;\n}\nfunction Lc(i) {\n  return Object.fromEntries(i.entries());\n}\nfunction Mc(i) {\n  return new Map(Object.entries(i));\n}\nfunction Ai(i = V.FIVE_MINUTES, e) {\n  const t = V.toMiliseconds(i || V.FIVE_MINUTES);\n  let s, r, n;\n  return { resolve: (o) => {\n    n && s && (clearTimeout(n), s(o));\n  }, reject: (o) => {\n    n && r && (clearTimeout(n), r(o));\n  }, done: () => new Promise((o, c) => {\n    n = setTimeout(() => {\n      c(new Error(e));\n    }, t), s = o, r = c;\n  }) };\n}\nfunction ds(i, e, t) {\n  return new Promise(async (s, r) => {\n    const n = setTimeout(() => r(new Error(t)), e);\n    try {\n      const o = await i;\n      s(o);\n    } catch (o) {\n      r(o);\n    }\n    clearTimeout(n);\n  });\n}\nfunction qc(i, e) {\n  if (typeof e == \"string\" && e.startsWith(`${i}:`))\n    return e;\n  if (i.toLowerCase() === \"topic\") {\n    if (typeof e != \"string\")\n      throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${e}`;\n  } else if (i.toLowerCase() === \"id\") {\n    if (typeof e != \"number\")\n      throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${e}`;\n  }\n  throw new Error(`Unknown expirer target type: ${i}`);\n}\nfunction vp(i) {\n  return qc(\"topic\", i);\n}\nfunction _p(i) {\n  return qc(\"id\", i);\n}\nfunction jc(i) {\n  const [e, t] = i.split(\":\"), s = { id: void 0, topic: void 0 };\n  if (e === \"topic\" && typeof t == \"string\")\n    s.topic = t;\n  else if (e === \"id\" && Number.isInteger(Number(t)))\n    s.id = Number(t);\n  else\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);\n  return s;\n}\nfunction Mt(i, e) {\n  return V.fromMiliseconds((e || Date.now()) + V.toMiliseconds(i));\n}\nfunction ai(i) {\n  return Date.now() >= V.toMiliseconds(i);\n}\nfunction Be(i, e) {\n  return `${i}${e ? `:${e}` : \"\"}`;\n}\nasync function Ep({ id: i, topic: e, wcDeepLink: t }) {\n  try {\n    if (!t)\n      return;\n    let r = (typeof t == \"string\" ? JSON.parse(t) : t)?.href;\n    if (typeof r != \"string\")\n      return;\n    r.endsWith(\"/\") && (r = r.slice(0, -1));\n    const n = `${r}/wc?requestId=${i}&sessionTopic=${e}`, o = _s();\n    o === Ot.browser ? n.startsWith(\"https://\") ? window.open(n, \"_blank\", \"noreferrer noopener\") : window.open(n, \"_self\", \"noreferrer noopener\") : o === Ot.reactNative && typeof (global == null ? void 0 : global.Linking) < \"u\" && await global.Linking.openURL(n);\n  } catch (s) {\n    console.error(s);\n  }\n}\nconst Sp = \"irn\";\nfunction Gr(i) {\n  return i?.relay || { protocol: Sp };\n}\nfunction js(i) {\n  const e = Ac[i];\n  if (typeof e > \"u\")\n    throw new Error(`Relay Protocol not supported: ${i}`);\n  return e;\n}\nvar Ip = Object.defineProperty, $o = Object.getOwnPropertySymbols, Dp = Object.prototype.hasOwnProperty, xp = Object.prototype.propertyIsEnumerable, Fo = (i, e, t) => e in i ? Ip(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Op = (i, e) => {\n  for (var t in e || (e = {}))\n    Dp.call(e, t) && Fo(i, t, e[t]);\n  if ($o)\n    for (var t of $o(e))\n      xp.call(e, t) && Fo(i, t, e[t]);\n  return i;\n};\nfunction Np(i, e = \"-\") {\n  const t = {}, s = \"relay\" + e;\n  return Object.keys(i).forEach((r) => {\n    if (r.startsWith(s)) {\n      const n = r.replace(s, \"\"), o = i[r];\n      t[n] = o;\n    }\n  }), t;\n}\nfunction Pp(i) {\n  const e = i.indexOf(\":\"), t = i.indexOf(\"?\") !== -1 ? i.indexOf(\"?\") : void 0, s = i.substring(0, e), r = i.substring(e + 1, t).split(\"@\"), n = typeof t < \"u\" ? i.substring(t) : \"\", o = ii.parse(n);\n  return { protocol: s, topic: Rp(r[0]), version: parseInt(r[1], 10), symKey: o.symKey, relay: Np(o) };\n}\nfunction Rp(i) {\n  return i.startsWith(\"//\") ? i.substring(2) : i;\n}\nfunction Cp(i, e = \"-\") {\n  const t = \"relay\", s = {};\n  return Object.keys(i).forEach((r) => {\n    const n = t + e + r;\n    i[r] && (s[n] = i[r]);\n  }), s;\n}\nfunction Ap(i) {\n  return `${i.protocol}:${i.topic}@${i.version}?` + ii.stringify(Op({ symKey: i.symKey }, Cp(i.relay)));\n}\nfunction Mi(i) {\n  const e = [];\n  return i.forEach((t) => {\n    const [s, r] = t.split(\":\");\n    e.push(`${s}:${r}`);\n  }), e;\n}\nfunction Tp(i) {\n  const e = [];\n  return Object.values(i).forEach((t) => {\n    e.push(...Mi(t.accounts));\n  }), e;\n}\nfunction $p(i, e) {\n  const t = [];\n  return Object.values(i).forEach((s) => {\n    Mi(s.accounts).includes(e) && t.push(...s.methods);\n  }), t;\n}\nfunction Fp(i, e) {\n  const t = [];\n  return Object.values(i).forEach((s) => {\n    Mi(s.accounts).includes(e) && t.push(...s.events);\n  }), t;\n}\nfunction Up(i, e) {\n  const t = zs(i, e);\n  if (t)\n    throw new Error(t.message);\n  const s = {};\n  for (const [r, n] of Object.entries(i))\n    s[r] = { methods: n.methods, events: n.events, chains: n.accounts.map((o) => `${o.split(\":\")[0]}:${o.split(\":\")[1]}`) };\n  return s;\n}\nconst Lp = { INVALID_METHOD: { message: \"Invalid method.\", code: 1001 }, INVALID_EVENT: { message: \"Invalid event.\", code: 1002 }, INVALID_UPDATE_REQUEST: { message: \"Invalid update request.\", code: 1003 }, INVALID_EXTEND_REQUEST: { message: \"Invalid extend request.\", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: \"Invalid session settle request.\", code: 1005 }, UNAUTHORIZED_METHOD: { message: \"Unauthorized method.\", code: 3001 }, UNAUTHORIZED_EVENT: { message: \"Unauthorized event.\", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: \"Unauthorized update request.\", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: \"Unauthorized extend request.\", code: 3004 }, USER_REJECTED: { message: \"User rejected.\", code: 5e3 }, USER_REJECTED_CHAINS: { message: \"User rejected chains.\", code: 5001 }, USER_REJECTED_METHODS: { message: \"User rejected methods.\", code: 5002 }, USER_REJECTED_EVENTS: { message: \"User rejected events.\", code: 5003 }, UNSUPPORTED_CHAINS: { message: \"Unsupported chains.\", code: 5100 }, UNSUPPORTED_METHODS: { message: \"Unsupported methods.\", code: 5101 }, UNSUPPORTED_EVENTS: { message: \"Unsupported events.\", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: \"Unsupported accounts.\", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: \"Unsupported namespace key.\", code: 5104 }, USER_DISCONNECTED: { message: \"User disconnected.\", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: \"Session settlement failed.\", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: \"Unsupported wc_ method.\", code: 10001 } }, Mp = { NOT_INITIALIZED: { message: \"Not initialized.\", code: 1 }, NO_MATCHING_KEY: { message: \"No matching key.\", code: 2 }, RESTORE_WILL_OVERRIDE: { message: \"Restore will override.\", code: 3 }, RESUBSCRIBED: { message: \"Resubscribed.\", code: 4 }, MISSING_OR_INVALID: { message: \"Missing or invalid.\", code: 5 }, EXPIRED: { message: \"Expired.\", code: 6 }, UNKNOWN_TYPE: { message: \"Unknown type.\", code: 7 }, MISMATCHED_TOPIC: { message: \"Mismatched topic.\", code: 8 }, NON_CONFORMING_NAMESPACES: { message: \"Non conforming namespaces.\", code: 9 } };\nfunction Y(i, e) {\n  const { message: t, code: s } = Mp[i];\n  return { message: e ? `${t} ${e}` : t, code: s };\n}\nfunction nt(i, e) {\n  const { message: t, code: s } = Lp[i];\n  return { message: e ? `${t} ${e}` : t, code: s };\n}\nfunction Es(i, e) {\n  return Array.isArray(i) ? typeof e < \"u\" && i.length ? i.every(e) : !0 : !1;\n}\nfunction cs(i) {\n  return Object.getPrototypeOf(i) === Object.prototype && Object.keys(i).length;\n}\nfunction bt(i) {\n  return typeof i > \"u\";\n}\nfunction ot(i, e) {\n  return e && bt(i) ? !0 : typeof i == \"string\" && !!i.trim().length;\n}\nfunction mn(i, e) {\n  return e && bt(i) ? !0 : typeof i == \"number\" && !isNaN(i);\n}\nfunction qp(i, e) {\n  const { requiredNamespaces: t } = e, s = Object.keys(i.namespaces), r = Object.keys(t);\n  let n = !0;\n  return _i(r, s) ? (s.forEach((o) => {\n    const { accounts: c, methods: u, events: d } = i.namespaces[o], p = Mi(c), b = t[o];\n    (!_i(Tc(o, b), p) || !_i(b.methods, u) || !_i(b.events, d)) && (n = !1);\n  }), n) : !1;\n}\nfunction Js(i) {\n  return ot(i, !1) && i.includes(\":\") ? i.split(\":\").length === 2 : !1;\n}\nfunction jp(i) {\n  if (ot(i, !1) && i.includes(\":\")) {\n    const e = i.split(\":\");\n    if (e.length === 3) {\n      const t = e[0] + \":\" + e[1];\n      return !!e[2] && Js(t);\n    }\n  }\n  return !1;\n}\nfunction zp(i) {\n  if (ot(i, !1))\n    try {\n      return typeof new URL(i) < \"u\";\n    } catch {\n      return !1;\n    }\n  return !1;\n}\nfunction Kp(i) {\n  var e;\n  return (e = i?.proposer) == null ? void 0 : e.publicKey;\n}\nfunction Vp(i) {\n  return i?.topic;\n}\nfunction Bp(i, e) {\n  let t = null;\n  return ot(i?.publicKey, !1) || (t = Y(\"MISSING_OR_INVALID\", `${e} controller public key should be a string`)), t;\n}\nfunction Uo(i) {\n  let e = !0;\n  return Es(i) ? i.length && (e = i.every((t) => ot(t, !1))) : e = !1, e;\n}\nfunction kp(i, e, t) {\n  let s = null;\n  return Es(e) && e.length ? e.forEach((r) => {\n    s || Js(r) || (s = nt(\"UNSUPPORTED_CHAINS\", `${t}, chain ${r} should be a string and conform to \"namespace:chainId\" format`));\n  }) : Js(i) || (s = nt(\"UNSUPPORTED_CHAINS\", `${t}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`)), s;\n}\nfunction Hp(i, e, t) {\n  let s = null;\n  return Object.entries(i).forEach(([r, n]) => {\n    if (s)\n      return;\n    const o = kp(r, Tc(r, n), `${e} ${t}`);\n    o && (s = o);\n  }), s;\n}\nfunction Gp(i, e) {\n  let t = null;\n  return Es(i) ? i.forEach((s) => {\n    t || jp(s) || (t = nt(\"UNSUPPORTED_ACCOUNTS\", `${e}, account ${s} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = nt(\"UNSUPPORTED_ACCOUNTS\", `${e}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction Wp(i, e) {\n  let t = null;\n  return Object.values(i).forEach((s) => {\n    if (t)\n      return;\n    const r = Gp(s?.accounts, `${e} namespace`);\n    r && (t = r);\n  }), t;\n}\nfunction Yp(i, e) {\n  let t = null;\n  return Uo(i?.methods) ? Uo(i?.events) || (t = nt(\"UNSUPPORTED_EVENTS\", `${e}, events should be an array of strings or empty array for no events`)) : t = nt(\"UNSUPPORTED_METHODS\", `${e}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction zc(i, e) {\n  let t = null;\n  return Object.values(i).forEach((s) => {\n    if (t)\n      return;\n    const r = Yp(s, `${e}, namespace`);\n    r && (t = r);\n  }), t;\n}\nfunction Jp(i, e, t) {\n  let s = null;\n  if (i && cs(i)) {\n    const r = zc(i, e);\n    r && (s = r);\n    const n = Hp(i, e, t);\n    n && (s = n);\n  } else\n    s = Y(\"MISSING_OR_INVALID\", `${e}, ${t} should be an object with data`);\n  return s;\n}\nfunction zs(i, e) {\n  let t = null;\n  if (i && cs(i)) {\n    const s = zc(i, e);\n    s && (t = s);\n    const r = Wp(i, e);\n    r && (t = r);\n  } else\n    t = Y(\"MISSING_OR_INVALID\", `${e}, namespaces should be an object with data`);\n  return t;\n}\nfunction Kc(i) {\n  return ot(i.protocol, !0);\n}\nfunction Qp(i, e) {\n  let t = !1;\n  return e && !i ? t = !0 : i && Es(i) && i.length && i.forEach((s) => {\n    t = Kc(s);\n  }), t;\n}\nfunction Xp(i) {\n  return typeof i == \"number\";\n}\nfunction St(i) {\n  return typeof i < \"u\" && typeof i !== null;\n}\nfunction Zp(i) {\n  return !(!i || typeof i != \"object\" || !i.code || !mn(i.code, !1) || !i.message || !ot(i.message, !1));\n}\nfunction eg(i) {\n  return !(bt(i) || !ot(i.method, !1));\n}\nfunction tg(i) {\n  return !(bt(i) || bt(i.result) && bt(i.error) || !mn(i.id, !1) || !ot(i.jsonrpc, !1));\n}\nfunction ig(i) {\n  return !(bt(i) || !ot(i.name, !1));\n}\nfunction Lo(i, e) {\n  return !(!Js(e) || !Tp(i).includes(e));\n}\nfunction sg(i, e, t) {\n  return ot(t, !1) ? $p(i, e).includes(t) : !1;\n}\nfunction rg(i, e, t) {\n  return ot(t, !1) ? Fp(i, e).includes(t) : !1;\n}\nfunction Mo(i, e, t) {\n  let s = null;\n  const r = ng(i), n = og(e), o = Object.keys(r), c = Object.keys(n), u = qo(Object.keys(i)), d = qo(Object.keys(e)), p = u.filter((b) => !d.includes(b));\n  return p.length && (s = Y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${p.toString()}\n      Received: ${Object.keys(e).toString()}`)), _i(o, c) || (s = Y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces chains don't satisfy required namespaces.\n      Required: ${o.toString()}\n      Approved: ${c.toString()}`)), Object.keys(e).forEach((b) => {\n    if (!b.includes(\":\") || s)\n      return;\n    const x = Mi(e[b].accounts);\n    x.includes(b) || (s = Y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace accounts for ${b}\n        Required: ${b}\n        Approved: ${x.toString()}`));\n  }), o.forEach((b) => {\n    s || (_i(r[b].methods, n[b].methods) ? _i(r[b].events, n[b].events) || (s = Y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${b}`)) : s = Y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${b}`));\n  }), s;\n}\nfunction ng(i) {\n  const e = {};\n  return Object.keys(i).forEach((t) => {\n    var s;\n    t.includes(\":\") ? e[t] = i[t] : (s = i[t].chains) == null || s.forEach((r) => {\n      e[r] = { methods: i[t].methods, events: i[t].events };\n    });\n  }), e;\n}\nfunction qo(i) {\n  return [...new Set(i.map((e) => e.includes(\":\") ? e.split(\":\")[0] : e))];\n}\nfunction og(i) {\n  const e = {};\n  return Object.keys(i).forEach((t) => {\n    t.includes(\":\") ? e[t] = i[t] : Mi(i[t].accounts)?.forEach((r) => {\n      e[r] = { accounts: i[t].accounts.filter((n) => n.includes(`${r}:`)), methods: i[t].methods, events: i[t].events };\n    });\n  }), e;\n}\nfunction ag(i, e) {\n  return mn(i, !1) && i <= e.max && i >= e.min;\n}\nfunction jo() {\n  const i = _s();\n  return new Promise((e) => {\n    switch (i) {\n      case Ot.browser:\n        e(cg());\n        break;\n      case Ot.reactNative:\n        e(hg());\n        break;\n      case Ot.node:\n        e(ug());\n        break;\n      default:\n        e(!0);\n    }\n  });\n}\nfunction cg() {\n  return vs() && navigator?.onLine;\n}\nasync function hg() {\n  return ur() && typeof global < \"u\" && global != null && global.NetInfo ? (await (global == null ? void 0 : global.NetInfo.fetch()))?.isConnected : !0;\n}\nfunction ug() {\n  return !0;\n}\nfunction lg(i) {\n  switch (_s()) {\n    case Ot.browser:\n      dg(i);\n      break;\n    case Ot.reactNative:\n      fg(i);\n      break;\n  }\n}\nfunction dg(i) {\n  vs() && (window.addEventListener(\"online\", () => i(!0)), window.addEventListener(\"offline\", () => i(!1)));\n}\nfunction fg(i) {\n  ur() && typeof global < \"u\" && global != null && global.NetInfo && global?.NetInfo.addEventListener((e) => i(e?.isConnected));\n}\nconst xr = {};\nlet $s = class {\n  static get(e) {\n    return xr[e];\n  }\n  static set(e, t) {\n    xr[e] = t;\n  }\n  static delete(e) {\n    delete xr[e];\n  }\n};\nconst pg = \"PARSE_ERROR\", gg = \"INVALID_REQUEST\", yg = \"METHOD_NOT_FOUND\", mg = \"INVALID_PARAMS\", Vc = \"INTERNAL_ERROR\", bn = \"SERVER_ERROR\", bg = [-32700, -32600, -32601, -32602, -32603], hs = {\n  [pg]: { code: -32700, message: \"Parse error\" },\n  [gg]: { code: -32600, message: \"Invalid Request\" },\n  [yg]: { code: -32601, message: \"Method not found\" },\n  [mg]: { code: -32602, message: \"Invalid params\" },\n  [Vc]: { code: -32603, message: \"Internal error\" },\n  [bn]: { code: -32e3, message: \"Server error\" }\n}, Bc = bn;\nfunction wg(i) {\n  return bg.includes(i);\n}\nfunction zo(i) {\n  return Object.keys(hs).includes(i) ? hs[i] : hs[Bc];\n}\nfunction vg(i) {\n  const e = Object.values(hs).find((t) => t.code === i);\n  return e || hs[Bc];\n}\nfunction _g(i, e, t) {\n  return i.message.includes(\"getaddrinfo ENOTFOUND\") || i.message.includes(\"connect ECONNREFUSED\") ? new Error(`Unavailable ${t} RPC url at ${e}`) : i;\n}\nvar kc = {}, Qt = {}, Ko;\nfunction Eg() {\n  if (Ko)\n    return Qt;\n  Ko = 1, Object.defineProperty(Qt, \"__esModule\", { value: !0 }), Qt.isBrowserCryptoAvailable = Qt.getSubtleCrypto = Qt.getBrowerCrypto = void 0;\n  function i() {\n    return (_lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c === null || _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c === void 0 ? void 0 : _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c.crypto) || (_lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c === null || _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c === void 0 ? void 0 : _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c.msCrypto) || {};\n  }\n  Qt.getBrowerCrypto = i;\n  function e() {\n    const s = i();\n    return s.subtle || s.webkitSubtle;\n  }\n  Qt.getSubtleCrypto = e;\n  function t() {\n    return !!i() && !!e();\n  }\n  return Qt.isBrowserCryptoAvailable = t, Qt;\n}\nvar Xt = {}, Vo;\nfunction Sg() {\n  if (Vo)\n    return Xt;\n  Vo = 1, Object.defineProperty(Xt, \"__esModule\", { value: !0 }), Xt.isBrowser = Xt.isNode = Xt.isReactNative = void 0;\n  function i() {\n    return typeof document > \"u\" && typeof navigator < \"u\" && navigator.product === \"ReactNative\";\n  }\n  Xt.isReactNative = i;\n  function e() {\n    return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n  }\n  Xt.isNode = e;\n  function t() {\n    return !i() && !e();\n  }\n  return Xt.isBrowser = t, Xt;\n}\n(function(i) {\n  Object.defineProperty(i, \"__esModule\", { value: !0 });\n  const e = Ft;\n  e.__exportStar(Eg(), i), e.__exportStar(Sg(), i);\n})(kc);\nfunction wn(i = 3) {\n  const e = Date.now() * Math.pow(10, i), t = Math.floor(Math.random() * Math.pow(10, i));\n  return e + t;\n}\nfunction vn(i = 6) {\n  return BigInt(wn(i));\n}\nfunction ti(i, e, t) {\n  return {\n    id: t || wn(),\n    jsonrpc: \"2.0\",\n    method: i,\n    params: e\n  };\n}\nfunction xi(i, e) {\n  return {\n    id: i,\n    jsonrpc: \"2.0\",\n    result: e\n  };\n}\nfunction qi(i, e, t) {\n  return {\n    id: i,\n    jsonrpc: \"2.0\",\n    error: Ig(e, t)\n  };\n}\nfunction Ig(i, e) {\n  return typeof i > \"u\" ? zo(Vc) : (typeof i == \"string\" && (i = Object.assign(Object.assign({}, zo(bn)), { message: i })), typeof e < \"u\" && (i.data = e), wg(i.code) && (i = vg(i.code)), i);\n}\nclass Hc {\n}\nclass Dg extends Hc {\n  constructor(e) {\n    super();\n  }\n}\nclass xg extends Hc {\n  constructor() {\n    super();\n  }\n}\nclass Og extends xg {\n  constructor(e) {\n    super();\n  }\n}\nconst Ng = \"^wss?:\";\nfunction Pg(i) {\n  const e = i.match(new RegExp(/^\\w+:/, \"gi\"));\n  if (!(!e || !e.length))\n    return e[0];\n}\nfunction Rg(i, e) {\n  const t = Pg(i);\n  return typeof t > \"u\" ? !1 : new RegExp(e).test(t);\n}\nfunction Bo(i) {\n  return Rg(i, Ng);\n}\nfunction Cg(i) {\n  return new RegExp(\"wss?://localhost(:d{2,5})?\").test(i);\n}\nfunction Gc(i) {\n  return typeof i == \"object\" && \"id\" in i && \"jsonrpc\" in i && i.jsonrpc === \"2.0\";\n}\nfunction ji(i) {\n  return Gc(i) && \"method\" in i;\n}\nfunction Oi(i) {\n  return Gc(i) && (ht(i) || Ge(i));\n}\nfunction ht(i) {\n  return \"result\" in i;\n}\nfunction Ge(i) {\n  return \"error\" in i;\n}\nclass _n extends Og {\n  constructor(e) {\n    super(e), this.events = new We.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();\n  }\n  async connect(e = this.connection) {\n    await this.open(e);\n  }\n  async disconnect() {\n    await this.close();\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async request(e, t) {\n    return this.requestStrict(ti(e.method, e.params || [], e.id || vn().toString()), t);\n  }\n  async requestStrict(e, t) {\n    return new Promise(async (s, r) => {\n      if (!this.connection.connected)\n        try {\n          await this.open();\n        } catch (n) {\n          r(n);\n        }\n      this.events.on(`${e.id}`, (n) => {\n        Ge(n) ? r(n.error) : s(n.result);\n      });\n      try {\n        await this.connection.send(e, t);\n      } catch (n) {\n        r(n);\n      }\n    });\n  }\n  setConnection(e = this.connection) {\n    return e;\n  }\n  onPayload(e) {\n    this.events.emit(\"payload\", e), Oi(e) ? this.events.emit(`${e.id}`, e) : this.events.emit(\"message\", {\n      type: e.method,\n      data: e.params\n    });\n  }\n  onClose(e) {\n    e && e.code === 3e3 && this.events.emit(\"error\", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : \"\"}`)), this.events.emit(\"disconnect\");\n  }\n  async open(e = this.connection) {\n    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == \"string\" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit(\"connect\"));\n  }\n  async close() {\n    await this.connection.close();\n  }\n  registerEventListeners() {\n    this.hasRegisteredEventListeners || (this.connection.on(\"payload\", (e) => this.onPayload(e)), this.connection.on(\"close\", (e) => this.onClose(e)), this.connection.on(\"error\", (e) => this.events.emit(\"error\", e)), this.connection.on(\"register_error\", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);\n  }\n}\nconst Ag = () => typeof WebSocket < \"u\" ? WebSocket : typeof global < \"u\" && typeof global.WebSocket < \"u\" ? global.WebSocket : typeof window < \"u\" && typeof window.WebSocket < \"u\" ? window.WebSocket : typeof self < \"u\" && typeof self.WebSocket < \"u\" ? self.WebSocket : require(\"ws\"), Tg = () => typeof WebSocket < \"u\" || typeof global < \"u\" && typeof global.WebSocket < \"u\" || typeof window < \"u\" && typeof window.WebSocket < \"u\" || typeof self < \"u\" && typeof self.WebSocket < \"u\", ko = (i) => i.split(\"?\")[0], Ho = 10, $g = Ag();\nclass Wc {\n  constructor(e) {\n    if (this.url = e, this.events = new We.EventEmitter(), this.registering = !1, !Bo(e))\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);\n    this.url = e;\n  }\n  get connected() {\n    return typeof this.socket < \"u\";\n  }\n  get connecting() {\n    return this.registering;\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async open(e = this.url) {\n    await this.register(e);\n  }\n  async close() {\n    return new Promise((e, t) => {\n      if (typeof this.socket > \"u\") {\n        t(new Error(\"Connection already closed\"));\n        return;\n      }\n      this.socket.onclose = (s) => {\n        this.onClose(s), e();\n      }, this.socket.close();\n    });\n  }\n  async send(e, t) {\n    typeof this.socket > \"u\" && (this.socket = await this.register());\n    try {\n      this.socket.send(rr(e));\n    } catch (s) {\n      this.onError(e.id, s);\n    }\n  }\n  register(e = this.url) {\n    if (!Bo(e))\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);\n    if (this.registering) {\n      const t = this.events.getMaxListeners();\n      return (this.events.listenerCount(\"register_error\") >= t || this.events.listenerCount(\"open\") >= t) && this.events.setMaxListeners(t + 1), new Promise((s, r) => {\n        this.events.once(\"register_error\", (n) => {\n          this.resetMaxListeners(), r(n);\n        }), this.events.once(\"open\", () => {\n          if (this.resetMaxListeners(), typeof this.socket > \"u\")\n            return r(new Error(\"WebSocket connection is missing or invalid\"));\n          s(this.socket);\n        });\n      });\n    }\n    return this.url = e, this.registering = !0, new Promise((t, s) => {\n      const r = kc.isReactNative() ? void 0 : { rejectUnauthorized: !Cg(e) }, n = new $g(e, [], r);\n      Tg() ? n.onerror = (o) => {\n        const c = o;\n        s(this.emitError(c.error));\n      } : n.on(\"error\", (o) => {\n        s(this.emitError(o));\n      }), n.onopen = () => {\n        this.onOpen(n), t(n);\n      };\n    });\n  }\n  onOpen(e) {\n    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = !1, this.events.emit(\"open\");\n  }\n  onClose(e) {\n    this.socket = void 0, this.registering = !1, this.events.emit(\"close\", e);\n  }\n  onPayload(e) {\n    if (typeof e.data > \"u\")\n      return;\n    const t = typeof e.data == \"string\" ? rn(e.data) : e.data;\n    this.events.emit(\"payload\", t);\n  }\n  onError(e, t) {\n    const s = this.parseError(t), r = s.message || s.toString(), n = qi(e, r);\n    this.events.emit(\"payload\", n);\n  }\n  parseError(e, t = this.url) {\n    return _g(e, ko(t), \"WS\");\n  }\n  resetMaxListeners() {\n    this.events.getMaxListeners() > Ho && this.events.setMaxListeners(Ho);\n  }\n  emitError(e) {\n    const t = this.parseError(new Error(e?.message || `WebSocket connection failed for host: ${ko(this.url)}`));\n    return this.events.emit(\"register_error\", t), t;\n  }\n}\nvar Qs = { exports: {} };\nQs.exports;\n(function(i, e) {\n  var t = 200, s = \"__lodash_hash_undefined__\", r = 1, n = 2, o = 9007199254740991, c = \"[object Arguments]\", u = \"[object Array]\", d = \"[object AsyncFunction]\", p = \"[object Boolean]\", b = \"[object Date]\", x = \"[object Error]\", O = \"[object Function]\", _ = \"[object GeneratorFunction]\", C = \"[object Map]\", F = \"[object Number]\", K = \"[object Null]\", I = \"[object Object]\", D = \"[object Promise]\", y = \"[object Proxy]\", w = \"[object RegExp]\", f = \"[object Set]\", a = \"[object String]\", l = \"[object Symbol]\", L = \"[object Undefined]\", v = \"[object WeakMap]\", R = \"[object ArrayBuffer]\", $ = \"[object DataView]\", q = \"[object Float32Array]\", m = \"[object Float64Array]\", E = \"[object Int8Array]\", B = \"[object Int16Array]\", z = \"[object Int32Array]\", j = \"[object Uint8Array]\", U = \"[object Uint8ClampedArray]\", M = \"[object Uint16Array]\", H = \"[object Uint32Array]\", te = /[\\\\^$.*+?()[\\]{}|]/g, G = /^\\[object .+?Constructor\\]$/, ie = /^(?:0|[1-9]\\d*)$/, Q = {};\n  Q[q] = Q[m] = Q[E] = Q[B] = Q[z] = Q[j] = Q[U] = Q[M] = Q[H] = !0, Q[c] = Q[u] = Q[R] = Q[p] = Q[$] = Q[b] = Q[x] = Q[O] = Q[C] = Q[F] = Q[I] = Q[w] = Q[f] = Q[a] = Q[v] = !1;\n  var se = typeof _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c == \"object\" && _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c && _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c.Object === Object && _lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.c, T = typeof self == \"object\" && self && self.Object === Object && self, A = se || T || Function(\"return this\")(), N = e && !e.nodeType && e, h = N && !0 && i && !i.nodeType && i, S = h && h.exports === N, W = S && se.process, X = function() {\n    try {\n      return W && W.binding && W.binding(\"util\");\n    } catch {\n    }\n  }(), fe = X && X.isTypedArray;\n  function ve(g, P) {\n    for (var k = -1, Z = g == null ? 0 : g.length, Re = 0, ae = []; ++k < Z; ) {\n      var Le = g[k];\n      P(Le, k, g) && (ae[Re++] = Le);\n    }\n    return ae;\n  }\n  function ge(g, P) {\n    for (var k = -1, Z = P.length, Re = g.length; ++k < Z; )\n      g[Re + k] = P[k];\n    return g;\n  }\n  function Se(g, P) {\n    for (var k = -1, Z = g == null ? 0 : g.length; ++k < Z; )\n      if (P(g[k], k, g))\n        return !0;\n    return !1;\n  }\n  function Me(g, P) {\n    for (var k = -1, Z = Array(g); ++k < g; )\n      Z[k] = P(k);\n    return Z;\n  }\n  function $e(g) {\n    return function(P) {\n      return g(P);\n    };\n  }\n  function be(g, P) {\n    return g.has(P);\n  }\n  function ye(g, P) {\n    return g?.[P];\n  }\n  function pe(g) {\n    var P = -1, k = Array(g.size);\n    return g.forEach(function(Z, Re) {\n      k[++P] = [Re, Z];\n    }), k;\n  }\n  function le(g, P) {\n    return function(k) {\n      return g(P(k));\n    };\n  }\n  function ue(g) {\n    var P = -1, k = Array(g.size);\n    return g.forEach(function(Z) {\n      k[++P] = Z;\n    }), k;\n  }\n  var he = Array.prototype, ce = Function.prototype, re = Object.prototype, de = A[\"__core-js_shared__\"], me = ce.toString, ne = re.hasOwnProperty, _e = function() {\n    var g = /[^.]+$/.exec(de && de.keys && de.keys.IE_PROTO || \"\");\n    return g ? \"Symbol(src)_1.\" + g : \"\";\n  }(), Ee = re.toString, De = RegExp(\n    \"^\" + me.call(ne).replace(te, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n  ), xe = S ? A.Buffer : void 0, Ie = A.Symbol, Ut = A.Uint8Array, qt = re.propertyIsEnumerable, si = he.splice, Dt = Ie ? Ie.toStringTag : void 0, fi = Object.getOwnPropertySymbols, Ki = xe ? xe.isBuffer : void 0, Os = le(Object.keys, Object), qe = Pi(A, \"DataView\"), Fe = Pi(A, \"Map\"), je = Pi(A, \"Promise\"), ze = Pi(A, \"Set\"), Ke = Pi(A, \"WeakMap\"), Ue = Pi(Object, \"create\"), Qe = gi(qe), Xe = gi(Fe), Ze = gi(je), et = gi(ze), tt = gi(Ke), Ye = Ie ? Ie.prototype : void 0, Ve = Ye ? Ye.valueOf : void 0;\n  function Ae(g) {\n    var P = -1, k = g == null ? 0 : g.length;\n    for (this.clear(); ++P < k; ) {\n      var Z = g[P];\n      this.set(Z[0], Z[1]);\n    }\n  }\n  function it() {\n    this.__data__ = Ue ? Ue(null) : {}, this.size = 0;\n  }\n  function st(g) {\n    var P = this.has(g) && delete this.__data__[g];\n    return this.size -= P ? 1 : 0, P;\n  }\n  function kh(g) {\n    var P = this.__data__;\n    if (Ue) {\n      var k = P[g];\n      return k === s ? void 0 : k;\n    }\n    return ne.call(P, g) ? P[g] : void 0;\n  }\n  function Hh(g) {\n    var P = this.__data__;\n    return Ue ? P[g] !== void 0 : ne.call(P, g);\n  }\n  function Gh(g, P) {\n    var k = this.__data__;\n    return this.size += this.has(g) ? 0 : 1, k[g] = Ue && P === void 0 ? s : P, this;\n  }\n  Ae.prototype.clear = it, Ae.prototype.delete = st, Ae.prototype.get = kh, Ae.prototype.has = Hh, Ae.prototype.set = Gh;\n  function Yt(g) {\n    var P = -1, k = g == null ? 0 : g.length;\n    for (this.clear(); ++P < k; ) {\n      var Z = g[P];\n      this.set(Z[0], Z[1]);\n    }\n  }\n  function Wh() {\n    this.__data__ = [], this.size = 0;\n  }\n  function Yh(g) {\n    var P = this.__data__, k = Ps(P, g);\n    if (k < 0)\n      return !1;\n    var Z = P.length - 1;\n    return k == Z ? P.pop() : si.call(P, k, 1), --this.size, !0;\n  }\n  function Jh(g) {\n    var P = this.__data__, k = Ps(P, g);\n    return k < 0 ? void 0 : P[k][1];\n  }\n  function Qh(g) {\n    return Ps(this.__data__, g) > -1;\n  }\n  function Xh(g, P) {\n    var k = this.__data__, Z = Ps(k, g);\n    return Z < 0 ? (++this.size, k.push([g, P])) : k[Z][1] = P, this;\n  }\n  Yt.prototype.clear = Wh, Yt.prototype.delete = Yh, Yt.prototype.get = Jh, Yt.prototype.has = Qh, Yt.prototype.set = Xh;\n  function pi(g) {\n    var P = -1, k = g == null ? 0 : g.length;\n    for (this.clear(); ++P < k; ) {\n      var Z = g[P];\n      this.set(Z[0], Z[1]);\n    }\n  }\n  function Zh() {\n    this.size = 0, this.__data__ = {\n      hash: new Ae(),\n      map: new (Fe || Yt)(),\n      string: new Ae()\n    };\n  }\n  function eu(g) {\n    var P = Rs(this, g).delete(g);\n    return this.size -= P ? 1 : 0, P;\n  }\n  function tu(g) {\n    return Rs(this, g).get(g);\n  }\n  function iu(g) {\n    return Rs(this, g).has(g);\n  }\n  function su(g, P) {\n    var k = Rs(this, g), Z = k.size;\n    return k.set(g, P), this.size += k.size == Z ? 0 : 1, this;\n  }\n  pi.prototype.clear = Zh, pi.prototype.delete = eu, pi.prototype.get = tu, pi.prototype.has = iu, pi.prototype.set = su;\n  function Ns(g) {\n    var P = -1, k = g == null ? 0 : g.length;\n    for (this.__data__ = new pi(); ++P < k; )\n      this.add(g[P]);\n  }\n  function ru(g) {\n    return this.__data__.set(g, s), this;\n  }\n  function nu(g) {\n    return this.__data__.has(g);\n  }\n  Ns.prototype.add = Ns.prototype.push = ru, Ns.prototype.has = nu;\n  function ri(g) {\n    var P = this.__data__ = new Yt(g);\n    this.size = P.size;\n  }\n  function ou() {\n    this.__data__ = new Yt(), this.size = 0;\n  }\n  function au(g) {\n    var P = this.__data__, k = P.delete(g);\n    return this.size = P.size, k;\n  }\n  function cu(g) {\n    return this.__data__.get(g);\n  }\n  function hu(g) {\n    return this.__data__.has(g);\n  }\n  function uu(g, P) {\n    var k = this.__data__;\n    if (k instanceof Yt) {\n      var Z = k.__data__;\n      if (!Fe || Z.length < t - 1)\n        return Z.push([g, P]), this.size = ++k.size, this;\n      k = this.__data__ = new pi(Z);\n    }\n    return k.set(g, P), this.size = k.size, this;\n  }\n  ri.prototype.clear = ou, ri.prototype.delete = au, ri.prototype.get = cu, ri.prototype.has = hu, ri.prototype.set = uu;\n  function lu(g, P) {\n    var k = Cs(g), Z = !k && xu(g), Re = !k && !Z && gr(g), ae = !k && !Z && !Re && Kn(g), Le = k || Z || Re || ae, rt = Le ? Me(g.length, String) : [], ct = rt.length;\n    for (var Te in g)\n      (P || ne.call(g, Te)) && !(Le && // Safari 9 has enumerable `arguments.length` in strict mode.\n      (Te == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n      Re && (Te == \"offset\" || Te == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n      ae && (Te == \"buffer\" || Te == \"byteLength\" || Te == \"byteOffset\") || // Skip index properties.\n      _u(Te, ct))) && rt.push(Te);\n    return rt;\n  }\n  function Ps(g, P) {\n    for (var k = g.length; k--; )\n      if (Mn(g[k][0], P))\n        return k;\n    return -1;\n  }\n  function du(g, P, k) {\n    var Z = P(g);\n    return Cs(g) ? Z : ge(Z, k(g));\n  }\n  function Vi(g) {\n    return g == null ? g === void 0 ? L : K : Dt && Dt in Object(g) ? wu(g) : Du(g);\n  }\n  function $n(g) {\n    return Bi(g) && Vi(g) == c;\n  }\n  function Fn(g, P, k, Z, Re) {\n    return g === P ? !0 : g == null || P == null || !Bi(g) && !Bi(P) ? g !== g && P !== P : fu(g, P, k, Z, Fn, Re);\n  }\n  function fu(g, P, k, Z, Re, ae) {\n    var Le = Cs(g), rt = Cs(P), ct = Le ? u : ni(g), Te = rt ? u : ni(P);\n    ct = ct == c ? I : ct, Te = Te == c ? I : Te;\n    var xt = ct == I, Lt = Te == I, ft = ct == Te;\n    if (ft && gr(g)) {\n      if (!gr(P))\n        return !1;\n      Le = !0, xt = !1;\n    }\n    if (ft && !xt)\n      return ae || (ae = new ri()), Le || Kn(g) ? Un(g, P, k, Z, Re, ae) : mu(g, P, ct, k, Z, Re, ae);\n    if (!(k & r)) {\n      var Rt = xt && ne.call(g, \"__wrapped__\"), Ct = Lt && ne.call(P, \"__wrapped__\");\n      if (Rt || Ct) {\n        var oi = Rt ? g.value() : g, Jt = Ct ? P.value() : P;\n        return ae || (ae = new ri()), Re(oi, Jt, k, Z, ae);\n      }\n    }\n    return ft ? (ae || (ae = new ri()), bu(g, P, k, Z, Re, ae)) : !1;\n  }\n  function pu(g) {\n    if (!zn(g) || Su(g))\n      return !1;\n    var P = qn(g) ? De : G;\n    return P.test(gi(g));\n  }\n  function gu(g) {\n    return Bi(g) && jn(g.length) && !!Q[Vi(g)];\n  }\n  function yu(g) {\n    if (!Iu(g))\n      return Os(g);\n    var P = [];\n    for (var k in Object(g))\n      ne.call(g, k) && k != \"constructor\" && P.push(k);\n    return P;\n  }\n  function Un(g, P, k, Z, Re, ae) {\n    var Le = k & r, rt = g.length, ct = P.length;\n    if (rt != ct && !(Le && ct > rt))\n      return !1;\n    var Te = ae.get(g);\n    if (Te && ae.get(P))\n      return Te == P;\n    var xt = -1, Lt = !0, ft = k & n ? new Ns() : void 0;\n    for (ae.set(g, P), ae.set(P, g); ++xt < rt; ) {\n      var Rt = g[xt], Ct = P[xt];\n      if (Z)\n        var oi = Le ? Z(Ct, Rt, xt, P, g, ae) : Z(Rt, Ct, xt, g, P, ae);\n      if (oi !== void 0) {\n        if (oi)\n          continue;\n        Lt = !1;\n        break;\n      }\n      if (ft) {\n        if (!Se(P, function(Jt, yi) {\n          if (!be(ft, yi) && (Rt === Jt || Re(Rt, Jt, k, Z, ae)))\n            return ft.push(yi);\n        })) {\n          Lt = !1;\n          break;\n        }\n      } else if (!(Rt === Ct || Re(Rt, Ct, k, Z, ae))) {\n        Lt = !1;\n        break;\n      }\n    }\n    return ae.delete(g), ae.delete(P), Lt;\n  }\n  function mu(g, P, k, Z, Re, ae, Le) {\n    switch (k) {\n      case $:\n        if (g.byteLength != P.byteLength || g.byteOffset != P.byteOffset)\n          return !1;\n        g = g.buffer, P = P.buffer;\n      case R:\n        return !(g.byteLength != P.byteLength || !ae(new Ut(g), new Ut(P)));\n      case p:\n      case b:\n      case F:\n        return Mn(+g, +P);\n      case x:\n        return g.name == P.name && g.message == P.message;\n      case w:\n      case a:\n        return g == P + \"\";\n      case C:\n        var rt = pe;\n      case f:\n        var ct = Z & r;\n        if (rt || (rt = ue), g.size != P.size && !ct)\n          return !1;\n        var Te = Le.get(g);\n        if (Te)\n          return Te == P;\n        Z |= n, Le.set(g, P);\n        var xt = Un(rt(g), rt(P), Z, Re, ae, Le);\n        return Le.delete(g), xt;\n      case l:\n        if (Ve)\n          return Ve.call(g) == Ve.call(P);\n    }\n    return !1;\n  }\n  function bu(g, P, k, Z, Re, ae) {\n    var Le = k & r, rt = Ln(g), ct = rt.length, Te = Ln(P), xt = Te.length;\n    if (ct != xt && !Le)\n      return !1;\n    for (var Lt = ct; Lt--; ) {\n      var ft = rt[Lt];\n      if (!(Le ? ft in P : ne.call(P, ft)))\n        return !1;\n    }\n    var Rt = ae.get(g);\n    if (Rt && ae.get(P))\n      return Rt == P;\n    var Ct = !0;\n    ae.set(g, P), ae.set(P, g);\n    for (var oi = Le; ++Lt < ct; ) {\n      ft = rt[Lt];\n      var Jt = g[ft], yi = P[ft];\n      if (Z)\n        var Vn = Le ? Z(yi, Jt, ft, P, g, ae) : Z(Jt, yi, ft, g, P, ae);\n      if (!(Vn === void 0 ? Jt === yi || Re(Jt, yi, k, Z, ae) : Vn)) {\n        Ct = !1;\n        break;\n      }\n      oi || (oi = ft == \"constructor\");\n    }\n    if (Ct && !oi) {\n      var As = g.constructor, Ts = P.constructor;\n      As != Ts && \"constructor\" in g && \"constructor\" in P && !(typeof As == \"function\" && As instanceof As && typeof Ts == \"function\" && Ts instanceof Ts) && (Ct = !1);\n    }\n    return ae.delete(g), ae.delete(P), Ct;\n  }\n  function Ln(g) {\n    return du(g, Pu, vu);\n  }\n  function Rs(g, P) {\n    var k = g.__data__;\n    return Eu(P) ? k[typeof P == \"string\" ? \"string\" : \"hash\"] : k.map;\n  }\n  function Pi(g, P) {\n    var k = ye(g, P);\n    return pu(k) ? k : void 0;\n  }\n  function wu(g) {\n    var P = ne.call(g, Dt), k = g[Dt];\n    try {\n      g[Dt] = void 0;\n      var Z = !0;\n    } catch {\n    }\n    var Re = Ee.call(g);\n    return Z && (P ? g[Dt] = k : delete g[Dt]), Re;\n  }\n  var vu = fi ? function(g) {\n    return g == null ? [] : (g = Object(g), ve(fi(g), function(P) {\n      return qt.call(g, P);\n    }));\n  } : Ru, ni = Vi;\n  (qe && ni(new qe(new ArrayBuffer(1))) != $ || Fe && ni(new Fe()) != C || je && ni(je.resolve()) != D || ze && ni(new ze()) != f || Ke && ni(new Ke()) != v) && (ni = function(g) {\n    var P = Vi(g), k = P == I ? g.constructor : void 0, Z = k ? gi(k) : \"\";\n    if (Z)\n      switch (Z) {\n        case Qe:\n          return $;\n        case Xe:\n          return C;\n        case Ze:\n          return D;\n        case et:\n          return f;\n        case tt:\n          return v;\n      }\n    return P;\n  });\n  function _u(g, P) {\n    return P = P ?? o, !!P && (typeof g == \"number\" || ie.test(g)) && g > -1 && g % 1 == 0 && g < P;\n  }\n  function Eu(g) {\n    var P = typeof g;\n    return P == \"string\" || P == \"number\" || P == \"symbol\" || P == \"boolean\" ? g !== \"__proto__\" : g === null;\n  }\n  function Su(g) {\n    return !!_e && _e in g;\n  }\n  function Iu(g) {\n    var P = g && g.constructor, k = typeof P == \"function\" && P.prototype || re;\n    return g === k;\n  }\n  function Du(g) {\n    return Ee.call(g);\n  }\n  function gi(g) {\n    if (g != null) {\n      try {\n        return me.call(g);\n      } catch {\n      }\n      try {\n        return g + \"\";\n      } catch {\n      }\n    }\n    return \"\";\n  }\n  function Mn(g, P) {\n    return g === P || g !== g && P !== P;\n  }\n  var xu = $n(function() {\n    return arguments;\n  }()) ? $n : function(g) {\n    return Bi(g) && ne.call(g, \"callee\") && !qt.call(g, \"callee\");\n  }, Cs = Array.isArray;\n  function Ou(g) {\n    return g != null && jn(g.length) && !qn(g);\n  }\n  var gr = Ki || Cu;\n  function Nu(g, P) {\n    return Fn(g, P);\n  }\n  function qn(g) {\n    if (!zn(g))\n      return !1;\n    var P = Vi(g);\n    return P == O || P == _ || P == d || P == y;\n  }\n  function jn(g) {\n    return typeof g == \"number\" && g > -1 && g % 1 == 0 && g <= o;\n  }\n  function zn(g) {\n    var P = typeof g;\n    return g != null && (P == \"object\" || P == \"function\");\n  }\n  function Bi(g) {\n    return g != null && typeof g == \"object\";\n  }\n  var Kn = fe ? $e(fe) : gu;\n  function Pu(g) {\n    return Ou(g) ? lu(g) : yu(g);\n  }\n  function Ru() {\n    return [];\n  }\n  function Cu() {\n    return !1;\n  }\n  i.exports = Nu;\n})(Qs, Qs.exports);\nvar Fg = Qs.exports;\nconst Yc = /* @__PURE__ */ (0,_lastConnected_b964dc30_js__WEBPACK_IMPORTED_MODULE_0__.e)(Fg);\nfunction Ug(i, e) {\n  if (i.length >= 255)\n    throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), s = 0; s < t.length; s++)\n    t[s] = 255;\n  for (var r = 0; r < i.length; r++) {\n    var n = i.charAt(r), o = n.charCodeAt(0);\n    if (t[o] !== 255)\n      throw new TypeError(n + \" is ambiguous\");\n    t[o] = r;\n  }\n  var c = i.length, u = i.charAt(0), d = Math.log(c) / Math.log(256), p = Math.log(256) / Math.log(c);\n  function b(_) {\n    if (_ instanceof Uint8Array || (ArrayBuffer.isView(_) ? _ = new Uint8Array(_.buffer, _.byteOffset, _.byteLength) : Array.isArray(_) && (_ = Uint8Array.from(_))), !(_ instanceof Uint8Array))\n      throw new TypeError(\"Expected Uint8Array\");\n    if (_.length === 0)\n      return \"\";\n    for (var C = 0, F = 0, K = 0, I = _.length; K !== I && _[K] === 0; )\n      K++, C++;\n    for (var D = (I - K) * p + 1 >>> 0, y = new Uint8Array(D); K !== I; ) {\n      for (var w = _[K], f = 0, a = D - 1; (w !== 0 || f < F) && a !== -1; a--, f++)\n        w += 256 * y[a] >>> 0, y[a] = w % c >>> 0, w = w / c >>> 0;\n      if (w !== 0)\n        throw new Error(\"Non-zero carry\");\n      F = f, K++;\n    }\n    for (var l = D - F; l !== D && y[l] === 0; )\n      l++;\n    for (var L = u.repeat(C); l < D; ++l)\n      L += i.charAt(y[l]);\n    return L;\n  }\n  function x(_) {\n    if (typeof _ != \"string\")\n      throw new TypeError(\"Expected String\");\n    if (_.length === 0)\n      return new Uint8Array();\n    var C = 0;\n    if (_[C] !== \" \") {\n      for (var F = 0, K = 0; _[C] === u; )\n        F++, C++;\n      for (var I = (_.length - C) * d + 1 >>> 0, D = new Uint8Array(I); _[C]; ) {\n        var y = t[_.charCodeAt(C)];\n        if (y === 255)\n          return;\n        for (var w = 0, f = I - 1; (y !== 0 || w < K) && f !== -1; f--, w++)\n          y += c * D[f] >>> 0, D[f] = y % 256 >>> 0, y = y / 256 >>> 0;\n        if (y !== 0)\n          throw new Error(\"Non-zero carry\");\n        K = w, C++;\n      }\n      if (_[C] !== \" \") {\n        for (var a = I - K; a !== I && D[a] === 0; )\n          a++;\n        for (var l = new Uint8Array(F + (I - a)), L = F; a !== I; )\n          l[L++] = D[a++];\n        return l;\n      }\n    }\n  }\n  function O(_) {\n    var C = x(_);\n    if (C)\n      return C;\n    throw new Error(`Non-${e} character`);\n  }\n  return { encode: b, decodeUnsafe: x, decode: O };\n}\nvar Lg = Ug, Mg = Lg;\nconst Jc = (i) => {\n  if (i instanceof Uint8Array && i.constructor.name === \"Uint8Array\")\n    return i;\n  if (i instanceof ArrayBuffer)\n    return new Uint8Array(i);\n  if (ArrayBuffer.isView(i))\n    return new Uint8Array(i.buffer, i.byteOffset, i.byteLength);\n  throw new Error(\"Unknown type, must be binary type\");\n}, qg = (i) => new TextEncoder().encode(i), jg = (i) => new TextDecoder().decode(i);\nlet zg = class {\n  constructor(e, t, s) {\n    this.name = e, this.prefix = t, this.baseEncode = s;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array)\n      return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}, Kg = class {\n  constructor(e, t, s) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)\n      throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint)\n        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else\n      throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return Qc(this, e);\n  }\n}, Vg = class {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return Qc(this, e);\n  }\n  decode(e) {\n    const t = e[0], s = this.decoders[t];\n    if (s)\n      return s.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n};\nconst Qc = (i, e) => new Vg({ ...i.decoders || { [i.prefix]: i }, ...e.decoders || { [e.prefix]: e } });\nlet Bg = class {\n  constructor(e, t, s, r) {\n    this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = r, this.encoder = new zg(e, t, s), this.decoder = new Kg(e, t, r);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n};\nconst lr = ({ name: i, prefix: e, encode: t, decode: s }) => new Bg(i, e, t, s), Ss = ({ prefix: i, name: e, alphabet: t }) => {\n  const { encode: s, decode: r } = Mg(t, e);\n  return lr({ prefix: i, name: e, encode: s, decode: (n) => Jc(r(n)) });\n}, kg = (i, e, t, s) => {\n  const r = {};\n  for (let p = 0; p < e.length; ++p)\n    r[e[p]] = p;\n  let n = i.length;\n  for (; i[n - 1] === \"=\"; )\n    --n;\n  const o = new Uint8Array(n * t / 8 | 0);\n  let c = 0, u = 0, d = 0;\n  for (let p = 0; p < n; ++p) {\n    const b = r[i[p]];\n    if (b === void 0)\n      throw new SyntaxError(`Non-${s} character`);\n    u = u << t | b, c += t, c >= 8 && (c -= 8, o[d++] = 255 & u >> c);\n  }\n  if (c >= t || 255 & u << 8 - c)\n    throw new SyntaxError(\"Unexpected end of data\");\n  return o;\n}, Hg = (i, e, t) => {\n  const s = e[e.length - 1] === \"=\", r = (1 << t) - 1;\n  let n = \"\", o = 0, c = 0;\n  for (let u = 0; u < i.length; ++u)\n    for (c = c << 8 | i[u], o += 8; o > t; )\n      o -= t, n += e[r & c >> o];\n  if (o && (n += e[r & c << t - o]), s)\n    for (; n.length * t & 7; )\n      n += \"=\";\n  return n;\n}, lt = ({ name: i, prefix: e, bitsPerChar: t, alphabet: s }) => lr({ prefix: e, name: i, encode(r) {\n  return Hg(r, s, t);\n}, decode(r) {\n  return kg(r, s, t, i);\n} }), Gg = lr({ prefix: \"\\0\", name: \"identity\", encode: (i) => jg(i), decode: (i) => qg(i) });\nvar Wg = Object.freeze({ __proto__: null, identity: Gg });\nconst Yg = lt({ prefix: \"0\", name: \"base2\", alphabet: \"01\", bitsPerChar: 1 });\nvar Jg = Object.freeze({ __proto__: null, base2: Yg });\nconst Qg = lt({ prefix: \"7\", name: \"base8\", alphabet: \"01234567\", bitsPerChar: 3 });\nvar Xg = Object.freeze({ __proto__: null, base8: Qg });\nconst Zg = Ss({ prefix: \"9\", name: \"base10\", alphabet: \"0123456789\" });\nvar ey = Object.freeze({ __proto__: null, base10: Zg });\nconst ty = lt({ prefix: \"f\", name: \"base16\", alphabet: \"0123456789abcdef\", bitsPerChar: 4 }), iy = lt({ prefix: \"F\", name: \"base16upper\", alphabet: \"0123456789ABCDEF\", bitsPerChar: 4 });\nvar sy = Object.freeze({ __proto__: null, base16: ty, base16upper: iy });\nconst ry = lt({ prefix: \"b\", name: \"base32\", alphabet: \"abcdefghijklmnopqrstuvwxyz234567\", bitsPerChar: 5 }), ny = lt({ prefix: \"B\", name: \"base32upper\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\", bitsPerChar: 5 }), oy = lt({ prefix: \"c\", name: \"base32pad\", alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\", bitsPerChar: 5 }), ay = lt({ prefix: \"C\", name: \"base32padupper\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\", bitsPerChar: 5 }), cy = lt({ prefix: \"v\", name: \"base32hex\", alphabet: \"0123456789abcdefghijklmnopqrstuv\", bitsPerChar: 5 }), hy = lt({ prefix: \"V\", name: \"base32hexupper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\", bitsPerChar: 5 }), uy = lt({ prefix: \"t\", name: \"base32hexpad\", alphabet: \"0123456789abcdefghijklmnopqrstuv=\", bitsPerChar: 5 }), ly = lt({ prefix: \"T\", name: \"base32hexpadupper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\", bitsPerChar: 5 }), dy = lt({ prefix: \"h\", name: \"base32z\", alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\", bitsPerChar: 5 });\nvar fy = Object.freeze({ __proto__: null, base32: ry, base32upper: ny, base32pad: oy, base32padupper: ay, base32hex: cy, base32hexupper: hy, base32hexpad: uy, base32hexpadupper: ly, base32z: dy });\nconst py = Ss({ prefix: \"k\", name: \"base36\", alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\" }), gy = Ss({ prefix: \"K\", name: \"base36upper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" });\nvar yy = Object.freeze({ __proto__: null, base36: py, base36upper: gy });\nconst my = Ss({ name: \"base58btc\", prefix: \"z\", alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" }), by = Ss({ name: \"base58flickr\", prefix: \"Z\", alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\" });\nvar wy = Object.freeze({ __proto__: null, base58btc: my, base58flickr: by });\nconst vy = lt({ prefix: \"m\", name: \"base64\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", bitsPerChar: 6 }), _y = lt({ prefix: \"M\", name: \"base64pad\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", bitsPerChar: 6 }), Ey = lt({ prefix: \"u\", name: \"base64url\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\", bitsPerChar: 6 }), Sy = lt({ prefix: \"U\", name: \"base64urlpad\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\", bitsPerChar: 6 });\nvar Iy = Object.freeze({ __proto__: null, base64: vy, base64pad: _y, base64url: Ey, base64urlpad: Sy });\nconst Xc = Array.from(\"🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂\"), Dy = Xc.reduce((i, e, t) => (i[t] = e, i), []), xy = Xc.reduce((i, e, t) => (i[e.codePointAt(0)] = t, i), []);\nfunction Oy(i) {\n  return i.reduce((e, t) => (e += Dy[t], e), \"\");\n}\nfunction Ny(i) {\n  const e = [];\n  for (const t of i) {\n    const s = xy[t.codePointAt(0)];\n    if (s === void 0)\n      throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(s);\n  }\n  return new Uint8Array(e);\n}\nconst Py = lr({ prefix: \"🚀\", name: \"base256emoji\", encode: Oy, decode: Ny });\nvar Ry = Object.freeze({ __proto__: null, base256emoji: Py }), Cy = Zc, Go = 128, Ay = 127, Ty = ~Ay, $y = Math.pow(2, 31);\nfunction Zc(i, e, t) {\n  e = e || [], t = t || 0;\n  for (var s = t; i >= $y; )\n    e[t++] = i & 255 | Go, i /= 128;\n  for (; i & Ty; )\n    e[t++] = i & 255 | Go, i >>>= 7;\n  return e[t] = i | 0, Zc.bytes = t - s + 1, e;\n}\nvar Fy = Wr, Uy = 128, Wo = 127;\nfunction Wr(i, s) {\n  var t = 0, s = s || 0, r = 0, n = s, o, c = i.length;\n  do {\n    if (n >= c)\n      throw Wr.bytes = 0, new RangeError(\"Could not decode varint\");\n    o = i[n++], t += r < 28 ? (o & Wo) << r : (o & Wo) * Math.pow(2, r), r += 7;\n  } while (o >= Uy);\n  return Wr.bytes = n - s, t;\n}\nvar Ly = Math.pow(2, 7), My = Math.pow(2, 14), qy = Math.pow(2, 21), jy = Math.pow(2, 28), zy = Math.pow(2, 35), Ky = Math.pow(2, 42), Vy = Math.pow(2, 49), By = Math.pow(2, 56), ky = Math.pow(2, 63), Hy = function(i) {\n  return i < Ly ? 1 : i < My ? 2 : i < qy ? 3 : i < jy ? 4 : i < zy ? 5 : i < Ky ? 6 : i < Vy ? 7 : i < By ? 8 : i < ky ? 9 : 10;\n}, Gy = { encode: Cy, decode: Fy, encodingLength: Hy }, eh = Gy;\nconst Yo = (i, e, t = 0) => (eh.encode(i, e, t), e), Jo = (i) => eh.encodingLength(i), Yr = (i, e) => {\n  const t = e.byteLength, s = Jo(i), r = s + Jo(t), n = new Uint8Array(r + t);\n  return Yo(i, n, 0), Yo(t, n, s), n.set(e, r), new Wy(i, t, e, n);\n};\nlet Wy = class {\n  constructor(e, t, s, r) {\n    this.code = e, this.size = t, this.digest = s, this.bytes = r;\n  }\n};\nconst th = ({ name: i, code: e, encode: t }) => new Yy(i, e, t);\nlet Yy = class {\n  constructor(e, t, s) {\n    this.name = e, this.code = t, this.encode = s;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? Yr(this.code, t) : t.then((s) => Yr(this.code, s));\n    } else\n      throw Error(\"Unknown type, must be binary type\");\n  }\n};\nconst ih = (i) => async (e) => new Uint8Array(await crypto.subtle.digest(i, e)), Jy = th({ name: \"sha2-256\", code: 18, encode: ih(\"SHA-256\") }), Qy = th({ name: \"sha2-512\", code: 19, encode: ih(\"SHA-512\") });\nvar Xy = Object.freeze({ __proto__: null, sha256: Jy, sha512: Qy });\nconst sh = 0, Zy = \"identity\", rh = Jc, e1 = (i) => Yr(sh, rh(i)), t1 = { code: sh, name: Zy, encode: rh, digest: e1 };\nvar i1 = Object.freeze({ __proto__: null, identity: t1 });\nnew TextEncoder(), new TextDecoder();\nconst Qo = { ...Wg, ...Jg, ...Xg, ...ey, ...sy, ...fy, ...yy, ...wy, ...Iy, ...Ry };\n({ ...Xy, ...i1 });\nfunction nh(i) {\n  return globalThis.Buffer != null ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : i;\n}\nfunction s1(i = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? nh(globalThis.Buffer.allocUnsafe(i)) : new Uint8Array(i);\n}\nfunction oh(i, e, t, s) {\n  return { name: i, prefix: e, encoder: { name: i, prefix: e, encode: t }, decoder: { decode: s } };\n}\nconst Xo = oh(\"utf8\", \"u\", (i) => \"u\" + new TextDecoder(\"utf8\").decode(i), (i) => new TextEncoder().encode(i.substring(1))), Or = oh(\"ascii\", \"a\", (i) => {\n  let e = \"a\";\n  for (let t = 0; t < i.length; t++)\n    e += String.fromCharCode(i[t]);\n  return e;\n}, (i) => {\n  i = i.substring(1);\n  const e = s1(i.length);\n  for (let t = 0; t < i.length; t++)\n    e[t] = i.charCodeAt(t);\n  return e;\n}), r1 = { utf8: Xo, \"utf-8\": Xo, hex: Qo.base16, latin1: Or, ascii: Or, binary: Or, ...Qo };\nfunction n1(i, e = \"utf8\") {\n  const t = r1[e];\n  if (!t)\n    throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? nh(globalThis.Buffer.from(i, \"utf-8\")) : t.decoder.decode(`${t.prefix}${i}`);\n}\nconst ah = \"wc\", o1 = 2, En = \"core\", hi = `${ah}@2:${En}:`, a1 = { name: En, logger: \"error\" }, c1 = { database: \":memory:\" }, h1 = \"crypto\", Zo = \"client_ed25519_seed\", u1 = V.ONE_DAY, l1 = \"keychain\", d1 = \"0.3\", f1 = \"messages\", p1 = \"0.3\", g1 = V.SIX_HOURS, y1 = \"publisher\", ch = \"irn\", m1 = \"error\", hh = \"wss://relay.walletconnect.com\", ea = \"wss://relay.walletconnect.org\", b1 = \"relayer\", gt = { message: \"relayer_message\", message_ack: \"relayer_message_ack\", connect: \"relayer_connect\", disconnect: \"relayer_disconnect\", error: \"relayer_error\", connection_stalled: \"relayer_connection_stalled\", transport_closed: \"relayer_transport_closed\", publish: \"relayer_publish\" }, w1 = \"_subscription\", Zt = { payload: \"payload\", connect: \"connect\", disconnect: \"disconnect\", error: \"error\" }, v1 = V.ONE_SECOND, _1 = \"2.10.1\", E1 = 1e4, S1 = \"0.3\", I1 = \"WALLETCONNECT_CLIENT_ID\", Vt = { created: \"subscription_created\", deleted: \"subscription_deleted\", expired: \"subscription_expired\", disabled: \"subscription_disabled\", sync: \"subscription_sync\", resubscribed: \"subscription_resubscribed\" }, D1 = \"subscription\", x1 = \"0.3\", O1 = V.FIVE_SECONDS * 1e3, N1 = \"pairing\", P1 = \"0.3\", Xi = { wc_pairingDelete: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 0 } } }, os = { create: \"pairing_create\", expire: \"pairing_expire\", delete: \"pairing_delete\", ping: \"pairing_ping\" }, zt = { created: \"history_created\", updated: \"history_updated\", deleted: \"history_deleted\", sync: \"history_sync\" }, R1 = \"history\", C1 = \"0.3\", A1 = \"expirer\", Tt = { created: \"expirer_created\", deleted: \"expirer_deleted\", expired: \"expirer_expired\", sync: \"expirer_sync\" }, T1 = \"0.3\", Nr = \"verify-api\", Ks = \"https://verify.walletconnect.com\", ta = \"https://verify.walletconnect.org\";\nlet $1 = class {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = l1, this.version = d1, this.initialized = !1, this.storagePrefix = hi, this.init = async () => {\n      if (!this.initialized) {\n        const s = await this.getKeyChain();\n        typeof s < \"u\" && (this.keychain = s), this.initialized = !0;\n      }\n    }, this.has = (s) => (this.isInitialized(), this.keychain.has(s)), this.set = async (s, r) => {\n      this.isInitialized(), this.keychain.set(s, r), await this.persist();\n    }, this.get = (s) => {\n      this.isInitialized();\n      const r = this.keychain.get(s);\n      if (typeof r > \"u\") {\n        const { message: n } = Y(\"NO_MATCHING_KEY\", `${this.name}: ${s}`);\n        throw new Error(n);\n      }\n      return r;\n    }, this.del = async (s) => {\n      this.isInitialized(), this.keychain.delete(s), await this.persist();\n    }, this.core = e, this.logger = ee.generateChildLogger(t, this.name);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setKeyChain(e) {\n    await this.core.storage.setItem(this.storageKey, Lc(e));\n  }\n  async getKeyChain() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? Mc(e) : void 0;\n  }\n  async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}, F1 = class {\n  constructor(e, t, s) {\n    this.core = e, this.logger = t, this.name = h1, this.initialized = !1, this.init = async () => {\n      this.initialized || (await this.keychain.init(), this.initialized = !0);\n    }, this.hasKeys = (r) => (this.isInitialized(), this.keychain.has(r)), this.getClientId = async () => {\n      this.isInitialized();\n      const r = await this.getClientSeed(), n = Ws(r);\n      return an(n.publicKey);\n    }, this.generateKeyPair = () => {\n      this.isInitialized();\n      const r = tp();\n      return this.setPrivateKey(r.publicKey, r.privateKey);\n    }, this.signJWT = async (r) => {\n      this.isInitialized();\n      const n = await this.getClientSeed(), o = Ws(n), c = Hr();\n      return await Ic(c, r, u1, o);\n    }, this.generateSharedKey = (r, n, o) => {\n      this.isInitialized();\n      const c = this.getPrivateKey(r), u = ip(c, n);\n      return this.setSymKey(u, o);\n    }, this.setSymKey = async (r, n) => {\n      this.isInitialized();\n      const o = n || sp(r);\n      return await this.keychain.set(o, r), o;\n    }, this.deleteKeyPair = async (r) => {\n      this.isInitialized(), await this.keychain.del(r);\n    }, this.deleteSymKey = async (r) => {\n      this.isInitialized(), await this.keychain.del(r);\n    }, this.encode = async (r, n, o) => {\n      this.isInitialized();\n      const c = Uc(o), u = rr(n);\n      if (Ro(c)) {\n        const x = c.senderPublicKey, O = c.receiverPublicKey;\n        r = await this.generateSharedKey(x, O);\n      }\n      const d = this.getSymKey(r), { type: p, senderPublicKey: b } = c;\n      return np({ type: p, symKey: d, message: u, senderPublicKey: b });\n    }, this.decode = async (r, n, o) => {\n      this.isInitialized();\n      const c = cp(n, o);\n      if (Ro(c)) {\n        const u = c.receiverPublicKey, d = c.senderPublicKey;\n        r = await this.generateSharedKey(u, d);\n      }\n      try {\n        const u = this.getSymKey(r), d = op({ symKey: u, encoded: n });\n        return rn(d);\n      } catch (u) {\n        this.logger.error(`Failed to decode message from topic: '${r}', clientId: '${await this.getClientId()}'`), this.logger.error(u);\n      }\n    }, this.getPayloadType = (r) => {\n      const n = Ys(r);\n      return ws(n.type);\n    }, this.getPayloadSenderPublicKey = (r) => {\n      const n = Ys(r);\n      return n.senderPublicKey ? Ne(n.senderPublicKey, vt) : void 0;\n    }, this.core = e, this.logger = ee.generateChildLogger(t, this.name), this.keychain = s || new $1(this.core, this.logger);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  async setPrivateKey(e, t) {\n    return await this.keychain.set(e, t), e;\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  async getClientSeed() {\n    let e = \"\";\n    try {\n      e = this.keychain.get(Zo);\n    } catch {\n      e = Hr(), await this.keychain.set(Zo, e);\n    }\n    return n1(e, \"base16\");\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}, U1 = class extends gl {\n  constructor(e, t) {\n    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = f1, this.version = p1, this.initialized = !1, this.storagePrefix = hi, this.init = async () => {\n      if (!this.initialized) {\n        this.logger.trace(\"Initialized\");\n        try {\n          const s = await this.getRelayerMessages();\n          typeof s < \"u\" && (this.messages = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", size: this.messages.size });\n        } catch (s) {\n          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s);\n        } finally {\n          this.initialized = !0;\n        }\n      }\n    }, this.set = async (s, r) => {\n      this.isInitialized();\n      const n = Fi(r);\n      let o = this.messages.get(s);\n      return typeof o > \"u\" && (o = {}), typeof o[n] < \"u\" || (o[n] = r, this.messages.set(s, o), await this.persist()), n;\n    }, this.get = (s) => {\n      this.isInitialized();\n      let r = this.messages.get(s);\n      return typeof r > \"u\" && (r = {}), r;\n    }, this.has = (s, r) => {\n      this.isInitialized();\n      const n = this.get(s), o = Fi(r);\n      return typeof n[o] < \"u\";\n    }, this.del = async (s) => {\n      this.isInitialized(), this.messages.delete(s), await this.persist();\n    }, this.logger = ee.generateChildLogger(e, this.name), this.core = t;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setRelayerMessages(e) {\n    await this.core.storage.setItem(this.storageKey, Lc(e));\n  }\n  async getRelayerMessages() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? Mc(e) : void 0;\n  }\n  async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}, L1 = class extends yl {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.events = new We.EventEmitter(), this.name = y1, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = V.toMiliseconds(V.TEN_SECONDS), this.needsTransportRestart = !1, this.publish = async (s, r, n) => {\n      var o;\n      this.logger.debug(\"Publishing Payload\"), this.logger.trace({ type: \"method\", method: \"publish\", params: { topic: s, message: r, opts: n } });\n      try {\n        const c = n?.ttl || g1, u = Gr(n), d = n?.prompt || !1, p = n?.tag || 0, b = n?.id || vn().toString(), x = { topic: s, message: r, opts: { ttl: c, relay: u, prompt: d, tag: p, id: b } }, O = setTimeout(() => this.queue.set(b, x), this.publishTimeout);\n        try {\n          await await ds(this.rpcPublish(s, r, c, u, d, p, b), this.publishTimeout, \"Failed to publish payload, please try again.\"), this.removeRequestFromQueue(b), this.relayer.events.emit(gt.publish, x);\n        } catch (_) {\n          if (this.logger.debug(\"Publishing Payload stalled\"), this.needsTransportRestart = !0, (o = n?.internal) != null && o.throwOnFailedPublish)\n            throw this.removeRequestFromQueue(b), _;\n          return;\n        } finally {\n          clearTimeout(O);\n        }\n        this.logger.debug(\"Successfully Published Payload\"), this.logger.trace({ type: \"method\", method: \"publish\", params: { topic: s, message: r, opts: n } });\n      } catch (c) {\n        throw this.logger.debug(\"Failed to Publish Payload\"), this.logger.error(c), c;\n      }\n    }, this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.relayer = e, this.logger = ee.generateChildLogger(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  rpcPublish(e, t, s, r, n, o, c) {\n    var u, d, p, b;\n    const x = { method: js(r.protocol).publish, params: { topic: e, message: t, ttl: s, prompt: n, tag: o }, id: c };\n    return bt((u = x.params) == null ? void 0 : u.prompt) && ((d = x.params) == null || delete d.prompt), bt((p = x.params) == null ? void 0 : p.tag) && ((b = x.params) == null || delete b.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"message\", direction: \"outgoing\", request: x }), this.relayer.request(x);\n  }\n  removeRequestFromQueue(e) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    this.queue.forEach(async (e) => {\n      const { topic: t, message: s, opts: r } = e;\n      await this.publish(t, s, r);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, () => {\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = !1, this.relayer.events.emit(gt.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    }), this.relayer.on(gt.message_ack, (e) => {\n      this.removeRequestFromQueue(e.id.toString());\n    });\n  }\n}, M1 = class {\n  constructor() {\n    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {\n      const s = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...s, t]);\n    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e))\n        return;\n      const s = this.get(e);\n      if (!this.exists(e, t))\n        return;\n      const r = s.filter((n) => n !== t);\n      if (!r.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, r);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n};\nvar q1 = Object.defineProperty, j1 = Object.defineProperties, z1 = Object.getOwnPropertyDescriptors, ia = Object.getOwnPropertySymbols, K1 = Object.prototype.hasOwnProperty, V1 = Object.prototype.propertyIsEnumerable, sa = (i, e, t) => e in i ? q1(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Zi = (i, e) => {\n  for (var t in e || (e = {}))\n    K1.call(e, t) && sa(i, t, e[t]);\n  if (ia)\n    for (var t of ia(e))\n      V1.call(e, t) && sa(i, t, e[t]);\n  return i;\n}, Pr = (i, e) => j1(i, z1(e));\nlet B1 = class extends wl {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new M1(), this.events = new We.EventEmitter(), this.name = D1, this.version = x1, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pollingInterval = 20, this.storagePrefix = hi, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());\n    }, this.subscribe = async (s, r) => {\n      await this.restartToComplete(), this.isInitialized(), this.logger.debug(\"Subscribing Topic\"), this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic: s, opts: r } });\n      try {\n        const n = Gr(r), o = { topic: s, relay: n };\n        this.pending.set(s, o);\n        const c = await this.rpcSubscribe(s, n);\n        return this.onSubscribe(c, o), this.logger.debug(\"Successfully Subscribed Topic\"), this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic: s, opts: r } }), c;\n      } catch (n) {\n        throw this.logger.debug(\"Failed to Subscribe Topic\"), this.logger.error(n), n;\n      }\n    }, this.unsubscribe = async (s, r) => {\n      await this.restartToComplete(), this.isInitialized(), typeof r?.id < \"u\" ? await this.unsubscribeById(s, r.id, r) : await this.unsubscribeByTopic(s, r);\n    }, this.isSubscribed = async (s) => this.topics.includes(s) ? !0 : await new Promise((r, n) => {\n      const o = new V.Watch();\n      o.start(this.pendingSubscriptionWatchLabel);\n      const c = setInterval(() => {\n        !this.pending.has(s) && this.topics.includes(s) && (clearInterval(c), o.stop(this.pendingSubscriptionWatchLabel), r(!0)), o.elapsed(this.pendingSubscriptionWatchLabel) >= O1 && (clearInterval(c), o.stop(this.pendingSubscriptionWatchLabel), n(new Error(\"Subscription resolution timeout\")));\n      }, this.pollingInterval);\n    }).catch(() => !1), this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.restart = async () => {\n      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;\n    }, this.relayer = e, this.logger = ee.generateChildLogger(t, this.name), this.clientId = \"\";\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  hasSubscription(e, t) {\n    let s = !1;\n    try {\n      s = this.getSubscription(e).topic === t;\n    } catch {\n    }\n    return s;\n  }\n  onEnable() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();\n  }\n  async unsubscribeByTopic(e, t) {\n    const s = this.topicMap.get(e);\n    await Promise.all(s.map(async (r) => await this.unsubscribeById(e, r, t)));\n  }\n  async unsubscribeById(e, t, s) {\n    this.logger.debug(\"Unsubscribing Topic\"), this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic: e, id: t, opts: s } });\n    try {\n      const r = Gr(s);\n      await this.rpcUnsubscribe(e, t, r);\n      const n = nt(\"USER_DISCONNECTED\", `${this.name}, ${e}`);\n      await this.onUnsubscribe(e, t, n), this.logger.debug(\"Successfully Unsubscribed Topic\"), this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic: e, id: t, opts: s } });\n    } catch (r) {\n      throw this.logger.debug(\"Failed to Unsubscribe Topic\"), this.logger.error(r), r;\n    }\n  }\n  async rpcSubscribe(e, t) {\n    const s = { method: js(t.protocol).subscribe, params: { topic: e } };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: s });\n    try {\n      await await ds(this.relayer.request(s), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Subscribe Payload stalled\"), this.relayer.events.emit(gt.connection_stalled);\n    }\n    return Fi(e + this.clientId);\n  }\n  async rpcBatchSubscribe(e) {\n    if (!e.length)\n      return;\n    const t = e[0].relay, s = { method: js(t.protocol).batchSubscribe, params: { topics: e.map((r) => r.topic) } };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: s });\n    try {\n      return await await ds(this.relayer.request(s), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Payload stalled\"), this.relayer.events.emit(gt.connection_stalled);\n    }\n  }\n  rpcUnsubscribe(e, t, s) {\n    const r = { method: js(s.protocol).unsubscribe, params: { topic: e, id: t } };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: r }), this.relayer.request(r);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, Pr(Zi({}, t), { id: e })), this.pending.delete(t.topic);\n  }\n  onBatchSubscribe(e) {\n    e.length && e.forEach((t) => {\n      this.setSubscription(t.id, Zi({}, t)), this.pending.delete(t.topic);\n    });\n  }\n  async onUnsubscribe(e, t, s) {\n    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s), await this.relayer.messages.del(e);\n  }\n  async setRelayerSubscriptions(e) {\n    await this.relayer.core.storage.setItem(this.storageKey, e);\n  }\n  async getRelayerSubscriptions() {\n    return await this.relayer.core.storage.getItem(this.storageKey);\n  }\n  setSubscription(e, t) {\n    this.subscriptions.has(e) || (this.logger.debug(\"Setting subscription\"), this.logger.trace({ type: \"method\", method: \"setSubscription\", id: e, subscription: t }), this.addSubscription(e, t));\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, Zi({}, t)), this.topicMap.set(t.topic, e), this.events.emit(Vt.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({ type: \"method\", method: \"getSubscription\", id: e });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const { message: s } = Y(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(s);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({ type: \"method\", method: \"deleteSubscription\", id: e, reason: t });\n    const s = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(s.topic, e), this.events.emit(Vt.deleted, Pr(Zi({}, s), { reason: t }));\n  }\n  async persist() {\n    await this.setRelayerSubscriptions(this.values), this.events.emit(Vt.sync);\n  }\n  async reset() {\n    if (this.cached.length) {\n      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let t = 0; t < e; t++) {\n        const s = this.cached.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(s);\n      }\n    }\n    this.events.emit(Vt.resubscribed);\n  }\n  async restore() {\n    try {\n      const e = await this.getRelayerSubscriptions();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.subscriptions.size) {\n        const { message: t } = Y(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);\n    }\n  }\n  async batchSubscribe(e) {\n    if (!e.length)\n      return;\n    const t = await this.rpcBatchSubscribe(e);\n    Es(t) && this.onBatchSubscribe(t.map((s, r) => Pr(Zi({}, e[r]), { id: s })));\n  }\n  async onConnect() {\n    this.restartInProgress || (await this.restart(), this.onEnable());\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  async checkPending() {\n    if (!this.initialized || this.relayer.transportExplicitlyClosed)\n      return;\n    const e = [];\n    this.pending.forEach((t) => {\n      e.push(t);\n    }), await this.batchSubscribe(e);\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, async () => {\n      await this.checkPending();\n    }), this.relayer.on(gt.connect, async () => {\n      await this.onConnect();\n    }), this.relayer.on(gt.disconnect, () => {\n      this.onDisconnect();\n    }), this.events.on(Vt.created, async (e) => {\n      const t = Vt.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), await this.persist();\n    }), this.events.on(Vt.deleted, async (e) => {\n      const t = Vt.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), await this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async restartToComplete() {\n    this.restartInProgress && await new Promise((e) => {\n      const t = setInterval(() => {\n        this.restartInProgress || (clearInterval(t), e());\n      }, this.pollingInterval);\n    });\n  }\n};\nvar k1 = Object.defineProperty, ra = Object.getOwnPropertySymbols, H1 = Object.prototype.hasOwnProperty, G1 = Object.prototype.propertyIsEnumerable, na = (i, e, t) => e in i ? k1(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, W1 = (i, e) => {\n  for (var t in e || (e = {}))\n    H1.call(e, t) && na(i, t, e[t]);\n  if (ra)\n    for (var t of ra(e))\n      G1.call(e, t) && na(i, t, e[t]);\n  return i;\n};\nlet Y1 = class extends ml {\n  constructor(e) {\n    super(e), this.protocol = \"wc\", this.version = 2, this.events = new We.EventEmitter(), this.name = b1, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = [\"socket hang up\", \"socket stalled\"], this.hasExperiencedNetworkDisruption = !1, this.request = async (t) => {\n      this.logger.debug(\"Publishing Request Payload\");\n      try {\n        return await this.toEstablishConnection(), await this.provider.request(t);\n      } catch (s) {\n        throw this.logger.debug(\"Failed to Publish Request\"), this.logger.error(s), s;\n      }\n    }, this.onPayloadHandler = (t) => {\n      this.onProviderPayload(t);\n    }, this.onConnectHandler = () => {\n      this.events.emit(gt.connect);\n    }, this.onDisconnectHandler = () => {\n      this.onProviderDisconnect();\n    }, this.onProviderErrorHandler = (t) => {\n      this.logger.error(t), this.events.emit(gt.error, t), this.logger.info(\"Fatal socket error received, closing transport\"), this.transportClose();\n    }, this.registerProviderListeners = () => {\n      this.provider.on(Zt.payload, this.onPayloadHandler), this.provider.on(Zt.connect, this.onConnectHandler), this.provider.on(Zt.disconnect, this.onDisconnectHandler), this.provider.on(Zt.error, this.onProviderErrorHandler);\n    }, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? ee.generateChildLogger(e.logger, this.name) : ee.pino(ee.getDefaultLoggerOptions({ level: e.logger || m1 })), this.messages = new U1(this.logger, e.core), this.subscriber = new B1(this, this.logger), this.publisher = new L1(this, this.logger), this.relayUrl = e?.relayUrl || hh, this.projectId = e.projectId, this.provider = {};\n  }\n  async init() {\n    this.logger.trace(\"Initialized\"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);\n    try {\n      await this.transportOpen();\n    } catch {\n      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${ea}...`), await this.restartTransport(ea);\n    }\n    this.initialized = !0, setTimeout(async () => {\n      this.subscriber.topics.length === 0 && (this.logger.info(\"No topics subscribed to after init, closing transport\"), await this.transportClose(), this.transportExplicitlyClosed = !1);\n    }, E1);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get connected() {\n    return this.provider.connection.connected;\n  }\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n  async publish(e, t, s) {\n    this.isInitialized(), await this.publisher.publish(e, t, s), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });\n  }\n  async subscribe(e, t) {\n    var s;\n    this.isInitialized();\n    let r = ((s = this.subscriber.topicMap.get(e)) == null ? void 0 : s[0]) || \"\";\n    return r || (await Promise.all([new Promise((n) => {\n      this.subscriber.once(Vt.created, (o) => {\n        o.topic === e && n();\n      });\n    }), new Promise(async (n) => {\n      r = await this.subscriber.subscribe(e, t), n();\n    })]), r);\n  }\n  async unsubscribe(e, t) {\n    this.isInitialized(), await this.subscriber.unsubscribe(e, t);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async transportClose() {\n    this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await ds(this.provider.disconnect(), 1e3, \"provider.disconnect()\").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();\n  }\n  async transportOpen(e) {\n    if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {\n      e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;\n      try {\n        await Promise.all([new Promise((t) => {\n          if (!this.initialized)\n            return t();\n          this.subscriber.once(Vt.resubscribed, () => {\n            t();\n          });\n        }), new Promise(async (t, s) => {\n          try {\n            await ds(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);\n          } catch (r) {\n            s(r);\n            return;\n          }\n          t();\n        })]);\n      } catch (t) {\n        this.logger.error(t);\n        const s = t;\n        if (!this.isConnectionStalled(s.message))\n          throw t;\n        this.provider.events.emit(Zt.disconnect);\n      } finally {\n        this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1;\n      }\n    }\n  }\n  async restartTransport(e) {\n    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());\n  }\n  async confirmOnlineStateOrThrow() {\n    if (!await jo())\n      throw new Error(\"No internet connection detected. Please restart your network and try again.\");\n  }\n  isConnectionStalled(e) {\n    return this.staleConnectionErrors.some((t) => e.includes(t));\n  }\n  async createProvider() {\n    this.provider.connection && this.unregisterProviderListeners();\n    const e = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = new _n(new Wc(wp({ sdkVersion: _1, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0 }))), this.registerProviderListeners();\n  }\n  async recordMessageEvent(e) {\n    const { topic: t, message: s } = e;\n    await this.messages.set(t, s);\n  }\n  async shouldIgnoreMessageEvent(e) {\n    const { topic: t, message: s } = e;\n    if (!s || s.length === 0)\n      return this.logger.debug(`Ignoring invalid/empty message: ${s}`), !0;\n    if (!await this.subscriber.isSubscribed(t))\n      return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), !0;\n    const r = this.messages.has(t, s);\n    return r && this.logger.debug(`Ignoring duplicate message: ${s}`), r;\n  }\n  async onProviderPayload(e) {\n    if (this.logger.debug(\"Incoming Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"incoming\", payload: e }), ji(e)) {\n      if (!e.method.endsWith(w1))\n        return;\n      const t = e.params, { topic: s, message: r, publishedAt: n } = t.data, o = { topic: s, message: r, publishedAt: n };\n      this.logger.debug(\"Emitting Relayer Payload\"), this.logger.trace(W1({ type: \"event\", event: t.id }, o)), this.events.emit(t.id, o), await this.acknowledgePayload(e), await this.onMessageEvent(o);\n    } else\n      Oi(e) && this.events.emit(gt.message_ack, e);\n  }\n  async onMessageEvent(e) {\n    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(gt.message, e), await this.recordMessageEvent(e));\n  }\n  async acknowledgePayload(e) {\n    const t = xi(e.id, !0);\n    await this.provider.connection.send(t);\n  }\n  unregisterProviderListeners() {\n    this.provider.off(Zt.payload, this.onPayloadHandler), this.provider.off(Zt.connect, this.onConnectHandler), this.provider.off(Zt.disconnect, this.onDisconnectHandler), this.provider.off(Zt.error, this.onProviderErrorHandler);\n  }\n  async registerEventListeners() {\n    this.events.on(gt.connection_stalled, () => {\n      this.restartTransport().catch((t) => this.logger.error(t));\n    });\n    let e = await jo();\n    lg(async (t) => {\n      this.initialized && e !== t && (e = t, t ? await this.restartTransport().catch((s) => this.logger.error(s)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch((s) => this.logger.error(s))));\n    });\n  }\n  onProviderDisconnect() {\n    this.events.emit(gt.disconnect), this.attemptToReconnect();\n  }\n  attemptToReconnect() {\n    this.transportExplicitlyClosed || (this.logger.info(\"attemptToReconnect called. Connecting...\"), setTimeout(async () => {\n      await this.restartTransport().catch((e) => this.logger.error(e));\n    }, V.toMiliseconds(v1)));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async toEstablishConnection() {\n    if (await this.confirmOnlineStateOrThrow(), !this.connected) {\n      if (this.connectionAttemptInProgress)\n        return await new Promise((e) => {\n          const t = setInterval(() => {\n            this.connected && (clearInterval(t), e());\n          }, this.connectionStatusPollingInterval);\n        });\n      await this.restartTransport();\n    }\n  }\n};\nvar J1 = Object.defineProperty, oa = Object.getOwnPropertySymbols, Q1 = Object.prototype.hasOwnProperty, X1 = Object.prototype.propertyIsEnumerable, aa = (i, e, t) => e in i ? J1(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, ca = (i, e) => {\n  for (var t in e || (e = {}))\n    Q1.call(e, t) && aa(i, t, e[t]);\n  if (oa)\n    for (var t of oa(e))\n      X1.call(e, t) && aa(i, t, e[t]);\n  return i;\n};\nlet dr = class extends bl {\n  constructor(e, t, s, r = hi, n = void 0) {\n    super(e, t, s, r), this.core = e, this.logger = t, this.name = s, this.map = /* @__PURE__ */ new Map(), this.version = S1, this.cached = [], this.initialized = !1, this.storagePrefix = hi, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((o) => {\n        this.getKey && o !== null && !bt(o) ? this.map.set(this.getKey(o), o) : Kp(o) ? this.map.set(o.id, o) : Vp(o) && this.map.set(o.topic, o);\n      }), this.cached = [], this.initialized = !0);\n    }, this.set = async (o, c) => {\n      this.isInitialized(), this.map.has(o) ? await this.update(o, c) : (this.logger.debug(\"Setting value\"), this.logger.trace({ type: \"method\", method: \"set\", key: o, value: c }), this.map.set(o, c), await this.persist());\n    }, this.get = (o) => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({ type: \"method\", method: \"get\", key: o }), this.getData(o)), this.getAll = (o) => (this.isInitialized(), o ? this.values.filter((c) => Object.keys(o).every((u) => Yc(c[u], o[u]))) : this.values), this.update = async (o, c) => {\n      this.isInitialized(), this.logger.debug(\"Updating value\"), this.logger.trace({ type: \"method\", method: \"update\", key: o, update: c });\n      const u = ca(ca({}, this.getData(o)), c);\n      this.map.set(o, u), await this.persist();\n    }, this.delete = async (o, c) => {\n      this.isInitialized(), this.map.has(o) && (this.logger.debug(\"Deleting value\"), this.logger.trace({ type: \"method\", method: \"delete\", key: o, reason: c }), this.map.delete(o), await this.persist());\n    }, this.logger = ee.generateChildLogger(t, this.name), this.storagePrefix = r, this.getKey = n;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  async setDataStore(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getDataStore() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      const { message: s } = Y(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(s), new Error(s);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setDataStore(this.values);\n  }\n  async restore() {\n    try {\n      const e = await this.getDataStore();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.map.size) {\n        const { message: t } = Y(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", value: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}, Z1 = class {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.name = N1, this.version = P1, this.events = new ir(), this.initialized = !1, this.storagePrefix = hi, this.ignoredPayloadTypes = [Di], this.registeredMethods = [], this.init = async () => {\n      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace(\"Initialized\"));\n    }, this.register = ({ methods: s }) => {\n      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s])];\n    }, this.create = async () => {\n      this.isInitialized();\n      const s = Hr(), r = await this.core.crypto.setSymKey(s), n = Mt(V.FIVE_MINUTES), o = { protocol: ch }, c = { topic: r, expiry: n, relay: o, active: !1 }, u = Ap({ protocol: this.core.protocol, version: this.core.version, topic: r, symKey: s, relay: o });\n      return await this.pairings.set(r, c), await this.core.relayer.subscribe(r), this.core.expirer.set(r, n), { topic: r, uri: u };\n    }, this.pair = async (s) => {\n      this.isInitialized(), this.isValidPair(s);\n      const { topic: r, symKey: n, relay: o } = Pp(s.uri);\n      let c;\n      if (this.pairings.keys.includes(r) && (c = this.pairings.get(r), c.active))\n        throw new Error(`Pairing already exists: ${r}. Please try again with a new connection URI.`);\n      this.core.crypto.keychain.has(r) || (await this.core.crypto.setSymKey(n, r), await this.core.relayer.subscribe(r, { relay: o }));\n      const u = Mt(V.FIVE_MINUTES), d = { topic: r, relay: o, expiry: u, active: !1 };\n      return await this.pairings.set(r, d), this.core.expirer.set(r, u), s.activatePairing && await this.activate({ topic: r }), this.events.emit(os.create, d), d;\n    }, this.activate = async ({ topic: s }) => {\n      this.isInitialized();\n      const r = Mt(V.THIRTY_DAYS);\n      await this.pairings.update(s, { active: !0, expiry: r }), this.core.expirer.set(s, r);\n    }, this.ping = async (s) => {\n      this.isInitialized(), await this.isValidPing(s);\n      const { topic: r } = s;\n      if (this.pairings.keys.includes(r)) {\n        const n = await this.sendRequest(r, \"wc_pairingPing\", {}), { done: o, resolve: c, reject: u } = Ai();\n        this.events.once(Be(\"pairing_ping\", n), ({ error: d }) => {\n          d ? u(d) : c();\n        }), await o();\n      }\n    }, this.updateExpiry = async ({ topic: s, expiry: r }) => {\n      this.isInitialized(), await this.pairings.update(s, { expiry: r });\n    }, this.updateMetadata = async ({ topic: s, metadata: r }) => {\n      this.isInitialized(), await this.pairings.update(s, { peerMetadata: r });\n    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s) => {\n      this.isInitialized(), await this.isValidDisconnect(s);\n      const { topic: r } = s;\n      this.pairings.keys.includes(r) && (await this.sendRequest(r, \"wc_pairingDelete\", nt(\"USER_DISCONNECTED\")), await this.deletePairing(r));\n    }, this.sendRequest = async (s, r, n) => {\n      const o = ti(r, n), c = await this.core.crypto.encode(s, o), u = Xi[r].req;\n      return this.core.history.set(s, o), this.core.relayer.publish(s, c, u), o.id;\n    }, this.sendResult = async (s, r, n) => {\n      const o = xi(s, n), c = await this.core.crypto.encode(r, o), u = await this.core.history.get(r, s), d = Xi[u.request.method].res;\n      await this.core.relayer.publish(r, c, d), await this.core.history.resolve(o);\n    }, this.sendError = async (s, r, n) => {\n      const o = qi(s, n), c = await this.core.crypto.encode(r, o), u = await this.core.history.get(r, s), d = Xi[u.request.method] ? Xi[u.request.method].res : Xi.unregistered_method.res;\n      await this.core.relayer.publish(r, c, d), await this.core.history.resolve(o);\n    }, this.deletePairing = async (s, r) => {\n      await this.core.relayer.unsubscribe(s), await Promise.all([this.pairings.delete(s, nt(\"USER_DISCONNECTED\")), this.core.crypto.deleteSymKey(s), r ? Promise.resolve() : this.core.expirer.del(s)]);\n    }, this.cleanup = async () => {\n      const s = this.pairings.getAll().filter((r) => ai(r.expiry));\n      await Promise.all(s.map((r) => this.deletePairing(r.topic)));\n    }, this.onRelayEventRequest = (s) => {\n      const { topic: r, payload: n } = s;\n      switch (n.method) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingRequest(r, n);\n        case \"wc_pairingDelete\":\n          return this.onPairingDeleteRequest(r, n);\n        default:\n          return this.onUnknownRpcMethodRequest(r, n);\n      }\n    }, this.onRelayEventResponse = async (s) => {\n      const { topic: r, payload: n } = s, o = (await this.core.history.get(r, n.id)).request.method;\n      switch (o) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingResponse(r, n);\n        default:\n          return this.onUnknownRpcMethodResponse(o);\n      }\n    }, this.onPairingPingRequest = async (s, r) => {\n      const { id: n } = r;\n      try {\n        this.isValidPing({ topic: s }), await this.sendResult(n, s, !0), this.events.emit(os.ping, { id: n, topic: s });\n      } catch (o) {\n        await this.sendError(n, s, o), this.logger.error(o);\n      }\n    }, this.onPairingPingResponse = (s, r) => {\n      const { id: n } = r;\n      setTimeout(() => {\n        ht(r) ? this.events.emit(Be(\"pairing_ping\", n), {}) : Ge(r) && this.events.emit(Be(\"pairing_ping\", n), { error: r.error });\n      }, 500);\n    }, this.onPairingDeleteRequest = async (s, r) => {\n      const { id: n } = r;\n      try {\n        this.isValidDisconnect({ topic: s }), await this.deletePairing(s), this.events.emit(os.delete, { id: n, topic: s });\n      } catch (o) {\n        await this.sendError(n, s, o), this.logger.error(o);\n      }\n    }, this.onUnknownRpcMethodRequest = async (s, r) => {\n      const { id: n, method: o } = r;\n      try {\n        if (this.registeredMethods.includes(o))\n          return;\n        const c = nt(\"WC_METHOD_UNSUPPORTED\", o);\n        await this.sendError(n, s, c), this.logger.error(c);\n      } catch (c) {\n        await this.sendError(n, s, c), this.logger.error(c);\n      }\n    }, this.onUnknownRpcMethodResponse = (s) => {\n      this.registeredMethods.includes(s) || this.logger.error(nt(\"WC_METHOD_UNSUPPORTED\", s));\n    }, this.isValidPair = (s) => {\n      if (!St(s)) {\n        const { message: r } = Y(\"MISSING_OR_INVALID\", `pair() params: ${s}`);\n        throw new Error(r);\n      }\n      if (!zp(s.uri)) {\n        const { message: r } = Y(\"MISSING_OR_INVALID\", `pair() uri: ${s.uri}`);\n        throw new Error(r);\n      }\n    }, this.isValidPing = async (s) => {\n      if (!St(s)) {\n        const { message: n } = Y(\"MISSING_OR_INVALID\", `ping() params: ${s}`);\n        throw new Error(n);\n      }\n      const { topic: r } = s;\n      await this.isValidPairingTopic(r);\n    }, this.isValidDisconnect = async (s) => {\n      if (!St(s)) {\n        const { message: n } = Y(\"MISSING_OR_INVALID\", `disconnect() params: ${s}`);\n        throw new Error(n);\n      }\n      const { topic: r } = s;\n      await this.isValidPairingTopic(r);\n    }, this.isValidPairingTopic = async (s) => {\n      if (!ot(s, !1)) {\n        const { message: r } = Y(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${s}`);\n        throw new Error(r);\n      }\n      if (!this.pairings.keys.includes(s)) {\n        const { message: r } = Y(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${s}`);\n        throw new Error(r);\n      }\n      if (ai(this.pairings.get(s).expiry)) {\n        await this.deletePairing(s);\n        const { message: r } = Y(\"EXPIRED\", `pairing topic: ${s}`);\n        throw new Error(r);\n      }\n    }, this.core = e, this.logger = ee.generateChildLogger(t, this.name), this.pairings = new dr(this.core, this.logger, this.name, this.storagePrefix);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    this.core.relayer.on(gt.message, async (e) => {\n      const { topic: t, message: s } = e;\n      if (!this.pairings.keys.includes(t) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s)))\n        return;\n      const r = await this.core.crypto.decode(t, s);\n      try {\n        ji(r) ? (this.core.history.set(t, r), this.onRelayEventRequest({ topic: t, payload: r })) : Oi(r) && (await this.core.history.resolve(r), await this.onRelayEventResponse({ topic: t, payload: r }), this.core.history.delete(t, r.id));\n      } catch (n) {\n        this.logger.error(n);\n      }\n    });\n  }\n  registerExpirerEvents() {\n    this.core.expirer.on(Tt.expired, async (e) => {\n      const { topic: t } = jc(e.target);\n      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(os.expire, { topic: t }));\n    });\n  }\n}, em = class extends pl {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new We.EventEmitter(), this.name = R1, this.version = C1, this.cached = [], this.initialized = !1, this.storagePrefix = hi, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((s) => this.records.set(s.id, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.set = (s, r, n) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({ type: \"method\", method: \"set\", topic: s, request: r, chainId: n }), this.records.has(r.id))\n        return;\n      const o = { id: r.id, topic: s, request: { method: r.method, params: r.params || null }, chainId: n, expiry: Mt(V.THIRTY_DAYS) };\n      this.records.set(o.id, o), this.events.emit(zt.created, o);\n    }, this.resolve = async (s) => {\n      if (this.isInitialized(), this.logger.debug(\"Updating JSON-RPC response history record\"), this.logger.trace({ type: \"method\", method: \"update\", response: s }), !this.records.has(s.id))\n        return;\n      const r = await this.getRecord(s.id);\n      typeof r.response > \"u\" && (r.response = Ge(s) ? { error: s.error } : { result: s.result }, this.records.set(r.id, r), this.events.emit(zt.updated, r));\n    }, this.get = async (s, r) => (this.isInitialized(), this.logger.debug(\"Getting record\"), this.logger.trace({ type: \"method\", method: \"get\", topic: s, id: r }), await this.getRecord(r)), this.delete = (s, r) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({ type: \"method\", method: \"delete\", id: r }), this.values.forEach((n) => {\n        if (n.topic === s) {\n          if (typeof r < \"u\" && n.id !== r)\n            return;\n          this.records.delete(n.id), this.events.emit(zt.deleted, n);\n        }\n      });\n    }, this.exists = async (s, r) => (this.isInitialized(), this.records.has(r) ? (await this.getRecord(r)).topic === s : !1), this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.logger = ee.generateChildLogger(t, this.name);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const e = [];\n    return this.values.forEach((t) => {\n      if (typeof t.response < \"u\")\n        return;\n      const s = { topic: t.topic, request: ti(t.request.method, t.request.params, t.id), chainId: t.chainId };\n      return e.push(s);\n    }), e;\n  }\n  async setJsonRpcRecords(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getJsonRpcRecords() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getRecord(e) {\n    this.isInitialized();\n    const t = this.records.get(e);\n    if (!t) {\n      const { message: s } = Y(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(s);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setJsonRpcRecords(this.values), this.events.emit(zt.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getJsonRpcRecords();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.records.size) {\n        const { message: t } = Y(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", records: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);\n    }\n  }\n  registerEventListeners() {\n    this.events.on(zt.created, (e) => {\n      const t = zt.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e }), this.persist();\n    }), this.events.on(zt.updated, (e) => {\n      const t = zt.updated;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e }), this.persist();\n    }), this.events.on(zt.deleted, (e) => {\n      const t = zt.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e }), this.persist();\n    }), this.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, () => {\n      this.cleanup();\n    });\n  }\n  cleanup() {\n    try {\n      this.records.forEach((e) => {\n        V.toMiliseconds(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));\n      });\n    } catch (e) {\n      this.logger.warn(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}, tm = class extends vl {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new We.EventEmitter(), this.name = A1, this.version = T1, this.cached = [], this.initialized = !1, this.storagePrefix = hi, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((s) => this.expirations.set(s.target, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.has = (s) => {\n      try {\n        const r = this.formatTarget(s);\n        return typeof this.getExpiration(r) < \"u\";\n      } catch {\n        return !1;\n      }\n    }, this.set = (s, r) => {\n      this.isInitialized();\n      const n = this.formatTarget(s), o = { target: n, expiry: r };\n      this.expirations.set(n, o), this.checkExpiry(n, o), this.events.emit(Tt.created, { target: n, expiration: o });\n    }, this.get = (s) => {\n      this.isInitialized();\n      const r = this.formatTarget(s);\n      return this.getExpiration(r);\n    }, this.del = (s) => {\n      if (this.isInitialized(), this.has(s)) {\n        const r = this.formatTarget(s), n = this.getExpiration(r);\n        this.expirations.delete(r), this.events.emit(Tt.deleted, { target: r, expiration: n });\n      }\n    }, this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.logger = ee.generateChildLogger(t, this.name);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(e) {\n    if (typeof e == \"string\")\n      return vp(e);\n    if (typeof e == \"number\")\n      return _p(e);\n    const { message: t } = Y(\"UNKNOWN_TYPE\", `Target type: ${typeof e}`);\n    throw new Error(t);\n  }\n  async setExpirations(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getExpirations() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  async persist() {\n    await this.setExpirations(this.values), this.events.emit(Tt.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getExpirations();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.expirations.size) {\n        const { message: t } = Y(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", expirations: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);\n    }\n  }\n  getExpiration(e) {\n    const t = this.expirations.get(e);\n    if (!t) {\n      const { message: s } = Y(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(s), new Error(s);\n    }\n    return t;\n  }\n  checkExpiry(e, t) {\n    const { expiry: s } = t;\n    V.toMiliseconds(s) - Date.now() <= 0 && this.expire(e, t);\n  }\n  expire(e, t) {\n    this.expirations.delete(e), this.events.emit(Tt.expired, { target: e, expiration: t });\n  }\n  checkExpirations() {\n    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(Tt.created, (e) => {\n      const t = Tt.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    }), this.events.on(Tt.expired, (e) => {\n      const t = Tt.expired;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    }), this.events.on(Tt.deleted, (e) => {\n      const t = Tt.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}, im = class extends _l {\n  constructor(e, t) {\n    super(e, t), this.projectId = e, this.logger = t, this.name = Nr, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async (s) => {\n      if (this.verifyDisabled || ur() || !vs())\n        return;\n      const r = s?.verifyUrl || Ks;\n      this.verifyUrl !== r && this.removeIframe(), this.verifyUrl = r;\n      try {\n        await this.createIframe();\n      } catch (n) {\n        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n);\n      }\n      if (!this.initialized) {\n        this.removeIframe(), this.verifyUrl = ta;\n        try {\n          await this.createIframe();\n        } catch (n) {\n          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n), this.verifyDisabled = !0;\n        }\n      }\n    }, this.register = async (s) => {\n      this.initialized ? this.sendPost(s.attestationId) : (this.addToQueue(s.attestationId), await this.init());\n    }, this.resolve = async (s) => {\n      if (this.isDevEnv)\n        return \"\";\n      const r = s?.verifyUrl || Ks;\n      let n;\n      try {\n        n = await this.fetchAttestation(s.attestationId, r);\n      } catch (o) {\n        this.logger.info(`failed to resolve attestation: ${s.attestationId} from url: ${r}`), this.logger.info(o), n = await this.fetchAttestation(s.attestationId, ta);\n      }\n      return n;\n    }, this.fetchAttestation = async (s, r) => {\n      this.logger.info(`resolving attestation: ${s} from url: ${r}`);\n      const n = this.startAbortTimer(V.ONE_SECOND * 2), o = await fetch(`${r}/attestation/${s}`, { signal: this.abortController.signal });\n      return clearTimeout(n), o.status === 200 ? await o.json() : void 0;\n    }, this.addToQueue = (s) => {\n      this.queue.push(s);\n    }, this.processQueue = () => {\n      this.queue.length !== 0 && (this.queue.forEach((s) => this.sendPost(s)), this.queue = []);\n    }, this.sendPost = (s) => {\n      var r;\n      try {\n        if (!this.iframe)\n          return;\n        (r = this.iframe.contentWindow) == null || r.postMessage(s, \"*\"), this.logger.info(`postMessage sent: ${s} ${this.verifyUrl}`);\n      } catch {\n      }\n    }, this.createIframe = async () => {\n      let s;\n      const r = (n) => {\n        n.data === \"verify_ready\" && (this.initialized = !0, this.processQueue(), window.removeEventListener(\"message\", r), s());\n      };\n      await Promise.race([new Promise((n) => {\n        if (document.getElementById(Nr))\n          return n();\n        window.addEventListener(\"message\", r);\n        const o = document.createElement(\"iframe\");\n        o.id = Nr, o.src = `${this.verifyUrl}/${this.projectId}`, o.style.display = \"none\", document.body.append(o), this.iframe = o, s = n;\n      }), new Promise((n, o) => setTimeout(() => {\n        window.removeEventListener(\"message\", r), o(\"verify iframe load timeout\");\n      }, V.toMiliseconds(V.FIVE_SECONDS)))]);\n    }, this.removeIframe = () => {\n      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1);\n    }, this.logger = ee.generateChildLogger(t, this.name), this.verifyUrl = Ks, this.abortController = new AbortController(), this.isDevEnv = yn() && process.env.IS_VITEST;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  startAbortTimer(e) {\n    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), V.toMiliseconds(e));\n  }\n};\nvar sm = Object.defineProperty, ha = Object.getOwnPropertySymbols, rm = Object.prototype.hasOwnProperty, nm = Object.prototype.propertyIsEnumerable, ua = (i, e, t) => e in i ? sm(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, la = (i, e) => {\n  for (var t in e || (e = {}))\n    rm.call(e, t) && ua(i, t, e[t]);\n  if (ha)\n    for (var t of ha(e))\n      nm.call(e, t) && ua(i, t, e[t]);\n  return i;\n};\nlet om = class uh extends fl {\n  constructor(e) {\n    super(e), this.protocol = ah, this.version = o1, this.name = En, this.events = new We.EventEmitter(), this.initialized = !1, this.on = (s, r) => this.events.on(s, r), this.once = (s, r) => this.events.once(s, r), this.off = (s, r) => this.events.off(s, r), this.removeListener = (s, r) => this.events.removeListener(s, r), this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || hh;\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : ee.pino(ee.getDefaultLoggerOptions({ level: e?.logger || a1.logger }));\n    this.logger = ee.generateChildLogger(t, this.name), this.heartbeat = new Wt.HeartBeat(), this.crypto = new F1(this, this.logger, e?.keychain), this.history = new em(this, this.logger), this.expirer = new tm(this, this.logger), this.storage = e != null && e.storage ? e.storage : new nc(la(la({}, c1), e?.storageOptions)), this.relayer = new Y1({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Z1(this, this.logger), this.verify = new im(this.projectId || \"\", this.logger);\n  }\n  static async init(e) {\n    const t = new uh(e);\n    await t.initialize();\n    const s = await t.crypto.getClientId();\n    return await t.storage.setItem(I1, s), t;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  async start() {\n    this.initialized || await this.initialize();\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info(\"Core Initialization Success\");\n    } catch (e) {\n      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;\n    }\n  }\n};\nconst am = om, lh = \"wc\", dh = 2, fh = \"client\", Sn = `${lh}@${dh}:${fh}:`, Rr = { name: fh, logger: \"error\", controller: !1, relayUrl: \"wss://relay.walletconnect.com\" }, da = \"WALLETCONNECT_DEEPLINK_CHOICE\", cm = \"proposal\", hm = \"Proposal expired\", um = \"session\", Fs = V.SEVEN_DAYS, lm = \"engine\", es = { wc_sessionPropose: { req: { ttl: V.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: V.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: V.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, Cr = { min: V.FIVE_MINUTES, max: V.SEVEN_DAYS }, ei = { idle: \"IDLE\", active: \"ACTIVE\" }, dm = \"request\", fm = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\nvar pm = Object.defineProperty, gm = Object.defineProperties, ym = Object.getOwnPropertyDescriptors, fa = Object.getOwnPropertySymbols, mm = Object.prototype.hasOwnProperty, bm = Object.prototype.propertyIsEnumerable, pa = (i, e, t) => e in i ? pm(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Et = (i, e) => {\n  for (var t in e || (e = {}))\n    mm.call(e, t) && pa(i, t, e[t]);\n  if (fa)\n    for (var t of fa(e))\n      bm.call(e, t) && pa(i, t, e[t]);\n  return i;\n}, ts = (i, e) => gm(i, ym(e));\nlet wm = class extends Sl {\n  constructor(e) {\n    super(e), this.name = lm, this.events = new ir(), this.initialized = !1, this.ignoredPayloadTypes = [Di], this.requestQueue = { state: ei.idle, queue: [] }, this.sessionRequestQueue = { state: ei.idle, queue: [] }, this.requestQueueDelay = V.ONE_SECOND, this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(es) }), this.initialized = !0, setTimeout(() => {\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();\n      }, V.toMiliseconds(this.requestQueueDelay)));\n    }, this.connect = async (t) => {\n      await this.isInitialized();\n      const s = ts(Et({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });\n      await this.isValidConnect(s);\n      const { pairingTopic: r, requiredNamespaces: n, optionalNamespaces: o, sessionProperties: c, relays: u } = s;\n      let d = r, p, b = !1;\n      if (d && (b = this.client.core.pairing.pairings.get(d).active), !d || !b) {\n        const { topic: D, uri: y } = await this.client.core.pairing.create();\n        d = D, p = y;\n      }\n      const x = await this.client.core.crypto.generateKeyPair(), O = Et({ requiredNamespaces: n, optionalNamespaces: o, relays: u ?? [{ protocol: ch }], proposer: { publicKey: x, metadata: this.client.metadata } }, c && { sessionProperties: c }), { reject: _, resolve: C, done: F } = Ai(V.FIVE_MINUTES, hm);\n      if (this.events.once(Be(\"session_connect\"), async ({ error: D, session: y }) => {\n        if (D)\n          _(D);\n        else if (y) {\n          y.self.publicKey = x;\n          const w = ts(Et({}, y), { requiredNamespaces: y.requiredNamespaces, optionalNamespaces: y.optionalNamespaces });\n          await this.client.session.set(y.topic, w), await this.setExpiry(y.topic, y.expiry), d && await this.client.core.pairing.updateMetadata({ topic: d, metadata: y.peer.metadata }), C(w);\n        }\n      }), !d) {\n        const { message: D } = Y(\"NO_MATCHING_KEY\", `connect() pairing topic: ${d}`);\n        throw new Error(D);\n      }\n      const K = await this.sendRequest({ topic: d, method: \"wc_sessionPropose\", params: O }), I = Mt(V.FIVE_MINUTES);\n      return await this.setProposal(K, Et({ id: K, expiry: I }, O)), { uri: p, approval: F };\n    }, this.pair = async (t) => (await this.isInitialized(), await this.client.core.pairing.pair(t)), this.approve = async (t) => {\n      await this.isInitialized(), await this.isValidApprove(t);\n      const { id: s, relayProtocol: r, namespaces: n, sessionProperties: o } = t, c = this.client.proposal.get(s);\n      let { pairingTopic: u, proposer: d, requiredNamespaces: p, optionalNamespaces: b } = c;\n      u = u || \"\", cs(p) || (p = Up(n, \"approve()\"));\n      const x = await this.client.core.crypto.generateKeyPair(), O = d.publicKey, _ = await this.client.core.crypto.generateSharedKey(x, O);\n      u && s && (await this.client.core.pairing.updateMetadata({ topic: u, metadata: d.metadata }), await this.sendResult({ id: s, topic: u, result: { relay: { protocol: r ?? \"irn\" }, responderPublicKey: x } }), await this.client.proposal.delete(s, nt(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({ topic: u }));\n      const C = Et({ relay: { protocol: r ?? \"irn\" }, namespaces: n, requiredNamespaces: p, optionalNamespaces: b, pairingTopic: u, controller: { publicKey: x, metadata: this.client.metadata }, expiry: Mt(Fs) }, o && { sessionProperties: o });\n      await this.client.core.relayer.subscribe(_), await this.sendRequest({ topic: _, method: \"wc_sessionSettle\", params: C, throwOnFailedPublish: !0 });\n      const F = ts(Et({}, C), { topic: _, pairingTopic: u, acknowledged: !1, self: C.controller, peer: { publicKey: d.publicKey, metadata: d.metadata }, controller: x });\n      return await this.client.session.set(_, F), await this.setExpiry(_, Mt(Fs)), { topic: _, acknowledged: () => new Promise((K) => setTimeout(() => K(this.client.session.get(_)), 500)) };\n    }, this.reject = async (t) => {\n      await this.isInitialized(), await this.isValidReject(t);\n      const { id: s, reason: r } = t, { pairingTopic: n } = this.client.proposal.get(s);\n      n && (await this.sendError(s, n, r), await this.client.proposal.delete(s, nt(\"USER_DISCONNECTED\")));\n    }, this.update = async (t) => {\n      await this.isInitialized(), await this.isValidUpdate(t);\n      const { topic: s, namespaces: r } = t, n = await this.sendRequest({ topic: s, method: \"wc_sessionUpdate\", params: { namespaces: r } }), { done: o, resolve: c, reject: u } = Ai();\n      return this.events.once(Be(\"session_update\", n), ({ error: d }) => {\n        d ? u(d) : c();\n      }), await this.client.session.update(s, { namespaces: r }), { acknowledged: o };\n    }, this.extend = async (t) => {\n      await this.isInitialized(), await this.isValidExtend(t);\n      const { topic: s } = t, r = await this.sendRequest({ topic: s, method: \"wc_sessionExtend\", params: {} }), { done: n, resolve: o, reject: c } = Ai();\n      return this.events.once(Be(\"session_extend\", r), ({ error: u }) => {\n        u ? c(u) : o();\n      }), await this.setExpiry(s, Mt(Fs)), { acknowledged: n };\n    }, this.request = async (t) => {\n      await this.isInitialized(), await this.isValidRequest(t);\n      const { chainId: s, request: r, topic: n, expiry: o } = t, c = wn(), { done: u, resolve: d, reject: p } = Ai(o);\n      return this.events.once(Be(\"session_request\", c), ({ error: b, result: x }) => {\n        b ? p(b) : d(x);\n      }), await Promise.all([new Promise(async (b) => {\n        await this.sendRequest({ clientRpcId: c, topic: n, method: \"wc_sessionRequest\", params: { request: r, chainId: s }, expiry: o, throwOnFailedPublish: !0 }).catch((x) => p(x)), this.client.events.emit(\"session_request_sent\", { topic: n, request: r, chainId: s, id: c }), b();\n      }), new Promise(async (b) => {\n        const x = await this.client.core.storage.getItem(da);\n        Ep({ id: c, topic: n, wcDeepLink: x }), b();\n      }), u()]).then((b) => b[2]);\n    }, this.respond = async (t) => {\n      await this.isInitialized(), await this.isValidRespond(t);\n      const { topic: s, response: r } = t, { id: n } = r;\n      ht(r) ? await this.sendResult({ id: n, topic: s, result: r.result, throwOnFailedPublish: !0 }) : Ge(r) && await this.sendError(n, s, r.error), this.cleanupAfterResponse(t);\n    }, this.ping = async (t) => {\n      await this.isInitialized(), await this.isValidPing(t);\n      const { topic: s } = t;\n      if (this.client.session.keys.includes(s)) {\n        const r = await this.sendRequest({ topic: s, method: \"wc_sessionPing\", params: {} }), { done: n, resolve: o, reject: c } = Ai();\n        this.events.once(Be(\"session_ping\", r), ({ error: u }) => {\n          u ? c(u) : o();\n        }), await n();\n      } else\n        this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({ topic: s });\n    }, this.emit = async (t) => {\n      await this.isInitialized(), await this.isValidEmit(t);\n      const { topic: s, event: r, chainId: n } = t;\n      await this.sendRequest({ topic: s, method: \"wc_sessionEvent\", params: { event: r, chainId: n } });\n    }, this.disconnect = async (t) => {\n      await this.isInitialized(), await this.isValidDisconnect(t);\n      const { topic: s } = t;\n      this.client.session.keys.includes(s) ? (await this.sendRequest({ topic: s, method: \"wc_sessionDelete\", params: nt(\"USER_DISCONNECTED\"), throwOnFailedPublish: !0 }), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({ topic: s });\n    }, this.find = (t) => (this.isInitialized(), this.client.session.getAll().filter((s) => qp(s, t))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (t) => {\n      if (t.pairingTopic)\n        try {\n          const s = this.client.core.pairing.pairings.get(t.pairingTopic), r = this.client.core.pairing.pairings.getAll().filter((n) => {\n            var o, c;\n            return ((o = n.peerMetadata) == null ? void 0 : o.url) && ((c = n.peerMetadata) == null ? void 0 : c.url) === t.peer.metadata.url && n.topic && n.topic !== s.topic;\n          });\n          if (r.length === 0)\n            return;\n          this.client.logger.info(`Cleaning up ${r.length} duplicate pairing(s)`), await Promise.all(r.map((n) => this.client.core.pairing.disconnect({ topic: n.topic }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n        } catch (s) {\n          this.client.logger.error(s);\n        }\n    }, this.deleteSession = async (t, s) => {\n      const { self: r } = this.client.session.get(t);\n      await this.client.core.relayer.unsubscribe(t), this.client.session.delete(t, nt(\"USER_DISCONNECTED\")), this.client.core.crypto.keychain.has(r.publicKey) && await this.client.core.crypto.deleteKeyPair(r.publicKey), this.client.core.crypto.keychain.has(t) && await this.client.core.crypto.deleteSymKey(t), s || this.client.core.expirer.del(t), this.client.core.storage.removeItem(da).catch((n) => this.client.logger.warn(n));\n    }, this.deleteProposal = async (t, s) => {\n      await Promise.all([this.client.proposal.delete(t, nt(\"USER_DISCONNECTED\")), s ? Promise.resolve() : this.client.core.expirer.del(t)]);\n    }, this.deletePendingSessionRequest = async (t, s, r = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(t, s), r ? Promise.resolve() : this.client.core.expirer.del(t)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((n) => n.id !== t), r && (this.sessionRequestQueue.state = ei.idle);\n    }, this.setExpiry = async (t, s) => {\n      this.client.session.keys.includes(t) && await this.client.session.update(t, { expiry: s }), this.client.core.expirer.set(t, s);\n    }, this.setProposal = async (t, s) => {\n      await this.client.proposal.set(t, s), this.client.core.expirer.set(t, s.expiry);\n    }, this.setPendingSessionRequest = async (t) => {\n      const s = es.wc_sessionRequest.req.ttl, { id: r, topic: n, params: o, verifyContext: c } = t;\n      await this.client.pendingRequest.set(r, { id: r, topic: n, params: o, verifyContext: c }), s && this.client.core.expirer.set(r, Mt(s));\n    }, this.sendRequest = async (t) => {\n      const { topic: s, method: r, params: n, expiry: o, relayRpcId: c, clientRpcId: u, throwOnFailedPublish: d } = t, p = ti(r, n, u);\n      if (vs() && fm.includes(r)) {\n        const O = Fi(JSON.stringify(p));\n        this.client.core.verify.register({ attestationId: O });\n      }\n      const b = await this.client.core.crypto.encode(s, p), x = es[r].req;\n      return o && (x.ttl = o), c && (x.id = c), this.client.core.history.set(s, p), d ? (x.internal = ts(Et({}, x.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(s, b, x)) : this.client.core.relayer.publish(s, b, x).catch((O) => this.client.logger.error(O)), p.id;\n    }, this.sendResult = async (t) => {\n      const { id: s, topic: r, result: n, throwOnFailedPublish: o } = t, c = xi(s, n), u = await this.client.core.crypto.encode(r, c), d = await this.client.core.history.get(r, s), p = es[d.request.method].res;\n      o ? (p.internal = ts(Et({}, p.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(r, u, p)) : this.client.core.relayer.publish(r, u, p).catch((b) => this.client.logger.error(b)), await this.client.core.history.resolve(c);\n    }, this.sendError = async (t, s, r) => {\n      const n = qi(t, r), o = await this.client.core.crypto.encode(s, n), c = await this.client.core.history.get(s, t), u = es[c.request.method].res;\n      this.client.core.relayer.publish(s, o, u), await this.client.core.history.resolve(n);\n    }, this.cleanup = async () => {\n      const t = [], s = [];\n      this.client.session.getAll().forEach((r) => {\n        ai(r.expiry) && t.push(r.topic);\n      }), this.client.proposal.getAll().forEach((r) => {\n        ai(r.expiry) && s.push(r.id);\n      }), await Promise.all([...t.map((r) => this.deleteSession(r)), ...s.map((r) => this.deleteProposal(r))]);\n    }, this.onRelayEventRequest = async (t) => {\n      this.requestQueue.queue.push(t), await this.processRequestsQueue();\n    }, this.processRequestsQueue = async () => {\n      if (this.requestQueue.state === ei.active) {\n        this.client.logger.info(\"Request queue already active, skipping...\");\n        return;\n      }\n      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {\n        this.requestQueue.state = ei.active;\n        const t = this.requestQueue.queue.shift();\n        if (t)\n          try {\n            this.processRequest(t), await new Promise((s) => setTimeout(s, 300));\n          } catch (s) {\n            this.client.logger.warn(s);\n          }\n      }\n      this.requestQueue.state = ei.idle;\n    }, this.processRequest = (t) => {\n      const { topic: s, payload: r } = t, n = r.method;\n      switch (n) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(s, r);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(s, r);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(s, r);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(s, r);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(s, r);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(s, r);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(s, r);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(s, r);\n        default:\n          return this.client.logger.info(`Unsupported request method ${n}`);\n      }\n    }, this.onRelayEventResponse = async (t) => {\n      const { topic: s, payload: r } = t, n = (await this.client.core.history.get(s, r.id)).request.method;\n      switch (n) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(s, r);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(s, r);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(s, r);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(s, r);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(s, r);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(s, r);\n        default:\n          return this.client.logger.info(`Unsupported response method ${n}`);\n      }\n    }, this.onRelayEventUnknownPayload = (t) => {\n      const { topic: s } = t, { message: r } = Y(\"MISSING_OR_INVALID\", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(r);\n    }, this.onSessionProposeRequest = async (t, s) => {\n      const { params: r, id: n } = s;\n      try {\n        this.isValidConnect(Et({}, s.params));\n        const o = Mt(V.FIVE_MINUTES), c = Et({ id: n, pairingTopic: t, expiry: o }, r);\n        await this.setProposal(n, c);\n        const u = Fi(JSON.stringify(s)), d = await this.getVerifyContext(u, c.proposer.metadata);\n        this.client.events.emit(\"session_proposal\", { id: n, params: c, verifyContext: d });\n      } catch (o) {\n        await this.sendError(n, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionProposeResponse = async (t, s) => {\n      const { id: r } = s;\n      if (ht(s)) {\n        const { result: n } = s;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result: n });\n        const o = this.client.proposal.get(r);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal: o });\n        const c = o.proposer.publicKey;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", selfPublicKey: c });\n        const u = n.responderPublicKey;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", peerPublicKey: u });\n        const d = await this.client.core.crypto.generateSharedKey(c, u);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", sessionTopic: d });\n        const p = await this.client.core.relayer.subscribe(d);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", subscriptionId: p }), await this.client.core.pairing.activate({ topic: t });\n      } else\n        Ge(s) && (await this.client.proposal.delete(r, nt(\"USER_DISCONNECTED\")), this.events.emit(Be(\"session_connect\"), { error: s.error }));\n    }, this.onSessionSettleRequest = async (t, s) => {\n      const { id: r, params: n } = s;\n      try {\n        this.isValidSessionSettleRequest(n);\n        const { relay: o, controller: c, expiry: u, namespaces: d, requiredNamespaces: p, optionalNamespaces: b, sessionProperties: x, pairingTopic: O } = s.params, _ = Et({ topic: t, relay: o, expiry: u, namespaces: d, acknowledged: !0, pairingTopic: O, requiredNamespaces: p, optionalNamespaces: b, controller: c.publicKey, self: { publicKey: \"\", metadata: this.client.metadata }, peer: { publicKey: c.publicKey, metadata: c.metadata } }, x && { sessionProperties: x });\n        await this.sendResult({ id: s.id, topic: t, result: !0 }), this.events.emit(Be(\"session_connect\"), { session: _ }), this.cleanupDuplicatePairings(_);\n      } catch (o) {\n        await this.sendError(r, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionSettleResponse = async (t, s) => {\n      const { id: r } = s;\n      ht(s) ? (await this.client.session.update(t, { acknowledged: !0 }), this.events.emit(Be(\"session_approve\", r), {})) : Ge(s) && (await this.client.session.delete(t, nt(\"USER_DISCONNECTED\")), this.events.emit(Be(\"session_approve\", r), { error: s.error }));\n    }, this.onSessionUpdateRequest = async (t, s) => {\n      const { params: r, id: n } = s;\n      try {\n        const o = `${t}_session_update`, c = $s.get(o);\n        if (c && this.isRequestOutOfSync(c, n)) {\n          this.client.logger.info(`Discarding out of sync request - ${n}`);\n          return;\n        }\n        this.isValidUpdate(Et({ topic: t }, r)), await this.client.session.update(t, { namespaces: r.namespaces }), await this.sendResult({ id: n, topic: t, result: !0 }), this.client.events.emit(\"session_update\", { id: n, topic: t, params: r }), $s.set(o, n);\n      } catch (o) {\n        await this.sendError(n, t, o), this.client.logger.error(o);\n      }\n    }, this.isRequestOutOfSync = (t, s) => parseInt(s.toString().slice(0, -3)) <= parseInt(t.toString().slice(0, -3)), this.onSessionUpdateResponse = (t, s) => {\n      const { id: r } = s;\n      ht(s) ? this.events.emit(Be(\"session_update\", r), {}) : Ge(s) && this.events.emit(Be(\"session_update\", r), { error: s.error });\n    }, this.onSessionExtendRequest = async (t, s) => {\n      const { id: r } = s;\n      try {\n        this.isValidExtend({ topic: t }), await this.setExpiry(t, Mt(Fs)), await this.sendResult({ id: r, topic: t, result: !0 }), this.client.events.emit(\"session_extend\", { id: r, topic: t });\n      } catch (n) {\n        await this.sendError(r, t, n), this.client.logger.error(n);\n      }\n    }, this.onSessionExtendResponse = (t, s) => {\n      const { id: r } = s;\n      ht(s) ? this.events.emit(Be(\"session_extend\", r), {}) : Ge(s) && this.events.emit(Be(\"session_extend\", r), { error: s.error });\n    }, this.onSessionPingRequest = async (t, s) => {\n      const { id: r } = s;\n      try {\n        this.isValidPing({ topic: t }), await this.sendResult({ id: r, topic: t, result: !0 }), this.client.events.emit(\"session_ping\", { id: r, topic: t });\n      } catch (n) {\n        await this.sendError(r, t, n), this.client.logger.error(n);\n      }\n    }, this.onSessionPingResponse = (t, s) => {\n      const { id: r } = s;\n      setTimeout(() => {\n        ht(s) ? this.events.emit(Be(\"session_ping\", r), {}) : Ge(s) && this.events.emit(Be(\"session_ping\", r), { error: s.error });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (t, s) => {\n      const { id: r } = s;\n      try {\n        this.isValidDisconnect({ topic: t, reason: s.params }), await Promise.all([new Promise((n) => {\n          this.client.core.relayer.once(gt.publish, async () => {\n            n(await this.deleteSession(t));\n          });\n        }), this.sendResult({ id: r, topic: t, result: !0 })]), this.client.events.emit(\"session_delete\", { id: r, topic: t });\n      } catch (n) {\n        this.client.logger.error(n);\n      }\n    }, this.onSessionRequest = async (t, s) => {\n      const { id: r, params: n } = s;\n      try {\n        this.isValidRequest(Et({ topic: t }, n));\n        const o = Fi(JSON.stringify(ti(\"wc_sessionRequest\", n, r))), c = this.client.session.get(t), u = await this.getVerifyContext(o, c.peer.metadata), d = { id: r, topic: t, params: n, verifyContext: u };\n        await this.setPendingSessionRequest(d), this.addSessionRequestToSessionRequestQueue(d), this.processSessionRequestQueue();\n      } catch (o) {\n        await this.sendError(r, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionRequestResponse = (t, s) => {\n      const { id: r } = s;\n      ht(s) ? this.events.emit(Be(\"session_request\", r), { result: s.result }) : Ge(s) && this.events.emit(Be(\"session_request\", r), { error: s.error });\n    }, this.onSessionEventRequest = async (t, s) => {\n      const { id: r, params: n } = s;\n      try {\n        const o = `${t}_session_event_${n.event.name}`, c = $s.get(o);\n        if (c && this.isRequestOutOfSync(c, r)) {\n          this.client.logger.info(`Discarding out of sync request - ${r}`);\n          return;\n        }\n        this.isValidEmit(Et({ topic: t }, n)), this.client.events.emit(\"session_event\", { id: r, topic: t, params: n }), $s.set(o, r);\n      } catch (o) {\n        await this.sendError(r, t, o), this.client.logger.error(o);\n      }\n    }, this.addSessionRequestToSessionRequestQueue = (t) => {\n      this.sessionRequestQueue.queue.push(t);\n    }, this.cleanupAfterResponse = (t) => {\n      this.deletePendingSessionRequest(t.response.id, { message: \"fulfilled\", code: 0 }), setTimeout(() => {\n        this.sessionRequestQueue.state = ei.idle, this.processSessionRequestQueue();\n      }, V.toMiliseconds(this.requestQueueDelay));\n    }, this.processSessionRequestQueue = () => {\n      if (this.sessionRequestQueue.state === ei.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const t = this.sessionRequestQueue.queue[0];\n      if (!t) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        this.sessionRequestQueue.state = ei.active, this.client.events.emit(\"session_request\", t);\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.onPairingCreated = (t) => {\n      if (t.active)\n        return;\n      const s = this.client.proposal.getAll().find((r) => r.pairingTopic === t.topic);\n      s && this.onSessionProposeRequest(t.topic, ti(\"wc_sessionPropose\", { requiredNamespaces: s.requiredNamespaces, optionalNamespaces: s.optionalNamespaces, relays: s.relays, proposer: s.proposer }, s.id));\n    }, this.isValidConnect = async (t) => {\n      if (!St(t)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(t)}`);\n        throw new Error(u);\n      }\n      const { pairingTopic: s, requiredNamespaces: r, optionalNamespaces: n, sessionProperties: o, relays: c } = t;\n      if (bt(s) || await this.isValidPairingTopic(s), !Qp(c, !0)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `connect() relays: ${c}`);\n        throw new Error(u);\n      }\n      !bt(r) && cs(r) !== 0 && this.validateNamespaces(r, \"requiredNamespaces\"), !bt(n) && cs(n) !== 0 && this.validateNamespaces(n, \"optionalNamespaces\"), bt(o) || this.validateSessionProps(o, \"sessionProperties\");\n    }, this.validateNamespaces = (t, s) => {\n      const r = Jp(t, \"connect()\", s);\n      if (r)\n        throw new Error(r.message);\n    }, this.isValidApprove = async (t) => {\n      if (!St(t))\n        throw new Error(Y(\"MISSING_OR_INVALID\", `approve() params: ${t}`).message);\n      const { id: s, namespaces: r, relayProtocol: n, sessionProperties: o } = t;\n      await this.isValidProposalId(s);\n      const c = this.client.proposal.get(s), u = zs(r, \"approve()\");\n      if (u)\n        throw new Error(u.message);\n      const d = Mo(c.requiredNamespaces, r, \"approve()\");\n      if (d)\n        throw new Error(d.message);\n      if (!ot(n, !0)) {\n        const { message: p } = Y(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${n}`);\n        throw new Error(p);\n      }\n      bt(o) || this.validateSessionProps(o, \"sessionProperties\");\n    }, this.isValidReject = async (t) => {\n      if (!St(t)) {\n        const { message: n } = Y(\"MISSING_OR_INVALID\", `reject() params: ${t}`);\n        throw new Error(n);\n      }\n      const { id: s, reason: r } = t;\n      if (await this.isValidProposalId(s), !Zp(r)) {\n        const { message: n } = Y(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(r)}`);\n        throw new Error(n);\n      }\n    }, this.isValidSessionSettleRequest = (t) => {\n      if (!St(t)) {\n        const { message: d } = Y(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${t}`);\n        throw new Error(d);\n      }\n      const { relay: s, controller: r, namespaces: n, expiry: o } = t;\n      if (!Kc(s)) {\n        const { message: d } = Y(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(d);\n      }\n      const c = Bp(r, \"onSessionSettleRequest()\");\n      if (c)\n        throw new Error(c.message);\n      const u = zs(n, \"onSessionSettleRequest()\");\n      if (u)\n        throw new Error(u.message);\n      if (ai(o)) {\n        const { message: d } = Y(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(d);\n      }\n    }, this.isValidUpdate = async (t) => {\n      if (!St(t)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `update() params: ${t}`);\n        throw new Error(u);\n      }\n      const { topic: s, namespaces: r } = t;\n      await this.isValidSessionTopic(s);\n      const n = this.client.session.get(s), o = zs(r, \"update()\");\n      if (o)\n        throw new Error(o.message);\n      const c = Mo(n.requiredNamespaces, r, \"update()\");\n      if (c)\n        throw new Error(c.message);\n    }, this.isValidExtend = async (t) => {\n      if (!St(t)) {\n        const { message: r } = Y(\"MISSING_OR_INVALID\", `extend() params: ${t}`);\n        throw new Error(r);\n      }\n      const { topic: s } = t;\n      await this.isValidSessionTopic(s);\n    }, this.isValidRequest = async (t) => {\n      if (!St(t)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `request() params: ${t}`);\n        throw new Error(u);\n      }\n      const { topic: s, request: r, chainId: n, expiry: o } = t;\n      await this.isValidSessionTopic(s);\n      const { namespaces: c } = this.client.session.get(s);\n      if (!Lo(c, n)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `request() chainId: ${n}`);\n        throw new Error(u);\n      }\n      if (!eg(r)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(r)}`);\n        throw new Error(u);\n      }\n      if (!sg(c, n, r.method)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `request() method: ${r.method}`);\n        throw new Error(u);\n      }\n      if (o && !ag(o, Cr)) {\n        const { message: u } = Y(\"MISSING_OR_INVALID\", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${Cr.min} and ${Cr.max}`);\n        throw new Error(u);\n      }\n    }, this.isValidRespond = async (t) => {\n      if (!St(t)) {\n        const { message: n } = Y(\"MISSING_OR_INVALID\", `respond() params: ${t}`);\n        throw new Error(n);\n      }\n      const { topic: s, response: r } = t;\n      if (await this.isValidSessionTopic(s), !tg(r)) {\n        const { message: n } = Y(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(r)}`);\n        throw new Error(n);\n      }\n    }, this.isValidPing = async (t) => {\n      if (!St(t)) {\n        const { message: r } = Y(\"MISSING_OR_INVALID\", `ping() params: ${t}`);\n        throw new Error(r);\n      }\n      const { topic: s } = t;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.isValidEmit = async (t) => {\n      if (!St(t)) {\n        const { message: c } = Y(\"MISSING_OR_INVALID\", `emit() params: ${t}`);\n        throw new Error(c);\n      }\n      const { topic: s, event: r, chainId: n } = t;\n      await this.isValidSessionTopic(s);\n      const { namespaces: o } = this.client.session.get(s);\n      if (!Lo(o, n)) {\n        const { message: c } = Y(\"MISSING_OR_INVALID\", `emit() chainId: ${n}`);\n        throw new Error(c);\n      }\n      if (!ig(r)) {\n        const { message: c } = Y(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(r)}`);\n        throw new Error(c);\n      }\n      if (!rg(o, n, r.name)) {\n        const { message: c } = Y(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(r)}`);\n        throw new Error(c);\n      }\n    }, this.isValidDisconnect = async (t) => {\n      if (!St(t)) {\n        const { message: r } = Y(\"MISSING_OR_INVALID\", `disconnect() params: ${t}`);\n        throw new Error(r);\n      }\n      const { topic: s } = t;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.getVerifyContext = async (t, s) => {\n      const r = { verified: { verifyUrl: s.verifyUrl || Ks, validation: \"UNKNOWN\", origin: s.url || \"\" } };\n      try {\n        const n = await this.client.core.verify.resolve({ attestationId: t, verifyUrl: s.verifyUrl });\n        n && (r.verified.origin = n.origin, r.verified.isScam = n.isScam, r.verified.validation = n.origin === new URL(s.url).origin ? \"VALID\" : \"INVALID\");\n      } catch (n) {\n        this.client.logger.info(n);\n      }\n      return this.client.logger.info(`Verify context: ${JSON.stringify(r)}`), r;\n    }, this.validateSessionProps = (t, s) => {\n      Object.values(t).forEach((r) => {\n        if (!ot(r, !1)) {\n          const { message: n } = Y(\"MISSING_OR_INVALID\", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(r)}`);\n          throw new Error(n);\n        }\n      });\n    };\n  }\n  async isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = Y(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(gt.message, async (e) => {\n      const { topic: t, message: s } = e;\n      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))\n        return;\n      const r = await this.client.core.crypto.decode(t, s);\n      try {\n        ji(r) ? (this.client.core.history.set(t, r), this.onRelayEventRequest({ topic: t, payload: r })) : Oi(r) ? (await this.client.core.history.resolve(r), await this.onRelayEventResponse({ topic: t, payload: r }), this.client.core.history.delete(t, r.id)) : this.onRelayEventUnknownPayload({ topic: t, payload: r });\n      } catch (n) {\n        this.client.logger.error(n);\n      }\n    });\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(Tt.expired, async (e) => {\n      const { topic: t, id: s } = jc(e.target);\n      if (s && this.client.pendingRequest.keys.includes(s))\n        return await this.deletePendingSessionRequest(s, Y(\"EXPIRED\"), !0);\n      t ? this.client.session.keys.includes(t) && (await this.deleteSession(t, !0), this.client.events.emit(\"session_expire\", { topic: t })) : s && (await this.deleteProposal(s, !0), this.client.events.emit(\"proposal_expire\", { id: s }));\n    });\n  }\n  registerPairingEvents() {\n    this.client.core.pairing.events.on(os.create, (e) => this.onPairingCreated(e));\n  }\n  isValidPairingTopic(e) {\n    if (!ot(e, !1)) {\n      const { message: t } = Y(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(e)) {\n      const { message: t } = Y(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (ai(this.client.core.pairing.pairings.get(e).expiry)) {\n      const { message: t } = Y(\"EXPIRED\", `pairing topic: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidSessionTopic(e) {\n    if (!ot(e, !1)) {\n      const { message: t } = Y(\"MISSING_OR_INVALID\", `session topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.session.keys.includes(e)) {\n      const { message: t } = Y(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (ai(this.client.session.get(e).expiry)) {\n      await this.deleteSession(e);\n      const { message: t } = Y(\"EXPIRED\", `session topic: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidSessionOrPairingTopic(e) {\n    if (this.client.session.keys.includes(e))\n      await this.isValidSessionTopic(e);\n    else if (this.client.core.pairing.pairings.keys.includes(e))\n      this.isValidPairingTopic(e);\n    else if (ot(e, !1)) {\n      const { message: t } = Y(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${e}`);\n      throw new Error(t);\n    } else {\n      const { message: t } = Y(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidProposalId(e) {\n    if (!Xp(e)) {\n      const { message: t } = Y(\"MISSING_OR_INVALID\", `proposal id should be a number: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.proposal.keys.includes(e)) {\n      const { message: t } = Y(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (ai(this.client.proposal.get(e).expiry)) {\n      await this.deleteProposal(e);\n      const { message: t } = Y(\"EXPIRED\", `proposal id: ${e}`);\n      throw new Error(t);\n    }\n  }\n}, vm = class extends dr {\n  constructor(e, t) {\n    super(e, t, cm, Sn), this.core = e, this.logger = t;\n  }\n}, _m = class extends dr {\n  constructor(e, t) {\n    super(e, t, um, Sn), this.core = e, this.logger = t;\n  }\n}, Em = class extends dr {\n  constructor(e, t) {\n    super(e, t, dm, Sn, (s) => s.id), this.core = e, this.logger = t;\n  }\n}, Sm = class ph extends El {\n  constructor(e) {\n    super(e), this.protocol = lh, this.version = dh, this.name = Rr.name, this.events = new We.EventEmitter(), this.on = (s, r) => this.events.on(s, r), this.once = (s, r) => this.events.once(s, r), this.off = (s, r) => this.events.off(s, r), this.removeListener = (s, r) => this.events.removeListener(s, r), this.removeAllListeners = (s) => this.events.removeAllListeners(s), this.connect = async (s) => {\n      try {\n        return await this.engine.connect(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.pair = async (s) => {\n      try {\n        return await this.engine.pair(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.approve = async (s) => {\n      try {\n        return await this.engine.approve(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.reject = async (s) => {\n      try {\n        return await this.engine.reject(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.update = async (s) => {\n      try {\n        return await this.engine.update(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.extend = async (s) => {\n      try {\n        return await this.engine.extend(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.request = async (s) => {\n      try {\n        return await this.engine.request(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.respond = async (s) => {\n      try {\n        return await this.engine.respond(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.ping = async (s) => {\n      try {\n        return await this.engine.ping(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.emit = async (s) => {\n      try {\n        return await this.engine.emit(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.disconnect = async (s) => {\n      try {\n        return await this.engine.disconnect(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.find = (s) => {\n      try {\n        return this.engine.find(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = e?.name || Rr.name, this.metadata = e?.metadata || gp();\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : ee.pino(ee.getDefaultLoggerOptions({ level: e?.logger || Rr.logger }));\n    this.core = e?.core || new am(e), this.logger = ee.generateChildLogger(t, this.name), this.session = new _m(this.core, this.logger), this.proposal = new vm(this.core, this.logger), this.pendingRequest = new Em(this.core, this.logger), this.engine = new wm(this);\n  }\n  static async init(e) {\n    const t = new ph(e);\n    return await t.initialize(), t;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info(\"SignClient Initialization Success\");\n    } catch (e) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(e.message), e;\n    }\n  }\n};\nconst Im = () => {\n  const e = hn()?.os?.toLowerCase();\n  return e?.includes(\"android\") ? \"android\" : e?.toLowerCase().includes(\"ios\") || e?.toLowerCase().includes(\"mac\") && navigator.maxTouchPoints > 1 ? \"ios\" : \"desktop\";\n}, Us = Im(), Dm = {\n  position: \"fixed\",\n  top: \"0\",\n  left: \"0\",\n  right: \"0\",\n  bottom: \"0\",\n  backgroundColor: \"rgba(0,0,0,0.8)\",\n  backdropFilter: \"blur(10px)\",\n  zIndex: \"9999\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  flexDirection: \"column\",\n  color: \"white\",\n  fontWeight: \"500\",\n  fontFamily: \"'Barlow', sans-serif\"\n}, xm = {\n  width: \"840px\",\n  height: \"540px\",\n  zIndex: \"99999\",\n  backgroundColor: \"white\",\n  border: \"none\",\n  outline: \"none\",\n  borderRadius: \"40px\",\n  boxShadow: \"0px 4px 40px 0px rgb(0 0 0), 0px 4px 8px 0px rgb(0 0 0 / 25%)\",\n  position: \"fixed\",\n  top: \"50%\",\n  left: \"50%\",\n  transform: \"translate(-50%,-50%)\"\n}, Om = `\n  <div id=\"argent-mobile-modal-container\" style=\"position: relative\">\n    <iframe class=\"argent-iframe\" allow=\"clipboard-write\"></iframe>\n    <div class=\"argent-close-button\" style=\"position: absolute; top: 24px; right: 24px; cursor: pointer;\">\n      <svg width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <circle cx=\"16\" cy=\"16\" r=\"16\" fill=\"#F5F3F0\"/>\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M22.2462 9.75382C22.7018 10.2094 22.7018 10.9481 22.2462 11.4037L17.6499 16L22.2462 20.5963C22.7018 21.0519 22.7018 21.7906 22.2462 22.2462C21.7905 22.7018 21.0519 22.7018 20.5962 22.2462L16 17.6499L11.4039 22.246C10.9482 22.7017 10.2096 22.7017 9.75394 22.246C9.29833 21.7904 9.29833 21.0517 9.75394 20.5961L14.3501 16L9.75394 11.4039C9.29833 10.9483 9.29833 10.2096 9.75394 9.75396C10.2096 9.29835 10.9482 9.29835 11.4039 9.75396L16 14.3501L20.5962 9.75382C21.0519 9.29821 21.7905 9.29821 22.2462 9.75382Z\" fill=\"#333332\"/>\n      </svg>\n    </div>\n  </div>\n`;\nclass Nm {\n  constructor() {\n    we(this, \"bridgeUrl\", \"https://login.argent.xyz\");\n    we(this, \"mobileUrl\", \"argent://\");\n    we(this, \"type\", \"overlay\");\n    we(this, \"wcUri\");\n    we(this, \"overlay\");\n    we(this, \"popupWindow\");\n    we(this, \"closingTimeout\");\n    we(this, \"close\", () => {\n      this.overlay?.remove(), this.popupWindow?.close(), this.overlay = void 0, this.popupWindow = void 0;\n    });\n  }\n  showConnectionModal(e) {\n    const t = encodeURIComponent(e), s = encodeURIComponent(window.location.href);\n    this.showModal({\n      desktop: `${this.bridgeUrl}?wc=${t}&device=desktop`,\n      ios: `${this.mobileUrl}app/wc?uri=${t}&href=${s}&device=mobile`,\n      android: `${this.mobileUrl}app/wc?uri=${t}&href=${s}&device=mobile`\n    });\n  }\n  showApprovalModal(e) {\n    if (Us === \"desktop\") {\n      this.showModal({\n        desktop: `${this.bridgeUrl}?action=sign`,\n        ios: \"\",\n        android: \"\"\n      });\n      return;\n    }\n    const t = encodeURIComponent(window.location.href);\n    this.showModal({\n      desktop: `${this.bridgeUrl}?action=sign&device=desktop`,\n      ios: `${this.mobileUrl}app/wc/request?href=${t}&device=mobile`,\n      android: `${this.mobileUrl}app/wc/request?href=${t}&device=mobile`\n    });\n  }\n  closeModal(e) {\n    e ? (this.overlay?.querySelector(\"iframe\")?.contentWindow?.postMessage(\"argent-login.success\", \"*\"), this.popupWindow?.postMessage(\"argent-login.success\", \"*\"), this.closingTimeout = setTimeout(this.close, 3400)) : this.close();\n  }\n  showModal(e) {\n    if (clearTimeout(this.closingTimeout), (this.overlay || this.popupWindow) && this.close(), Us === \"android\" || Us === \"ios\") {\n      const n = document.createElement(\"button\");\n      n.style.display = \"none\", n.addEventListener(\"click\", () => {\n        window.location.href = e[Us];\n      }), n.click();\n      return;\n    }\n    if (this.type === \"window\") {\n      const n = \"menubar=no,location=no,resizable=no,scrollbars=no,status=no,width=840,height=540\";\n      this.popupWindow = window.open(e.desktop, \"_blank\", n) || void 0;\n      return;\n    }\n    const t = document.createElement(\"div\");\n    t.innerHTML = Om, t.id = \"argent-mobile-modal-overlay\";\n    for (const [n, o] of Object.entries(Dm))\n      t.style[n] = o;\n    document.body.appendChild(t), t.addEventListener(\"click\", () => this.closeModal()), this.overlay = t;\n    const s = t.querySelector(\"iframe\");\n    s.setAttribute(\"src\", e.desktop);\n    for (const [n, o] of Object.entries(xm))\n      s.style[n] = o;\n    t.querySelector(\n      \".argent-close-button\"\n    ).addEventListener(\"click\", () => this.closeModal());\n  }\n}\nconst kt = new Nm(), Xs = starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName, Pm = async ({\n  projectId: i,\n  chainId: e,\n  name: t,\n  description: s,\n  rpcUrl: r,\n  bridgeUrl: n = Rm(e),\n  mobileUrl: o = Cm(e),\n  modalType: c = \"overlay\",\n  url: u,\n  icons: d,\n  walletConnect: p,\n  provider: b\n}, x) => {\n  if (!n)\n    throw new Error(\"bridgeUrl is required\");\n  if (!o)\n    throw new Error(\"mobileUrl is required\");\n  kt.bridgeUrl = n, kt.mobileUrl = o, kt.type = c;\n  const O = {\n    projectId: i,\n    metadata: {\n      name: t ?? \"Unknown dapp\",\n      description: s ?? \"Unknown dapp description\",\n      url: u ?? \"#\",\n      icons: d ?? [],\n      ...p?.metadata\n    }\n  }, _ = await Sm.init(O), C = new x({ client: _, chainId: e, rpcUrl: r, provider: b });\n  _.on(\"session_event\", (F) => {\n  }), _.on(\"session_update\", ({ topic: F, params: K }) => {\n    const { namespaces: I } = K, D = _.session.get(F);\n    C.updateSession({ ...D, namespaces: I });\n  }), _.on(\"session_delete\", () => {\n  });\n  try {\n    const F = _.session.getAll().find(C.isValidSession);\n    if (F)\n      return C.updateSession(F), C;\n    const K = { requiredNamespaces: C.getRequiredNamespaces() };\n    (0,_index_70f373da_js__WEBPACK_IMPORTED_MODULE_2__.r)(), await new Promise((y) => setTimeout(y, 200));\n    const { uri: I, approval: D } = await _.connect(K);\n    if (I) {\n      kt.showConnectionModal(I), kt.wcUri = I;\n      const y = await D();\n      C.updateSession(y), kt.closeModal(\"animateSuccess\");\n    }\n    return C;\n  } catch {\n    return console.error(\"@argent/login::error\"), kt.closeModal(), null;\n  }\n}, Rm = (i) => {\n  if (!i)\n    throw new Error(\n      `Unknown or unsupported chainId (${i}), either specify a supported chain or set bridgeUrl.`\n    );\n  const e = parseInt(`${i}`);\n  if (String(i).startsWith(Xs.SN_SEPOLIA) || e === 11155111)\n    return \"https://login.hydrogen.argent47.net\";\n  if (String(i).startsWith(Xs.SN_MAIN) || e === 1)\n    return \"https://login.argent.xyz\";\n}, Cm = (i) => {\n  if (!i)\n    throw new Error(\n      `Unknown or unsupported chainId (${i}), either specify a supported chain or set mobileUrl.`\n    );\n  const e = parseInt(`${i}`);\n  if (String(i).startsWith(Xs.SN_SEPOLIA) || e === 11155111)\n    return \"argent-dev://\";\n  if (String(i).startsWith(Xs.SN_MAIN) || e === 1)\n    return \"argent://\";\n};\nclass Am extends Nt {\n  constructor(e) {\n    super(), this.opts = e, this.protocol = \"wc\", this.version = 2;\n  }\n}\nclass Tm extends Nt {\n  constructor(e, t) {\n    super(), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map();\n  }\n}\nclass $m {\n  constructor(e, t) {\n    this.logger = e, this.core = t;\n  }\n}\nclass Fm extends Nt {\n  constructor(e, t) {\n    super(), this.relayer = e, this.logger = t;\n  }\n}\nlet Um = class extends Nt {\n  constructor(e) {\n    super();\n  }\n}, Lm = class {\n  constructor(e, t, s, r) {\n    this.core = e, this.logger = t, this.name = s;\n  }\n};\nclass Mm extends Nt {\n  constructor(e, t) {\n    super(), this.relayer = e, this.logger = t;\n  }\n}\nclass qm extends Nt {\n  constructor(e, t) {\n    super(), this.core = e, this.logger = t;\n  }\n}\nclass jm {\n  constructor(e, t) {\n    this.projectId = e, this.logger = t;\n  }\n}\nlet zm = class {\n  constructor(e) {\n    this.opts = e, this.protocol = \"wc\", this.version = 2;\n  }\n}, Km = class {\n  constructor(e) {\n    this.client = e;\n  }\n};\nconst gh = \":\";\nfunction Vm(i) {\n  const { namespace: e, reference: t } = i;\n  return [e, t].join(gh);\n}\nfunction Bm(i) {\n  const [e, t, s] = i.split(gh);\n  return { namespace: e, reference: t, address: s };\n}\nfunction km(i, e) {\n  const t = [];\n  return i.forEach((s) => {\n    const r = e(s);\n    t.includes(r) || t.push(r);\n  }), t;\n}\nfunction Hm(i) {\n  const { namespace: e, reference: t } = Bm(i);\n  return Vm({ namespace: e, reference: t });\n}\nfunction Gm(i) {\n  return km(i, Hm);\n}\nfunction Wm(i, e = []) {\n  const t = [];\n  return Object.keys(i).forEach((s) => {\n    if (e.length && !e.includes(s))\n      return;\n    const r = i[s];\n    t.push(...r.accounts);\n  }), t;\n}\nfunction Ym(i, e = []) {\n  const t = [];\n  return Object.keys(i).forEach((s) => {\n    if (e.length && !e.includes(s))\n      return;\n    const r = i[s];\n    t.push(...Gm(r.accounts));\n  }), t;\n}\nfunction Jm(i, e = []) {\n  const t = [];\n  return Object.keys(i).forEach((s) => {\n    if (e.length && !e.includes(s))\n      return;\n    const r = i[s];\n    t.push(...In(s, r));\n  }), t;\n}\nfunction In(i, e) {\n  return i.includes(\":\") ? [i] : e.chains || [];\n}\nconst yh = \"base10\", _t = \"base16\", Jr = \"base64pad\", Dn = \"utf8\", mh = 0, Ni = 1, Qm = 0, ga = 1, Qr = 12, xn = 32;\nfunction Xm() {\n  const i = ms.generateKeyPair();\n  return { privateKey: Ne(i.secretKey, _t), publicKey: Ne(i.publicKey, _t) };\n}\nfunction Xr() {\n  const i = li.randomBytes(xn);\n  return Ne(i, _t);\n}\nfunction Zm(i, e) {\n  const t = ms.sharedKey(Ce(i, _t), Ce(e, _t)), s = new Rc(Si.SHA256, t).expand(xn);\n  return Ne(s, _t);\n}\nfunction eb(i) {\n  const e = Si.hash(Ce(i, _t));\n  return Ne(e, _t);\n}\nfunction Ui(i) {\n  const e = Si.hash(Ce(i, Dn));\n  return Ne(e, _t);\n}\nfunction tb(i) {\n  return Ce(`${i}`, yh);\n}\nfunction Is(i) {\n  return Number(Ne(i, yh));\n}\nfunction ib(i) {\n  const e = tb(typeof i.type < \"u\" ? i.type : mh);\n  if (Is(e) === Ni && typeof i.senderPublicKey > \"u\")\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof i.senderPublicKey < \"u\" ? Ce(i.senderPublicKey, _t) : void 0, s = typeof i.iv < \"u\" ? Ce(i.iv, _t) : li.randomBytes(Qr), r = new gs.ChaCha20Poly1305(Ce(i.symKey, _t)).seal(s, Ce(i.message, Dn));\n  return rb({ type: e, sealed: r, iv: s, senderPublicKey: t });\n}\nfunction sb(i) {\n  const e = new gs.ChaCha20Poly1305(Ce(i.symKey, _t)), { sealed: t, iv: s } = Zs(i.encoded), r = e.open(s, t);\n  if (r === null)\n    throw new Error(\"Failed to decrypt\");\n  return Ne(r, Dn);\n}\nfunction rb(i) {\n  if (Is(i.type) === Ni) {\n    if (typeof i.senderPublicKey > \"u\")\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    return Ne(ls([i.type, i.senderPublicKey, i.iv, i.sealed]), Jr);\n  }\n  return Ne(ls([i.type, i.iv, i.sealed]), Jr);\n}\nfunction Zs(i) {\n  const e = Ce(i, Jr), t = e.slice(Qm, ga), s = ga;\n  if (Is(t) === Ni) {\n    const c = s + xn, u = c + Qr, d = e.slice(s, c), p = e.slice(c, u), b = e.slice(u);\n    return { type: t, sealed: b, iv: p, senderPublicKey: d };\n  }\n  const r = s + Qr, n = e.slice(s, r), o = e.slice(r);\n  return { type: t, sealed: o, iv: n };\n}\nfunction nb(i, e) {\n  const t = Zs(i);\n  return bh({ type: Is(t.type), senderPublicKey: typeof t.senderPublicKey < \"u\" ? Ne(t.senderPublicKey, _t) : void 0, receiverPublicKey: e?.receiverPublicKey });\n}\nfunction bh(i) {\n  const e = i?.type || mh;\n  if (e === Ni) {\n    if (typeof i?.senderPublicKey > \"u\")\n      throw new Error(\"missing sender public key\");\n    if (typeof i?.receiverPublicKey > \"u\")\n      throw new Error(\"missing receiver public key\");\n  }\n  return { type: e, senderPublicKey: i?.senderPublicKey, receiverPublicKey: i?.receiverPublicKey };\n}\nfunction ya(i) {\n  return i.type === Ni && typeof i.senderPublicKey == \"string\" && typeof i.receiverPublicKey == \"string\";\n}\nvar ob = Object.defineProperty, ma = Object.getOwnPropertySymbols, ab = Object.prototype.hasOwnProperty, cb = Object.prototype.propertyIsEnumerable, ba = (i, e, t) => e in i ? ob(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, wa = (i, e) => {\n  for (var t in e || (e = {}))\n    ab.call(e, t) && ba(i, t, e[t]);\n  if (ma)\n    for (var t of ma(e))\n      cb.call(e, t) && ba(i, t, e[t]);\n  return i;\n};\nconst hb = \"ReactNative\", as = { reactNative: \"react-native\", node: \"node\", browser: \"browser\", unknown: \"unknown\" }, ub = \"js\";\nfunction On() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction wh() {\n  return !un() && !!bs() && navigator.product === hb;\n}\nfunction Nn() {\n  return !On() && !!bs();\n}\nfunction lb() {\n  return wh() ? as.reactNative : On() ? as.node : Nn() ? as.browser : as.unknown;\n}\nfunction db(i, e) {\n  let t = ii.parse(i);\n  return t = wa(wa({}, t), e), i = ii.stringify(t), i;\n}\nfunction fb() {\n  return fn() || { name: \"\", description: \"\", url: \"\", icons: [\"\"] };\n}\nfunction pb() {\n  const i = hn();\n  if (i === null)\n    return \"unknown\";\n  const e = i.os ? i.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return i.type === \"browser\" ? [e, i.name, i.version].join(\"-\") : [e, i.version].join(\"-\");\n}\nfunction gb() {\n  var i;\n  const e = lb();\n  return e === as.browser ? [e, ((i = ln()) == null ? void 0 : i.host) || \"unknown\"].join(\":\") : e;\n}\nfunction yb(i, e, t) {\n  const s = pb(), r = gb();\n  return [[i, e].join(\"-\"), [ub, t].join(\"-\"), s, r].join(\"/\");\n}\nfunction mb({ protocol: i, version: e, relayUrl: t, sdkVersion: s, auth: r, projectId: n, useOnCloseEvent: o }) {\n  const c = t.split(\"?\"), u = yb(i, e, s), d = { auth: r, ua: u, projectId: n, useOnCloseEvent: o || void 0 }, p = db(c[1] || \"\", d);\n  return c[0] + \"?\" + p;\n}\nfunction Ei(i, e) {\n  return i.filter((t) => e.includes(t)).length === i.length;\n}\nfunction vh(i) {\n  return Object.fromEntries(i.entries());\n}\nfunction _h(i) {\n  return new Map(Object.entries(i));\n}\nfunction Ti(i = V.FIVE_MINUTES, e) {\n  const t = V.toMiliseconds(i || V.FIVE_MINUTES);\n  let s, r, n;\n  return { resolve: (o) => {\n    n && s && (clearTimeout(n), s(o));\n  }, reject: (o) => {\n    n && r && (clearTimeout(n), r(o));\n  }, done: () => new Promise((o, c) => {\n    n = setTimeout(() => {\n      c(new Error(e));\n    }, t), s = o, r = c;\n  }) };\n}\nfunction er(i, e, t) {\n  return new Promise(async (s, r) => {\n    const n = setTimeout(() => r(new Error(t)), e);\n    try {\n      const o = await i;\n      s(o);\n    } catch (o) {\n      r(o);\n    }\n    clearTimeout(n);\n  });\n}\nfunction Eh(i, e) {\n  if (typeof e == \"string\" && e.startsWith(`${i}:`))\n    return e;\n  if (i.toLowerCase() === \"topic\") {\n    if (typeof e != \"string\")\n      throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${e}`;\n  } else if (i.toLowerCase() === \"id\") {\n    if (typeof e != \"number\")\n      throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${e}`;\n  }\n  throw new Error(`Unknown expirer target type: ${i}`);\n}\nfunction bb(i) {\n  return Eh(\"topic\", i);\n}\nfunction wb(i) {\n  return Eh(\"id\", i);\n}\nfunction Sh(i) {\n  const [e, t] = i.split(\":\"), s = { id: void 0, topic: void 0 };\n  if (e === \"topic\" && typeof t == \"string\")\n    s.topic = t;\n  else if (e === \"id\" && Number.isInteger(Number(t)))\n    s.id = Number(t);\n  else\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);\n  return s;\n}\nfunction Ht(i, e) {\n  return V.fromMiliseconds((e || Date.now()) + V.toMiliseconds(i));\n}\nfunction ci(i) {\n  return Date.now() >= V.toMiliseconds(i);\n}\nfunction ke(i, e) {\n  return `${i}${e ? `:${e}` : \"\"}`;\n}\nconst vb = \"irn\";\nfunction Zr(i) {\n  return i?.relay || { protocol: vb };\n}\nfunction Vs(i) {\n  const e = Ac[i];\n  if (typeof e > \"u\")\n    throw new Error(`Relay Protocol not supported: ${i}`);\n  return e;\n}\nvar _b = Object.defineProperty, va = Object.getOwnPropertySymbols, Eb = Object.prototype.hasOwnProperty, Sb = Object.prototype.propertyIsEnumerable, _a = (i, e, t) => e in i ? _b(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Ib = (i, e) => {\n  for (var t in e || (e = {}))\n    Eb.call(e, t) && _a(i, t, e[t]);\n  if (va)\n    for (var t of va(e))\n      Sb.call(e, t) && _a(i, t, e[t]);\n  return i;\n};\nfunction Db(i, e = \"-\") {\n  const t = {}, s = \"relay\" + e;\n  return Object.keys(i).forEach((r) => {\n    if (r.startsWith(s)) {\n      const n = r.replace(s, \"\"), o = i[r];\n      t[n] = o;\n    }\n  }), t;\n}\nfunction xb(i) {\n  const e = i.indexOf(\":\"), t = i.indexOf(\"?\") !== -1 ? i.indexOf(\"?\") : void 0, s = i.substring(0, e), r = i.substring(e + 1, t).split(\"@\"), n = typeof t < \"u\" ? i.substring(t) : \"\", o = ii.parse(n);\n  return { protocol: s, topic: Ob(r[0]), version: parseInt(r[1], 10), symKey: o.symKey, relay: Db(o) };\n}\nfunction Ob(i) {\n  return i.startsWith(\"//\") ? i.substring(2) : i;\n}\nfunction Nb(i, e = \"-\") {\n  const t = \"relay\", s = {};\n  return Object.keys(i).forEach((r) => {\n    const n = t + e + r;\n    i[r] && (s[n] = i[r]);\n  }), s;\n}\nfunction Pb(i) {\n  return `${i.protocol}:${i.topic}@${i.version}?` + ii.stringify(Ib({ symKey: i.symKey }, Nb(i.relay)));\n}\nfunction zi(i) {\n  const e = [];\n  return i.forEach((t) => {\n    const [s, r] = t.split(\":\");\n    e.push(`${s}:${r}`);\n  }), e;\n}\nfunction Rb(i) {\n  const e = [];\n  return Object.values(i).forEach((t) => {\n    e.push(...zi(t.accounts));\n  }), e;\n}\nfunction Cb(i, e) {\n  const t = [];\n  return Object.values(i).forEach((s) => {\n    zi(s.accounts).includes(e) && t.push(...s.methods);\n  }), t;\n}\nfunction Ab(i, e) {\n  const t = [];\n  return Object.values(i).forEach((s) => {\n    zi(s.accounts).includes(e) && t.push(...s.events);\n  }), t;\n}\nfunction Tb(i, e) {\n  const t = Bs(i, e);\n  if (t)\n    throw new Error(t.message);\n  const s = {};\n  for (const [r, n] of Object.entries(i))\n    s[r] = { methods: n.methods, events: n.events, chains: n.accounts.map((o) => `${o.split(\":\")[0]}:${o.split(\":\")[1]}`) };\n  return s;\n}\nconst $b = { INVALID_METHOD: { message: \"Invalid method.\", code: 1001 }, INVALID_EVENT: { message: \"Invalid event.\", code: 1002 }, INVALID_UPDATE_REQUEST: { message: \"Invalid update request.\", code: 1003 }, INVALID_EXTEND_REQUEST: { message: \"Invalid extend request.\", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: \"Invalid session settle request.\", code: 1005 }, UNAUTHORIZED_METHOD: { message: \"Unauthorized method.\", code: 3001 }, UNAUTHORIZED_EVENT: { message: \"Unauthorized event.\", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: \"Unauthorized update request.\", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: \"Unauthorized extend request.\", code: 3004 }, USER_REJECTED: { message: \"User rejected.\", code: 5e3 }, USER_REJECTED_CHAINS: { message: \"User rejected chains.\", code: 5001 }, USER_REJECTED_METHODS: { message: \"User rejected methods.\", code: 5002 }, USER_REJECTED_EVENTS: { message: \"User rejected events.\", code: 5003 }, UNSUPPORTED_CHAINS: { message: \"Unsupported chains.\", code: 5100 }, UNSUPPORTED_METHODS: { message: \"Unsupported methods.\", code: 5101 }, UNSUPPORTED_EVENTS: { message: \"Unsupported events.\", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: \"Unsupported accounts.\", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: \"Unsupported namespace key.\", code: 5104 }, USER_DISCONNECTED: { message: \"User disconnected.\", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: \"Session settlement failed.\", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: \"Unsupported wc_ method.\", code: 10001 } }, Fb = { NOT_INITIALIZED: { message: \"Not initialized.\", code: 1 }, NO_MATCHING_KEY: { message: \"No matching key.\", code: 2 }, RESTORE_WILL_OVERRIDE: { message: \"Restore will override.\", code: 3 }, RESUBSCRIBED: { message: \"Resubscribed.\", code: 4 }, MISSING_OR_INVALID: { message: \"Missing or invalid.\", code: 5 }, EXPIRED: { message: \"Expired.\", code: 6 }, UNKNOWN_TYPE: { message: \"Unknown type.\", code: 7 }, MISMATCHED_TOPIC: { message: \"Mismatched topic.\", code: 8 }, NON_CONFORMING_NAMESPACES: { message: \"Non conforming namespaces.\", code: 9 } };\nfunction J(i, e) {\n  const { message: t, code: s } = Fb[i];\n  return { message: e ? `${t} ${e}` : t, code: s };\n}\nfunction Je(i, e) {\n  const { message: t, code: s } = $b[i];\n  return { message: e ? `${t} ${e}` : t, code: s };\n}\nfunction Ds(i, e) {\n  return Array.isArray(i) ? typeof e < \"u\" && i.length ? i.every(e) : !0 : !1;\n}\nfunction us(i) {\n  return Object.getPrototypeOf(i) === Object.prototype && Object.keys(i).length;\n}\nfunction wt(i) {\n  return typeof i > \"u\";\n}\nfunction at(i, e) {\n  return e && wt(i) ? !0 : typeof i == \"string\" && !!i.trim().length;\n}\nfunction Pn(i, e) {\n  return e && wt(i) ? !0 : typeof i == \"number\" && !isNaN(i);\n}\nfunction Ub(i, e) {\n  const { requiredNamespaces: t } = e, s = Object.keys(i.namespaces), r = Object.keys(t);\n  let n = !0;\n  return Ei(r, s) ? (s.forEach((o) => {\n    const { accounts: c, methods: u, events: d } = i.namespaces[o], p = zi(c), b = t[o];\n    (!Ei(In(o, b), p) || !Ei(b.methods, u) || !Ei(b.events, d)) && (n = !1);\n  }), n) : !1;\n}\nfunction Rn(i) {\n  return at(i, !1) && i.includes(\":\") ? i.split(\":\").length === 2 : !1;\n}\nfunction Lb(i) {\n  if (at(i, !1) && i.includes(\":\")) {\n    const e = i.split(\":\");\n    if (e.length === 3) {\n      const t = e[0] + \":\" + e[1];\n      return !!e[2] && Rn(t);\n    }\n  }\n  return !1;\n}\nfunction Mb(i) {\n  if (at(i, !1))\n    try {\n      return typeof new URL(i) < \"u\";\n    } catch {\n      return !1;\n    }\n  return !1;\n}\nfunction qb(i) {\n  var e;\n  return (e = i?.proposer) == null ? void 0 : e.publicKey;\n}\nfunction jb(i) {\n  return i?.topic;\n}\nfunction zb(i, e) {\n  let t = null;\n  return at(i?.publicKey, !1) || (t = J(\"MISSING_OR_INVALID\", `${e} controller public key should be a string`)), t;\n}\nfunction Ea(i) {\n  let e = !0;\n  return Ds(i) ? i.length && (e = i.every((t) => at(t, !1))) : e = !1, e;\n}\nfunction Kb(i, e, t) {\n  let s = null;\n  return Ds(e) ? e.forEach((r) => {\n    s || (!Rn(r) || !r.includes(i)) && (s = Je(\"UNSUPPORTED_CHAINS\", `${t}, chain ${r} should be a string and conform to \"namespace:chainId\" format`));\n  }) : s = Je(\"UNSUPPORTED_CHAINS\", `${t}, chains ${e} should be an array of strings conforming to \"namespace:chainId\" format`), s;\n}\nfunction Vb(i, e) {\n  let t = null;\n  return Object.entries(i).forEach(([s, r]) => {\n    if (t)\n      return;\n    const n = Kb(s, In(s, r), `${e} requiredNamespace`);\n    n && (t = n);\n  }), t;\n}\nfunction Bb(i, e) {\n  let t = null;\n  return Ds(i) ? i.forEach((s) => {\n    t || Lb(s) || (t = Je(\"UNSUPPORTED_ACCOUNTS\", `${e}, account ${s} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = Je(\"UNSUPPORTED_ACCOUNTS\", `${e}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction kb(i, e) {\n  let t = null;\n  return Object.values(i).forEach((s) => {\n    if (t)\n      return;\n    const r = Bb(s?.accounts, `${e} namespace`);\n    r && (t = r);\n  }), t;\n}\nfunction Hb(i, e) {\n  let t = null;\n  return Ea(i?.methods) ? Ea(i?.events) || (t = Je(\"UNSUPPORTED_EVENTS\", `${e}, events should be an array of strings or empty array for no events`)) : t = Je(\"UNSUPPORTED_METHODS\", `${e}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction Ih(i, e) {\n  let t = null;\n  return Object.values(i).forEach((s) => {\n    if (t)\n      return;\n    const r = Hb(s, `${e}, namespace`);\n    r && (t = r);\n  }), t;\n}\nfunction Gb(i, e, t) {\n  let s = null;\n  if (i && us(i)) {\n    const r = Ih(i, e);\n    r && (s = r);\n    const n = Vb(i, e);\n    n && (s = n);\n  } else\n    s = J(\"MISSING_OR_INVALID\", `${e}, ${t} should be an object with data`);\n  return s;\n}\nfunction Bs(i, e) {\n  let t = null;\n  if (i && us(i)) {\n    const s = Ih(i, e);\n    s && (t = s);\n    const r = kb(i, e);\n    r && (t = r);\n  } else\n    t = J(\"MISSING_OR_INVALID\", `${e}, namespaces should be an object with data`);\n  return t;\n}\nfunction Dh(i) {\n  return at(i.protocol, !0);\n}\nfunction Wb(i, e) {\n  let t = !1;\n  return e && !i ? t = !0 : i && Ds(i) && i.length && i.forEach((s) => {\n    t = Dh(s);\n  }), t;\n}\nfunction Yb(i) {\n  return typeof i == \"number\";\n}\nfunction It(i) {\n  return typeof i < \"u\" && typeof i !== null;\n}\nfunction Jb(i) {\n  return !(!i || typeof i != \"object\" || !i.code || !Pn(i.code, !1) || !i.message || !at(i.message, !1));\n}\nfunction Qb(i) {\n  return !(wt(i) || !at(i.method, !1));\n}\nfunction Xb(i) {\n  return !(wt(i) || wt(i.result) && wt(i.error) || !Pn(i.id, !1) || !at(i.jsonrpc, !1));\n}\nfunction Zb(i) {\n  return !(wt(i) || !at(i.name, !1));\n}\nfunction Sa(i, e) {\n  return !(!Rn(e) || !Rb(i).includes(e));\n}\nfunction ew(i, e, t) {\n  return at(t, !1) ? Cb(i, e).includes(t) : !1;\n}\nfunction tw(i, e, t) {\n  return at(t, !1) ? Ab(i, e).includes(t) : !1;\n}\nfunction Ia(i, e, t) {\n  let s = null;\n  const r = iw(i), n = sw(e), o = Object.keys(r), c = Object.keys(n), u = Da(Object.keys(i)), d = Da(Object.keys(e)), p = u.filter((b) => !d.includes(b));\n  return p.length && (s = J(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${p.toString()}\n      Received: ${Object.keys(e).toString()}`)), Ei(o, c) || (s = J(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces chains don't satisfy required namespaces.\n      Required: ${o.toString()}\n      Approved: ${c.toString()}`)), Object.keys(e).forEach((b) => {\n    if (!b.includes(\":\") || s)\n      return;\n    const x = zi(e[b].accounts);\n    x.includes(b) || (s = J(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace accounts for ${b}\n        Required: ${b}\n        Approved: ${x.toString()}`));\n  }), o.forEach((b) => {\n    s || (Ei(r[b].methods, n[b].methods) ? Ei(r[b].events, n[b].events) || (s = J(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${b}`)) : s = J(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${b}`));\n  }), s;\n}\nfunction iw(i) {\n  const e = {};\n  return Object.keys(i).forEach((t) => {\n    var s;\n    t.includes(\":\") ? e[t] = i[t] : (s = i[t].chains) == null || s.forEach((r) => {\n      e[r] = { methods: i[t].methods, events: i[t].events };\n    });\n  }), e;\n}\nfunction Da(i) {\n  return [...new Set(i.map((e) => e.includes(\":\") ? e.split(\":\")[0] : e))];\n}\nfunction sw(i) {\n  const e = {};\n  return Object.keys(i).forEach((t) => {\n    t.includes(\":\") ? e[t] = i[t] : zi(i[t].accounts)?.forEach((r) => {\n      e[r] = { accounts: i[t].accounts.filter((n) => n.includes(`${r}:`)), methods: i[t].methods, events: i[t].events };\n    });\n  }), e;\n}\nfunction rw(i, e) {\n  return Pn(i, !1) && i <= e.max && i >= e.min;\n}\nfunction nw(i, e) {\n  if (i.length >= 255)\n    throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), s = 0; s < t.length; s++)\n    t[s] = 255;\n  for (var r = 0; r < i.length; r++) {\n    var n = i.charAt(r), o = n.charCodeAt(0);\n    if (t[o] !== 255)\n      throw new TypeError(n + \" is ambiguous\");\n    t[o] = r;\n  }\n  var c = i.length, u = i.charAt(0), d = Math.log(c) / Math.log(256), p = Math.log(256) / Math.log(c);\n  function b(_) {\n    if (_ instanceof Uint8Array || (ArrayBuffer.isView(_) ? _ = new Uint8Array(_.buffer, _.byteOffset, _.byteLength) : Array.isArray(_) && (_ = Uint8Array.from(_))), !(_ instanceof Uint8Array))\n      throw new TypeError(\"Expected Uint8Array\");\n    if (_.length === 0)\n      return \"\";\n    for (var C = 0, F = 0, K = 0, I = _.length; K !== I && _[K] === 0; )\n      K++, C++;\n    for (var D = (I - K) * p + 1 >>> 0, y = new Uint8Array(D); K !== I; ) {\n      for (var w = _[K], f = 0, a = D - 1; (w !== 0 || f < F) && a !== -1; a--, f++)\n        w += 256 * y[a] >>> 0, y[a] = w % c >>> 0, w = w / c >>> 0;\n      if (w !== 0)\n        throw new Error(\"Non-zero carry\");\n      F = f, K++;\n    }\n    for (var l = D - F; l !== D && y[l] === 0; )\n      l++;\n    for (var L = u.repeat(C); l < D; ++l)\n      L += i.charAt(y[l]);\n    return L;\n  }\n  function x(_) {\n    if (typeof _ != \"string\")\n      throw new TypeError(\"Expected String\");\n    if (_.length === 0)\n      return new Uint8Array();\n    var C = 0;\n    if (_[C] !== \" \") {\n      for (var F = 0, K = 0; _[C] === u; )\n        F++, C++;\n      for (var I = (_.length - C) * d + 1 >>> 0, D = new Uint8Array(I); _[C]; ) {\n        var y = t[_.charCodeAt(C)];\n        if (y === 255)\n          return;\n        for (var w = 0, f = I - 1; (y !== 0 || w < K) && f !== -1; f--, w++)\n          y += c * D[f] >>> 0, D[f] = y % 256 >>> 0, y = y / 256 >>> 0;\n        if (y !== 0)\n          throw new Error(\"Non-zero carry\");\n        K = w, C++;\n      }\n      if (_[C] !== \" \") {\n        for (var a = I - K; a !== I && D[a] === 0; )\n          a++;\n        for (var l = new Uint8Array(F + (I - a)), L = F; a !== I; )\n          l[L++] = D[a++];\n        return l;\n      }\n    }\n  }\n  function O(_) {\n    var C = x(_);\n    if (C)\n      return C;\n    throw new Error(`Non-${e} character`);\n  }\n  return { encode: b, decodeUnsafe: x, decode: O };\n}\nvar ow = nw, aw = ow;\nconst xh = (i) => {\n  if (i instanceof Uint8Array && i.constructor.name === \"Uint8Array\")\n    return i;\n  if (i instanceof ArrayBuffer)\n    return new Uint8Array(i);\n  if (ArrayBuffer.isView(i))\n    return new Uint8Array(i.buffer, i.byteOffset, i.byteLength);\n  throw new Error(\"Unknown type, must be binary type\");\n}, cw = (i) => new TextEncoder().encode(i), hw = (i) => new TextDecoder().decode(i);\nclass uw {\n  constructor(e, t, s) {\n    this.name = e, this.prefix = t, this.baseEncode = s;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array)\n      return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass lw {\n  constructor(e, t, s) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)\n      throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint)\n        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else\n      throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return Oh(this, e);\n  }\n}\nclass dw {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return Oh(this, e);\n  }\n  decode(e) {\n    const t = e[0], s = this.decoders[t];\n    if (s)\n      return s.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst Oh = (i, e) => new dw({ ...i.decoders || { [i.prefix]: i }, ...e.decoders || { [e.prefix]: e } });\nclass fw {\n  constructor(e, t, s, r) {\n    this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = r, this.encoder = new uw(e, t, s), this.decoder = new lw(e, t, r);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst fr = ({ name: i, prefix: e, encode: t, decode: s }) => new fw(i, e, t, s), xs = ({ prefix: i, name: e, alphabet: t }) => {\n  const { encode: s, decode: r } = aw(t, e);\n  return fr({ prefix: i, name: e, encode: s, decode: (n) => xh(r(n)) });\n}, pw = (i, e, t, s) => {\n  const r = {};\n  for (let p = 0; p < e.length; ++p)\n    r[e[p]] = p;\n  let n = i.length;\n  for (; i[n - 1] === \"=\"; )\n    --n;\n  const o = new Uint8Array(n * t / 8 | 0);\n  let c = 0, u = 0, d = 0;\n  for (let p = 0; p < n; ++p) {\n    const b = r[i[p]];\n    if (b === void 0)\n      throw new SyntaxError(`Non-${s} character`);\n    u = u << t | b, c += t, c >= 8 && (c -= 8, o[d++] = 255 & u >> c);\n  }\n  if (c >= t || 255 & u << 8 - c)\n    throw new SyntaxError(\"Unexpected end of data\");\n  return o;\n}, gw = (i, e, t) => {\n  const s = e[e.length - 1] === \"=\", r = (1 << t) - 1;\n  let n = \"\", o = 0, c = 0;\n  for (let u = 0; u < i.length; ++u)\n    for (c = c << 8 | i[u], o += 8; o > t; )\n      o -= t, n += e[r & c >> o];\n  if (o && (n += e[r & c << t - o]), s)\n    for (; n.length * t & 7; )\n      n += \"=\";\n  return n;\n}, dt = ({ name: i, prefix: e, bitsPerChar: t, alphabet: s }) => fr({ prefix: e, name: i, encode(r) {\n  return gw(r, s, t);\n}, decode(r) {\n  return pw(r, s, t, i);\n} }), yw = fr({ prefix: \"\\0\", name: \"identity\", encode: (i) => hw(i), decode: (i) => cw(i) });\nvar mw = Object.freeze({ __proto__: null, identity: yw });\nconst bw = dt({ prefix: \"0\", name: \"base2\", alphabet: \"01\", bitsPerChar: 1 });\nvar ww = Object.freeze({ __proto__: null, base2: bw });\nconst vw = dt({ prefix: \"7\", name: \"base8\", alphabet: \"01234567\", bitsPerChar: 3 });\nvar _w = Object.freeze({ __proto__: null, base8: vw });\nconst Ew = xs({ prefix: \"9\", name: \"base10\", alphabet: \"0123456789\" });\nvar Sw = Object.freeze({ __proto__: null, base10: Ew });\nconst Iw = dt({ prefix: \"f\", name: \"base16\", alphabet: \"0123456789abcdef\", bitsPerChar: 4 }), Dw = dt({ prefix: \"F\", name: \"base16upper\", alphabet: \"0123456789ABCDEF\", bitsPerChar: 4 });\nvar xw = Object.freeze({ __proto__: null, base16: Iw, base16upper: Dw });\nconst Ow = dt({ prefix: \"b\", name: \"base32\", alphabet: \"abcdefghijklmnopqrstuvwxyz234567\", bitsPerChar: 5 }), Nw = dt({ prefix: \"B\", name: \"base32upper\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\", bitsPerChar: 5 }), Pw = dt({ prefix: \"c\", name: \"base32pad\", alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\", bitsPerChar: 5 }), Rw = dt({ prefix: \"C\", name: \"base32padupper\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\", bitsPerChar: 5 }), Cw = dt({ prefix: \"v\", name: \"base32hex\", alphabet: \"0123456789abcdefghijklmnopqrstuv\", bitsPerChar: 5 }), Aw = dt({ prefix: \"V\", name: \"base32hexupper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\", bitsPerChar: 5 }), Tw = dt({ prefix: \"t\", name: \"base32hexpad\", alphabet: \"0123456789abcdefghijklmnopqrstuv=\", bitsPerChar: 5 }), $w = dt({ prefix: \"T\", name: \"base32hexpadupper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\", bitsPerChar: 5 }), Fw = dt({ prefix: \"h\", name: \"base32z\", alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\", bitsPerChar: 5 });\nvar Uw = Object.freeze({ __proto__: null, base32: Ow, base32upper: Nw, base32pad: Pw, base32padupper: Rw, base32hex: Cw, base32hexupper: Aw, base32hexpad: Tw, base32hexpadupper: $w, base32z: Fw });\nconst Lw = xs({ prefix: \"k\", name: \"base36\", alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\" }), Mw = xs({ prefix: \"K\", name: \"base36upper\", alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" });\nvar qw = Object.freeze({ __proto__: null, base36: Lw, base36upper: Mw });\nconst jw = xs({ name: \"base58btc\", prefix: \"z\", alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" }), zw = xs({ name: \"base58flickr\", prefix: \"Z\", alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\" });\nvar Kw = Object.freeze({ __proto__: null, base58btc: jw, base58flickr: zw });\nconst Vw = dt({ prefix: \"m\", name: \"base64\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", bitsPerChar: 6 }), Bw = dt({ prefix: \"M\", name: \"base64pad\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", bitsPerChar: 6 }), kw = dt({ prefix: \"u\", name: \"base64url\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\", bitsPerChar: 6 }), Hw = dt({ prefix: \"U\", name: \"base64urlpad\", alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\", bitsPerChar: 6 });\nvar Gw = Object.freeze({ __proto__: null, base64: Vw, base64pad: Bw, base64url: kw, base64urlpad: Hw });\nconst Nh = Array.from(\"🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂\"), Ww = Nh.reduce((i, e, t) => (i[t] = e, i), []), Yw = Nh.reduce((i, e, t) => (i[e.codePointAt(0)] = t, i), []);\nfunction Jw(i) {\n  return i.reduce((e, t) => (e += Ww[t], e), \"\");\n}\nfunction Qw(i) {\n  const e = [];\n  for (const t of i) {\n    const s = Yw[t.codePointAt(0)];\n    if (s === void 0)\n      throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(s);\n  }\n  return new Uint8Array(e);\n}\nconst Xw = fr({ prefix: \"🚀\", name: \"base256emoji\", encode: Jw, decode: Qw });\nvar Zw = Object.freeze({ __proto__: null, base256emoji: Xw }), e0 = Ph, xa = 128, t0 = 127, i0 = ~t0, s0 = Math.pow(2, 31);\nfunction Ph(i, e, t) {\n  e = e || [], t = t || 0;\n  for (var s = t; i >= s0; )\n    e[t++] = i & 255 | xa, i /= 128;\n  for (; i & i0; )\n    e[t++] = i & 255 | xa, i >>>= 7;\n  return e[t] = i | 0, Ph.bytes = t - s + 1, e;\n}\nvar r0 = en, n0 = 128, Oa = 127;\nfunction en(i, s) {\n  var t = 0, s = s || 0, r = 0, n = s, o, c = i.length;\n  do {\n    if (n >= c)\n      throw en.bytes = 0, new RangeError(\"Could not decode varint\");\n    o = i[n++], t += r < 28 ? (o & Oa) << r : (o & Oa) * Math.pow(2, r), r += 7;\n  } while (o >= n0);\n  return en.bytes = n - s, t;\n}\nvar o0 = Math.pow(2, 7), a0 = Math.pow(2, 14), c0 = Math.pow(2, 21), h0 = Math.pow(2, 28), u0 = Math.pow(2, 35), l0 = Math.pow(2, 42), d0 = Math.pow(2, 49), f0 = Math.pow(2, 56), p0 = Math.pow(2, 63), g0 = function(i) {\n  return i < o0 ? 1 : i < a0 ? 2 : i < c0 ? 3 : i < h0 ? 4 : i < u0 ? 5 : i < l0 ? 6 : i < d0 ? 7 : i < f0 ? 8 : i < p0 ? 9 : 10;\n}, y0 = { encode: e0, decode: r0, encodingLength: g0 }, Rh = y0;\nconst Na = (i, e, t = 0) => (Rh.encode(i, e, t), e), Pa = (i) => Rh.encodingLength(i), tn = (i, e) => {\n  const t = e.byteLength, s = Pa(i), r = s + Pa(t), n = new Uint8Array(r + t);\n  return Na(i, n, 0), Na(t, n, s), n.set(e, r), new m0(i, t, e, n);\n};\nclass m0 {\n  constructor(e, t, s, r) {\n    this.code = e, this.size = t, this.digest = s, this.bytes = r;\n  }\n}\nconst Ch = ({ name: i, code: e, encode: t }) => new b0(i, e, t);\nclass b0 {\n  constructor(e, t, s) {\n    this.name = e, this.code = t, this.encode = s;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? tn(this.code, t) : t.then((s) => tn(this.code, s));\n    } else\n      throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst Ah = (i) => async (e) => new Uint8Array(await crypto.subtle.digest(i, e)), w0 = Ch({ name: \"sha2-256\", code: 18, encode: Ah(\"SHA-256\") }), v0 = Ch({ name: \"sha2-512\", code: 19, encode: Ah(\"SHA-512\") });\nvar _0 = Object.freeze({ __proto__: null, sha256: w0, sha512: v0 });\nconst Th = 0, E0 = \"identity\", $h = xh, S0 = (i) => tn(Th, $h(i)), I0 = { code: Th, name: E0, encode: $h, digest: S0 };\nvar D0 = Object.freeze({ __proto__: null, identity: I0 });\nnew TextEncoder(), new TextDecoder();\nconst Ra = { ...mw, ...ww, ..._w, ...Sw, ...xw, ...Uw, ...qw, ...Kw, ...Gw, ...Zw };\n({ ..._0, ...D0 });\nfunction Fh(i) {\n  return globalThis.Buffer != null ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : i;\n}\nfunction x0(i = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Fh(globalThis.Buffer.allocUnsafe(i)) : new Uint8Array(i);\n}\nfunction Uh(i, e, t, s) {\n  return { name: i, prefix: e, encoder: { name: i, prefix: e, encode: t }, decoder: { decode: s } };\n}\nconst Ca = Uh(\"utf8\", \"u\", (i) => \"u\" + new TextDecoder(\"utf8\").decode(i), (i) => new TextEncoder().encode(i.substring(1))), Ar = Uh(\"ascii\", \"a\", (i) => {\n  let e = \"a\";\n  for (let t = 0; t < i.length; t++)\n    e += String.fromCharCode(i[t]);\n  return e;\n}, (i) => {\n  i = i.substring(1);\n  const e = x0(i.length);\n  for (let t = 0; t < i.length; t++)\n    e[t] = i.charCodeAt(t);\n  return e;\n}), O0 = { utf8: Ca, \"utf-8\": Ca, hex: Ra.base16, latin1: Ar, ascii: Ar, binary: Ar, ...Ra };\nfunction N0(i, e = \"utf8\") {\n  const t = O0[e];\n  if (!t)\n    throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Fh(globalThis.Buffer.from(i, \"utf-8\")) : t.decoder.decode(`${t.prefix}${i}`);\n}\nconst Lh = \"wc\", P0 = 2, Cn = \"core\", ui = `${Lh}@2:${Cn}:`, R0 = { name: Cn, logger: \"error\" }, C0 = { database: \":memory:\" }, A0 = \"crypto\", Aa = \"client_ed25519_seed\", T0 = V.ONE_DAY, $0 = \"keychain\", F0 = \"0.3\", U0 = \"messages\", L0 = \"0.3\", M0 = V.SIX_HOURS, q0 = \"publisher\", Mh = \"irn\", j0 = \"error\", qh = \"wss://relay.walletconnect.com\", z0 = \"relayer\", He = { message: \"relayer_message\", message_ack: \"relayer_message_ack\", connect: \"relayer_connect\", disconnect: \"relayer_disconnect\", error: \"relayer_error\", connection_stalled: \"relayer_connection_stalled\", transport_closed: \"relayer_transport_closed\", publish: \"relayer_publish\" }, K0 = \"_subscription\", is = { payload: \"payload\", connect: \"connect\", disconnect: \"disconnect\", error: \"error\" }, V0 = V.ONE_SECOND / 2, B0 = \"y\", k0 = 1e4, H0 = \"0.3\", Bt = { created: \"subscription_created\", deleted: \"subscription_deleted\", expired: \"subscription_expired\", disabled: \"subscription_disabled\", sync: \"subscription_sync\", resubscribed: \"subscription_resubscribed\" }, G0 = \"subscription\", W0 = \"0.3\", Y0 = V.FIVE_SECONDS * 1e3, J0 = \"pairing\", Q0 = \"0.3\", ss = { wc_pairingDelete: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 0 } } }, Kt = { created: \"history_created\", updated: \"history_updated\", deleted: \"history_deleted\", sync: \"history_sync\" }, X0 = \"history\", Z0 = \"0.3\", ev = \"expirer\", $t = { created: \"expirer_created\", deleted: \"expirer_deleted\", expired: \"expirer_expired\", sync: \"expirer_sync\" }, tv = \"0.3\", Tr = \"verify-api\", Ta = \"https://verify.walletconnect.com\";\nclass iv {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = $0, this.version = F0, this.initialized = !1, this.storagePrefix = ui, this.init = async () => {\n      if (!this.initialized) {\n        const s = await this.getKeyChain();\n        typeof s < \"u\" && (this.keychain = s), this.initialized = !0;\n      }\n    }, this.has = (s) => (this.isInitialized(), this.keychain.has(s)), this.set = async (s, r) => {\n      this.isInitialized(), this.keychain.set(s, r), await this.persist();\n    }, this.get = (s) => {\n      this.isInitialized();\n      const r = this.keychain.get(s);\n      if (typeof r > \"u\") {\n        const { message: n } = J(\"NO_MATCHING_KEY\", `${this.name}: ${s}`);\n        throw new Error(n);\n      }\n      return r;\n    }, this.del = async (s) => {\n      this.isInitialized(), this.keychain.delete(s), await this.persist();\n    }, this.core = e, this.logger = ee.generateChildLogger(t, this.name);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setKeyChain(e) {\n    await this.core.storage.setItem(this.storageKey, vh(e));\n  }\n  async getKeyChain() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? _h(e) : void 0;\n  }\n  async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass sv {\n  constructor(e, t, s) {\n    this.core = e, this.logger = t, this.name = A0, this.initialized = !1, this.init = async () => {\n      this.initialized || (await this.keychain.init(), this.initialized = !0);\n    }, this.hasKeys = (r) => (this.isInitialized(), this.keychain.has(r)), this.getClientId = async () => {\n      this.isInitialized();\n      const r = await this.getClientSeed(), n = Ws(r);\n      return an(n.publicKey);\n    }, this.generateKeyPair = () => {\n      this.isInitialized();\n      const r = Xm();\n      return this.setPrivateKey(r.publicKey, r.privateKey);\n    }, this.signJWT = async (r) => {\n      this.isInitialized();\n      const n = await this.getClientSeed(), o = Ws(n), c = Xr();\n      return await Ic(c, r, T0, o);\n    }, this.generateSharedKey = (r, n, o) => {\n      this.isInitialized();\n      const c = this.getPrivateKey(r), u = Zm(c, n);\n      return this.setSymKey(u, o);\n    }, this.setSymKey = async (r, n) => {\n      this.isInitialized();\n      const o = n || eb(r);\n      return await this.keychain.set(o, r), o;\n    }, this.deleteKeyPair = async (r) => {\n      this.isInitialized(), await this.keychain.del(r);\n    }, this.deleteSymKey = async (r) => {\n      this.isInitialized(), await this.keychain.del(r);\n    }, this.encode = async (r, n, o) => {\n      this.isInitialized();\n      const c = bh(o), u = rr(n);\n      if (ya(c)) {\n        const x = c.senderPublicKey, O = c.receiverPublicKey;\n        r = await this.generateSharedKey(x, O);\n      }\n      const d = this.getSymKey(r), { type: p, senderPublicKey: b } = c;\n      return ib({ type: p, symKey: d, message: u, senderPublicKey: b });\n    }, this.decode = async (r, n, o) => {\n      this.isInitialized();\n      const c = nb(n, o);\n      if (ya(c)) {\n        const p = c.receiverPublicKey, b = c.senderPublicKey;\n        r = await this.generateSharedKey(p, b);\n      }\n      const u = this.getSymKey(r), d = sb({ symKey: u, encoded: n });\n      return rn(d);\n    }, this.getPayloadType = (r) => {\n      const n = Zs(r);\n      return Is(n.type);\n    }, this.getPayloadSenderPublicKey = (r) => {\n      const n = Zs(r);\n      return n.senderPublicKey ? Ne(n.senderPublicKey, _t) : void 0;\n    }, this.core = e, this.logger = ee.generateChildLogger(t, this.name), this.keychain = s || new iv(this.core, this.logger);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  async setPrivateKey(e, t) {\n    return await this.keychain.set(e, t), e;\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  async getClientSeed() {\n    let e = \"\";\n    try {\n      e = this.keychain.get(Aa);\n    } catch {\n      e = Xr(), await this.keychain.set(Aa, e);\n    }\n    return N0(e, \"base16\");\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass rv extends $m {\n  constructor(e, t) {\n    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = U0, this.version = L0, this.initialized = !1, this.storagePrefix = ui, this.init = async () => {\n      if (!this.initialized) {\n        this.logger.trace(\"Initialized\");\n        try {\n          const s = await this.getRelayerMessages();\n          typeof s < \"u\" && (this.messages = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", size: this.messages.size });\n        } catch (s) {\n          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s);\n        } finally {\n          this.initialized = !0;\n        }\n      }\n    }, this.set = async (s, r) => {\n      this.isInitialized();\n      const n = Ui(r);\n      let o = this.messages.get(s);\n      return typeof o > \"u\" && (o = {}), typeof o[n] < \"u\" || (o[n] = r, this.messages.set(s, o), await this.persist()), n;\n    }, this.get = (s) => {\n      this.isInitialized();\n      let r = this.messages.get(s);\n      return typeof r > \"u\" && (r = {}), r;\n    }, this.has = (s, r) => {\n      this.isInitialized();\n      const n = this.get(s), o = Ui(r);\n      return typeof n[o] < \"u\";\n    }, this.del = async (s) => {\n      this.isInitialized(), this.messages.delete(s), await this.persist();\n    }, this.logger = ee.generateChildLogger(e, this.name), this.core = t;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setRelayerMessages(e) {\n    await this.core.storage.setItem(this.storageKey, vh(e));\n  }\n  async getRelayerMessages() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? _h(e) : void 0;\n  }\n  async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass nv extends Fm {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.events = new We.EventEmitter(), this.name = q0, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = 1e4, this.publish = async (s, r, n) => {\n      this.logger.debug(\"Publishing Payload\"), this.logger.trace({ type: \"method\", method: \"publish\", params: { topic: s, message: r, opts: n } });\n      try {\n        const o = n?.ttl || M0, c = Zr(n), u = n?.prompt || !1, d = n?.tag || 0, p = n?.id || vn().toString(), b = { topic: s, message: r, opts: { ttl: o, relay: c, prompt: u, tag: d, id: p } };\n        this.queue.set(p, b);\n        try {\n          await await er(this.rpcPublish(s, r, o, c, u, d, p), this.publishTimeout), this.relayer.events.emit(He.publish, b);\n        } catch {\n          this.logger.debug(\"Publishing Payload stalled\"), this.relayer.events.emit(He.connection_stalled);\n          return;\n        }\n        this.logger.debug(\"Successfully Published Payload\"), this.logger.trace({ type: \"method\", method: \"publish\", params: { topic: s, message: r, opts: n } });\n      } catch (o) {\n        throw this.logger.debug(\"Failed to Publish Payload\"), this.logger.error(o), o;\n      }\n    }, this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.relayer = e, this.logger = ee.generateChildLogger(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  rpcPublish(e, t, s, r, n, o, c) {\n    var u, d, p, b;\n    const x = { method: Vs(r.protocol).publish, params: { topic: e, message: t, ttl: s, prompt: n, tag: o }, id: c };\n    return wt((u = x.params) == null ? void 0 : u.prompt) && ((d = x.params) == null || delete d.prompt), wt((p = x.params) == null ? void 0 : p.tag) && ((b = x.params) == null || delete b.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"message\", direction: \"outgoing\", request: x }), this.relayer.request(x);\n  }\n  onPublish(e) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    this.queue.forEach(async (e) => {\n      const { topic: t, message: s, opts: r } = e;\n      await this.publish(t, s, r);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, () => {\n      this.checkQueue();\n    }), this.relayer.on(He.message_ack, (e) => {\n      this.onPublish(e.id.toString());\n    });\n  }\n}\nclass ov {\n  constructor() {\n    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {\n      const s = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...s, t]);\n    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e))\n        return;\n      const s = this.get(e);\n      if (!this.exists(e, t))\n        return;\n      const r = s.filter((n) => n !== t);\n      if (!r.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, r);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n}\nvar av = Object.defineProperty, cv = Object.defineProperties, hv = Object.getOwnPropertyDescriptors, $a = Object.getOwnPropertySymbols, uv = Object.prototype.hasOwnProperty, lv = Object.prototype.propertyIsEnumerable, Fa = (i, e, t) => e in i ? av(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, rs = (i, e) => {\n  for (var t in e || (e = {}))\n    uv.call(e, t) && Fa(i, t, e[t]);\n  if ($a)\n    for (var t of $a(e))\n      lv.call(e, t) && Fa(i, t, e[t]);\n  return i;\n}, $r = (i, e) => cv(i, hv(e));\nclass dv extends Mm {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new ov(), this.events = new We.EventEmitter(), this.name = G0, this.version = W0, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pollingInterval = 20, this.storagePrefix = ui, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restart(), this.registerEventListeners(), this.onEnable(), this.clientId = await this.relayer.core.crypto.getClientId());\n    }, this.subscribe = async (s, r) => {\n      await this.restartToComplete(), this.isInitialized(), this.logger.debug(\"Subscribing Topic\"), this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic: s, opts: r } });\n      try {\n        const n = Zr(r), o = { topic: s, relay: n };\n        this.pending.set(s, o);\n        const c = await this.rpcSubscribe(s, n);\n        return this.onSubscribe(c, o), this.logger.debug(\"Successfully Subscribed Topic\"), this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic: s, opts: r } }), c;\n      } catch (n) {\n        throw this.logger.debug(\"Failed to Subscribe Topic\"), this.logger.error(n), n;\n      }\n    }, this.unsubscribe = async (s, r) => {\n      await this.restartToComplete(), this.isInitialized(), typeof r?.id < \"u\" ? await this.unsubscribeById(s, r.id, r) : await this.unsubscribeByTopic(s, r);\n    }, this.isSubscribed = async (s) => this.topics.includes(s) ? !0 : await new Promise((r, n) => {\n      const o = new V.Watch();\n      o.start(this.pendingSubscriptionWatchLabel);\n      const c = setInterval(() => {\n        !this.pending.has(s) && this.topics.includes(s) && (clearInterval(c), o.stop(this.pendingSubscriptionWatchLabel), r(!0)), o.elapsed(this.pendingSubscriptionWatchLabel) >= Y0 && (clearInterval(c), o.stop(this.pendingSubscriptionWatchLabel), n(new Error(\"Subscription resolution timeout\")));\n      }, this.pollingInterval);\n    }).catch(() => !1), this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.restart = async () => {\n      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;\n    }, this.relayer = e, this.logger = ee.generateChildLogger(t, this.name), this.clientId = \"\";\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  hasSubscription(e, t) {\n    let s = !1;\n    try {\n      s = this.getSubscription(e).topic === t;\n    } catch {\n    }\n    return s;\n  }\n  onEnable() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();\n  }\n  async unsubscribeByTopic(e, t) {\n    const s = this.topicMap.get(e);\n    await Promise.all(s.map(async (r) => await this.unsubscribeById(e, r, t)));\n  }\n  async unsubscribeById(e, t, s) {\n    this.logger.debug(\"Unsubscribing Topic\"), this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic: e, id: t, opts: s } });\n    try {\n      const r = Zr(s);\n      await this.rpcUnsubscribe(e, t, r);\n      const n = Je(\"USER_DISCONNECTED\", `${this.name}, ${e}`);\n      await this.onUnsubscribe(e, t, n), this.logger.debug(\"Successfully Unsubscribed Topic\"), this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic: e, id: t, opts: s } });\n    } catch (r) {\n      throw this.logger.debug(\"Failed to Unsubscribe Topic\"), this.logger.error(r), r;\n    }\n  }\n  async rpcSubscribe(e, t) {\n    const s = { method: Vs(t.protocol).subscribe, params: { topic: e } };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: s });\n    try {\n      await await er(this.relayer.request(s), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Subscribe Payload stalled\"), this.relayer.events.emit(He.connection_stalled);\n    }\n    return Ui(e + this.clientId);\n  }\n  async rpcBatchSubscribe(e) {\n    if (!e.length)\n      return;\n    const t = e[0].relay, s = { method: Vs(t.protocol).batchSubscribe, params: { topics: e.map((r) => r.topic) } };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: s });\n    try {\n      return await await er(this.relayer.request(s), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Payload stalled\"), this.relayer.events.emit(He.connection_stalled);\n    }\n  }\n  rpcUnsubscribe(e, t, s) {\n    const r = { method: Vs(s.protocol).unsubscribe, params: { topic: e, id: t } };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"outgoing\", request: r }), this.relayer.request(r);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, $r(rs({}, t), { id: e })), this.pending.delete(t.topic);\n  }\n  onBatchSubscribe(e) {\n    e.length && e.forEach((t) => {\n      this.setSubscription(t.id, rs({}, t)), this.pending.delete(t.topic);\n    });\n  }\n  async onUnsubscribe(e, t, s) {\n    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s), await this.relayer.messages.del(e);\n  }\n  async setRelayerSubscriptions(e) {\n    await this.relayer.core.storage.setItem(this.storageKey, e);\n  }\n  async getRelayerSubscriptions() {\n    return await this.relayer.core.storage.getItem(this.storageKey);\n  }\n  setSubscription(e, t) {\n    this.subscriptions.has(e) || (this.logger.debug(\"Setting subscription\"), this.logger.trace({ type: \"method\", method: \"setSubscription\", id: e, subscription: t }), this.addSubscription(e, t));\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, rs({}, t)), this.topicMap.set(t.topic, e), this.events.emit(Bt.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({ type: \"method\", method: \"getSubscription\", id: e });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const { message: s } = J(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(s);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({ type: \"method\", method: \"deleteSubscription\", id: e, reason: t });\n    const s = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(s.topic, e), this.events.emit(Bt.deleted, $r(rs({}, s), { reason: t }));\n  }\n  async persist() {\n    await this.setRelayerSubscriptions(this.values), this.events.emit(Bt.sync);\n  }\n  async reset() {\n    if (this.cached.length) {\n      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let t = 0; t < e; t++) {\n        const s = this.cached.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(s);\n      }\n    }\n    this.events.emit(Bt.resubscribed);\n  }\n  async restore() {\n    try {\n      const e = await this.getRelayerSubscriptions();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.subscriptions.size) {\n        const { message: t } = J(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);\n    }\n  }\n  async batchSubscribe(e) {\n    if (!e.length)\n      return;\n    const t = await this.rpcBatchSubscribe(e);\n    Ds(t) && this.onBatchSubscribe(t.map((s, r) => $r(rs({}, e[r]), { id: s })));\n  }\n  async onConnect() {\n    this.restartInProgress || (await this.restart(), this.onEnable());\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  async checkPending() {\n    if (this.relayer.transportExplicitlyClosed)\n      return;\n    const e = [];\n    this.pending.forEach((t) => {\n      e.push(t);\n    }), await this.batchSubscribe(e);\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, async () => {\n      await this.checkPending();\n    }), this.relayer.on(He.connect, async () => {\n      await this.onConnect();\n    }), this.relayer.on(He.disconnect, () => {\n      this.onDisconnect();\n    }), this.events.on(Bt.created, async (e) => {\n      const t = Bt.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), await this.persist();\n    }), this.events.on(Bt.deleted, async (e) => {\n      const t = Bt.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), await this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async restartToComplete() {\n    this.restartInProgress && await new Promise((e) => {\n      const t = setInterval(() => {\n        this.restartInProgress || (clearInterval(t), e());\n      }, this.pollingInterval);\n    });\n  }\n}\nvar fv = Object.defineProperty, Ua = Object.getOwnPropertySymbols, pv = Object.prototype.hasOwnProperty, gv = Object.prototype.propertyIsEnumerable, La = (i, e, t) => e in i ? fv(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, yv = (i, e) => {\n  for (var t in e || (e = {}))\n    pv.call(e, t) && La(i, t, e[t]);\n  if (Ua)\n    for (var t of Ua(e))\n      gv.call(e, t) && La(i, t, e[t]);\n  return i;\n};\nclass mv extends Um {\n  constructor(e) {\n    super(e), this.protocol = \"wc\", this.version = 2, this.events = new We.EventEmitter(), this.name = z0, this.transportExplicitlyClosed = !1, this.initialized = !1, this.reconnecting = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = [\"socket hang up\", \"socket stalled\"], this.request = async (t) => {\n      this.logger.debug(\"Publishing Request Payload\");\n      try {\n        return await this.toEstablishConnection(), await this.provider.request(t);\n      } catch (s) {\n        throw this.logger.debug(\"Failed to Publish Request\"), this.logger.error(s), s;\n      }\n    }, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? ee.generateChildLogger(e.logger, this.name) : ee.pino(ee.getDefaultLoggerOptions({ level: e.logger || j0 })), this.messages = new rv(this.logger, e.core), this.subscriber = new dv(this, this.logger), this.publisher = new nv(this, this.logger), this.relayUrl = e?.relayUrl || qh, this.projectId = e.projectId, this.provider = {};\n  }\n  async init() {\n    this.logger.trace(\"Initialized\"), await this.createProvider(), await Promise.all([this.messages.init(), this.transportOpen(), this.subscriber.init()]), this.registerEventListeners(), this.initialized = !0, setTimeout(async () => {\n      this.subscriber.topics.length === 0 && (this.logger.info(\"No topics subscribted to after init, closing transport\"), await this.transportClose(), this.transportExplicitlyClosed = !1);\n    }, k0);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get connected() {\n    return this.provider.connection.connected;\n  }\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n  async publish(e, t, s) {\n    this.isInitialized(), await this.publisher.publish(e, t, s), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now() });\n  }\n  async subscribe(e, t) {\n    this.isInitialized();\n    let s = \"\";\n    return await Promise.all([new Promise((r) => {\n      this.subscriber.once(Bt.created, (n) => {\n        n.topic === e && r();\n      });\n    }), new Promise(async (r) => {\n      s = await this.subscriber.subscribe(e, t), r();\n    })]), s;\n  }\n  async unsubscribe(e, t) {\n    this.isInitialized(), await this.subscriber.unsubscribe(e, t);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async transportClose() {\n    this.transportExplicitlyClosed = !0, this.connected && (await this.provider.disconnect(), this.events.emit(He.transport_closed));\n  }\n  async transportOpen(e) {\n    if (this.transportExplicitlyClosed = !1, !this.reconnecting) {\n      this.relayUrl = e || this.relayUrl, this.reconnecting = !0;\n      try {\n        await Promise.all([new Promise((t) => {\n          this.initialized || t(), this.subscriber.once(Bt.resubscribed, () => {\n            t();\n          });\n        }), await Promise.race([new Promise(async (t, s) => {\n          await er(this.provider.connect(), 5e3, \"socket stalled\").catch((r) => s(r)).then(() => t()).finally(() => this.removeListener(He.transport_closed, this.rejectTransportOpen));\n        }), new Promise((t) => this.once(He.transport_closed, this.rejectTransportOpen))])]);\n      } catch (t) {\n        this.logger.error(t);\n        const s = t;\n        if (!this.isConnectionStalled(s.message))\n          throw t;\n        this.events.emit(He.transport_closed);\n      } finally {\n        this.reconnecting = !1;\n      }\n    }\n  }\n  async restartTransport(e) {\n    this.transportExplicitlyClosed || (this.relayUrl = e || this.relayUrl, this.connected && await Promise.all([new Promise((t) => {\n      this.provider.once(is.disconnect, () => {\n        t();\n      });\n    }), this.transportClose()]), await this.createProvider(), await this.transportOpen());\n  }\n  isConnectionStalled(e) {\n    return this.staleConnectionErrors.some((t) => e.includes(t));\n  }\n  rejectTransportOpen() {\n    throw new Error(\"closeTransport called before connection was established\");\n  }\n  async createProvider() {\n    const e = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = new _n(new Wc(mb({ sdkVersion: B0, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0 }))), this.registerProviderListeners();\n  }\n  async recordMessageEvent(e) {\n    const { topic: t, message: s } = e;\n    await this.messages.set(t, s);\n  }\n  async shouldIgnoreMessageEvent(e) {\n    const { topic: t, message: s } = e;\n    return await this.subscriber.isSubscribed(t) ? this.messages.has(t, s) : !0;\n  }\n  async onProviderPayload(e) {\n    if (this.logger.debug(\"Incoming Relay Payload\"), this.logger.trace({ type: \"payload\", direction: \"incoming\", payload: e }), ji(e)) {\n      if (!e.method.endsWith(K0))\n        return;\n      const t = e.params, { topic: s, message: r, publishedAt: n } = t.data, o = { topic: s, message: r, publishedAt: n };\n      this.logger.debug(\"Emitting Relayer Payload\"), this.logger.trace(yv({ type: \"event\", event: t.id }, o)), this.events.emit(t.id, o), await this.acknowledgePayload(e), await this.onMessageEvent(o);\n    } else\n      Oi(e) && this.events.emit(He.message_ack, e);\n  }\n  async onMessageEvent(e) {\n    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(He.message, e), await this.recordMessageEvent(e));\n  }\n  async acknowledgePayload(e) {\n    const t = xi(e.id, !0);\n    await this.provider.connection.send(t);\n  }\n  registerProviderListeners() {\n    this.provider.on(is.payload, (e) => this.onProviderPayload(e)), this.provider.on(is.connect, () => {\n      this.events.emit(He.connect);\n    }), this.provider.on(is.disconnect, () => {\n      this.onProviderDisconnect();\n    }), this.provider.on(is.error, (e) => {\n      this.logger.error(e), this.events.emit(He.error, e);\n    });\n  }\n  registerEventListeners() {\n    this.events.on(He.connection_stalled, async () => {\n      await this.restartTransport();\n    });\n  }\n  onProviderDisconnect() {\n    this.events.emit(He.disconnect), this.attemptToReconnect();\n  }\n  attemptToReconnect() {\n    this.transportExplicitlyClosed || setTimeout(async () => {\n      await this.restartTransport();\n    }, V.toMiliseconds(V0));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async toEstablishConnection() {\n    if (!this.connected) {\n      if (this.connecting)\n        return await new Promise((e) => {\n          const t = setInterval(() => {\n            this.connected && (clearInterval(t), e());\n          }, this.connectionStatusPollingInterval);\n        });\n      await this.restartTransport();\n    }\n  }\n}\nvar bv = Object.defineProperty, Ma = Object.getOwnPropertySymbols, wv = Object.prototype.hasOwnProperty, vv = Object.prototype.propertyIsEnumerable, qa = (i, e, t) => e in i ? bv(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, ja = (i, e) => {\n  for (var t in e || (e = {}))\n    wv.call(e, t) && qa(i, t, e[t]);\n  if (Ma)\n    for (var t of Ma(e))\n      vv.call(e, t) && qa(i, t, e[t]);\n  return i;\n};\nclass pr extends Lm {\n  constructor(e, t, s, r = ui, n = void 0) {\n    super(e, t, s, r), this.core = e, this.logger = t, this.name = s, this.map = /* @__PURE__ */ new Map(), this.version = H0, this.cached = [], this.initialized = !1, this.storagePrefix = ui, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((o) => {\n        this.getKey && o !== null && !wt(o) ? this.map.set(this.getKey(o), o) : qb(o) ? this.map.set(o.id, o) : jb(o) && this.map.set(o.topic, o);\n      }), this.cached = [], this.initialized = !0);\n    }, this.set = async (o, c) => {\n      this.isInitialized(), this.map.has(o) ? await this.update(o, c) : (this.logger.debug(\"Setting value\"), this.logger.trace({ type: \"method\", method: \"set\", key: o, value: c }), this.map.set(o, c), await this.persist());\n    }, this.get = (o) => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({ type: \"method\", method: \"get\", key: o }), this.getData(o)), this.getAll = (o) => (this.isInitialized(), o ? this.values.filter((c) => Object.keys(o).every((u) => Yc(c[u], o[u]))) : this.values), this.update = async (o, c) => {\n      this.isInitialized(), this.logger.debug(\"Updating value\"), this.logger.trace({ type: \"method\", method: \"update\", key: o, update: c });\n      const u = ja(ja({}, this.getData(o)), c);\n      this.map.set(o, u), await this.persist();\n    }, this.delete = async (o, c) => {\n      this.isInitialized(), this.map.has(o) && (this.logger.debug(\"Deleting value\"), this.logger.trace({ type: \"method\", method: \"delete\", key: o, reason: c }), this.map.delete(o), await this.persist());\n    }, this.logger = ee.generateChildLogger(t, this.name), this.storagePrefix = r, this.getKey = n;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  async setDataStore(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getDataStore() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      const { message: s } = J(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(s), new Error(s);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setDataStore(this.values);\n  }\n  async restore() {\n    try {\n      const e = await this.getDataStore();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.map.size) {\n        const { message: t } = J(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", value: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass _v {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.name = J0, this.version = Q0, this.events = new ir(), this.initialized = !1, this.storagePrefix = ui, this.ignoredPayloadTypes = [Ni], this.registeredMethods = [], this.init = async () => {\n      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace(\"Initialized\"));\n    }, this.register = ({ methods: s }) => {\n      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s])];\n    }, this.create = async () => {\n      this.isInitialized();\n      const s = Xr(), r = await this.core.crypto.setSymKey(s), n = Ht(V.FIVE_MINUTES), o = { protocol: Mh }, c = { topic: r, expiry: n, relay: o, active: !1 }, u = Pb({ protocol: this.core.protocol, version: this.core.version, topic: r, symKey: s, relay: o });\n      return await this.pairings.set(r, c), await this.core.relayer.subscribe(r), this.core.expirer.set(r, n), { topic: r, uri: u };\n    }, this.pair = async (s) => {\n      this.isInitialized(), this.isValidPair(s);\n      const { topic: r, symKey: n, relay: o } = xb(s.uri);\n      if (this.pairings.keys.includes(r))\n        throw new Error(`Pairing already exists: ${r}`);\n      if (this.core.crypto.hasKeys(r))\n        throw new Error(`Keychain already exists: ${r}`);\n      const c = Ht(V.FIVE_MINUTES), u = { topic: r, relay: o, expiry: c, active: !1 };\n      return await this.pairings.set(r, u), await this.core.crypto.setSymKey(n, r), await this.core.relayer.subscribe(r, { relay: o }), this.core.expirer.set(r, c), s.activatePairing && await this.activate({ topic: r }), u;\n    }, this.activate = async ({ topic: s }) => {\n      this.isInitialized();\n      const r = Ht(V.THIRTY_DAYS);\n      await this.pairings.update(s, { active: !0, expiry: r }), this.core.expirer.set(s, r);\n    }, this.ping = async (s) => {\n      this.isInitialized(), await this.isValidPing(s);\n      const { topic: r } = s;\n      if (this.pairings.keys.includes(r)) {\n        const n = await this.sendRequest(r, \"wc_pairingPing\", {}), { done: o, resolve: c, reject: u } = Ti();\n        this.events.once(ke(\"pairing_ping\", n), ({ error: d }) => {\n          d ? u(d) : c();\n        }), await o();\n      }\n    }, this.updateExpiry = async ({ topic: s, expiry: r }) => {\n      this.isInitialized(), await this.pairings.update(s, { expiry: r });\n    }, this.updateMetadata = async ({ topic: s, metadata: r }) => {\n      this.isInitialized(), await this.pairings.update(s, { peerMetadata: r });\n    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s) => {\n      this.isInitialized(), await this.isValidDisconnect(s);\n      const { topic: r } = s;\n      this.pairings.keys.includes(r) && (await this.sendRequest(r, \"wc_pairingDelete\", Je(\"USER_DISCONNECTED\")), await this.deletePairing(r));\n    }, this.sendRequest = async (s, r, n) => {\n      const o = ti(r, n), c = await this.core.crypto.encode(s, o), u = ss[r].req;\n      return this.core.history.set(s, o), this.core.relayer.publish(s, c, u), o.id;\n    }, this.sendResult = async (s, r, n) => {\n      const o = xi(s, n), c = await this.core.crypto.encode(r, o), u = await this.core.history.get(r, s), d = ss[u.request.method].res;\n      await this.core.relayer.publish(r, c, d), await this.core.history.resolve(o);\n    }, this.sendError = async (s, r, n) => {\n      const o = qi(s, n), c = await this.core.crypto.encode(r, o), u = await this.core.history.get(r, s), d = ss[u.request.method] ? ss[u.request.method].res : ss.unregistered_method.res;\n      await this.core.relayer.publish(r, c, d), await this.core.history.resolve(o);\n    }, this.deletePairing = async (s, r) => {\n      await this.core.relayer.unsubscribe(s), await Promise.all([this.pairings.delete(s, Je(\"USER_DISCONNECTED\")), this.core.crypto.deleteSymKey(s), r ? Promise.resolve() : this.core.expirer.del(s)]);\n    }, this.cleanup = async () => {\n      const s = this.pairings.getAll().filter((r) => ci(r.expiry));\n      await Promise.all(s.map((r) => this.deletePairing(r.topic)));\n    }, this.onRelayEventRequest = (s) => {\n      const { topic: r, payload: n } = s, o = n.method;\n      if (this.pairings.keys.includes(r))\n        switch (o) {\n          case \"wc_pairingPing\":\n            return this.onPairingPingRequest(r, n);\n          case \"wc_pairingDelete\":\n            return this.onPairingDeleteRequest(r, n);\n          default:\n            return this.onUnknownRpcMethodRequest(r, n);\n        }\n    }, this.onRelayEventResponse = async (s) => {\n      const { topic: r, payload: n } = s, o = (await this.core.history.get(r, n.id)).request.method;\n      if (this.pairings.keys.includes(r))\n        switch (o) {\n          case \"wc_pairingPing\":\n            return this.onPairingPingResponse(r, n);\n          default:\n            return this.onUnknownRpcMethodResponse(o);\n        }\n    }, this.onPairingPingRequest = async (s, r) => {\n      const { id: n } = r;\n      try {\n        this.isValidPing({ topic: s }), await this.sendResult(n, s, !0), this.events.emit(\"pairing_ping\", { id: n, topic: s });\n      } catch (o) {\n        await this.sendError(n, s, o), this.logger.error(o);\n      }\n    }, this.onPairingPingResponse = (s, r) => {\n      const { id: n } = r;\n      setTimeout(() => {\n        ht(r) ? this.events.emit(ke(\"pairing_ping\", n), {}) : Ge(r) && this.events.emit(ke(\"pairing_ping\", n), { error: r.error });\n      }, 500);\n    }, this.onPairingDeleteRequest = async (s, r) => {\n      const { id: n } = r;\n      try {\n        this.isValidDisconnect({ topic: s }), await this.deletePairing(s), this.events.emit(\"pairing_delete\", { id: n, topic: s });\n      } catch (o) {\n        await this.sendError(n, s, o), this.logger.error(o);\n      }\n    }, this.onUnknownRpcMethodRequest = async (s, r) => {\n      const { id: n, method: o } = r;\n      try {\n        if (this.registeredMethods.includes(o))\n          return;\n        const c = Je(\"WC_METHOD_UNSUPPORTED\", o);\n        await this.sendError(n, s, c), this.logger.error(c);\n      } catch (c) {\n        await this.sendError(n, s, c), this.logger.error(c);\n      }\n    }, this.onUnknownRpcMethodResponse = (s) => {\n      this.registeredMethods.includes(s) || this.logger.error(Je(\"WC_METHOD_UNSUPPORTED\", s));\n    }, this.isValidPair = (s) => {\n      if (!It(s)) {\n        const { message: r } = J(\"MISSING_OR_INVALID\", `pair() params: ${s}`);\n        throw new Error(r);\n      }\n      if (!Mb(s.uri)) {\n        const { message: r } = J(\"MISSING_OR_INVALID\", `pair() uri: ${s.uri}`);\n        throw new Error(r);\n      }\n    }, this.isValidPing = async (s) => {\n      if (!It(s)) {\n        const { message: n } = J(\"MISSING_OR_INVALID\", `ping() params: ${s}`);\n        throw new Error(n);\n      }\n      const { topic: r } = s;\n      await this.isValidPairingTopic(r);\n    }, this.isValidDisconnect = async (s) => {\n      if (!It(s)) {\n        const { message: n } = J(\"MISSING_OR_INVALID\", `disconnect() params: ${s}`);\n        throw new Error(n);\n      }\n      const { topic: r } = s;\n      await this.isValidPairingTopic(r);\n    }, this.isValidPairingTopic = async (s) => {\n      if (!at(s, !1)) {\n        const { message: r } = J(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${s}`);\n        throw new Error(r);\n      }\n      if (!this.pairings.keys.includes(s)) {\n        const { message: r } = J(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${s}`);\n        throw new Error(r);\n      }\n      if (ci(this.pairings.get(s).expiry)) {\n        await this.deletePairing(s);\n        const { message: r } = J(\"EXPIRED\", `pairing topic: ${s}`);\n        throw new Error(r);\n      }\n    }, this.core = e, this.logger = ee.generateChildLogger(t, this.name), this.pairings = new pr(this.core, this.logger, this.name, this.storagePrefix);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    this.core.relayer.on(He.message, async (e) => {\n      const { topic: t, message: s } = e;\n      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s)))\n        return;\n      const r = await this.core.crypto.decode(t, s);\n      ji(r) ? (this.core.history.set(t, r), this.onRelayEventRequest({ topic: t, payload: r })) : Oi(r) && (await this.core.history.resolve(r), this.onRelayEventResponse({ topic: t, payload: r }));\n    });\n  }\n  registerExpirerEvents() {\n    this.core.expirer.on($t.expired, async (e) => {\n      const { topic: t } = Sh(e.target);\n      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(\"pairing_expire\", { topic: t }));\n    });\n  }\n}\nclass Ev extends Tm {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new We.EventEmitter(), this.name = X0, this.version = Z0, this.cached = [], this.initialized = !1, this.storagePrefix = ui, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((s) => this.records.set(s.id, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.set = (s, r, n) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({ type: \"method\", method: \"set\", topic: s, request: r, chainId: n }), this.records.has(r.id))\n        return;\n      const o = { id: r.id, topic: s, request: { method: r.method, params: r.params || null }, chainId: n };\n      this.records.set(o.id, o), this.events.emit(Kt.created, o);\n    }, this.resolve = async (s) => {\n      if (this.isInitialized(), this.logger.debug(\"Updating JSON-RPC response history record\"), this.logger.trace({ type: \"method\", method: \"update\", response: s }), !this.records.has(s.id))\n        return;\n      const r = await this.getRecord(s.id);\n      typeof r.response > \"u\" && (r.response = Ge(s) ? { error: s.error } : { result: s.result }, this.records.set(r.id, r), this.events.emit(Kt.updated, r));\n    }, this.get = async (s, r) => (this.isInitialized(), this.logger.debug(\"Getting record\"), this.logger.trace({ type: \"method\", method: \"get\", topic: s, id: r }), await this.getRecord(r)), this.delete = (s, r) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({ type: \"method\", method: \"delete\", id: r }), this.values.forEach((n) => {\n        if (n.topic === s) {\n          if (typeof r < \"u\" && n.id !== r)\n            return;\n          this.records.delete(n.id), this.events.emit(Kt.deleted, n);\n        }\n      });\n    }, this.exists = async (s, r) => (this.isInitialized(), this.records.has(r) ? (await this.getRecord(r)).topic === s : !1), this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.logger = ee.generateChildLogger(t, this.name);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const e = [];\n    return this.values.forEach((t) => {\n      if (typeof t.response < \"u\")\n        return;\n      const s = { topic: t.topic, request: ti(t.request.method, t.request.params, t.id), chainId: t.chainId };\n      return e.push(s);\n    }), e;\n  }\n  async setJsonRpcRecords(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getJsonRpcRecords() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getRecord(e) {\n    this.isInitialized();\n    const t = this.records.get(e);\n    if (!t) {\n      const { message: s } = J(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(s);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setJsonRpcRecords(this.values), this.events.emit(Kt.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getJsonRpcRecords();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.records.size) {\n        const { message: t } = J(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", records: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);\n    }\n  }\n  registerEventListeners() {\n    this.events.on(Kt.created, (e) => {\n      const t = Kt.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e }), this.persist();\n    }), this.events.on(Kt.updated, (e) => {\n      const t = Kt.updated;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e }), this.persist();\n    }), this.events.on(Kt.deleted, (e) => {\n      const t = Kt.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, record: e }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Sv extends qm {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new We.EventEmitter(), this.name = ev, this.version = tv, this.cached = [], this.initialized = !1, this.storagePrefix = ui, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach((s) => this.expirations.set(s.target, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.has = (s) => {\n      try {\n        const r = this.formatTarget(s);\n        return typeof this.getExpiration(r) < \"u\";\n      } catch {\n        return !1;\n      }\n    }, this.set = (s, r) => {\n      this.isInitialized();\n      const n = this.formatTarget(s), o = { target: n, expiry: r };\n      this.expirations.set(n, o), this.checkExpiry(n, o), this.events.emit($t.created, { target: n, expiration: o });\n    }, this.get = (s) => {\n      this.isInitialized();\n      const r = this.formatTarget(s);\n      return this.getExpiration(r);\n    }, this.del = (s) => {\n      if (this.isInitialized(), this.has(s)) {\n        const r = this.formatTarget(s), n = this.getExpiration(r);\n        this.expirations.delete(r), this.events.emit($t.deleted, { target: r, expiration: n });\n      }\n    }, this.on = (s, r) => {\n      this.events.on(s, r);\n    }, this.once = (s, r) => {\n      this.events.once(s, r);\n    }, this.off = (s, r) => {\n      this.events.off(s, r);\n    }, this.removeListener = (s, r) => {\n      this.events.removeListener(s, r);\n    }, this.logger = ee.generateChildLogger(t, this.name);\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(e) {\n    if (typeof e == \"string\")\n      return bb(e);\n    if (typeof e == \"number\")\n      return wb(e);\n    const { message: t } = J(\"UNKNOWN_TYPE\", `Target type: ${typeof e}`);\n    throw new Error(t);\n  }\n  async setExpirations(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getExpirations() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  async persist() {\n    await this.setExpirations(this.values), this.events.emit($t.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getExpirations();\n      if (typeof e > \"u\" || !e.length)\n        return;\n      if (this.expirations.size) {\n        const { message: t } = J(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: \"method\", method: \"restore\", expirations: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);\n    }\n  }\n  getExpiration(e) {\n    const t = this.expirations.get(e);\n    if (!t) {\n      const { message: s } = J(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(s), new Error(s);\n    }\n    return t;\n  }\n  checkExpiry(e, t) {\n    const { expiry: s } = t;\n    V.toMiliseconds(s) - Date.now() <= 0 && this.expire(e, t);\n  }\n  expire(e, t) {\n    this.expirations.delete(e), this.events.emit($t.expired, { target: e, expiration: t });\n  }\n  checkExpirations() {\n    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(Wt.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on($t.created, (e) => {\n      const t = $t.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    }), this.events.on($t.expired, (e) => {\n      const t = $t.expired;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    }), this.events.on($t.deleted, (e) => {\n      const t = $t.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: \"event\", event: t, data: e }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Iv extends jm {\n  constructor(e, t) {\n    super(e, t), this.projectId = e, this.logger = t, this.name = Tr, this.initialized = !1, this.init = async (s) => {\n      wh() || !Nn() || (this.verifyUrl = s?.verifyUrl || Ta, await this.createIframe());\n    }, this.register = async (s) => {\n      var r;\n      this.initialized || await this.init(), this.iframe && ((r = this.iframe.contentWindow) == null || r.postMessage(s.attestationId, this.verifyUrl), this.logger.info(`postMessage sent: ${s.attestationId} ${this.verifyUrl}`));\n    }, this.resolve = async (s) => {\n      var r;\n      if (this.isDevEnv)\n        return \"\";\n      this.logger.info(`resolving attestation: ${s.attestationId}`);\n      const n = this.startAbortTimer(V.FIVE_SECONDS), o = await fetch(`${this.verifyUrl}/attestation/${s.attestationId}`, { signal: this.abortController.signal });\n      return clearTimeout(n), o.status === 200 ? (r = await o.json()) == null ? void 0 : r.origin : \"\";\n    }, this.createIframe = async () => {\n      try {\n        await Promise.race([new Promise((s, r) => {\n          if (document.getElementById(Tr))\n            return s();\n          const n = document.createElement(\"iframe\");\n          n.setAttribute(\"id\", Tr), n.setAttribute(\"src\", `${this.verifyUrl}/${this.projectId}`), n.style.display = \"none\", n.addEventListener(\"load\", () => {\n            this.initialized = !0, s();\n          }), n.addEventListener(\"error\", (o) => {\n            r(o);\n          }), document.body.append(n), this.iframe = n;\n        }), new Promise((s) => {\n          setTimeout(() => s(\"iframe load timeout\"), V.toMiliseconds(V.ONE_SECOND / 2));\n        })]);\n      } catch (s) {\n        this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.error(s);\n      }\n    }, this.logger = ee.generateChildLogger(t, this.name), this.verifyUrl = Ta, this.abortController = new AbortController(), this.isDevEnv = On() && process.env.IS_VITEST;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  startAbortTimer(e) {\n    return setTimeout(() => this.abortController.abort(), V.toMiliseconds(e));\n  }\n}\nvar Dv = Object.defineProperty, za = Object.getOwnPropertySymbols, xv = Object.prototype.hasOwnProperty, Ov = Object.prototype.propertyIsEnumerable, Ka = (i, e, t) => e in i ? Dv(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Va = (i, e) => {\n  for (var t in e || (e = {}))\n    xv.call(e, t) && Ka(i, t, e[t]);\n  if (za)\n    for (var t of za(e))\n      Ov.call(e, t) && Ka(i, t, e[t]);\n  return i;\n};\nlet Nv = class jh extends Am {\n  constructor(e) {\n    super(e), this.protocol = Lh, this.version = P0, this.name = Cn, this.events = new We.EventEmitter(), this.initialized = !1, this.on = (s, r) => this.events.on(s, r), this.once = (s, r) => this.events.once(s, r), this.off = (s, r) => this.events.off(s, r), this.removeListener = (s, r) => this.events.removeListener(s, r), this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || qh;\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : ee.pino(ee.getDefaultLoggerOptions({ level: e?.logger || R0.logger }));\n    this.logger = ee.generateChildLogger(t, this.name), this.heartbeat = new Wt.HeartBeat(), this.crypto = new sv(this, this.logger, e?.keychain), this.history = new Ev(this, this.logger), this.expirer = new Sv(this, this.logger), this.storage = e != null && e.storage ? e.storage : new nc(Va(Va({}, C0), e?.storageOptions)), this.relayer = new mv({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new _v(this, this.logger), this.verify = new Iv(this.projectId || \"\", this.logger);\n  }\n  static async init(e) {\n    const t = new jh(e);\n    return await t.initialize(), t;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  async start() {\n    this.initialized || await this.initialize();\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info(\"Core Initialization Success\");\n    } catch (e) {\n      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;\n    }\n  }\n};\nconst Pv = Nv, zh = \"wc\", Kh = 2, Vh = \"client\", An = `${zh}@${Kh}:${Vh}:`, Fr = { name: Vh, logger: \"error\", controller: !1, relayUrl: \"wss://relay.walletconnect.com\" }, Rv = \"proposal\", Cv = \"Proposal expired\", Av = \"session\", Ls = V.SEVEN_DAYS, Tv = \"engine\", ns = { wc_sessionPropose: { req: { ttl: V.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: V.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: V.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: V.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: V.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: V.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: V.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, Ur = { min: V.FIVE_MINUTES, max: V.SEVEN_DAYS }, $v = \"request\", Fv = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\nvar Uv = Object.defineProperty, Lv = Object.defineProperties, Mv = Object.getOwnPropertyDescriptors, Ba = Object.getOwnPropertySymbols, qv = Object.prototype.hasOwnProperty, jv = Object.prototype.propertyIsEnumerable, ka = (i, e, t) => e in i ? Uv(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, At = (i, e) => {\n  for (var t in e || (e = {}))\n    qv.call(e, t) && ka(i, t, e[t]);\n  if (Ba)\n    for (var t of Ba(e))\n      jv.call(e, t) && ka(i, t, e[t]);\n  return i;\n}, Lr = (i, e) => Lv(i, Mv(e));\nclass zv extends Km {\n  constructor(e) {\n    super(e), this.name = Tv, this.events = new ir(), this.initialized = !1, this.ignoredPayloadTypes = [Ni], this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({ methods: Object.keys(ns) }), this.initialized = !0);\n    }, this.connect = async (t) => {\n      this.isInitialized();\n      const s = Lr(At({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });\n      await this.isValidConnect(s);\n      const { pairingTopic: r, requiredNamespaces: n, optionalNamespaces: o, sessionProperties: c, relays: u } = s;\n      let d = r, p, b = !1;\n      if (d && (b = this.client.core.pairing.pairings.get(d).active), !d || !b) {\n        const { topic: D, uri: y } = await this.client.core.pairing.create();\n        d = D, p = y;\n      }\n      const x = await this.client.core.crypto.generateKeyPair(), O = At({ requiredNamespaces: n, optionalNamespaces: o, relays: u ?? [{ protocol: Mh }], proposer: { publicKey: x, metadata: this.client.metadata } }, c && { sessionProperties: c }), { reject: _, resolve: C, done: F } = Ti(V.FIVE_MINUTES, Cv);\n      if (this.events.once(ke(\"session_connect\"), async ({ error: D, session: y }) => {\n        if (D)\n          _(D);\n        else if (y) {\n          y.self.publicKey = x;\n          const w = Lr(At({}, y), { requiredNamespaces: y.requiredNamespaces, optionalNamespaces: y.optionalNamespaces });\n          await this.client.session.set(y.topic, w), await this.setExpiry(y.topic, y.expiry), d && await this.client.core.pairing.updateMetadata({ topic: d, metadata: y.peer.metadata }), C(w);\n        }\n      }), !d) {\n        const { message: D } = J(\"NO_MATCHING_KEY\", `connect() pairing topic: ${d}`);\n        throw new Error(D);\n      }\n      const K = await this.sendRequest(d, \"wc_sessionPropose\", O), I = Ht(V.FIVE_MINUTES);\n      return await this.setProposal(K, At({ id: K, expiry: I }, O)), { uri: p, approval: F };\n    }, this.pair = async (t) => (this.isInitialized(), await this.client.core.pairing.pair(t)), this.approve = async (t) => {\n      this.isInitialized(), await this.isValidApprove(t);\n      const { id: s, relayProtocol: r, namespaces: n, sessionProperties: o } = t, c = this.client.proposal.get(s);\n      let { pairingTopic: u, proposer: d, requiredNamespaces: p, optionalNamespaces: b } = c;\n      u = u || \"\", us(p) || (p = Tb(n, \"approve()\"));\n      const x = await this.client.core.crypto.generateKeyPair(), O = d.publicKey, _ = await this.client.core.crypto.generateSharedKey(x, O);\n      u && s && (await this.client.core.pairing.updateMetadata({ topic: u, metadata: d.metadata }), await this.sendResult(s, u, { relay: { protocol: r ?? \"irn\" }, responderPublicKey: x }), await this.client.proposal.delete(s, Je(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({ topic: u }));\n      const C = At({ relay: { protocol: r ?? \"irn\" }, namespaces: n, requiredNamespaces: p, optionalNamespaces: b, pairingTopic: u, controller: { publicKey: x, metadata: this.client.metadata }, expiry: Ht(Ls) }, o && { sessionProperties: o });\n      await this.client.core.relayer.subscribe(_), await this.sendRequest(_, \"wc_sessionSettle\", C);\n      const F = Lr(At({}, C), { topic: _, pairingTopic: u, acknowledged: !1, self: C.controller, peer: { publicKey: d.publicKey, metadata: d.metadata }, controller: x });\n      return await this.client.session.set(_, F), await this.setExpiry(_, Ht(Ls)), { topic: _, acknowledged: () => new Promise((K) => setTimeout(() => K(this.client.session.get(_)), 500)) };\n    }, this.reject = async (t) => {\n      this.isInitialized(), await this.isValidReject(t);\n      const { id: s, reason: r } = t, { pairingTopic: n } = this.client.proposal.get(s);\n      n && (await this.sendError(s, n, r), await this.client.proposal.delete(s, Je(\"USER_DISCONNECTED\")));\n    }, this.update = async (t) => {\n      this.isInitialized(), await this.isValidUpdate(t);\n      const { topic: s, namespaces: r } = t, n = await this.sendRequest(s, \"wc_sessionUpdate\", { namespaces: r }), { done: o, resolve: c, reject: u } = Ti();\n      return this.events.once(ke(\"session_update\", n), ({ error: d }) => {\n        d ? u(d) : c();\n      }), await this.client.session.update(s, { namespaces: r }), { acknowledged: o };\n    }, this.extend = async (t) => {\n      this.isInitialized(), await this.isValidExtend(t);\n      const { topic: s } = t, r = await this.sendRequest(s, \"wc_sessionExtend\", {}), { done: n, resolve: o, reject: c } = Ti();\n      return this.events.once(ke(\"session_extend\", r), ({ error: u }) => {\n        u ? c(u) : o();\n      }), await this.setExpiry(s, Ht(Ls)), { acknowledged: n };\n    }, this.request = async (t) => {\n      this.isInitialized(), await this.isValidRequest(t);\n      const { chainId: s, request: r, topic: n, expiry: o } = t, c = await this.sendRequest(n, \"wc_sessionRequest\", { request: r, chainId: s }, o), { done: u, resolve: d, reject: p } = Ti(o);\n      return this.events.once(ke(\"session_request\", c), ({ error: b, result: x }) => {\n        b ? p(b) : d(x);\n      }), this.client.events.emit(\"session_request_sent\", { topic: n, request: r, chainId: s, id: c }), await u();\n    }, this.respond = async (t) => {\n      this.isInitialized(), await this.isValidRespond(t);\n      const { topic: s, response: r } = t, { id: n } = r;\n      ht(r) ? await this.sendResult(n, s, r.result) : Ge(r) && await this.sendError(n, s, r.error), this.deletePendingSessionRequest(t.response.id, { message: \"fulfilled\", code: 0 });\n    }, this.ping = async (t) => {\n      this.isInitialized(), await this.isValidPing(t);\n      const { topic: s } = t;\n      if (this.client.session.keys.includes(s)) {\n        const r = await this.sendRequest(s, \"wc_sessionPing\", {}), { done: n, resolve: o, reject: c } = Ti();\n        this.events.once(ke(\"session_ping\", r), ({ error: u }) => {\n          u ? c(u) : o();\n        }), await n();\n      } else\n        this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({ topic: s });\n    }, this.emit = async (t) => {\n      this.isInitialized(), await this.isValidEmit(t);\n      const { topic: s, event: r, chainId: n } = t;\n      await this.sendRequest(s, \"wc_sessionEvent\", { event: r, chainId: n });\n    }, this.disconnect = async (t) => {\n      this.isInitialized(), await this.isValidDisconnect(t);\n      const { topic: s } = t;\n      this.client.session.keys.includes(s) ? (await this.sendRequest(s, \"wc_sessionDelete\", Je(\"USER_DISCONNECTED\")), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({ topic: s });\n    }, this.find = (t) => (this.isInitialized(), this.client.session.getAll().filter((s) => Ub(s, t))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (t) => {\n      try {\n        const s = this.client.core.pairing.pairings.get(t.pairingTopic), r = this.client.core.pairing.pairings.getAll().filter((n) => {\n          var o, c;\n          return ((o = n.peerMetadata) == null ? void 0 : o.url) && ((c = n.peerMetadata) == null ? void 0 : c.url) === t.self.metadata.url && n.topic !== s.topic;\n        });\n        if (r.length === 0)\n          return;\n        this.client.logger.info(`Cleaning up ${r.length} duplicate pairing(s)`), await Promise.all(r.map((n) => this.client.core.pairing.disconnect({ topic: n.topic }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.deleteSession = async (t, s) => {\n      const { self: r } = this.client.session.get(t);\n      await this.client.core.relayer.unsubscribe(t), await Promise.all([this.client.session.delete(t, Je(\"USER_DISCONNECTED\")), this.client.core.crypto.deleteKeyPair(r.publicKey), this.client.core.crypto.deleteSymKey(t), s ? Promise.resolve() : this.client.core.expirer.del(t)]);\n    }, this.deleteProposal = async (t, s) => {\n      await Promise.all([this.client.proposal.delete(t, Je(\"USER_DISCONNECTED\")), s ? Promise.resolve() : this.client.core.expirer.del(t)]);\n    }, this.deletePendingSessionRequest = async (t, s, r = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(t, s), r ? Promise.resolve() : this.client.core.expirer.del(t)]);\n    }, this.setExpiry = async (t, s) => {\n      this.client.session.keys.includes(t) && await this.client.session.update(t, { expiry: s }), this.client.core.expirer.set(t, s);\n    }, this.setProposal = async (t, s) => {\n      await this.client.proposal.set(t, s), this.client.core.expirer.set(t, s.expiry);\n    }, this.setPendingSessionRequest = async (t) => {\n      const s = ns.wc_sessionRequest.req.ttl, { id: r, topic: n, params: o } = t;\n      await this.client.pendingRequest.set(r, { id: r, topic: n, params: o }), s && this.client.core.expirer.set(r, Ht(s));\n    }, this.sendRequest = async (t, s, r, n) => {\n      const o = ti(s, r);\n      if (Nn() && Fv.includes(s)) {\n        const d = Ui(JSON.stringify(o));\n        await this.client.core.verify.register({ attestationId: d });\n      }\n      const c = await this.client.core.crypto.encode(t, o), u = ns[s].req;\n      return n && (u.ttl = n), this.client.core.history.set(t, o), this.client.core.relayer.publish(t, c, u), o.id;\n    }, this.sendResult = async (t, s, r) => {\n      const n = xi(t, r), o = await this.client.core.crypto.encode(s, n), c = await this.client.core.history.get(s, t), u = ns[c.request.method].res;\n      this.client.core.relayer.publish(s, o, u), await this.client.core.history.resolve(n);\n    }, this.sendError = async (t, s, r) => {\n      const n = qi(t, r), o = await this.client.core.crypto.encode(s, n), c = await this.client.core.history.get(s, t), u = ns[c.request.method].res;\n      this.client.core.relayer.publish(s, o, u), await this.client.core.history.resolve(n);\n    }, this.cleanup = async () => {\n      const t = [], s = [];\n      this.client.session.getAll().forEach((r) => {\n        ci(r.expiry) && t.push(r.topic);\n      }), this.client.proposal.getAll().forEach((r) => {\n        ci(r.expiry) && s.push(r.id);\n      }), await Promise.all([...t.map((r) => this.deleteSession(r)), ...s.map((r) => this.deleteProposal(r))]);\n    }, this.onRelayEventRequest = (t) => {\n      const { topic: s, payload: r } = t, n = r.method;\n      switch (n) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(s, r);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(s, r);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(s, r);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(s, r);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(s, r);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(s, r);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(s, r);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(s, r);\n        default:\n          return this.client.logger.info(`Unsupported request method ${n}`);\n      }\n    }, this.onRelayEventResponse = async (t) => {\n      const { topic: s, payload: r } = t, n = (await this.client.core.history.get(s, r.id)).request.method;\n      switch (n) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(s, r);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(s, r);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(s, r);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(s, r);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(s, r);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(s, r);\n        default:\n          return this.client.logger.info(`Unsupported response method ${n}`);\n      }\n    }, this.onSessionProposeRequest = async (t, s) => {\n      const { params: r, id: n } = s;\n      try {\n        this.isValidConnect(At({}, s.params));\n        const o = Ht(V.FIVE_MINUTES), c = At({ id: n, pairingTopic: t, expiry: o }, r);\n        await this.setProposal(n, c);\n        const u = Ui(JSON.stringify(s)), d = await this.getVerifyContext(u, c.proposer.metadata);\n        this.client.events.emit(\"session_proposal\", { id: n, params: c, verifyContext: d });\n      } catch (o) {\n        await this.sendError(n, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionProposeResponse = async (t, s) => {\n      const { id: r } = s;\n      if (ht(s)) {\n        const { result: n } = s;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result: n });\n        const o = this.client.proposal.get(r);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal: o });\n        const c = o.proposer.publicKey;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", selfPublicKey: c });\n        const u = n.responderPublicKey;\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", peerPublicKey: u });\n        const d = await this.client.core.crypto.generateSharedKey(c, u);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", sessionTopic: d });\n        const p = await this.client.core.relayer.subscribe(d);\n        this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", subscriptionId: p }), await this.client.core.pairing.activate({ topic: t });\n      } else\n        Ge(s) && (await this.client.proposal.delete(r, Je(\"USER_DISCONNECTED\")), this.events.emit(ke(\"session_connect\"), { error: s.error }));\n    }, this.onSessionSettleRequest = async (t, s) => {\n      const { id: r, params: n } = s;\n      try {\n        this.isValidSessionSettleRequest(n);\n        const { relay: o, controller: c, expiry: u, namespaces: d, requiredNamespaces: p, optionalNamespaces: b, sessionProperties: x, pairingTopic: O } = s.params, _ = At({ topic: t, relay: o, expiry: u, namespaces: d, acknowledged: !0, pairingTopic: O, requiredNamespaces: p, optionalNamespaces: b, controller: c.publicKey, self: { publicKey: \"\", metadata: this.client.metadata }, peer: { publicKey: c.publicKey, metadata: c.metadata } }, x && { sessionProperties: x });\n        await this.sendResult(s.id, t, !0), this.events.emit(ke(\"session_connect\"), { session: _ }), this.cleanupDuplicatePairings(_);\n      } catch (o) {\n        await this.sendError(r, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionSettleResponse = async (t, s) => {\n      const { id: r } = s;\n      ht(s) ? (await this.client.session.update(t, { acknowledged: !0 }), this.events.emit(ke(\"session_approve\", r), {})) : Ge(s) && (await this.client.session.delete(t, Je(\"USER_DISCONNECTED\")), this.events.emit(ke(\"session_approve\", r), { error: s.error }));\n    }, this.onSessionUpdateRequest = async (t, s) => {\n      const { params: r, id: n } = s;\n      try {\n        this.isValidUpdate(At({ topic: t }, r)), await this.client.session.update(t, { namespaces: r.namespaces }), await this.sendResult(n, t, !0), this.client.events.emit(\"session_update\", { id: n, topic: t, params: r });\n      } catch (o) {\n        await this.sendError(n, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionUpdateResponse = (t, s) => {\n      const { id: r } = s;\n      ht(s) ? this.events.emit(ke(\"session_update\", r), {}) : Ge(s) && this.events.emit(ke(\"session_update\", r), { error: s.error });\n    }, this.onSessionExtendRequest = async (t, s) => {\n      const { id: r } = s;\n      try {\n        this.isValidExtend({ topic: t }), await this.setExpiry(t, Ht(Ls)), await this.sendResult(r, t, !0), this.client.events.emit(\"session_extend\", { id: r, topic: t });\n      } catch (n) {\n        await this.sendError(r, t, n), this.client.logger.error(n);\n      }\n    }, this.onSessionExtendResponse = (t, s) => {\n      const { id: r } = s;\n      ht(s) ? this.events.emit(ke(\"session_extend\", r), {}) : Ge(s) && this.events.emit(ke(\"session_extend\", r), { error: s.error });\n    }, this.onSessionPingRequest = async (t, s) => {\n      const { id: r } = s;\n      try {\n        this.isValidPing({ topic: t }), await this.sendResult(r, t, !0), this.client.events.emit(\"session_ping\", { id: r, topic: t });\n      } catch (n) {\n        await this.sendError(r, t, n), this.client.logger.error(n);\n      }\n    }, this.onSessionPingResponse = (t, s) => {\n      const { id: r } = s;\n      setTimeout(() => {\n        ht(s) ? this.events.emit(ke(\"session_ping\", r), {}) : Ge(s) && this.events.emit(ke(\"session_ping\", r), { error: s.error });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (t, s) => {\n      const { id: r } = s;\n      try {\n        this.isValidDisconnect({ topic: t, reason: s.params }), await Promise.all([new Promise((n) => {\n          this.client.core.relayer.once(He.publish, async () => {\n            n(await this.deleteSession(t));\n          });\n        }), this.sendResult(r, t, !0)]), this.client.events.emit(\"session_delete\", { id: r, topic: t });\n      } catch (n) {\n        await this.sendError(r, t, n), this.client.logger.error(n);\n      }\n    }, this.onSessionRequest = async (t, s) => {\n      const { id: r, params: n } = s;\n      try {\n        this.isValidRequest(At({ topic: t }, n)), await this.setPendingSessionRequest({ id: r, topic: t, params: n });\n        const o = Ui(JSON.stringify(s)), c = this.client.session.get(t), u = await this.getVerifyContext(o, c.peer.metadata);\n        this.client.events.emit(\"session_request\", { id: r, topic: t, params: n, verifyContext: u });\n      } catch (o) {\n        await this.sendError(r, t, o), this.client.logger.error(o);\n      }\n    }, this.onSessionRequestResponse = (t, s) => {\n      const { id: r } = s;\n      ht(s) ? this.events.emit(ke(\"session_request\", r), { result: s.result }) : Ge(s) && this.events.emit(ke(\"session_request\", r), { error: s.error });\n    }, this.onSessionEventRequest = async (t, s) => {\n      const { id: r, params: n } = s;\n      try {\n        this.isValidEmit(At({ topic: t }, n)), this.client.events.emit(\"session_event\", { id: r, topic: t, params: n });\n      } catch (o) {\n        await this.sendError(r, t, o), this.client.logger.error(o);\n      }\n    }, this.isValidConnect = async (t) => {\n      if (!It(t)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(t)}`);\n        throw new Error(u);\n      }\n      const { pairingTopic: s, requiredNamespaces: r, optionalNamespaces: n, sessionProperties: o, relays: c } = t;\n      if (wt(s) || await this.isValidPairingTopic(s), !Wb(c, !0)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `connect() relays: ${c}`);\n        throw new Error(u);\n      }\n      !wt(r) && us(r) !== 0 && this.validateNamespaces(r, \"requiredNamespaces\"), !wt(n) && us(n) !== 0 && this.validateNamespaces(n, \"optionalNamespaces\"), wt(o) || this.validateSessionProps(o, \"sessionProperties\");\n    }, this.validateNamespaces = (t, s) => {\n      const r = Gb(t, \"connect()\", s);\n      if (r)\n        throw new Error(r.message);\n    }, this.isValidApprove = async (t) => {\n      if (!It(t))\n        throw new Error(J(\"MISSING_OR_INVALID\", `approve() params: ${t}`).message);\n      const { id: s, namespaces: r, relayProtocol: n, sessionProperties: o } = t;\n      await this.isValidProposalId(s);\n      const c = this.client.proposal.get(s), u = Bs(r, \"approve()\");\n      if (u)\n        throw new Error(u.message);\n      const d = Ia(c.requiredNamespaces, r, \"approve()\");\n      if (d)\n        throw new Error(d.message);\n      if (!at(n, !0)) {\n        const { message: p } = J(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${n}`);\n        throw new Error(p);\n      }\n      wt(o) || this.validateSessionProps(o, \"sessionProperties\");\n    }, this.isValidReject = async (t) => {\n      if (!It(t)) {\n        const { message: n } = J(\"MISSING_OR_INVALID\", `reject() params: ${t}`);\n        throw new Error(n);\n      }\n      const { id: s, reason: r } = t;\n      if (await this.isValidProposalId(s), !Jb(r)) {\n        const { message: n } = J(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(r)}`);\n        throw new Error(n);\n      }\n    }, this.isValidSessionSettleRequest = (t) => {\n      if (!It(t)) {\n        const { message: d } = J(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${t}`);\n        throw new Error(d);\n      }\n      const { relay: s, controller: r, namespaces: n, expiry: o } = t;\n      if (!Dh(s)) {\n        const { message: d } = J(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(d);\n      }\n      const c = zb(r, \"onSessionSettleRequest()\");\n      if (c)\n        throw new Error(c.message);\n      const u = Bs(n, \"onSessionSettleRequest()\");\n      if (u)\n        throw new Error(u.message);\n      if (ci(o)) {\n        const { message: d } = J(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(d);\n      }\n    }, this.isValidUpdate = async (t) => {\n      if (!It(t)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `update() params: ${t}`);\n        throw new Error(u);\n      }\n      const { topic: s, namespaces: r } = t;\n      await this.isValidSessionTopic(s);\n      const n = this.client.session.get(s), o = Bs(r, \"update()\");\n      if (o)\n        throw new Error(o.message);\n      const c = Ia(n.requiredNamespaces, r, \"update()\");\n      if (c)\n        throw new Error(c.message);\n    }, this.isValidExtend = async (t) => {\n      if (!It(t)) {\n        const { message: r } = J(\"MISSING_OR_INVALID\", `extend() params: ${t}`);\n        throw new Error(r);\n      }\n      const { topic: s } = t;\n      await this.isValidSessionTopic(s);\n    }, this.isValidRequest = async (t) => {\n      if (!It(t)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `request() params: ${t}`);\n        throw new Error(u);\n      }\n      const { topic: s, request: r, chainId: n, expiry: o } = t;\n      await this.isValidSessionTopic(s);\n      const { namespaces: c } = this.client.session.get(s);\n      if (!Sa(c, n)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `request() chainId: ${n}`);\n        throw new Error(u);\n      }\n      if (!Qb(r)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(r)}`);\n        throw new Error(u);\n      }\n      if (!ew(c, n, r.method)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `request() method: ${r.method}`);\n        throw new Error(u);\n      }\n      if (o && !rw(o, Ur)) {\n        const { message: u } = J(\"MISSING_OR_INVALID\", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${Ur.min} and ${Ur.max}`);\n        throw new Error(u);\n      }\n    }, this.isValidRespond = async (t) => {\n      if (!It(t)) {\n        const { message: n } = J(\"MISSING_OR_INVALID\", `respond() params: ${t}`);\n        throw new Error(n);\n      }\n      const { topic: s, response: r } = t;\n      if (await this.isValidSessionTopic(s), !Xb(r)) {\n        const { message: n } = J(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(r)}`);\n        throw new Error(n);\n      }\n    }, this.isValidPing = async (t) => {\n      if (!It(t)) {\n        const { message: r } = J(\"MISSING_OR_INVALID\", `ping() params: ${t}`);\n        throw new Error(r);\n      }\n      const { topic: s } = t;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.isValidEmit = async (t) => {\n      if (!It(t)) {\n        const { message: c } = J(\"MISSING_OR_INVALID\", `emit() params: ${t}`);\n        throw new Error(c);\n      }\n      const { topic: s, event: r, chainId: n } = t;\n      await this.isValidSessionTopic(s);\n      const { namespaces: o } = this.client.session.get(s);\n      if (!Sa(o, n)) {\n        const { message: c } = J(\"MISSING_OR_INVALID\", `emit() chainId: ${n}`);\n        throw new Error(c);\n      }\n      if (!Zb(r)) {\n        const { message: c } = J(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(r)}`);\n        throw new Error(c);\n      }\n      if (!tw(o, n, r.name)) {\n        const { message: c } = J(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(r)}`);\n        throw new Error(c);\n      }\n    }, this.isValidDisconnect = async (t) => {\n      if (!It(t)) {\n        const { message: r } = J(\"MISSING_OR_INVALID\", `disconnect() params: ${t}`);\n        throw new Error(r);\n      }\n      const { topic: s } = t;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.getVerifyContext = async (t, s) => {\n      const r = { verified: { verifyUrl: s.verifyUrl || \"\", validation: \"UNKNOWN\", origin: s.url || \"\" } };\n      try {\n        const n = await this.client.core.verify.resolve({ attestationId: t, verifyUrl: s.verifyUrl });\n        n && (r.verified.origin = n, r.verified.validation = n === s.url ? \"VALID\" : \"INVALID\");\n      } catch (n) {\n        this.client.logger.error(n);\n      }\n      return this.client.logger.info(`Verify context: ${JSON.stringify(r)}`), r;\n    }, this.validateSessionProps = (t, s) => {\n      Object.values(t).forEach((r) => {\n        if (!at(r, !1)) {\n          const { message: n } = J(\"MISSING_OR_INVALID\", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(r)}`);\n          throw new Error(n);\n        }\n      });\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const { message: e } = J(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(He.message, async (e) => {\n      const { topic: t, message: s } = e;\n      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))\n        return;\n      const r = await this.client.core.crypto.decode(t, s);\n      ji(r) ? (this.client.core.history.set(t, r), this.onRelayEventRequest({ topic: t, payload: r })) : Oi(r) && (await this.client.core.history.resolve(r), this.onRelayEventResponse({ topic: t, payload: r }));\n    });\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on($t.expired, async (e) => {\n      const { topic: t, id: s } = Sh(e.target);\n      if (s && this.client.pendingRequest.keys.includes(s))\n        return await this.deletePendingSessionRequest(s, J(\"EXPIRED\"), !0);\n      t ? this.client.session.keys.includes(t) && (await this.deleteSession(t, !0), this.client.events.emit(\"session_expire\", { topic: t })) : s && (await this.deleteProposal(s, !0), this.client.events.emit(\"proposal_expire\", { id: s }));\n    });\n  }\n  isValidPairingTopic(e) {\n    if (!at(e, !1)) {\n      const { message: t } = J(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(e)) {\n      const { message: t } = J(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (ci(this.client.core.pairing.pairings.get(e).expiry)) {\n      const { message: t } = J(\"EXPIRED\", `pairing topic: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidSessionTopic(e) {\n    if (!at(e, !1)) {\n      const { message: t } = J(\"MISSING_OR_INVALID\", `session topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.session.keys.includes(e)) {\n      const { message: t } = J(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (ci(this.client.session.get(e).expiry)) {\n      await this.deleteSession(e);\n      const { message: t } = J(\"EXPIRED\", `session topic: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidSessionOrPairingTopic(e) {\n    if (this.client.session.keys.includes(e))\n      await this.isValidSessionTopic(e);\n    else if (this.client.core.pairing.pairings.keys.includes(e))\n      this.isValidPairingTopic(e);\n    else if (at(e, !1)) {\n      const { message: t } = J(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${e}`);\n      throw new Error(t);\n    } else {\n      const { message: t } = J(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${e}`);\n      throw new Error(t);\n    }\n  }\n  async isValidProposalId(e) {\n    if (!Yb(e)) {\n      const { message: t } = J(\"MISSING_OR_INVALID\", `proposal id should be a number: ${e}`);\n      throw new Error(t);\n    }\n    if (!this.client.proposal.keys.includes(e)) {\n      const { message: t } = J(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${e}`);\n      throw new Error(t);\n    }\n    if (ci(this.client.proposal.get(e).expiry)) {\n      await this.deleteProposal(e);\n      const { message: t } = J(\"EXPIRED\", `proposal id: ${e}`);\n      throw new Error(t);\n    }\n  }\n}\nclass Kv extends pr {\n  constructor(e, t) {\n    super(e, t, Rv, An), this.core = e, this.logger = t;\n  }\n}\nclass Vv extends pr {\n  constructor(e, t) {\n    super(e, t, Av, An), this.core = e, this.logger = t;\n  }\n}\nclass Bv extends pr {\n  constructor(e, t) {\n    super(e, t, $v, An, (s) => s.id), this.core = e, this.logger = t;\n  }\n}\nclass Tn extends zm {\n  constructor(e) {\n    super(e), this.protocol = zh, this.version = Kh, this.name = Fr.name, this.events = new We.EventEmitter(), this.on = (s, r) => this.events.on(s, r), this.once = (s, r) => this.events.once(s, r), this.off = (s, r) => this.events.off(s, r), this.removeListener = (s, r) => this.events.removeListener(s, r), this.removeAllListeners = (s) => this.events.removeAllListeners(s), this.connect = async (s) => {\n      try {\n        return await this.engine.connect(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.pair = async (s) => {\n      try {\n        return await this.engine.pair(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.approve = async (s) => {\n      try {\n        return await this.engine.approve(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.reject = async (s) => {\n      try {\n        return await this.engine.reject(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.update = async (s) => {\n      try {\n        return await this.engine.update(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.extend = async (s) => {\n      try {\n        return await this.engine.extend(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.request = async (s) => {\n      try {\n        return await this.engine.request(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.respond = async (s) => {\n      try {\n        return await this.engine.respond(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.ping = async (s) => {\n      try {\n        return await this.engine.ping(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.emit = async (s) => {\n      try {\n        return await this.engine.emit(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.disconnect = async (s) => {\n      try {\n        return await this.engine.disconnect(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.find = (s) => {\n      try {\n        return this.engine.find(s);\n      } catch (r) {\n        throw this.logger.error(r.message), r;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = e?.name || Fr.name, this.metadata = e?.metadata || fb();\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : ee.pino(ee.getDefaultLoggerOptions({ level: e?.logger || Fr.logger }));\n    this.core = e?.core || new Pv(e), this.logger = ee.generateChildLogger(t, this.name), this.session = new Vv(this.core, this.logger), this.proposal = new Kv(this.core, this.logger), this.pendingRequest = new Bv(this.core, this.logger), this.engine = new zv(this);\n  }\n  static async init(e) {\n    const t = new Tn(e);\n    return await t.initialize(), t;\n  }\n  get context() {\n    return ee.getLoggerContext(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info(\"SignClient Initialization Success\");\n    } catch (e) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(e.message), e;\n    }\n  }\n}\nfunction kv(i) {\n  return typeof i < \"u\" && typeof i.context < \"u\";\n}\nconst Gt = { init: \"signer_init\", uri: \"signer_uri\", created: \"signer_created\", updated: \"signer_updated\", deleted: \"signer_deleted\", event: \"signer_event\" };\nclass Hv extends Dg {\n  constructor(e) {\n    super(), this.events = new We.EventEmitter(), this.pending = !1, this.initializing = !1, this.requiredNamespaces = e?.requiredNamespaces || {}, this.opts = e?.client;\n  }\n  get connected() {\n    return typeof this.session < \"u\";\n  }\n  get connecting() {\n    return this.pending;\n  }\n  get chains() {\n    return this.session ? Ym(this.session.namespaces) : Jm(this.requiredNamespaces);\n  }\n  get accounts() {\n    return this.session ? Wm(this.session.namespaces) : [];\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async open() {\n    if (this.pending)\n      return new Promise((e, t) => {\n        this.events.once(\"open\", () => {\n          if (this.events.once(\"open_error\", (s) => {\n            t(s);\n          }), typeof this.client > \"u\")\n            return t(new Error(\"Sign Client not initialized\"));\n          e();\n        });\n      });\n    try {\n      this.pending = !0;\n      const e = await this.register(), t = e.find({ requiredNamespaces: this.requiredNamespaces });\n      if (t.length)\n        return this.onOpen(t[0]);\n      const { uri: s, approval: r } = await e.connect({ requiredNamespaces: this.requiredNamespaces });\n      this.events.emit(Gt.uri, { uri: s }), this.session = await r(), this.events.emit(Gt.created, this.session), this.onOpen();\n    } catch (e) {\n      throw this.events.emit(\"open_error\", e), e;\n    }\n  }\n  async close() {\n    typeof this.session > \"u\" || (await (await this.register()).disconnect({ topic: this.session.topic, reason: Je(\"USER_DISCONNECTED\") }), this.onClose());\n  }\n  async send(e, t) {\n    if (typeof this.client > \"u\" && (this.client = await this.register(), this.connected || await this.open()), typeof this.session > \"u\")\n      throw new Error(\"Signer connection is missing session\");\n    this.client.request({ topic: this.session.topic, request: e, chainId: t?.chainId }).then((s) => this.events.emit(\"payload\", xi(e.id, s))).catch((s) => this.events.emit(\"payload\", qi(e.id, s.message)));\n  }\n  async register(e = this.opts) {\n    if (typeof this.client < \"u\")\n      return this.client;\n    if (this.initializing)\n      return new Promise((t, s) => {\n        this.events.once(\"register_error\", (r) => {\n          s(r);\n        }), this.events.once(Gt.init, () => {\n          if (typeof this.client > \"u\")\n            return s(new Error(\"Sign Client not initialized\"));\n          t(this.client);\n        });\n      });\n    if (kv(e))\n      return this.client = e, this.registerEventListeners(), this.client;\n    try {\n      return this.initializing = !0, this.client = await Tn.init(e), this.initializing = !1, this.registerEventListeners(), this.events.emit(Gt.init), this.client;\n    } catch (t) {\n      throw this.events.emit(\"register_error\", t), t;\n    }\n  }\n  onOpen(e) {\n    this.pending = !1, e && (this.session = e), this.events.emit(\"open\");\n  }\n  onClose() {\n    this.pending = !1, this.client && (this.client = void 0), this.events.emit(\"close\");\n  }\n  registerEventListeners() {\n    typeof this.client < \"u\" && (this.client.on(\"session_event\", (e) => {\n      var t;\n      this.session && ((t = this.session) == null ? void 0 : t.topic) !== e.topic || this.events.emit(Gt.event, e.params);\n    }), this.client.on(\"session_update\", (e) => {\n      var t;\n      typeof this.client < \"u\" && (this.session && ((t = this.session) == null ? void 0 : t.topic) !== e.topic || (this.session = this.client.session.get(e.topic), this.events.emit(Gt.updated, this.session)));\n    }), this.client.on(\"session_delete\", (e) => {\n      var t;\n      this.session && (this.session && ((t = this.session) == null ? void 0 : t.topic) !== e.topic || (this.onClose(), this.events.emit(Gt.deleted, this.session), this.session = void 0));\n    }));\n  }\n}\nconst Bh = \":\";\nfunction Gv(i) {\n  const { namespace: e, reference: t } = i;\n  return [e, t].join(Bh);\n}\nfunction Wv(i) {\n  const [e, t, s] = i.split(Bh);\n  return { namespace: e, reference: t, address: s };\n}\nfunction Yv(i, e) {\n  const t = [];\n  return i.forEach((s) => {\n    const r = e(s);\n    t.includes(r) || t.push(r);\n  }), t;\n}\nfunction Jv(i) {\n  const { namespace: e, reference: t } = Wv(i);\n  return Gv({ namespace: e, reference: t });\n}\nfunction Qv(i) {\n  return Yv(i, Jv);\n}\nfunction Xv(i, e = []) {\n  const t = [];\n  return Object.keys(i).forEach((s) => {\n    if (e.length && !e.includes(s))\n      return;\n    const r = i[s];\n    t.push(...r.accounts);\n  }), t;\n}\nfunction Zv(i, e = []) {\n  const t = [];\n  return Object.keys(i).forEach((s) => {\n    if (e.length && !e.includes(s))\n      return;\n    const r = i[s];\n    t.push(...Qv(r.accounts));\n  }), t;\n}\nclass e_ {\n  constructor() {\n    we(this, \"accounts\", []);\n    we(this, \"eventEmitter\", new We.EventEmitter());\n    we(this, \"updateSession\", (e) => {\n      if (!this.isValidSession(e))\n        throw console.warn(\n          \"updateSession incompatible session\",\n          e,\n          \"for adapter\",\n          this.formatChainId(this.chainId)\n        ), new Error(\"Invalid session\");\n      this.session = e;\n      const t = Zv(e.namespaces, [this.namespace]);\n      this.setChainIds(t);\n      const s = Xv(e.namespaces, [\n        this.namespace\n      ]);\n      this.setAccounts(s);\n    });\n    we(this, \"isValidSession\", ({\n      namespaces: e,\n      requiredNamespaces: t\n    }) => {\n      const s = this.formatChainId(this.chainId);\n      return t ? !!t[this.namespace]?.chains?.includes(s) : !!e?.[this.namespace]?.accounts.some(\n        (r) => r.startsWith(s)\n      );\n    });\n  }\n  getRequiredNamespaces() {\n    const e = [this.formatChainId(this.chainId)];\n    return {\n      [this.namespace]: { chains: e, methods: this.methods, events: this.events }\n    };\n  }\n  isCompatibleChainId(e) {\n    return typeof e == \"string\" ? e.startsWith(`${this.namespace}:`) : !1;\n  }\n  setChainIds(e) {\n    const s = e.filter((r) => this.isCompatibleChainId(r)).map((r) => this.parseChainId(r)).filter((r) => r !== this.chainId);\n    s.length && (this.chainId = s[0], this.eventEmitter.emit(\"chainChanged\", this.chainId));\n  }\n  setChainId(e) {\n    if (this.isCompatibleChainId(e)) {\n      const t = this.parseChainId(e);\n      this.chainId = t, this.eventEmitter.emit(\"chainChanged\", this.chainId);\n    }\n  }\n  parseAccountId(e) {\n    const [t, s, r] = e.split(\":\");\n    return { chainId: `${t}:${s}`, address: r };\n  }\n  getSignerConnection(e) {\n    return new Hv({\n      requiredNamespaces: {\n        [this.namespace]: {\n          chains: this.rpc.chains,\n          methods: this.rpc.methods,\n          events: this.rpc.events\n        }\n      },\n      client: e\n    });\n  }\n  registerEventListeners() {\n    this.rpcProvider.on(\"connect\", () => {\n      const { chains: e, accounts: t } = this.signerConnection;\n      e?.length && this.setChainIds(e), t?.length && this.setAccounts(t);\n    }), this.signerConnection.on(Gt.created, this.updateSession), this.signerConnection.on(Gt.updated, this.updateSession), this.signerConnection.on(Gt.event, (e) => {\n      if (!this.rpc.chains.includes(e.chainId))\n        return;\n      const { event: t } = e;\n      t.name === \"accountsChanged\" ? (this.accounts = t.data, this.eventEmitter.emit(\"accountsChanged\", this.accounts)) : t.name === \"chainChanged\" ? this.setChainId(t.data) : this.eventEmitter.emit(t.name, t.data);\n    }), this.rpcProvider.on(\"disconnect\", () => {\n      this.eventEmitter.emit(\"disconnect\");\n    });\n  }\n}\nclass Ha extends starknet__WEBPACK_IMPORTED_MODULE_1__.Account {\n  constructor(e, t, s, r) {\n    super(e, t, s), this.wallet = r;\n  }\n  async execute(e, t = void 0, s = {}) {\n    return e = Array.isArray(e) ? e : [e], await this.wallet.starknet_requestAddInvokeTransaction({\n      accountAddress: this.address,\n      executionRequest: { calls: e, abis: t, invocationDetails: s }\n    });\n  }\n  async declare(e, t) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n  async deployAccount(e, t) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n}\nclass t_ {\n  constructor(e) {\n    this.wallet = e;\n  }\n  async getPubKey() {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n  async signMessage(e, t) {\n    const { signature: s } = await this.wallet.starknet_signTypedData({\n      accountAddress: t,\n      typedData: e\n    });\n    return s;\n  }\n  async signTransaction(e, t, s) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n  async signDeployAccountTransaction(e) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n  async signDeclareTransaction(e) {\n    throw new Error(\"Not supported via Argent Login\");\n  }\n}\nconst i_ = (i) => i.replace(/^SN_/, \"SN\"), s_ = (i) => i.replace(/^SN/, \"SN_\");\nclass r_ extends e_ {\n  constructor({ client: t, chainId: s, rpcUrl: r, provider: n }) {\n    super();\n    we(this, \"id\", \"argentMobile\");\n    we(this, \"name\", \"Argent Mobile\");\n    we(this, \"version\", \"0.1.0\");\n    we(this, \"icon\", \"\");\n    we(this, \"provider\");\n    we(this, \"signer\");\n    we(this, \"account\");\n    we(this, \"selectedAddress\", \"\");\n    // NamespaceAdapter\n    we(this, \"namespace\", \"starknet\");\n    we(this, \"methods\", [\n      \"starknet_signTypedData\",\n      \"starknet_requestAddInvokeTransaction\"\n    ]);\n    we(this, \"events\", [\"chainChanged\", \"accountsChanged\"]);\n    we(this, \"remoteSigner\");\n    we(this, \"signerConnection\");\n    we(this, \"rpcProvider\");\n    we(this, \"chainId\");\n    we(this, \"client\");\n    we(this, \"session\");\n    we(this, \"rpc\");\n    we(this, \"walletRpc\");\n    we(this, \"on\", (t, s) => {\n      this.eventEmitter.on(t, s);\n    });\n    we(this, \"off\", (t, s) => {\n      this.eventEmitter.off(t, s);\n    });\n    this.chainId = String(s ?? starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName.SN_MAIN), this.rpc = {\n      chains: s ? [this.formatChainId(this.chainId)] : [],\n      methods: this.methods,\n      events: this.events\n    }, this.signerConnection = this.getSignerConnection(t), this.rpcProvider = new _n(this.signerConnection), this.client = t, this.registerEventListeners(), this.walletRpc = new Proxy({}, {\n      get: (o, c) => (u) => this.requestWallet({ method: c, params: u })\n    }), this.remoteSigner = new t_(this.walletRpc), this.provider = n || new starknet__WEBPACK_IMPORTED_MODULE_1__.RpcProvider({ nodeUrl: r }), this.account = new Ha(\n      this.provider,\n      \"\",\n      this.remoteSigner,\n      this.walletRpc\n    );\n  }\n  getNetworkName(t) {\n    if (t === \"SN_SEPOLIA\")\n      return starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName.SN_SEPOLIA;\n    if (t === \"SN_MAIN\")\n      return starknet__WEBPACK_IMPORTED_MODULE_1__.constants.NetworkName.SN_MAIN;\n    throw new Error(`Unknown starknet.js network name for chainId ${t}`);\n  }\n  // StarknetWindowObject\n  async request(t) {\n    throw new Error(\"Not implemented: .request()\");\n  }\n  async enable() {\n    return await this.rpcProvider.connect(), this.accounts;\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  get isConnected() {\n    return !0;\n  }\n  async isPreauthorized() {\n    return !!this.client.session.getAll().find(this.isValidSession);\n  }\n  async requestWallet(t) {\n    if (!this.session)\n      throw new Error(\"No session\");\n    try {\n      const { topic: s } = this.session, r = this.formatChainId(this.chainId);\n      kt.showApprovalModal(t);\n      const n = await this.client.request({ topic: s, chainId: r, request: t });\n      return kt.closeModal(\"animateSuccess\"), n;\n    } catch (s) {\n      throw kt.closeModal(), s instanceof Error ? new Error(s.message) : new Error(\"Unknow error on requestWallet\");\n    }\n  }\n  // NamespaceAdapter\n  get isConnecting() {\n    return this.signerConnection.connecting;\n  }\n  async disable() {\n    await this.rpcProvider.disconnect();\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  // NamespaceAdapter private methods\n  registerEventListeners() {\n    super.registerEventListeners(), this.eventEmitter.on(\"chainChanged\", (t) => {\n      throw new Error(\"Not implemented: chainChanged\");\n    });\n  }\n  formatChainId(t) {\n    return `${this.namespace}:${i_(t)}`;\n  }\n  parseChainId(t) {\n    return s_(t.split(\":\")[1]);\n  }\n  setAccounts(t) {\n    this.accounts = t.filter(\n      (n) => this.parseChainId(this.parseAccountId(n).chainId) === this.chainId\n    ).map((n) => this.parseAccountId(n).address);\n    const { address: s } = this.parseAccountId(t[0]), r = s.startsWith(\"0x\") ? s : `0x${s}`;\n    this.account = new Ha(\n      this.provider,\n      r,\n      this.remoteSigner,\n      this.walletRpc\n    ), this.eventEmitter.emit(\"accountsChanged\", this.accounts), this.selectedAddress = r;\n  }\n}\nconst Y_ = async (i) => Pm(i, r_);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldGtpdC9kaXN0L2luZGV4LTAwNDUxZjFhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUN3RTtBQUNLO0FBQy9CO0FBQ1I7QUFDdEMsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUE0RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ3hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0EsQ0FBQztBQUNELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDZEQUE2RCxJQUFJLG9EQUFvRDtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdDQUFnQztBQUM3QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUSxpREFBaUQ7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixFQUFFLEdBQUcsRUFBRTtBQUNoQztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSSw2T0FBNk87QUFDMVE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsU0FBUztBQUNyRTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUyxTQUFTO0FBQzdCLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCLHlCQUF5Qiw2REFBRTtBQUNyRSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBNEM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EscUlBQXFJLE9BQU87QUFDNUk7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFNQUFxTSxVQUFVO0FBQy9NLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJB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Q0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtB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cy9zdGFya25ldGtpdC9kaXN0L2luZGV4LTAwNDUxZjFhLmpzPzNmYWUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEF1ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIFR1ID0gKGksIGUsIHQpID0+IGUgaW4gaSA/IEF1KGksIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBpW2VdID0gdDtcbnZhciB3ZSA9IChpLCBlLCB0KSA9PiAoVHUoaSwgdHlwZW9mIGUgIT0gXCJzeW1ib2xcIiA/IGUgKyBcIlwiIDogZSwgdCksIHQpO1xuaW1wb3J0IHsgZSBhcyBHYSwgYyBhcyBtdCwgZyBhcyBXYSB9IGZyb20gXCIuL2xhc3RDb25uZWN0ZWQtYjk2NGRjMzAuanNcIjtcbmltcG9ydCB7IGNvbnN0YW50cyBhcyBNcywgQWNjb3VudCBhcyAkdSwgUnBjUHJvdmlkZXIgYXMgRnUgfSBmcm9tIFwic3RhcmtuZXRcIjtcbmltcG9ydCB7IHIgYXMgVXUgfSBmcm9tIFwiLi9pbmRleC03MGYzNzNkYS5qc1wiO1xuaW1wb3J0IFwiLi9wdWJsaWNSY3BOb2Rlcy1iZTA0MTU4OC5qc1wiO1xudmFyIHNuID0geyBleHBvcnRzOiB7fSB9LCAkaSA9IHR5cGVvZiBSZWZsZWN0ID09IFwib2JqZWN0XCIgPyBSZWZsZWN0IDogbnVsbCwgQm4gPSAkaSAmJiB0eXBlb2YgJGkuYXBwbHkgPT0gXCJmdW5jdGlvblwiID8gJGkuYXBwbHkgOiBmdW5jdGlvbihlLCB0LCBzKSB7XG4gIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChlLCB0LCBzKTtcbn0sIHFzO1xuJGkgJiYgdHlwZW9mICRpLm93bktleXMgPT0gXCJmdW5jdGlvblwiID8gcXMgPSAkaS5vd25LZXlzIDogT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA/IHFzID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZSkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSkpO1xufSA6IHFzID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZSk7XG59O1xuZnVuY3Rpb24gTHUoaSkge1xuICBjb25zb2xlICYmIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLndhcm4oaSk7XG59XG52YXIgWWEgPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZSAhPT0gZTtcbn07XG5mdW5jdGlvbiBPZSgpIHtcbiAgT2UuaW5pdC5jYWxsKHRoaXMpO1xufVxuc24uZXhwb3J0cyA9IE9lO1xuc24uZXhwb3J0cy5vbmNlID0genU7XG5PZS5FdmVudEVtaXR0ZXIgPSBPZTtcbk9lLnByb3RvdHlwZS5fZXZlbnRzID0gdm9pZCAwO1xuT2UucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5PZS5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHZvaWQgMDtcbnZhciBrbiA9IDEwO1xuZnVuY3Rpb24gdHIoaSkge1xuICBpZiAodHlwZW9mIGkgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgaSk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoT2UsIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBrbjtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihpKSB7XG4gICAgaWYgKHR5cGVvZiBpICE9IFwibnVtYmVyXCIgfHwgaSA8IDAgfHwgWWEoaSkpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBpICsgXCIuXCIpO1xuICAgIGtuID0gaTtcbiAgfVxufSk7XG5PZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICh0aGlzLl9ldmVudHMgPT09IHZvaWQgMCB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSAmJiAodGhpcy5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRoaXMuX2V2ZW50c0NvdW50ID0gMCksIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB2b2lkIDA7XG59O1xuT2UucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKHR5cGVvZiBlICE9IFwibnVtYmVyXCIgfHwgZSA8IDAgfHwgWWEoZSkpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgZSArIFwiLlwiKTtcbiAgcmV0dXJuIHRoaXMuX21heExpc3RlbmVycyA9IGUsIHRoaXM7XG59O1xuZnVuY3Rpb24gSmEoaSkge1xuICByZXR1cm4gaS5fbWF4TGlzdGVuZXJzID09PSB2b2lkIDAgPyBPZS5kZWZhdWx0TWF4TGlzdGVuZXJzIDogaS5fbWF4TGlzdGVuZXJzO1xufVxuT2UucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSmEodGhpcyk7XG59O1xuT2UucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihlKSB7XG4gIGZvciAodmFyIHQgPSBbXSwgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspXG4gICAgdC5wdXNoKGFyZ3VtZW50c1tzXSk7XG4gIHZhciByID0gZSA9PT0gXCJlcnJvclwiLCBuID0gdGhpcy5fZXZlbnRzO1xuICBpZiAobiAhPT0gdm9pZCAwKVxuICAgIHIgPSByICYmIG4uZXJyb3IgPT09IHZvaWQgMDtcbiAgZWxzZSBpZiAoIXIpXG4gICAgcmV0dXJuICExO1xuICBpZiAocikge1xuICAgIHZhciBvO1xuICAgIGlmICh0Lmxlbmd0aCA+IDAgJiYgKG8gPSB0WzBdKSwgbyBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgdGhyb3cgbztcbiAgICB2YXIgYyA9IG5ldyBFcnJvcihcIlVuaGFuZGxlZCBlcnJvci5cIiArIChvID8gXCIgKFwiICsgby5tZXNzYWdlICsgXCIpXCIgOiBcIlwiKSk7XG4gICAgdGhyb3cgYy5jb250ZXh0ID0gbywgYztcbiAgfVxuICB2YXIgdSA9IG5bZV07XG4gIGlmICh1ID09PSB2b2lkIDApXG4gICAgcmV0dXJuICExO1xuICBpZiAodHlwZW9mIHUgPT0gXCJmdW5jdGlvblwiKVxuICAgIEJuKHUsIHRoaXMsIHQpO1xuICBlbHNlXG4gICAgZm9yICh2YXIgZCA9IHUubGVuZ3RoLCBwID0gdGModSwgZCksIHMgPSAwOyBzIDwgZDsgKytzKVxuICAgICAgQm4ocFtzXSwgdGhpcywgdCk7XG4gIHJldHVybiAhMDtcbn07XG5mdW5jdGlvbiBRYShpLCBlLCB0LCBzKSB7XG4gIHZhciByLCBuLCBvO1xuICBpZiAodHIodCksIG4gPSBpLl9ldmVudHMsIG4gPT09IHZvaWQgMCA/IChuID0gaS5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIGkuX2V2ZW50c0NvdW50ID0gMCkgOiAobi5uZXdMaXN0ZW5lciAhPT0gdm9pZCAwICYmIChpLmVtaXQoXG4gICAgXCJuZXdMaXN0ZW5lclwiLFxuICAgIGUsXG4gICAgdC5saXN0ZW5lciA/IHQubGlzdGVuZXIgOiB0XG4gICksIG4gPSBpLl9ldmVudHMpLCBvID0gbltlXSksIG8gPT09IHZvaWQgMClcbiAgICBvID0gbltlXSA9IHQsICsraS5fZXZlbnRzQ291bnQ7XG4gIGVsc2UgaWYgKHR5cGVvZiBvID09IFwiZnVuY3Rpb25cIiA/IG8gPSBuW2VdID0gcyA/IFt0LCBvXSA6IFtvLCB0XSA6IHMgPyBvLnVuc2hpZnQodCkgOiBvLnB1c2godCksIHIgPSBKYShpKSwgciA+IDAgJiYgby5sZW5ndGggPiByICYmICFvLndhcm5lZCkge1xuICAgIG8ud2FybmVkID0gITA7XG4gICAgdmFyIGMgPSBuZXcgRXJyb3IoXCJQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuIFwiICsgby5sZW5ndGggKyBcIiBcIiArIFN0cmluZyhlKSArIFwiIGxpc3RlbmVycyBhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXRcIik7XG4gICAgYy5uYW1lID0gXCJNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmdcIiwgYy5lbWl0dGVyID0gaSwgYy50eXBlID0gZSwgYy5jb3VudCA9IG8ubGVuZ3RoLCBMdShjKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbk9lLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIFFhKHRoaXMsIGUsIHQsICExKTtcbn07XG5PZS5wcm90b3R5cGUub24gPSBPZS5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5PZS5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID0gZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gUWEodGhpcywgZSwgdCwgITApO1xufTtcbmZ1bmN0aW9uIE11KCkge1xuICBpZiAoIXRoaXMuZmlyZWQpXG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pLCB0aGlzLmZpcmVkID0gITAsIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpIDogdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIFhhKGksIGUsIHQpIHtcbiAgdmFyIHMgPSB7IGZpcmVkOiAhMSwgd3JhcEZuOiB2b2lkIDAsIHRhcmdldDogaSwgdHlwZTogZSwgbGlzdGVuZXI6IHQgfSwgciA9IE11LmJpbmQocyk7XG4gIHJldHVybiByLmxpc3RlbmVyID0gdCwgcy53cmFwRm4gPSByLCByO1xufVxuT2UucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiB0cih0KSwgdGhpcy5vbihlLCBYYSh0aGlzLCBlLCB0KSksIHRoaXM7XG59O1xuT2UucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiB0cih0KSwgdGhpcy5wcmVwZW5kTGlzdGVuZXIoZSwgWGEodGhpcywgZSwgdCkpLCB0aGlzO1xufTtcbk9lLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgdmFyIHMsIHIsIG4sIG8sIGM7XG4gIGlmICh0cih0KSwgciA9IHRoaXMuX2V2ZW50cywgciA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAocyA9IHJbZV0sIHMgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHMgPT09IHQgfHwgcy5saXN0ZW5lciA9PT0gdClcbiAgICAtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwID8gdGhpcy5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkgOiAoZGVsZXRlIHJbZV0sIHIucmVtb3ZlTGlzdGVuZXIgJiYgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIiwgZSwgcy5saXN0ZW5lciB8fCB0KSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBzICE9IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobiA9IC0xLCBvID0gcy5sZW5ndGggLSAxOyBvID49IDA7IG8tLSlcbiAgICAgIGlmIChzW29dID09PSB0IHx8IHNbb10ubGlzdGVuZXIgPT09IHQpIHtcbiAgICAgICAgYyA9IHNbb10ubGlzdGVuZXIsIG4gPSBvO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBpZiAobiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBuID09PSAwID8gcy5zaGlmdCgpIDogcXUocywgbiksIHMubGVuZ3RoID09PSAxICYmIChyW2VdID0gc1swXSksIHIucmVtb3ZlTGlzdGVuZXIgIT09IHZvaWQgMCAmJiB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLCBlLCBjIHx8IHQpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbk9lLnByb3RvdHlwZS5vZmYgPSBPZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5PZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24oZSkge1xuICB2YXIgdCwgcywgcjtcbiAgaWYgKHMgPSB0aGlzLl9ldmVudHMsIHMgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHMucmVtb3ZlTGlzdGVuZXIgPT09IHZvaWQgMClcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/ICh0aGlzLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdGhpcy5fZXZlbnRzQ291bnQgPSAwKSA6IHNbZV0gIT09IHZvaWQgMCAmJiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCA/IHRoaXMuX2V2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpIDogZGVsZXRlIHNbZV0pLCB0aGlzO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBuID0gT2JqZWN0LmtleXMocyksIG87XG4gICAgZm9yIChyID0gMDsgciA8IG4ubGVuZ3RoOyArK3IpXG4gICAgICBvID0gbltyXSwgbyAhPT0gXCJyZW1vdmVMaXN0ZW5lclwiICYmIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKG8pO1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcInJlbW92ZUxpc3RlbmVyXCIpLCB0aGlzLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdGhpcy5fZXZlbnRzQ291bnQgPSAwLCB0aGlzO1xuICB9XG4gIGlmICh0ID0gc1tlXSwgdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKVxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZSwgdCk7XG4gIGVsc2UgaWYgKHQgIT09IHZvaWQgMClcbiAgICBmb3IgKHIgPSB0Lmxlbmd0aCAtIDE7IHIgPj0gMDsgci0tKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihlLCB0W3JdKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gWmEoaSwgZSwgdCkge1xuICB2YXIgcyA9IGkuX2V2ZW50cztcbiAgaWYgKHMgPT09IHZvaWQgMClcbiAgICByZXR1cm4gW107XG4gIHZhciByID0gc1tlXTtcbiAgcmV0dXJuIHIgPT09IHZvaWQgMCA/IFtdIDogdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gdCA/IFtyLmxpc3RlbmVyIHx8IHJdIDogW3JdIDogdCA/IGp1KHIpIDogdGMociwgci5sZW5ndGgpO1xufVxuT2UucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIFphKHRoaXMsIGUsICEwKTtcbn07XG5PZS5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gWmEodGhpcywgZSwgITEpO1xufTtcbk9lLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihpLCBlKSB7XG4gIHJldHVybiB0eXBlb2YgaS5saXN0ZW5lckNvdW50ID09IFwiZnVuY3Rpb25cIiA/IGkubGlzdGVuZXJDb3VudChlKSA6IGVjLmNhbGwoaSwgZSk7XG59O1xuT2UucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBlYztcbmZ1bmN0aW9uIGVjKGkpIHtcbiAgdmFyIGUgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChlICE9PSB2b2lkIDApIHtcbiAgICB2YXIgdCA9IGVbaV07XG4gICAgaWYgKHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiAxO1xuICAgIGlmICh0ICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gdC5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5PZS5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gcXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcbmZ1bmN0aW9uIHRjKGksIGUpIHtcbiAgZm9yICh2YXIgdCA9IG5ldyBBcnJheShlKSwgcyA9IDA7IHMgPCBlOyArK3MpXG4gICAgdFtzXSA9IGlbc107XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gcXUoaSwgZSkge1xuICBmb3IgKDsgZSArIDEgPCBpLmxlbmd0aDsgZSsrKVxuICAgIGlbZV0gPSBpW2UgKyAxXTtcbiAgaS5wb3AoKTtcbn1cbmZ1bmN0aW9uIGp1KGkpIHtcbiAgZm9yICh2YXIgZSA9IG5ldyBBcnJheShpLmxlbmd0aCksIHQgPSAwOyB0IDwgZS5sZW5ndGg7ICsrdClcbiAgICBlW3RdID0gaVt0XS5saXN0ZW5lciB8fCBpW3RdO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHp1KGksIGUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQsIHMpIHtcbiAgICBmdW5jdGlvbiByKG8pIHtcbiAgICAgIGkucmVtb3ZlTGlzdGVuZXIoZSwgbiksIHMobyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG4oKSB7XG4gICAgICB0eXBlb2YgaS5yZW1vdmVMaXN0ZW5lciA9PSBcImZ1bmN0aW9uXCIgJiYgaS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHIpLCB0KFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfVxuICAgIGljKGksIGUsIG4sIHsgb25jZTogITAgfSksIGUgIT09IFwiZXJyb3JcIiAmJiBLdShpLCByLCB7IG9uY2U6ICEwIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIEt1KGksIGUsIHQpIHtcbiAgdHlwZW9mIGkub24gPT0gXCJmdW5jdGlvblwiICYmIGljKGksIFwiZXJyb3JcIiwgZSwgdCk7XG59XG5mdW5jdGlvbiBpYyhpLCBlLCB0LCBzKSB7XG4gIGlmICh0eXBlb2YgaS5vbiA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcy5vbmNlID8gaS5vbmNlKGUsIHQpIDogaS5vbihlLCB0KTtcbiAgZWxzZSBpZiAodHlwZW9mIGkuYWRkRXZlbnRMaXN0ZW5lciA9PSBcImZ1bmN0aW9uXCIpXG4gICAgaS5hZGRFdmVudExpc3RlbmVyKGUsIGZ1bmN0aW9uIHIobikge1xuICAgICAgcy5vbmNlICYmIGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCByKSwgdChuKTtcbiAgICB9KTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgaSk7XG59XG52YXIgV2UgPSBzbi5leHBvcnRzO1xuY29uc3QgaXIgPSAvKiBAX19QVVJFX18gKi8gR2EoV2UpO1xudmFyIHNyID0ge30sIHNjID0geyBleHBvcnRzOiB7fSB9O1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4oZnVuY3Rpb24oaSkge1xuICB2YXIgZSwgdCwgcywgciwgbiwgbywgYywgdSwgZCwgcCwgYiwgeCwgTywgXywgQywgRiwgSywgSSwgRCwgeSwgdywgZiwgYTtcbiAgKGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgTCA9IHR5cGVvZiBtdCA9PSBcIm9iamVjdFwiID8gbXQgOiB0eXBlb2Ygc2VsZiA9PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XG4gICAgbCh2KEwsIHYoaS5leHBvcnRzKSkpO1xuICAgIGZ1bmN0aW9uIHYoUiwgJCkge1xuICAgICAgcmV0dXJuIFIgIT09IEwgJiYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09IFwiZnVuY3Rpb25cIiA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSkgOiBSLl9fZXNNb2R1bGUgPSAhMCksIGZ1bmN0aW9uKHEsIG0pIHtcbiAgICAgICAgcmV0dXJuIFJbcV0gPSAkID8gJChxLCBtKSA6IG07XG4gICAgICB9O1xuICAgIH1cbiAgfSkoZnVuY3Rpb24obCkge1xuICAgIHZhciBMID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24odiwgUikge1xuICAgICAgdi5fX3Byb3RvX18gPSBSO1xuICAgIH0gfHwgZnVuY3Rpb24odiwgUikge1xuICAgICAgZm9yICh2YXIgJCBpbiBSKVxuICAgICAgICBSLmhhc093blByb3BlcnR5KCQpICYmICh2WyRdID0gUlskXSk7XG4gICAgfTtcbiAgICBlID0gZnVuY3Rpb24odiwgUikge1xuICAgICAgTCh2LCBSKTtcbiAgICAgIGZ1bmN0aW9uICQoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSB2O1xuICAgICAgfVxuICAgICAgdi5wcm90b3R5cGUgPSBSID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShSKSA6ICgkLnByb3RvdHlwZSA9IFIucHJvdG90eXBlLCBuZXcgJCgpKTtcbiAgICB9LCB0ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih2KSB7XG4gICAgICBmb3IgKHZhciBSLCAkID0gMSwgcSA9IGFyZ3VtZW50cy5sZW5ndGg7ICQgPCBxOyAkKyspIHtcbiAgICAgICAgUiA9IGFyZ3VtZW50c1skXTtcbiAgICAgICAgZm9yICh2YXIgbSBpbiBSKVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChSLCBtKSAmJiAodlttXSA9IFJbbV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSwgcyA9IGZ1bmN0aW9uKHYsIFIpIHtcbiAgICAgIHZhciAkID0ge307XG4gICAgICBmb3IgKHZhciBxIGluIHYpXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2LCBxKSAmJiBSLmluZGV4T2YocSkgPCAwICYmICgkW3FdID0gdltxXSk7XG4gICAgICBpZiAodiAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgbSA9IDAsIHEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHYpOyBtIDwgcS5sZW5ndGg7IG0rKylcbiAgICAgICAgICBSLmluZGV4T2YocVttXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2LCBxW21dKSAmJiAoJFtxW21dXSA9IHZbcVttXV0pO1xuICAgICAgcmV0dXJuICQ7XG4gICAgfSwgciA9IGZ1bmN0aW9uKHYsIFIsICQsIHEpIHtcbiAgICAgIHZhciBtID0gYXJndW1lbnRzLmxlbmd0aCwgRSA9IG0gPCAzID8gUiA6IHEgPT09IG51bGwgPyBxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihSLCAkKSA6IHEsIEI7XG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIEUgPSBSZWZsZWN0LmRlY29yYXRlKHYsIFIsICQsIHEpO1xuICAgICAgZWxzZVxuICAgICAgICBmb3IgKHZhciB6ID0gdi5sZW5ndGggLSAxOyB6ID49IDA7IHotLSlcbiAgICAgICAgICAoQiA9IHZbel0pICYmIChFID0gKG0gPCAzID8gQihFKSA6IG0gPiAzID8gQihSLCAkLCBFKSA6IEIoUiwgJCkpIHx8IEUpO1xuICAgICAgcmV0dXJuIG0gPiAzICYmIEUgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KFIsICQsIEUpLCBFO1xuICAgIH0sIG4gPSBmdW5jdGlvbih2LCBSKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oJCwgcSkge1xuICAgICAgICBSKCQsIHEsIHYpO1xuICAgICAgfTtcbiAgICB9LCBvID0gZnVuY3Rpb24odiwgUikge1xuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YSh2LCBSKTtcbiAgICB9LCBjID0gZnVuY3Rpb24odiwgUiwgJCwgcSkge1xuICAgICAgZnVuY3Rpb24gbShFKSB7XG4gICAgICAgIHJldHVybiBFIGluc3RhbmNlb2YgJCA/IEUgOiBuZXcgJChmdW5jdGlvbihCKSB7XG4gICAgICAgICAgQihFKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3ICgkIHx8ICgkID0gUHJvbWlzZSkpKGZ1bmN0aW9uKEUsIEIpIHtcbiAgICAgICAgZnVuY3Rpb24geihNKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFUocS5uZXh0KE0pKTtcbiAgICAgICAgICB9IGNhdGNoIChIKSB7XG4gICAgICAgICAgICBCKEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBqKE0pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgVShxLnRocm93KE0pKTtcbiAgICAgICAgICB9IGNhdGNoIChIKSB7XG4gICAgICAgICAgICBCKEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBVKE0pIHtcbiAgICAgICAgICBNLmRvbmUgPyBFKE0udmFsdWUpIDogbShNLnZhbHVlKS50aGVuKHosIGopO1xuICAgICAgICB9XG4gICAgICAgIFUoKHEgPSBxLmFwcGx5KHYsIFIgfHwgW10pKS5uZXh0KCkpO1xuICAgICAgfSk7XG4gICAgfSwgdSA9IGZ1bmN0aW9uKHYsIFIpIHtcbiAgICAgIHZhciAkID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChFWzBdICYgMSlcbiAgICAgICAgICB0aHJvdyBFWzFdO1xuICAgICAgICByZXR1cm4gRVsxXTtcbiAgICAgIH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIHEsIG0sIEUsIEI7XG4gICAgICByZXR1cm4gQiA9IHsgbmV4dDogeigwKSwgdGhyb3c6IHooMSksIHJldHVybjogeigyKSB9LCB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiAoQltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSksIEI7XG4gICAgICBmdW5jdGlvbiB6KFUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICByZXR1cm4gaihbVSwgTV0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaihVKSB7XG4gICAgICAgIGlmIChxKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICBmb3IgKDsgJDsgKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocSA9IDEsIG0gJiYgKEUgPSBVWzBdICYgMiA/IG0ucmV0dXJuIDogVVswXSA/IG0udGhyb3cgfHwgKChFID0gbS5yZXR1cm4pICYmIEUuY2FsbChtKSwgMCkgOiBtLm5leHQpICYmICEoRSA9IEUuY2FsbChtLCBVWzFdKSkuZG9uZSlcbiAgICAgICAgICAgICAgcmV0dXJuIEU7XG4gICAgICAgICAgICBzd2l0Y2ggKG0gPSAwLCBFICYmIChVID0gW1VbMF0gJiAyLCBFLnZhbHVlXSksIFVbMF0pIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgRSA9IFU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5sYWJlbCsrLCB7IHZhbHVlOiBVWzFdLCBkb25lOiAhMSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgJC5sYWJlbCsrLCBtID0gVVsxXSwgVSA9IFswXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIFUgPSAkLm9wcy5wb3AoKSwgJC50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChFID0gJC50cnlzLCAhKEUgPSBFLmxlbmd0aCA+IDAgJiYgRVtFLmxlbmd0aCAtIDFdKSAmJiAoVVswXSA9PT0gNiB8fCBVWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgJCA9IDA7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFVbMF0gPT09IDMgJiYgKCFFIHx8IFVbMV0gPiBFWzBdICYmIFVbMV0gPCBFWzNdKSkge1xuICAgICAgICAgICAgICAgICAgJC5sYWJlbCA9IFVbMV07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFVbMF0gPT09IDYgJiYgJC5sYWJlbCA8IEVbMV0pIHtcbiAgICAgICAgICAgICAgICAgICQubGFiZWwgPSBFWzFdLCBFID0gVTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoRSAmJiAkLmxhYmVsIDwgRVsyXSkge1xuICAgICAgICAgICAgICAgICAgJC5sYWJlbCA9IEVbMl0sICQub3BzLnB1c2goVSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgRVsyXSAmJiAkLm9wcy5wb3AoKSwgJC50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVSA9IFIuY2FsbCh2LCAkKTtcbiAgICAgICAgICB9IGNhdGNoIChNKSB7XG4gICAgICAgICAgICBVID0gWzYsIE1dLCBtID0gMDtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcSA9IEUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKFVbMF0gJiA1KVxuICAgICAgICAgIHRocm93IFVbMV07XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBVWzBdID8gVVsxXSA6IHZvaWQgMCwgZG9uZTogITAgfTtcbiAgICAgIH1cbiAgICB9LCBhID0gZnVuY3Rpb24odiwgUiwgJCwgcSkge1xuICAgICAgcSA9PT0gdm9pZCAwICYmIChxID0gJCksIHZbcV0gPSBSWyRdO1xuICAgIH0sIGQgPSBmdW5jdGlvbih2LCBSKSB7XG4gICAgICBmb3IgKHZhciAkIGluIHYpXG4gICAgICAgICQgIT09IFwiZGVmYXVsdFwiICYmICFSLmhhc093blByb3BlcnR5KCQpICYmIChSWyRdID0gdlskXSk7XG4gICAgfSwgcCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciBSID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCAkID0gUiAmJiB2W1JdLCBxID0gMDtcbiAgICAgIGlmICgkKVxuICAgICAgICByZXR1cm4gJC5jYWxsKHYpO1xuICAgICAgaWYgKHYgJiYgdHlwZW9mIHYubGVuZ3RoID09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdiAmJiBxID49IHYubGVuZ3RoICYmICh2ID0gdm9pZCAwKSwgeyB2YWx1ZTogdiAmJiB2W3ErK10sIGRvbmU6ICF2IH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihSID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIH0sIGIgPSBmdW5jdGlvbih2LCBSKSB7XG4gICAgICB2YXIgJCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHZbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgIGlmICghJClcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB2YXIgcSA9ICQuY2FsbCh2KSwgbSwgRSA9IFtdLCBCO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7IChSID09PSB2b2lkIDAgfHwgUi0tID4gMCkgJiYgIShtID0gcS5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICBFLnB1c2gobS52YWx1ZSk7XG4gICAgICB9IGNhdGNoICh6KSB7XG4gICAgICAgIEIgPSB7IGVycm9yOiB6IH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG0gJiYgIW0uZG9uZSAmJiAoJCA9IHEucmV0dXJuKSAmJiAkLmNhbGwocSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKEIpXG4gICAgICAgICAgICB0aHJvdyBCLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gRTtcbiAgICB9LCB4ID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciB2ID0gW10sIFIgPSAwOyBSIDwgYXJndW1lbnRzLmxlbmd0aDsgUisrKVxuICAgICAgICB2ID0gdi5jb25jYXQoYihhcmd1bWVudHNbUl0pKTtcbiAgICAgIHJldHVybiB2O1xuICAgIH0sIE8gPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHYgPSAwLCBSID0gMCwgJCA9IGFyZ3VtZW50cy5sZW5ndGg7IFIgPCAkOyBSKyspXG4gICAgICAgIHYgKz0gYXJndW1lbnRzW1JdLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIHEgPSBBcnJheSh2KSwgbSA9IDAsIFIgPSAwOyBSIDwgJDsgUisrKVxuICAgICAgICBmb3IgKHZhciBFID0gYXJndW1lbnRzW1JdLCBCID0gMCwgeiA9IEUubGVuZ3RoOyBCIDwgejsgQisrLCBtKyspXG4gICAgICAgICAgcVttXSA9IEVbQl07XG4gICAgICByZXR1cm4gcTtcbiAgICB9LCBfID0gZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF8odik7XG4gICAgfSwgQyA9IGZ1bmN0aW9uKHYsIFIsICQpIHtcbiAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICB2YXIgcSA9ICQuYXBwbHkodiwgUiB8fCBbXSksIG0sIEUgPSBbXTtcbiAgICAgIHJldHVybiBtID0ge30sIEIoXCJuZXh0XCIpLCBCKFwidGhyb3dcIiksIEIoXCJyZXR1cm5cIiksIG1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgbTtcbiAgICAgIGZ1bmN0aW9uIEIodGUpIHtcbiAgICAgICAgcVt0ZV0gJiYgKG1bdGVdID0gZnVuY3Rpb24oRykge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihpZSwgUSkge1xuICAgICAgICAgICAgRS5wdXNoKFt0ZSwgRywgaWUsIFFdKSA+IDEgfHwgeih0ZSwgRyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geih0ZSwgRykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGoocVt0ZV0oRykpO1xuICAgICAgICB9IGNhdGNoIChpZSkge1xuICAgICAgICAgIEgoRVswXVszXSwgaWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBqKHRlKSB7XG4gICAgICAgIHRlLnZhbHVlIGluc3RhbmNlb2YgXyA/IFByb21pc2UucmVzb2x2ZSh0ZS52YWx1ZS52KS50aGVuKFUsIE0pIDogSChFWzBdWzJdLCB0ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBVKHRlKSB7XG4gICAgICAgIHooXCJuZXh0XCIsIHRlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIE0odGUpIHtcbiAgICAgICAgeihcInRocm93XCIsIHRlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEgodGUsIEcpIHtcbiAgICAgICAgdGUoRyksIEUuc2hpZnQoKSwgRS5sZW5ndGggJiYgeihFWzBdWzBdLCBFWzBdWzFdKTtcbiAgICAgIH1cbiAgICB9LCBGID0gZnVuY3Rpb24odikge1xuICAgICAgdmFyIFIsICQ7XG4gICAgICByZXR1cm4gUiA9IHt9LCBxKFwibmV4dFwiKSwgcShcInRocm93XCIsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdGhyb3cgbTtcbiAgICAgIH0pLCBxKFwicmV0dXJuXCIpLCBSW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCBSO1xuICAgICAgZnVuY3Rpb24gcShtLCBFKSB7XG4gICAgICAgIFJbbV0gPSB2W21dID8gZnVuY3Rpb24oQikge1xuICAgICAgICAgIHJldHVybiAoJCA9ICEkKSA/IHsgdmFsdWU6IF8odlttXShCKSksIGRvbmU6IG0gPT09IFwicmV0dXJuXCIgfSA6IEUgPyBFKEIpIDogQjtcbiAgICAgICAgfSA6IEU7XG4gICAgICB9XG4gICAgfSwgSyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICB2YXIgUiA9IHZbU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCAkO1xuICAgICAgcmV0dXJuIFIgPyBSLmNhbGwodikgOiAodiA9IHR5cGVvZiBwID09IFwiZnVuY3Rpb25cIiA/IHAodikgOiB2W1N5bWJvbC5pdGVyYXRvcl0oKSwgJCA9IHt9LCBxKFwibmV4dFwiKSwgcShcInRocm93XCIpLCBxKFwicmV0dXJuXCIpLCAkW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sICQpO1xuICAgICAgZnVuY3Rpb24gcShFKSB7XG4gICAgICAgICRbRV0gPSB2W0VdICYmIGZ1bmN0aW9uKEIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oeiwgaikge1xuICAgICAgICAgICAgQiA9IHZbRV0oQiksIG0oeiwgaiwgQi5kb25lLCBCLnZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG0oRSwgQiwgeiwgaikge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoaikudGhlbihmdW5jdGlvbihVKSB7XG4gICAgICAgICAgRSh7IHZhbHVlOiBVLCBkb25lOiB6IH0pO1xuICAgICAgICB9LCBCKTtcbiAgICAgIH1cbiAgICB9LCBJID0gZnVuY3Rpb24odiwgUikge1xuICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2LCBcInJhd1wiLCB7IHZhbHVlOiBSIH0pIDogdi5yYXcgPSBSLCB2O1xuICAgIH0sIEQgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAodiAmJiB2Ll9fZXNNb2R1bGUpXG4gICAgICAgIHJldHVybiB2O1xuICAgICAgdmFyIFIgPSB7fTtcbiAgICAgIGlmICh2ICE9IG51bGwpXG4gICAgICAgIGZvciAodmFyICQgaW4gdilcbiAgICAgICAgICBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh2LCAkKSAmJiAoUlskXSA9IHZbJF0pO1xuICAgICAgcmV0dXJuIFIuZGVmYXVsdCA9IHYsIFI7XG4gICAgfSwgeSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2ICYmIHYuX19lc01vZHVsZSA/IHYgOiB7IGRlZmF1bHQ6IHYgfTtcbiAgICB9LCB3ID0gZnVuY3Rpb24odiwgUikge1xuICAgICAgaWYgKCFSLmhhcyh2KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XG4gICAgICByZXR1cm4gUi5nZXQodik7XG4gICAgfSwgZiA9IGZ1bmN0aW9uKHYsIFIsICQpIHtcbiAgICAgIGlmICghUi5oYXModikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xuICAgICAgcmV0dXJuIFIuc2V0KHYsICQpLCAkO1xuICAgIH0sIGwoXCJfX2V4dGVuZHNcIiwgZSksIGwoXCJfX2Fzc2lnblwiLCB0KSwgbChcIl9fcmVzdFwiLCBzKSwgbChcIl9fZGVjb3JhdGVcIiwgciksIGwoXCJfX3BhcmFtXCIsIG4pLCBsKFwiX19tZXRhZGF0YVwiLCBvKSwgbChcIl9fYXdhaXRlclwiLCBjKSwgbChcIl9fZ2VuZXJhdG9yXCIsIHUpLCBsKFwiX19leHBvcnRTdGFyXCIsIGQpLCBsKFwiX19jcmVhdGVCaW5kaW5nXCIsIGEpLCBsKFwiX192YWx1ZXNcIiwgcCksIGwoXCJfX3JlYWRcIiwgYiksIGwoXCJfX3NwcmVhZFwiLCB4KSwgbChcIl9fc3ByZWFkQXJyYXlzXCIsIE8pLCBsKFwiX19hd2FpdFwiLCBfKSwgbChcIl9fYXN5bmNHZW5lcmF0b3JcIiwgQyksIGwoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIEYpLCBsKFwiX19hc3luY1ZhbHVlc1wiLCBLKSwgbChcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIEkpLCBsKFwiX19pbXBvcnRTdGFyXCIsIEQpLCBsKFwiX19pbXBvcnREZWZhdWx0XCIsIHkpLCBsKFwiX19jbGFzc1ByaXZhdGVGaWVsZEdldFwiLCB3KSwgbChcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgZik7XG4gIH0pO1xufSkoc2MpO1xudmFyIEZ0ID0gc2MuZXhwb3J0cywgZnMgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuZnVuY3Rpb24gVnUoaSkge1xuICBpZiAodHlwZW9mIGkgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzYWZlIGpzb24gcGFyc2UgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBpfWApO1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGkpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gaTtcbiAgfVxufVxuZnMuc2FmZUpzb25QYXJzZSA9IFZ1O1xuZnVuY3Rpb24gQnUoaSkge1xuICByZXR1cm4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IGkgOiBKU09OLnN0cmluZ2lmeShpLCAoZSwgdCkgPT4gdHlwZW9mIHQgPiBcInVcIiA/IG51bGwgOiB0KTtcbn1cbmZzLnNhZmVKc29uU3RyaW5naWZ5ID0gQnU7XG52YXIga2kgPSB7IGV4cG9ydHM6IHt9IH0sIEhuO1xuZnVuY3Rpb24ga3UoKSB7XG4gIHJldHVybiBIbiB8fCAoSG4gPSAxLCBmdW5jdGlvbigpIHtcbiAgICBsZXQgaTtcbiAgICBmdW5jdGlvbiBlKCkge1xuICAgIH1cbiAgICBpID0gZSwgaS5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc093blByb3BlcnR5KHQpID8gU3RyaW5nKHRoaXNbdF0pIDogbnVsbDtcbiAgICB9LCBpLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24odCwgcykge1xuICAgICAgdGhpc1t0XSA9IFN0cmluZyhzKTtcbiAgICB9LCBpLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24odCkge1xuICAgICAgZGVsZXRlIHRoaXNbdF07XG4gICAgfSwgaS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzO1xuICAgICAgT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICAgIHRbc10gPSB2b2lkIDAsIGRlbGV0ZSB0W3NdO1xuICAgICAgfSk7XG4gICAgfSwgaS5wcm90b3R5cGUua2V5ID0gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHQgPSB0IHx8IDAsIE9iamVjdC5rZXlzKHRoaXMpW3RdO1xuICAgIH0sIGkucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oXCJsZW5ndGhcIiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcykubGVuZ3RoO1xuICAgIH0pLCB0eXBlb2YgbXQgPCBcInVcIiAmJiBtdC5sb2NhbFN0b3JhZ2UgPyBraS5leHBvcnRzID0gbXQubG9jYWxTdG9yYWdlIDogdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UgPyBraS5leHBvcnRzID0gd2luZG93LmxvY2FsU3RvcmFnZSA6IGtpLmV4cG9ydHMgPSBuZXcgZSgpO1xuICB9KCkpLCBraS5leHBvcnRzO1xufVxudmFyIHlyID0ge30sIEhpID0ge30sIEduO1xuZnVuY3Rpb24gSHUoKSB7XG4gIGlmIChHbilcbiAgICByZXR1cm4gSGk7XG4gIEduID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEhpLklLZXlWYWx1ZVN0b3JhZ2UgPSB2b2lkIDA7XG4gIGNsYXNzIGkge1xuICB9XG4gIHJldHVybiBIaS5JS2V5VmFsdWVTdG9yYWdlID0gaSwgSGk7XG59XG52YXIgR2kgPSB7fSwgV247XG5mdW5jdGlvbiBHdSgpIHtcbiAgaWYgKFduKVxuICAgIHJldHVybiBHaTtcbiAgV24gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoR2ksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgR2kucGFyc2VFbnRyeSA9IHZvaWQgMDtcbiAgY29uc3QgaSA9IGZzO1xuICBmdW5jdGlvbiBlKHQpIHtcbiAgICB2YXIgcztcbiAgICByZXR1cm4gW3RbMF0sIGkuc2FmZUpzb25QYXJzZSgocyA9IHRbMV0pICE9PSBudWxsICYmIHMgIT09IHZvaWQgMCA/IHMgOiBcIlwiKV07XG4gIH1cbiAgcmV0dXJuIEdpLnBhcnNlRW50cnkgPSBlLCBHaTtcbn1cbnZhciBZbjtcbmZ1bmN0aW9uIFd1KCkge1xuICByZXR1cm4gWW4gfHwgKFluID0gMSwgZnVuY3Rpb24oaSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gICAgY29uc3QgZSA9IEZ0O1xuICAgIGUuX19leHBvcnRTdGFyKEh1KCksIGkpLCBlLl9fZXhwb3J0U3RhcihHdSgpLCBpKTtcbiAgfSh5cikpLCB5cjtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzciwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuc3IuS2V5VmFsdWVTdG9yYWdlID0gdm9pZCAwO1xuY29uc3QgQ2kgPSBGdCwgSm4gPSBmcywgWXUgPSBDaS5fX2ltcG9ydERlZmF1bHQoa3UoKSksIEp1ID0gV3UoKTtcbmNsYXNzIHJjIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBZdS5kZWZhdWx0O1xuICB9XG4gIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIENpLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmxvY2FsU3RvcmFnZSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0RW50cmllcygpIHtcbiAgICByZXR1cm4gQ2kuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMubG9jYWxTdG9yYWdlKS5tYXAoSnUucGFyc2VFbnRyeSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0SXRlbShlKSB7XG4gICAgcmV0dXJuIENpLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGUpO1xuICAgICAgaWYgKHQgIT09IG51bGwpXG4gICAgICAgIHJldHVybiBKbi5zYWZlSnNvblBhcnNlKHQpO1xuICAgIH0pO1xuICB9XG4gIHNldEl0ZW0oZSwgdCkge1xuICAgIHJldHVybiBDaS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGUsIEpuLnNhZmVKc29uU3RyaW5naWZ5KHQpKTtcbiAgICB9KTtcbiAgfVxuICByZW1vdmVJdGVtKGUpIHtcbiAgICByZXR1cm4gQ2kuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShlKTtcbiAgICB9KTtcbiAgfVxufVxuc3IuS2V5VmFsdWVTdG9yYWdlID0gcmM7XG52YXIgbmMgPSBzci5kZWZhdWx0ID0gcmMsIFd0ID0ge30sIFdpID0ge30sIFYgPSB7fSwgbXIgPSB7fSwgWWkgPSB7fSwgUW47XG5mdW5jdGlvbiBRdSgpIHtcbiAgaWYgKFFuKVxuICAgIHJldHVybiBZaTtcbiAgUW4gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoWWksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgWWkuZGVsYXkgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIGkoZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHQoITApO1xuICAgICAgfSwgZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFlpLmRlbGF5ID0gaSwgWWk7XG59XG52YXIgbWkgPSB7fSwgYnIgPSB7fSwgYmkgPSB7fSwgWG47XG5mdW5jdGlvbiBYdSgpIHtcbiAgcmV0dXJuIFhuIHx8IChYbiA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBiaS5PTkVfVEhPVVNBTkQgPSBiaS5PTkVfSFVORFJFRCA9IHZvaWQgMCwgYmkuT05FX0hVTkRSRUQgPSAxMDAsIGJpLk9ORV9USE9VU0FORCA9IDFlMyksIGJpO1xufVxudmFyIHdyID0ge30sIFpuO1xuZnVuY3Rpb24gWnUoKSB7XG4gIHJldHVybiBabiB8fCAoWm4gPSAxLCBmdW5jdGlvbihpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgaS5PTkVfWUVBUiA9IGkuRk9VUl9XRUVLUyA9IGkuVEhSRUVfV0VFS1MgPSBpLlRXT19XRUVLUyA9IGkuT05FX1dFRUsgPSBpLlRISVJUWV9EQVlTID0gaS5TRVZFTl9EQVlTID0gaS5GSVZFX0RBWVMgPSBpLlRIUkVFX0RBWVMgPSBpLk9ORV9EQVkgPSBpLlRXRU5UWV9GT1VSX0hPVVJTID0gaS5UV0VMVkVfSE9VUlMgPSBpLlNJWF9IT1VSUyA9IGkuVEhSRUVfSE9VUlMgPSBpLk9ORV9IT1VSID0gaS5TSVhUWV9NSU5VVEVTID0gaS5USElSVFlfTUlOVVRFUyA9IGkuVEVOX01JTlVURVMgPSBpLkZJVkVfTUlOVVRFUyA9IGkuT05FX01JTlVURSA9IGkuU0lYVFlfU0VDT05EUyA9IGkuVEhJUlRZX1NFQ09ORFMgPSBpLlRFTl9TRUNPTkRTID0gaS5GSVZFX1NFQ09ORFMgPSBpLk9ORV9TRUNPTkQgPSB2b2lkIDAsIGkuT05FX1NFQ09ORCA9IDEsIGkuRklWRV9TRUNPTkRTID0gNSwgaS5URU5fU0VDT05EUyA9IDEwLCBpLlRISVJUWV9TRUNPTkRTID0gMzAsIGkuU0lYVFlfU0VDT05EUyA9IDYwLCBpLk9ORV9NSU5VVEUgPSBpLlNJWFRZX1NFQ09ORFMsIGkuRklWRV9NSU5VVEVTID0gaS5PTkVfTUlOVVRFICogNSwgaS5URU5fTUlOVVRFUyA9IGkuT05FX01JTlVURSAqIDEwLCBpLlRISVJUWV9NSU5VVEVTID0gaS5PTkVfTUlOVVRFICogMzAsIGkuU0lYVFlfTUlOVVRFUyA9IGkuT05FX01JTlVURSAqIDYwLCBpLk9ORV9IT1VSID0gaS5TSVhUWV9NSU5VVEVTLCBpLlRIUkVFX0hPVVJTID0gaS5PTkVfSE9VUiAqIDMsIGkuU0lYX0hPVVJTID0gaS5PTkVfSE9VUiAqIDYsIGkuVFdFTFZFX0hPVVJTID0gaS5PTkVfSE9VUiAqIDEyLCBpLlRXRU5UWV9GT1VSX0hPVVJTID0gaS5PTkVfSE9VUiAqIDI0LCBpLk9ORV9EQVkgPSBpLlRXRU5UWV9GT1VSX0hPVVJTLCBpLlRIUkVFX0RBWVMgPSBpLk9ORV9EQVkgKiAzLCBpLkZJVkVfREFZUyA9IGkuT05FX0RBWSAqIDUsIGkuU0VWRU5fREFZUyA9IGkuT05FX0RBWSAqIDcsIGkuVEhJUlRZX0RBWVMgPSBpLk9ORV9EQVkgKiAzMCwgaS5PTkVfV0VFSyA9IGkuU0VWRU5fREFZUywgaS5UV09fV0VFS1MgPSBpLk9ORV9XRUVLICogMiwgaS5USFJFRV9XRUVLUyA9IGkuT05FX1dFRUsgKiAzLCBpLkZPVVJfV0VFS1MgPSBpLk9ORV9XRUVLICogNCwgaS5PTkVfWUVBUiA9IGkuT05FX0RBWSAqIDM2NTtcbiAgfSh3cikpLCB3cjtcbn1cbnZhciBlbztcbmZ1bmN0aW9uIG9jKCkge1xuICByZXR1cm4gZW8gfHwgKGVvID0gMSwgZnVuY3Rpb24oaSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gICAgY29uc3QgZSA9IEZ0O1xuICAgIGUuX19leHBvcnRTdGFyKFh1KCksIGkpLCBlLl9fZXhwb3J0U3RhcihadSgpLCBpKTtcbiAgfShicikpLCBicjtcbn1cbnZhciB0bztcbmZ1bmN0aW9uIGVsKCkge1xuICBpZiAodG8pXG4gICAgcmV0dXJuIG1pO1xuICB0byA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBtaS5mcm9tTWlsaXNlY29uZHMgPSBtaS50b01pbGlzZWNvbmRzID0gdm9pZCAwO1xuICBjb25zdCBpID0gb2MoKTtcbiAgZnVuY3Rpb24gZShzKSB7XG4gICAgcmV0dXJuIHMgKiBpLk9ORV9USE9VU0FORDtcbiAgfVxuICBtaS50b01pbGlzZWNvbmRzID0gZTtcbiAgZnVuY3Rpb24gdChzKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IocyAvIGkuT05FX1RIT1VTQU5EKTtcbiAgfVxuICByZXR1cm4gbWkuZnJvbU1pbGlzZWNvbmRzID0gdCwgbWk7XG59XG52YXIgaW87XG5mdW5jdGlvbiB0bCgpIHtcbiAgcmV0dXJuIGlvIHx8IChpbyA9IDEsIGZ1bmN0aW9uKGkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICAgIGNvbnN0IGUgPSBGdDtcbiAgICBlLl9fZXhwb3J0U3RhcihRdSgpLCBpKSwgZS5fX2V4cG9ydFN0YXIoZWwoKSwgaSk7XG4gIH0obXIpKSwgbXI7XG59XG52YXIgUmkgPSB7fSwgc287XG5mdW5jdGlvbiBpbCgpIHtcbiAgaWYgKHNvKVxuICAgIHJldHVybiBSaTtcbiAgc28gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgUmkuV2F0Y2ggPSB2b2lkIDA7XG4gIGNsYXNzIGkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy50aW1lc3RhbXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgc3RhcnQodCkge1xuICAgICAgaWYgKHRoaXMudGltZXN0YW1wcy5oYXModCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV2F0Y2ggYWxyZWFkeSBzdGFydGVkIGZvciBsYWJlbDogJHt0fWApO1xuICAgICAgdGhpcy50aW1lc3RhbXBzLnNldCh0LCB7IHN0YXJ0ZWQ6IERhdGUubm93KCkgfSk7XG4gICAgfVxuICAgIHN0b3AodCkge1xuICAgICAgY29uc3QgcyA9IHRoaXMuZ2V0KHQpO1xuICAgICAgaWYgKHR5cGVvZiBzLmVsYXBzZWQgPCBcInVcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXYXRjaCBhbHJlYWR5IHN0b3BwZWQgZm9yIGxhYmVsOiAke3R9YCk7XG4gICAgICBjb25zdCByID0gRGF0ZS5ub3coKSAtIHMuc3RhcnRlZDtcbiAgICAgIHRoaXMudGltZXN0YW1wcy5zZXQodCwgeyBzdGFydGVkOiBzLnN0YXJ0ZWQsIGVsYXBzZWQ6IHIgfSk7XG4gICAgfVxuICAgIGdldCh0KSB7XG4gICAgICBjb25zdCBzID0gdGhpcy50aW1lc3RhbXBzLmdldCh0KTtcbiAgICAgIGlmICh0eXBlb2YgcyA+IFwidVwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHRpbWVzdGFtcCBmb3VuZCBmb3IgbGFiZWw6ICR7dH1gKTtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBlbGFwc2VkKHQpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmdldCh0KTtcbiAgICAgIHJldHVybiBzLmVsYXBzZWQgfHwgRGF0ZS5ub3coKSAtIHMuc3RhcnRlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJpLldhdGNoID0gaSwgUmkuZGVmYXVsdCA9IGksIFJpO1xufVxudmFyIHZyID0ge30sIEppID0ge30sIHJvO1xuZnVuY3Rpb24gc2woKSB7XG4gIGlmIChybylcbiAgICByZXR1cm4gSmk7XG4gIHJvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEppLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEppLklXYXRjaCA9IHZvaWQgMDtcbiAgY2xhc3MgaSB7XG4gIH1cbiAgcmV0dXJuIEppLklXYXRjaCA9IGksIEppO1xufVxudmFyIG5vO1xuZnVuY3Rpb24gcmwoKSB7XG4gIHJldHVybiBubyB8fCAobm8gPSAxLCBmdW5jdGlvbihpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgRnQuX19leHBvcnRTdGFyKHNsKCksIGkpO1xuICB9KHZyKSksIHZyO1xufVxuKGZ1bmN0aW9uKGkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgY29uc3QgZSA9IEZ0O1xuICBlLl9fZXhwb3J0U3Rhcih0bCgpLCBpKSwgZS5fX2V4cG9ydFN0YXIoaWwoKSwgaSksIGUuX19leHBvcnRTdGFyKHJsKCksIGkpLCBlLl9fZXhwb3J0U3RhcihvYygpLCBpKTtcbn0pKFYpO1xudmFyIF9yID0ge30sIFFpID0ge307XG5sZXQgTnQgPSBjbGFzcyB7XG59O1xuY29uc3QgbmwgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBJRXZlbnRzOiBOdFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgb2wgPSAvKiBAX19QVVJFX18gKi8gV2EobmwpO1xudmFyIG9vO1xuZnVuY3Rpb24gYWwoKSB7XG4gIGlmIChvbylcbiAgICByZXR1cm4gUWk7XG4gIG9vID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFFpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFFpLklIZWFydEJlYXQgPSB2b2lkIDA7XG4gIGNvbnN0IGkgPSBvbDtcbiAgY2xhc3MgZSBleHRlbmRzIGkuSUV2ZW50cyB7XG4gICAgY29uc3RydWN0b3Iocykge1xuICAgICAgc3VwZXIoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFFpLklIZWFydEJlYXQgPSBlLCBRaTtcbn1cbnZhciBhbztcbmZ1bmN0aW9uIGFjKCkge1xuICByZXR1cm4gYW8gfHwgKGFvID0gMSwgZnVuY3Rpb24oaSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEZ0Ll9fZXhwb3J0U3RhcihhbCgpLCBpKTtcbiAgfShfcikpLCBfcjtcbn1cbnZhciBFciA9IHt9LCB3aSA9IHt9LCBjbztcbmZ1bmN0aW9uIGNsKCkge1xuICBpZiAoY28pXG4gICAgcmV0dXJuIHdpO1xuICBjbyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB3aS5IRUFSVEJFQVRfRVZFTlRTID0gd2kuSEVBUlRCRUFUX0lOVEVSVkFMID0gdm9pZCAwO1xuICBjb25zdCBpID0gVjtcbiAgcmV0dXJuIHdpLkhFQVJUQkVBVF9JTlRFUlZBTCA9IGkuRklWRV9TRUNPTkRTLCB3aS5IRUFSVEJFQVRfRVZFTlRTID0ge1xuICAgIHB1bHNlOiBcImhlYXJ0YmVhdF9wdWxzZVwiXG4gIH0sIHdpO1xufVxudmFyIGhvO1xuZnVuY3Rpb24gY2MoKSB7XG4gIHJldHVybiBobyB8fCAoaG8gPSAxLCBmdW5jdGlvbihpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgRnQuX19leHBvcnRTdGFyKGNsKCksIGkpO1xuICB9KEVyKSksIEVyO1xufVxudmFyIHVvO1xuZnVuY3Rpb24gaGwoKSB7XG4gIGlmICh1bylcbiAgICByZXR1cm4gV2k7XG4gIHVvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFdpLkhlYXJ0QmVhdCA9IHZvaWQgMDtcbiAgY29uc3QgaSA9IEZ0LCBlID0gV2UsIHQgPSBWLCBzID0gYWMoKSwgciA9IGNjKCk7XG4gIGNsYXNzIG4gZXh0ZW5kcyBzLklIZWFydEJlYXQge1xuICAgIGNvbnN0cnVjdG9yKGMpIHtcbiAgICAgIHN1cGVyKGMpLCB0aGlzLmV2ZW50cyA9IG5ldyBlLkV2ZW50RW1pdHRlcigpLCB0aGlzLmludGVydmFsID0gci5IRUFSVEJFQVRfSU5URVJWQUwsIHRoaXMuaW50ZXJ2YWwgPSBjPy5pbnRlcnZhbCB8fCByLkhFQVJUQkVBVF9JTlRFUlZBTDtcbiAgICB9XG4gICAgc3RhdGljIGluaXQoYykge1xuICAgICAgcmV0dXJuIGkuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCB1ID0gbmV3IG4oYyk7XG4gICAgICAgIHJldHVybiB5aWVsZCB1LmluaXQoKSwgdTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgcmV0dXJuIGkuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB5aWVsZCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsUmVmKTtcbiAgICB9XG4gICAgb24oYywgdSkge1xuICAgICAgdGhpcy5ldmVudHMub24oYywgdSk7XG4gICAgfVxuICAgIG9uY2UoYywgdSkge1xuICAgICAgdGhpcy5ldmVudHMub25jZShjLCB1KTtcbiAgICB9XG4gICAgb2ZmKGMsIHUpIHtcbiAgICAgIHRoaXMuZXZlbnRzLm9mZihjLCB1KTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoYywgdSkge1xuICAgICAgdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIoYywgdSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICByZXR1cm4gaS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxSZWYgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnB1bHNlKCksIHQudG9NaWxpc2Vjb25kcyh0aGlzLmludGVydmFsKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHVsc2UoKSB7XG4gICAgICB0aGlzLmV2ZW50cy5lbWl0KHIuSEVBUlRCRUFUX0VWRU5UUy5wdWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBXaS5IZWFydEJlYXQgPSBuLCBXaTtcbn1cbihmdW5jdGlvbihpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIGNvbnN0IGUgPSBGdDtcbiAgZS5fX2V4cG9ydFN0YXIoaGwoKSwgaSksIGUuX19leHBvcnRTdGFyKGFjKCksIGkpLCBlLl9fZXhwb3J0U3RhcihjYygpLCBpKTtcbn0pKFd0KTtcbnZhciBlZSA9IHt9LCBTciwgbG87XG5mdW5jdGlvbiB1bCgpIHtcbiAgaWYgKGxvKVxuICAgIHJldHVybiBTcjtcbiAgbG8gPSAxO1xuICBmdW5jdGlvbiBpKHQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHQpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuICdcIltDaXJjdWxhcl1cIic7XG4gICAgfVxuICB9XG4gIFNyID0gZTtcbiAgZnVuY3Rpb24gZSh0LCBzLCByKSB7XG4gICAgdmFyIG4gPSByICYmIHIuc3RyaW5naWZ5IHx8IGksIG8gPSAxO1xuICAgIGlmICh0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgIT09IG51bGwpIHtcbiAgICAgIHZhciBjID0gcy5sZW5ndGggKyBvO1xuICAgICAgaWYgKGMgPT09IDEpXG4gICAgICAgIHJldHVybiB0O1xuICAgICAgdmFyIHUgPSBuZXcgQXJyYXkoYyk7XG4gICAgICB1WzBdID0gbih0KTtcbiAgICAgIGZvciAodmFyIGQgPSAxOyBkIDwgYzsgZCsrKVxuICAgICAgICB1W2RdID0gbihzW2RdKTtcbiAgICAgIHJldHVybiB1LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB0O1xuICAgIHZhciBwID0gcy5sZW5ndGg7XG4gICAgaWYgKHAgPT09IDApXG4gICAgICByZXR1cm4gdDtcbiAgICBmb3IgKHZhciBiID0gXCJcIiwgeCA9IDEgLSBvLCBPID0gLTEsIF8gPSB0ICYmIHQubGVuZ3RoIHx8IDAsIEMgPSAwOyBDIDwgXzsgKSB7XG4gICAgICBpZiAodC5jaGFyQ29kZUF0KEMpID09PSAzNyAmJiBDICsgMSA8IF8pIHtcbiAgICAgICAgc3dpdGNoIChPID0gTyA+IC0xID8gTyA6IDAsIHQuY2hhckNvZGVBdChDICsgMSkpIHtcbiAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICBjYXNlIDEwMjpcbiAgICAgICAgICAgIGlmICh4ID49IHAgfHwgc1t4XSA9PSBudWxsKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIE8gPCBDICYmIChiICs9IHQuc2xpY2UoTywgQykpLCBiICs9IE51bWJlcihzW3hdKSwgTyA9IEMgKyAyLCBDKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEwNTpcbiAgICAgICAgICAgIGlmICh4ID49IHAgfHwgc1t4XSA9PSBudWxsKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIE8gPCBDICYmIChiICs9IHQuc2xpY2UoTywgQykpLCBiICs9IE1hdGguZmxvb3IoTnVtYmVyKHNbeF0pKSwgTyA9IEMgKyAyLCBDKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc5OlxuICAgICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgIGNhc2UgMTA2OlxuICAgICAgICAgICAgaWYgKHggPj0gcCB8fCBzW3hdID09PSB2b2lkIDApXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgTyA8IEMgJiYgKGIgKz0gdC5zbGljZShPLCBDKSk7XG4gICAgICAgICAgICB2YXIgRiA9IHR5cGVvZiBzW3hdO1xuICAgICAgICAgICAgaWYgKEYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgYiArPSBcIidcIiArIHNbeF0gKyBcIidcIiwgTyA9IEMgKyAyLCBDKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBiICs9IHNbeF0ubmFtZSB8fCBcIjxhbm9ueW1vdXM+XCIsIE8gPSBDICsgMiwgQysrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgKz0gbihzW3hdKSwgTyA9IEMgKyAyLCBDKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgIGlmICh4ID49IHApXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgTyA8IEMgJiYgKGIgKz0gdC5zbGljZShPLCBDKSksIGIgKz0gU3RyaW5nKHNbeF0pLCBPID0gQyArIDIsIEMrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICBPIDwgQyAmJiAoYiArPSB0LnNsaWNlKE8sIEMpKSwgYiArPSBcIiVcIiwgTyA9IEMgKyAyLCBDKyssIHgtLTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgICsreDtcbiAgICAgIH1cbiAgICAgICsrQztcbiAgICB9XG4gICAgcmV0dXJuIE8gPT09IC0xID8gdCA6IChPIDwgXyAmJiAoYiArPSB0LnNsaWNlKE8pKSwgYik7XG4gIH1cbiAgcmV0dXJuIFNyO1xufVxudmFyIElyLCBmbztcbmZ1bmN0aW9uIGxsKCkge1xuICBpZiAoZm8pXG4gICAgcmV0dXJuIElyO1xuICBmbyA9IDE7XG4gIGNvbnN0IGkgPSB1bCgpO1xuICBJciA9IHI7XG4gIGNvbnN0IGUgPSB3KCkuY29uc29sZSB8fCB7fSwgdCA9IHtcbiAgICBtYXBIdHRwUmVxdWVzdDogXyxcbiAgICBtYXBIdHRwUmVzcG9uc2U6IF8sXG4gICAgd3JhcFJlcXVlc3RTZXJpYWxpemVyOiBDLFxuICAgIHdyYXBSZXNwb25zZVNlcmlhbGl6ZXI6IEMsXG4gICAgd3JhcEVycm9yU2VyaWFsaXplcjogQyxcbiAgICByZXE6IF8sXG4gICAgcmVzOiBfLFxuICAgIGVycjogeFxuICB9O1xuICBmdW5jdGlvbiBzKGYsIGEpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShmKSA/IGYuZmlsdGVyKGZ1bmN0aW9uKEwpIHtcbiAgICAgIHJldHVybiBMICE9PSBcIiFzdGRTZXJpYWxpemVycy5lcnJcIjtcbiAgICB9KSA6IGYgPT09ICEwID8gT2JqZWN0LmtleXMoYSkgOiAhMTtcbiAgfVxuICBmdW5jdGlvbiByKGYpIHtcbiAgICBmID0gZiB8fCB7fSwgZi5icm93c2VyID0gZi5icm93c2VyIHx8IHt9O1xuICAgIGNvbnN0IGEgPSBmLmJyb3dzZXIudHJhbnNtaXQ7XG4gICAgaWYgKGEgJiYgdHlwZW9mIGEuc2VuZCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBFcnJvcihcInBpbm86IHRyYW5zbWl0IG9wdGlvbiBtdXN0IGhhdmUgYSBzZW5kIGZ1bmN0aW9uXCIpO1xuICAgIGNvbnN0IGwgPSBmLmJyb3dzZXIud3JpdGUgfHwgZTtcbiAgICBmLmJyb3dzZXIud3JpdGUgJiYgKGYuYnJvd3Nlci5hc09iamVjdCA9ICEwKTtcbiAgICBjb25zdCBMID0gZi5zZXJpYWxpemVycyB8fCB7fSwgdiA9IHMoZi5icm93c2VyLnNlcmlhbGl6ZSwgTCk7XG4gICAgbGV0IFIgPSBmLmJyb3dzZXIuc2VyaWFsaXplO1xuICAgIEFycmF5LmlzQXJyYXkoZi5icm93c2VyLnNlcmlhbGl6ZSkgJiYgZi5icm93c2VyLnNlcmlhbGl6ZS5pbmRleE9mKFwiIXN0ZFNlcmlhbGl6ZXJzLmVyclwiKSA+IC0xICYmIChSID0gITEpO1xuICAgIGNvbnN0ICQgPSBbXCJlcnJvclwiLCBcImZhdGFsXCIsIFwid2FyblwiLCBcImluZm9cIiwgXCJkZWJ1Z1wiLCBcInRyYWNlXCJdO1xuICAgIHR5cGVvZiBsID09IFwiZnVuY3Rpb25cIiAmJiAobC5lcnJvciA9IGwuZmF0YWwgPSBsLndhcm4gPSBsLmluZm8gPSBsLmRlYnVnID0gbC50cmFjZSA9IGwpLCBmLmVuYWJsZWQgPT09ICExICYmIChmLmxldmVsID0gXCJzaWxlbnRcIik7XG4gICAgY29uc3QgcSA9IGYubGV2ZWwgfHwgXCJpbmZvXCIsIG0gPSBPYmplY3QuY3JlYXRlKGwpO1xuICAgIG0ubG9nIHx8IChtLmxvZyA9IEYpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobSwgXCJsZXZlbFZhbFwiLCB7XG4gICAgICBnZXQ6IEJcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG0sIFwibGV2ZWxcIiwge1xuICAgICAgZ2V0OiB6LFxuICAgICAgc2V0OiBqXG4gICAgfSk7XG4gICAgY29uc3QgRSA9IHtcbiAgICAgIHRyYW5zbWl0OiBhLFxuICAgICAgc2VyaWFsaXplOiB2LFxuICAgICAgYXNPYmplY3Q6IGYuYnJvd3Nlci5hc09iamVjdCxcbiAgICAgIGxldmVsczogJCxcbiAgICAgIHRpbWVzdGFtcDogTyhmKVxuICAgIH07XG4gICAgbS5sZXZlbHMgPSByLmxldmVscywgbS5sZXZlbCA9IHEsIG0uc2V0TWF4TGlzdGVuZXJzID0gbS5nZXRNYXhMaXN0ZW5lcnMgPSBtLmVtaXQgPSBtLmFkZExpc3RlbmVyID0gbS5vbiA9IG0ucHJlcGVuZExpc3RlbmVyID0gbS5vbmNlID0gbS5wcmVwZW5kT25jZUxpc3RlbmVyID0gbS5yZW1vdmVMaXN0ZW5lciA9IG0ucmVtb3ZlQWxsTGlzdGVuZXJzID0gbS5saXN0ZW5lcnMgPSBtLmxpc3RlbmVyQ291bnQgPSBtLmV2ZW50TmFtZXMgPSBtLndyaXRlID0gbS5mbHVzaCA9IEYsIG0uc2VyaWFsaXplcnMgPSBMLCBtLl9zZXJpYWxpemUgPSB2LCBtLl9zdGRFcnJTZXJpYWxpemUgPSBSLCBtLmNoaWxkID0gVSwgYSAmJiAobS5fbG9nRXZlbnQgPSBiKCkpO1xuICAgIGZ1bmN0aW9uIEIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXZlbCA9PT0gXCJzaWxlbnRcIiA/IDEgLyAwIDogdGhpcy5sZXZlbHMudmFsdWVzW3RoaXMubGV2ZWxdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xldmVsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqKE0pIHtcbiAgICAgIGlmIChNICE9PSBcInNpbGVudFwiICYmICF0aGlzLmxldmVscy52YWx1ZXNbTV0pXG4gICAgICAgIHRocm93IEVycm9yKFwidW5rbm93biBsZXZlbCBcIiArIE0pO1xuICAgICAgdGhpcy5fbGV2ZWwgPSBNLCBuKEUsIG0sIFwiZXJyb3JcIiwgXCJsb2dcIiksIG4oRSwgbSwgXCJmYXRhbFwiLCBcImVycm9yXCIpLCBuKEUsIG0sIFwid2FyblwiLCBcImVycm9yXCIpLCBuKEUsIG0sIFwiaW5mb1wiLCBcImxvZ1wiKSwgbihFLCBtLCBcImRlYnVnXCIsIFwibG9nXCIpLCBuKEUsIG0sIFwidHJhY2VcIiwgXCJsb2dcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFUoTSwgSCkge1xuICAgICAgaWYgKCFNKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGJpbmRpbmdzIGZvciBjaGlsZCBQaW5vXCIpO1xuICAgICAgSCA9IEggfHwge30sIHYgJiYgTS5zZXJpYWxpemVycyAmJiAoSC5zZXJpYWxpemVycyA9IE0uc2VyaWFsaXplcnMpO1xuICAgICAgY29uc3QgdGUgPSBILnNlcmlhbGl6ZXJzO1xuICAgICAgaWYgKHYgJiYgdGUpIHtcbiAgICAgICAgdmFyIEcgPSBPYmplY3QuYXNzaWduKHt9LCBMLCB0ZSksIGllID0gZi5icm93c2VyLnNlcmlhbGl6ZSA9PT0gITAgPyBPYmplY3Qua2V5cyhHKSA6IHY7XG4gICAgICAgIGRlbGV0ZSBNLnNlcmlhbGl6ZXJzLCB1KFtNXSwgaWUsIEcsIHRoaXMuX3N0ZEVyclNlcmlhbGl6ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBRKHNlKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkTGV2ZWwgPSAoc2UuX2NoaWxkTGV2ZWwgfCAwKSArIDEsIHRoaXMuZXJyb3IgPSBkKHNlLCBNLCBcImVycm9yXCIpLCB0aGlzLmZhdGFsID0gZChzZSwgTSwgXCJmYXRhbFwiKSwgdGhpcy53YXJuID0gZChzZSwgTSwgXCJ3YXJuXCIpLCB0aGlzLmluZm8gPSBkKHNlLCBNLCBcImluZm9cIiksIHRoaXMuZGVidWcgPSBkKHNlLCBNLCBcImRlYnVnXCIpLCB0aGlzLnRyYWNlID0gZChzZSwgTSwgXCJ0cmFjZVwiKSwgRyAmJiAodGhpcy5zZXJpYWxpemVycyA9IEcsIHRoaXMuX3NlcmlhbGl6ZSA9IGllKSwgYSAmJiAodGhpcy5fbG9nRXZlbnQgPSBiKFxuICAgICAgICAgIFtdLmNvbmNhdChzZS5fbG9nRXZlbnQuYmluZGluZ3MsIE0pXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFEucHJvdG90eXBlID0gdGhpcywgbmV3IFEodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9XG4gIHIubGV2ZWxzID0ge1xuICAgIHZhbHVlczoge1xuICAgICAgZmF0YWw6IDYwLFxuICAgICAgZXJyb3I6IDUwLFxuICAgICAgd2FybjogNDAsXG4gICAgICBpbmZvOiAzMCxcbiAgICAgIGRlYnVnOiAyMCxcbiAgICAgIHRyYWNlOiAxMFxuICAgIH0sXG4gICAgbGFiZWxzOiB7XG4gICAgICAxMDogXCJ0cmFjZVwiLFxuICAgICAgMjA6IFwiZGVidWdcIixcbiAgICAgIDMwOiBcImluZm9cIixcbiAgICAgIDQwOiBcIndhcm5cIixcbiAgICAgIDUwOiBcImVycm9yXCIsXG4gICAgICA2MDogXCJmYXRhbFwiXG4gICAgfVxuICB9LCByLnN0ZFNlcmlhbGl6ZXJzID0gdCwgci5zdGRUaW1lRnVuY3Rpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgeyBudWxsVGltZTogSywgZXBvY2hUaW1lOiBJLCB1bml4VGltZTogRCwgaXNvVGltZTogeSB9KTtcbiAgZnVuY3Rpb24gbihmLCBhLCBsLCBMKSB7XG4gICAgY29uc3QgdiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhKTtcbiAgICBhW2xdID0gYS5sZXZlbFZhbCA+IGEubGV2ZWxzLnZhbHVlc1tsXSA/IEYgOiB2W2xdID8gdltsXSA6IGVbbF0gfHwgZVtMXSB8fCBGLCBvKGYsIGEsIGwpO1xuICB9XG4gIGZ1bmN0aW9uIG8oZiwgYSwgbCkge1xuICAgICFmLnRyYW5zbWl0ICYmIGFbbF0gPT09IEYgfHwgKGFbbF0gPSBmdW5jdGlvbihMKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IFIgPSBmLnRpbWVzdGFtcCgpLCAkID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpLCBxID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSA9PT0gZSA/IGUgOiB0aGlzO1xuICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8ICQubGVuZ3RoOyBtKyspXG4gICAgICAgICAgJFttXSA9IGFyZ3VtZW50c1ttXTtcbiAgICAgICAgaWYgKGYuc2VyaWFsaXplICYmICFmLmFzT2JqZWN0ICYmIHUoJCwgdGhpcy5fc2VyaWFsaXplLCB0aGlzLnNlcmlhbGl6ZXJzLCB0aGlzLl9zdGRFcnJTZXJpYWxpemUpLCBmLmFzT2JqZWN0ID8gTC5jYWxsKHEsIGModGhpcywgbCwgJCwgUikpIDogTC5hcHBseShxLCAkKSwgZi50cmFuc21pdCkge1xuICAgICAgICAgIGNvbnN0IEUgPSBmLnRyYW5zbWl0LmxldmVsIHx8IGEubGV2ZWwsIEIgPSByLmxldmVscy52YWx1ZXNbRV0sIHogPSByLmxldmVscy52YWx1ZXNbbF07XG4gICAgICAgICAgaWYgKHogPCBCKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHAodGhpcywge1xuICAgICAgICAgICAgdHM6IFIsXG4gICAgICAgICAgICBtZXRob2RMZXZlbDogbCxcbiAgICAgICAgICAgIG1ldGhvZFZhbHVlOiB6LFxuICAgICAgICAgICAgdHJhbnNtaXRMZXZlbDogRSxcbiAgICAgICAgICAgIHRyYW5zbWl0VmFsdWU6IHIubGV2ZWxzLnZhbHVlc1tmLnRyYW5zbWl0LmxldmVsIHx8IGEubGV2ZWxdLFxuICAgICAgICAgICAgc2VuZDogZi50cmFuc21pdC5zZW5kLFxuICAgICAgICAgICAgdmFsOiBhLmxldmVsVmFsXG4gICAgICAgICAgfSwgJCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfShhW2xdKSk7XG4gIH1cbiAgZnVuY3Rpb24gYyhmLCBhLCBsLCBMKSB7XG4gICAgZi5fc2VyaWFsaXplICYmIHUobCwgZi5fc2VyaWFsaXplLCBmLnNlcmlhbGl6ZXJzLCBmLl9zdGRFcnJTZXJpYWxpemUpO1xuICAgIGNvbnN0IHYgPSBsLnNsaWNlKCk7XG4gICAgbGV0IFIgPSB2WzBdO1xuICAgIGNvbnN0ICQgPSB7fTtcbiAgICBMICYmICgkLnRpbWUgPSBMKSwgJC5sZXZlbCA9IHIubGV2ZWxzLnZhbHVlc1thXTtcbiAgICBsZXQgcSA9IChmLl9jaGlsZExldmVsIHwgMCkgKyAxO1xuICAgIGlmIChxIDwgMSAmJiAocSA9IDEpLCBSICE9PSBudWxsICYmIHR5cGVvZiBSID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZvciAoOyBxLS0gJiYgdHlwZW9mIHZbMF0gPT0gXCJvYmplY3RcIjsgKVxuICAgICAgICBPYmplY3QuYXNzaWduKCQsIHYuc2hpZnQoKSk7XG4gICAgICBSID0gdi5sZW5ndGggPyBpKHYuc2hpZnQoKSwgdikgOiB2b2lkIDA7XG4gICAgfSBlbHNlXG4gICAgICB0eXBlb2YgUiA9PSBcInN0cmluZ1wiICYmIChSID0gaSh2LnNoaWZ0KCksIHYpKTtcbiAgICByZXR1cm4gUiAhPT0gdm9pZCAwICYmICgkLm1zZyA9IFIpLCAkO1xuICB9XG4gIGZ1bmN0aW9uIHUoZiwgYSwgbCwgTCkge1xuICAgIGZvciAoY29uc3QgdiBpbiBmKVxuICAgICAgaWYgKEwgJiYgZlt2XSBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICBmW3ZdID0gci5zdGRTZXJpYWxpemVycy5lcnIoZlt2XSk7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZlt2XSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGZbdl0pKVxuICAgICAgICBmb3IgKGNvbnN0IFIgaW4gZlt2XSlcbiAgICAgICAgICBhICYmIGEuaW5kZXhPZihSKSA+IC0xICYmIFIgaW4gbCAmJiAoZlt2XVtSXSA9IGxbUl0oZlt2XVtSXSkpO1xuICB9XG4gIGZ1bmN0aW9uIGQoZiwgYSwgbCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IEwgPSBuZXcgQXJyYXkoMSArIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgTFswXSA9IGE7XG4gICAgICBmb3IgKHZhciB2ID0gMTsgdiA8IEwubGVuZ3RoOyB2KyspXG4gICAgICAgIExbdl0gPSBhcmd1bWVudHNbdiAtIDFdO1xuICAgICAgcmV0dXJuIGZbbF0uYXBwbHkodGhpcywgTCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBwKGYsIGEsIGwpIHtcbiAgICBjb25zdCBMID0gYS5zZW5kLCB2ID0gYS50cywgUiA9IGEubWV0aG9kTGV2ZWwsICQgPSBhLm1ldGhvZFZhbHVlLCBxID0gYS52YWwsIG0gPSBmLl9sb2dFdmVudC5iaW5kaW5ncztcbiAgICB1KFxuICAgICAgbCxcbiAgICAgIGYuX3NlcmlhbGl6ZSB8fCBPYmplY3Qua2V5cyhmLnNlcmlhbGl6ZXJzKSxcbiAgICAgIGYuc2VyaWFsaXplcnMsXG4gICAgICBmLl9zdGRFcnJTZXJpYWxpemUgPT09IHZvaWQgMCA/ICEwIDogZi5fc3RkRXJyU2VyaWFsaXplXG4gICAgKSwgZi5fbG9nRXZlbnQudHMgPSB2LCBmLl9sb2dFdmVudC5tZXNzYWdlcyA9IGwuZmlsdGVyKGZ1bmN0aW9uKEUpIHtcbiAgICAgIHJldHVybiBtLmluZGV4T2YoRSkgPT09IC0xO1xuICAgIH0pLCBmLl9sb2dFdmVudC5sZXZlbC5sYWJlbCA9IFIsIGYuX2xvZ0V2ZW50LmxldmVsLnZhbHVlID0gJCwgTChSLCBmLl9sb2dFdmVudCwgcSksIGYuX2xvZ0V2ZW50ID0gYihtKTtcbiAgfVxuICBmdW5jdGlvbiBiKGYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHM6IDAsXG4gICAgICBtZXNzYWdlczogW10sXG4gICAgICBiaW5kaW5nczogZiB8fCBbXSxcbiAgICAgIGxldmVsOiB7IGxhYmVsOiBcIlwiLCB2YWx1ZTogMCB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB4KGYpIHtcbiAgICBjb25zdCBhID0ge1xuICAgICAgdHlwZTogZi5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgbXNnOiBmLm1lc3NhZ2UsXG4gICAgICBzdGFjazogZi5zdGFja1xuICAgIH07XG4gICAgZm9yIChjb25zdCBsIGluIGYpXG4gICAgICBhW2xdID09PSB2b2lkIDAgJiYgKGFbbF0gPSBmW2xdKTtcbiAgICByZXR1cm4gYTtcbiAgfVxuICBmdW5jdGlvbiBPKGYpIHtcbiAgICByZXR1cm4gdHlwZW9mIGYudGltZXN0YW1wID09IFwiZnVuY3Rpb25cIiA/IGYudGltZXN0YW1wIDogZi50aW1lc3RhbXAgPT09ICExID8gSyA6IEk7XG4gIH1cbiAgZnVuY3Rpb24gXygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgZnVuY3Rpb24gQyhmKSB7XG4gICAgcmV0dXJuIGY7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHtcbiAgfVxuICBmdW5jdGlvbiBLKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBmdW5jdGlvbiBJKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9XG4gIGZ1bmN0aW9uIEQoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyk7XG4gIH1cbiAgZnVuY3Rpb24geSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5ub3coKSkudG9JU09TdHJpbmcoKTtcbiAgfVxuICBmdW5jdGlvbiB3KCkge1xuICAgIGZ1bmN0aW9uIGYoYSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBhIDwgXCJ1XCIgJiYgYTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCBcImdsb2JhbFRoaXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5nbG9iYWxUaGlzLCB0aGlzLmdsb2JhbFRoaXMgPSB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KSwgZ2xvYmFsVGhpcztcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmKHNlbGYpIHx8IGYod2luZG93KSB8fCBmKHRoaXMpIHx8IHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gSXI7XG59XG52YXIgdmkgPSB7fSwgcG87XG5mdW5jdGlvbiBoYygpIHtcbiAgcmV0dXJuIHBvIHx8IChwbyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2aSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB2aS5QSU5PX0NVU1RPTV9DT05URVhUX0tFWSA9IHZpLlBJTk9fTE9HR0VSX0RFRkFVTFRTID0gdm9pZCAwLCB2aS5QSU5PX0xPR0dFUl9ERUZBVUxUUyA9IHtcbiAgICBsZXZlbDogXCJpbmZvXCJcbiAgfSwgdmkuUElOT19DVVNUT01fQ09OVEVYVF9LRVkgPSBcImN1c3RvbV9jb250ZXh0XCIpLCB2aTtcbn1cbnZhciB5dCA9IHt9LCBnbztcbmZ1bmN0aW9uIGRsKCkge1xuICBpZiAoZ28pXG4gICAgcmV0dXJuIHl0O1xuICBnbyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh5dCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB5dC5nZW5lcmF0ZUNoaWxkTG9nZ2VyID0geXQuZm9ybWF0Q2hpbGRMb2dnZXJDb250ZXh0ID0geXQuZ2V0TG9nZ2VyQ29udGV4dCA9IHl0LnNldEJyb3dzZXJMb2dnZXJDb250ZXh0ID0geXQuZ2V0QnJvd3NlckxvZ2dlckNvbnRleHQgPSB5dC5nZXREZWZhdWx0TG9nZ2VyT3B0aW9ucyA9IHZvaWQgMDtcbiAgY29uc3QgaSA9IGhjKCk7XG4gIGZ1bmN0aW9uIGUoYykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGMpLCB7IGxldmVsOiBjPy5sZXZlbCB8fCBpLlBJTk9fTE9HR0VSX0RFRkFVTFRTLmxldmVsIH0pO1xuICB9XG4gIHl0LmdldERlZmF1bHRMb2dnZXJPcHRpb25zID0gZTtcbiAgZnVuY3Rpb24gdChjLCB1ID0gaS5QSU5PX0NVU1RPTV9DT05URVhUX0tFWSkge1xuICAgIHJldHVybiBjW3VdIHx8IFwiXCI7XG4gIH1cbiAgeXQuZ2V0QnJvd3NlckxvZ2dlckNvbnRleHQgPSB0O1xuICBmdW5jdGlvbiBzKGMsIHUsIGQgPSBpLlBJTk9fQ1VTVE9NX0NPTlRFWFRfS0VZKSB7XG4gICAgcmV0dXJuIGNbZF0gPSB1LCBjO1xuICB9XG4gIHl0LnNldEJyb3dzZXJMb2dnZXJDb250ZXh0ID0gcztcbiAgZnVuY3Rpb24gcihjLCB1ID0gaS5QSU5PX0NVU1RPTV9DT05URVhUX0tFWSkge1xuICAgIGxldCBkID0gXCJcIjtcbiAgICByZXR1cm4gdHlwZW9mIGMuYmluZGluZ3MgPiBcInVcIiA/IGQgPSB0KGMsIHUpIDogZCA9IGMuYmluZGluZ3MoKS5jb250ZXh0IHx8IFwiXCIsIGQ7XG4gIH1cbiAgeXQuZ2V0TG9nZ2VyQ29udGV4dCA9IHI7XG4gIGZ1bmN0aW9uIG4oYywgdSwgZCA9IGkuUElOT19DVVNUT01fQ09OVEVYVF9LRVkpIHtcbiAgICBjb25zdCBwID0gcihjLCBkKTtcbiAgICByZXR1cm4gcC50cmltKCkgPyBgJHtwfS8ke3V9YCA6IHU7XG4gIH1cbiAgeXQuZm9ybWF0Q2hpbGRMb2dnZXJDb250ZXh0ID0gbjtcbiAgZnVuY3Rpb24gbyhjLCB1LCBkID0gaS5QSU5PX0NVU1RPTV9DT05URVhUX0tFWSkge1xuICAgIGNvbnN0IHAgPSBuKGMsIHUsIGQpLCBiID0gYy5jaGlsZCh7IGNvbnRleHQ6IHAgfSk7XG4gICAgcmV0dXJuIHMoYiwgcCwgZCk7XG4gIH1cbiAgcmV0dXJuIHl0LmdlbmVyYXRlQ2hpbGRMb2dnZXIgPSBvLCB5dDtcbn1cbihmdW5jdGlvbihpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGkucGlubyA9IHZvaWQgMDtcbiAgY29uc3QgZSA9IEZ0LCB0ID0gZS5fX2ltcG9ydERlZmF1bHQobGwoKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcInBpbm9cIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5kZWZhdWx0O1xuICB9IH0pLCBlLl9fZXhwb3J0U3RhcihoYygpLCBpKSwgZS5fX2V4cG9ydFN0YXIoZGwoKSwgaSk7XG59KShlZSk7XG5sZXQgZmwgPSBjbGFzcyBleHRlbmRzIE50IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMub3B0cyA9IGUsIHRoaXMucHJvdG9jb2wgPSBcIndjXCIsIHRoaXMudmVyc2lvbiA9IDI7XG4gIH1cbn0sIHBsID0gY2xhc3MgZXh0ZW5kcyBOdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMucmVjb3JkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbn0sIGdsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy5sb2dnZXIgPSBlLCB0aGlzLmNvcmUgPSB0O1xuICB9XG59LCB5bCA9IGNsYXNzIGV4dGVuZHMgTnQge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5yZWxheWVyID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59LCBtbCA9IGNsYXNzIGV4dGVuZHMgTnQge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufSwgYmwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMsIHIpIHtcbiAgICB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMubmFtZSA9IHM7XG4gIH1cbn0sIHdsID0gY2xhc3MgZXh0ZW5kcyBOdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLnJlbGF5ZXIgPSBlLCB0aGlzLmxvZ2dlciA9IHQ7XG4gIH1cbn0sIHZsID0gY2xhc3MgZXh0ZW5kcyBOdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQ7XG4gIH1cbn0sIF9sID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy5wcm9qZWN0SWQgPSBlLCB0aGlzLmxvZ2dlciA9IHQ7XG4gIH1cbn0sIEVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5vcHRzID0gZSwgdGhpcy5wcm90b2NvbCA9IFwid2NcIiwgdGhpcy52ZXJzaW9uID0gMjtcbiAgfVxufSwgU2wgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmNsaWVudCA9IGU7XG4gIH1cbn07XG5jb25zdCBJbCA9IChpKSA9PiBKU09OLnN0cmluZ2lmeShpLCAoZSwgdCkgPT4gdHlwZW9mIHQgPT0gXCJiaWdpbnRcIiA/IHQudG9TdHJpbmcoKSArIFwiblwiIDogdCksIERsID0gKGkpID0+IHtcbiAgY29uc3QgZSA9IC8oW1xcWzpdKT8oXFxkezE3LH18KD86WzldKD86WzEtOV0wNzE5OTI1NDc0MDk5MXwwWzEtOV03MTk5MjU0NzQwOTkxfDAwWzgtOV0xOTkyNTQ3NDA5OTF8MDA3WzItOV05OTI1NDc0MDk5MXwwMDcxOTlbMy05XTU0NzQwOTkxfDAwNzE5OTJbNi05XTQ3NDA5OTF8MDA3MTk5MjVbNS05XTc0MDk5MXwwMDcxOTkyNTRbOC05XTQwOTkxfDAwNzE5OTI1NDdbNS05XTA5OTF8MDA3MTk5MjU0NzRbMS05XTk5MXwwMDcxOTkyNTQ3NDA5OVsyLTldKSkpKFssXFx9XFxdXSkvZywgdCA9IGkucmVwbGFjZShlLCAnJDFcIiQyblwiJDMnKTtcbiAgcmV0dXJuIEpTT04ucGFyc2UodCwgKHMsIHIpID0+IHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgci5tYXRjaCgvXlxcZCtuJC8pID8gQmlnSW50KHIuc3Vic3RyaW5nKDAsIHIubGVuZ3RoIC0gMSkpIDogcik7XG59O1xuZnVuY3Rpb24gcm4oaSkge1xuICBpZiAodHlwZW9mIGkgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzYWZlIGpzb24gcGFyc2UgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBpfWApO1xuICB0cnkge1xuICAgIHJldHVybiBEbChpKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJyKGkpIHtcbiAgcmV0dXJuIHR5cGVvZiBpID09IFwic3RyaW5nXCIgPyBpIDogSWwoaSkgfHwgXCJcIjtcbn1cbnZhciBubiA9IHt9LCBsaSA9IHt9LCBuciA9IHt9LCBvciA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5vci5Ccm93c2VyUmFuZG9tU291cmNlID0gdm9pZCAwO1xuY29uc3QgeW8gPSA2NTUzNjtcbmNsYXNzIHhsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pc0F2YWlsYWJsZSA9ICExLCB0aGlzLmlzSW5zdGFudGlhdGVkID0gITE7XG4gICAgY29uc3QgZSA9IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmLmNyeXB0byB8fCBzZWxmLm1zQ3J5cHRvIDogbnVsbDtcbiAgICBlICYmIGUuZ2V0UmFuZG9tVmFsdWVzICE9PSB2b2lkIDAgJiYgKHRoaXMuX2NyeXB0byA9IGUsIHRoaXMuaXNBdmFpbGFibGUgPSAhMCwgdGhpcy5pc0luc3RhbnRpYXRlZCA9ICEwKTtcbiAgfVxuICByYW5kb21CeXRlcyhlKSB7XG4gICAgaWYgKCF0aGlzLmlzQXZhaWxhYmxlIHx8ICF0aGlzLl9jcnlwdG8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyIHJhbmRvbSBieXRlIGdlbmVyYXRvciBpcyBub3QgYXZhaWxhYmxlLlwiKTtcbiAgICBjb25zdCB0ID0gbmV3IFVpbnQ4QXJyYXkoZSk7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcyArPSB5bylcbiAgICAgIHRoaXMuX2NyeXB0by5nZXRSYW5kb21WYWx1ZXModC5zdWJhcnJheShzLCBzICsgTWF0aC5taW4odC5sZW5ndGggLSBzLCB5bykpKTtcbiAgICByZXR1cm4gdDtcbiAgfVxufVxub3IuQnJvd3NlclJhbmRvbVNvdXJjZSA9IHhsO1xuZnVuY3Rpb24gT2woaSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkeW5hbWljYWxseSByZXF1aXJlIFwiJyArIGkgKyAnXCIuIFBsZWFzZSBjb25maWd1cmUgdGhlIGR5bmFtaWNSZXF1aXJlVGFyZ2V0cyBvci9hbmQgaWdub3JlRHluYW1pY1JlcXVpcmVzIG9wdGlvbiBvZiBAcm9sbHVwL3BsdWdpbi1jb21tb25qcyBhcHByb3ByaWF0ZWx5IGZvciB0aGlzIHJlcXVpcmUgY2FsbCB0byB3b3JrLicpO1xufVxudmFyIGFyID0ge30sIFB0ID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmZ1bmN0aW9uIE5sKGkpIHtcbiAgZm9yICh2YXIgZSA9IDA7IGUgPCBpLmxlbmd0aDsgZSsrKVxuICAgIGlbZV0gPSAwO1xuICByZXR1cm4gaTtcbn1cblB0LndpcGUgPSBObDtcbmNvbnN0IFBsID0ge30sIFJsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZGVmYXVsdDogUGxcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIENsID0gLyogQF9fUFVSRV9fICovIFdhKFJsKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhciwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuYXIuTm9kZVJhbmRvbVNvdXJjZSA9IHZvaWQgMDtcbmNvbnN0IEFsID0gUHQ7XG5jbGFzcyBUbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmlzQXZhaWxhYmxlID0gITEsIHRoaXMuaXNJbnN0YW50aWF0ZWQgPSAhMSwgdHlwZW9mIE9sIDwgXCJ1XCIpIHtcbiAgICAgIGNvbnN0IGUgPSBDbDtcbiAgICAgIGUgJiYgZS5yYW5kb21CeXRlcyAmJiAodGhpcy5fY3J5cHRvID0gZSwgdGhpcy5pc0F2YWlsYWJsZSA9ICEwLCB0aGlzLmlzSW5zdGFudGlhdGVkID0gITApO1xuICAgIH1cbiAgfVxuICByYW5kb21CeXRlcyhlKSB7XG4gICAgaWYgKCF0aGlzLmlzQXZhaWxhYmxlIHx8ICF0aGlzLl9jcnlwdG8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlLmpzIHJhbmRvbSBieXRlIGdlbmVyYXRvciBpcyBub3QgYXZhaWxhYmxlLlwiKTtcbiAgICBsZXQgdCA9IHRoaXMuX2NyeXB0by5yYW5kb21CeXRlcyhlKTtcbiAgICBpZiAodC5sZW5ndGggIT09IGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlUmFuZG9tU291cmNlOiBnb3QgZmV3ZXIgYnl0ZXMgdGhhbiByZXF1ZXN0ZWRcIik7XG4gICAgY29uc3QgcyA9IG5ldyBVaW50OEFycmF5KGUpO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgcy5sZW5ndGg7IHIrKylcbiAgICAgIHNbcl0gPSB0W3JdO1xuICAgIHJldHVybiAoMCwgQWwud2lwZSkodCksIHM7XG4gIH1cbn1cbmFyLk5vZGVSYW5kb21Tb3VyY2UgPSBUbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShuciwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xubnIuU3lzdGVtUmFuZG9tU291cmNlID0gdm9pZCAwO1xuY29uc3QgJGwgPSBvciwgRmwgPSBhcjtcbmNsYXNzIFVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHRoaXMuaXNBdmFpbGFibGUgPSAhMSwgdGhpcy5uYW1lID0gXCJcIiwgdGhpcy5fc291cmNlID0gbmV3ICRsLkJyb3dzZXJSYW5kb21Tb3VyY2UoKSwgdGhpcy5fc291cmNlLmlzQXZhaWxhYmxlKSB7XG4gICAgICB0aGlzLmlzQXZhaWxhYmxlID0gITAsIHRoaXMubmFtZSA9IFwiQnJvd3NlclwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlID0gbmV3IEZsLk5vZGVSYW5kb21Tb3VyY2UoKSwgdGhpcy5fc291cmNlLmlzQXZhaWxhYmxlKSB7XG4gICAgICB0aGlzLmlzQXZhaWxhYmxlID0gITAsIHRoaXMubmFtZSA9IFwiTm9kZVwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByYW5kb21CeXRlcyhlKSB7XG4gICAgaWYgKCF0aGlzLmlzQXZhaWxhYmxlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3lzdGVtIHJhbmRvbSBieXRlIGdlbmVyYXRvciBpcyBub3QgYXZhaWxhYmxlLlwiKTtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlLnJhbmRvbUJ5dGVzKGUpO1xuICB9XG59XG5uci5TeXN0ZW1SYW5kb21Tb3VyY2UgPSBVbDtcbnZhciBvZSA9IHt9LCB1YyA9IHt9O1xuKGZ1bmN0aW9uKGkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgZnVuY3Rpb24gZShjLCB1KSB7XG4gICAgdmFyIGQgPSBjID4+PiAxNiAmIDY1NTM1LCBwID0gYyAmIDY1NTM1LCBiID0gdSA+Pj4gMTYgJiA2NTUzNSwgeCA9IHUgJiA2NTUzNTtcbiAgICByZXR1cm4gcCAqIHggKyAoZCAqIHggKyBwICogYiA8PCAxNiA+Pj4gMCkgfCAwO1xuICB9XG4gIGkubXVsID0gTWF0aC5pbXVsIHx8IGU7XG4gIGZ1bmN0aW9uIHQoYywgdSkge1xuICAgIHJldHVybiBjICsgdSB8IDA7XG4gIH1cbiAgaS5hZGQgPSB0O1xuICBmdW5jdGlvbiBzKGMsIHUpIHtcbiAgICByZXR1cm4gYyAtIHUgfCAwO1xuICB9XG4gIGkuc3ViID0gcztcbiAgZnVuY3Rpb24gcihjLCB1KSB7XG4gICAgcmV0dXJuIGMgPDwgdSB8IGMgPj4+IDMyIC0gdTtcbiAgfVxuICBpLnJvdGwgPSByO1xuICBmdW5jdGlvbiBuKGMsIHUpIHtcbiAgICByZXR1cm4gYyA8PCAzMiAtIHUgfCBjID4+PiB1O1xuICB9XG4gIGkucm90ciA9IG47XG4gIGZ1bmN0aW9uIG8oYykge1xuICAgIHJldHVybiB0eXBlb2YgYyA9PSBcIm51bWJlclwiICYmIGlzRmluaXRlKGMpICYmIE1hdGguZmxvb3IoYykgPT09IGM7XG4gIH1cbiAgaS5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IG8sIGkuTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsIGkuaXNTYWZlSW50ZWdlciA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gaS5pc0ludGVnZXIoYykgJiYgYyA+PSAtaS5NQVhfU0FGRV9JTlRFR0VSICYmIGMgPD0gaS5NQVhfU0FGRV9JTlRFR0VSO1xuICB9O1xufSkodWMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KG9lLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgbGMgPSB1YztcbmZ1bmN0aW9uIExsKGksIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApLCAoaVtlICsgMF0gPDwgOCB8IGlbZSArIDFdKSA8PCAxNiA+PiAxNjtcbn1cbm9lLnJlYWRJbnQxNkJFID0gTGw7XG5mdW5jdGlvbiBNbChpLCBlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwgKGlbZSArIDBdIDw8IDggfCBpW2UgKyAxXSkgPj4+IDA7XG59XG5vZS5yZWFkVWludDE2QkUgPSBNbDtcbmZ1bmN0aW9uIHFsKGksIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApLCAoaVtlICsgMV0gPDwgOCB8IGlbZV0pIDw8IDE2ID4+IDE2O1xufVxub2UucmVhZEludDE2TEUgPSBxbDtcbmZ1bmN0aW9uIGpsKGksIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApLCAoaVtlICsgMV0gPDwgOCB8IGlbZV0pID4+PiAwO1xufVxub2UucmVhZFVpbnQxNkxFID0gamw7XG5mdW5jdGlvbiBkYyhpLCBlLCB0KSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgVWludDhBcnJheSgyKSksIHQgPT09IHZvaWQgMCAmJiAodCA9IDApLCBlW3QgKyAwXSA9IGkgPj4+IDgsIGVbdCArIDFdID0gaSA+Pj4gMCwgZTtcbn1cbm9lLndyaXRlVWludDE2QkUgPSBkYztcbm9lLndyaXRlSW50MTZCRSA9IGRjO1xuZnVuY3Rpb24gZmMoaSwgZSwgdCkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gbmV3IFVpbnQ4QXJyYXkoMikpLCB0ID09PSB2b2lkIDAgJiYgKHQgPSAwKSwgZVt0ICsgMF0gPSBpID4+PiAwLCBlW3QgKyAxXSA9IGkgPj4+IDgsIGU7XG59XG5vZS53cml0ZVVpbnQxNkxFID0gZmM7XG5vZS53cml0ZUludDE2TEUgPSBmYztcbmZ1bmN0aW9uIE1yKGksIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApLCBpW2VdIDw8IDI0IHwgaVtlICsgMV0gPDwgMTYgfCBpW2UgKyAyXSA8PCA4IHwgaVtlICsgM107XG59XG5vZS5yZWFkSW50MzJCRSA9IE1yO1xuZnVuY3Rpb24gcXIoaSwgZSkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gMCksIChpW2VdIDw8IDI0IHwgaVtlICsgMV0gPDwgMTYgfCBpW2UgKyAyXSA8PCA4IHwgaVtlICsgM10pID4+PiAwO1xufVxub2UucmVhZFVpbnQzMkJFID0gcXI7XG5mdW5jdGlvbiBqcihpLCBlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwgaVtlICsgM10gPDwgMjQgfCBpW2UgKyAyXSA8PCAxNiB8IGlbZSArIDFdIDw8IDggfCBpW2VdO1xufVxub2UucmVhZEludDMyTEUgPSBqcjtcbmZ1bmN0aW9uIHpyKGksIGUpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApLCAoaVtlICsgM10gPDwgMjQgfCBpW2UgKyAyXSA8PCAxNiB8IGlbZSArIDFdIDw8IDggfCBpW2VdKSA+Pj4gMDtcbn1cbm9lLnJlYWRVaW50MzJMRSA9IHpyO1xuZnVuY3Rpb24ga3MoaSwgZSwgdCkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gbmV3IFVpbnQ4QXJyYXkoNCkpLCB0ID09PSB2b2lkIDAgJiYgKHQgPSAwKSwgZVt0ICsgMF0gPSBpID4+PiAyNCwgZVt0ICsgMV0gPSBpID4+PiAxNiwgZVt0ICsgMl0gPSBpID4+PiA4LCBlW3QgKyAzXSA9IGkgPj4+IDAsIGU7XG59XG5vZS53cml0ZVVpbnQzMkJFID0ga3M7XG5vZS53cml0ZUludDMyQkUgPSBrcztcbmZ1bmN0aW9uIEhzKGksIGUsIHQpIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBVaW50OEFycmF5KDQpKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gMCksIGVbdCArIDBdID0gaSA+Pj4gMCwgZVt0ICsgMV0gPSBpID4+PiA4LCBlW3QgKyAyXSA9IGkgPj4+IDE2LCBlW3QgKyAzXSA9IGkgPj4+IDI0LCBlO1xufVxub2Uud3JpdGVVaW50MzJMRSA9IEhzO1xub2Uud3JpdGVJbnQzMkxFID0gSHM7XG5mdW5jdGlvbiB6bChpLCBlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApO1xuICB2YXIgdCA9IE1yKGksIGUpLCBzID0gTXIoaSwgZSArIDQpO1xuICByZXR1cm4gdCAqIDQyOTQ5NjcyOTYgKyBzIC0gKHMgPj4gMzEpICogNDI5NDk2NzI5Njtcbn1cbm9lLnJlYWRJbnQ2NEJFID0gemw7XG5mdW5jdGlvbiBLbChpLCBlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApO1xuICB2YXIgdCA9IHFyKGksIGUpLCBzID0gcXIoaSwgZSArIDQpO1xuICByZXR1cm4gdCAqIDQyOTQ5NjcyOTYgKyBzO1xufVxub2UucmVhZFVpbnQ2NEJFID0gS2w7XG5mdW5jdGlvbiBWbChpLCBlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApO1xuICB2YXIgdCA9IGpyKGksIGUpLCBzID0ganIoaSwgZSArIDQpO1xuICByZXR1cm4gcyAqIDQyOTQ5NjcyOTYgKyB0IC0gKHQgPj4gMzEpICogNDI5NDk2NzI5Njtcbn1cbm9lLnJlYWRJbnQ2NExFID0gVmw7XG5mdW5jdGlvbiBCbChpLCBlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApO1xuICB2YXIgdCA9IHpyKGksIGUpLCBzID0genIoaSwgZSArIDQpO1xuICByZXR1cm4gcyAqIDQyOTQ5NjcyOTYgKyB0O1xufVxub2UucmVhZFVpbnQ2NExFID0gQmw7XG5mdW5jdGlvbiBwYyhpLCBlLCB0KSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgVWludDhBcnJheSg4KSksIHQgPT09IHZvaWQgMCAmJiAodCA9IDApLCBrcyhpIC8gNDI5NDk2NzI5NiA+Pj4gMCwgZSwgdCksIGtzKGkgPj4+IDAsIGUsIHQgKyA0KSwgZTtcbn1cbm9lLndyaXRlVWludDY0QkUgPSBwYztcbm9lLndyaXRlSW50NjRCRSA9IHBjO1xuZnVuY3Rpb24gZ2MoaSwgZSwgdCkge1xuICByZXR1cm4gZSA9PT0gdm9pZCAwICYmIChlID0gbmV3IFVpbnQ4QXJyYXkoOCkpLCB0ID09PSB2b2lkIDAgJiYgKHQgPSAwKSwgSHMoaSA+Pj4gMCwgZSwgdCksIEhzKGkgLyA0Mjk0OTY3Mjk2ID4+PiAwLCBlLCB0ICsgNCksIGU7XG59XG5vZS53cml0ZVVpbnQ2NExFID0gZ2M7XG5vZS53cml0ZUludDY0TEUgPSBnYztcbmZ1bmN0aW9uIGtsKGksIGUsIHQpIHtcbiAgaWYgKHQgPT09IHZvaWQgMCAmJiAodCA9IDApLCBpICUgOCAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWFkVWludEJFIHN1cHBvcnRzIG9ubHkgYml0TGVuZ3RocyBkaXZpc2libGUgYnkgOFwiKTtcbiAgaWYgKGkgLyA4ID4gZS5sZW5ndGggLSB0KVxuICAgIHRocm93IG5ldyBFcnJvcihcInJlYWRVaW50QkU6IGFycmF5IGlzIHRvbyBzaG9ydCBmb3IgdGhlIGdpdmVuIGJpdExlbmd0aFwiKTtcbiAgZm9yICh2YXIgcyA9IDAsIHIgPSAxLCBuID0gaSAvIDggKyB0IC0gMTsgbiA+PSB0OyBuLS0pXG4gICAgcyArPSBlW25dICogciwgciAqPSAyNTY7XG4gIHJldHVybiBzO1xufVxub2UucmVhZFVpbnRCRSA9IGtsO1xuZnVuY3Rpb24gSGwoaSwgZSwgdCkge1xuICBpZiAodCA9PT0gdm9pZCAwICYmICh0ID0gMCksIGkgJSA4ICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcInJlYWRVaW50TEUgc3VwcG9ydHMgb25seSBiaXRMZW5ndGhzIGRpdmlzaWJsZSBieSA4XCIpO1xuICBpZiAoaSAvIDggPiBlLmxlbmd0aCAtIHQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVhZFVpbnRMRTogYXJyYXkgaXMgdG9vIHNob3J0IGZvciB0aGUgZ2l2ZW4gYml0TGVuZ3RoXCIpO1xuICBmb3IgKHZhciBzID0gMCwgciA9IDEsIG4gPSB0OyBuIDwgdCArIGkgLyA4OyBuKyspXG4gICAgcyArPSBlW25dICogciwgciAqPSAyNTY7XG4gIHJldHVybiBzO1xufVxub2UucmVhZFVpbnRMRSA9IEhsO1xuZnVuY3Rpb24gR2woaSwgZSwgdCwgcykge1xuICBpZiAodCA9PT0gdm9pZCAwICYmICh0ID0gbmV3IFVpbnQ4QXJyYXkoaSAvIDgpKSwgcyA9PT0gdm9pZCAwICYmIChzID0gMCksIGkgJSA4ICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIndyaXRlVWludEJFIHN1cHBvcnRzIG9ubHkgYml0TGVuZ3RocyBkaXZpc2libGUgYnkgOFwiKTtcbiAgaWYgKCFsYy5pc1NhZmVJbnRlZ2VyKGUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIndyaXRlVWludEJFIHZhbHVlIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgZm9yICh2YXIgciA9IDEsIG4gPSBpIC8gOCArIHMgLSAxOyBuID49IHM7IG4tLSlcbiAgICB0W25dID0gZSAvIHIgJiAyNTUsIHIgKj0gMjU2O1xuICByZXR1cm4gdDtcbn1cbm9lLndyaXRlVWludEJFID0gR2w7XG5mdW5jdGlvbiBXbChpLCBlLCB0LCBzKSB7XG4gIGlmICh0ID09PSB2b2lkIDAgJiYgKHQgPSBuZXcgVWludDhBcnJheShpIC8gOCkpLCBzID09PSB2b2lkIDAgJiYgKHMgPSAwKSwgaSAlIDggIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwid3JpdGVVaW50TEUgc3VwcG9ydHMgb25seSBiaXRMZW5ndGhzIGRpdmlzaWJsZSBieSA4XCIpO1xuICBpZiAoIWxjLmlzU2FmZUludGVnZXIoZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwid3JpdGVVaW50TEUgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICBmb3IgKHZhciByID0gMSwgbiA9IHM7IG4gPCBzICsgaSAvIDg7IG4rKylcbiAgICB0W25dID0gZSAvIHIgJiAyNTUsIHIgKj0gMjU2O1xuICByZXR1cm4gdDtcbn1cbm9lLndyaXRlVWludExFID0gV2w7XG5mdW5jdGlvbiBZbChpLCBlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApO1xuICB2YXIgdCA9IG5ldyBEYXRhVmlldyhpLmJ1ZmZlciwgaS5ieXRlT2Zmc2V0LCBpLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gdC5nZXRGbG9hdDMyKGUpO1xufVxub2UucmVhZEZsb2F0MzJCRSA9IFlsO1xuZnVuY3Rpb24gSmwoaSwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSAwKTtcbiAgdmFyIHQgPSBuZXcgRGF0YVZpZXcoaS5idWZmZXIsIGkuYnl0ZU9mZnNldCwgaS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHQuZ2V0RmxvYXQzMihlLCAhMCk7XG59XG5vZS5yZWFkRmxvYXQzMkxFID0gSmw7XG5mdW5jdGlvbiBRbChpLCBlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IDApO1xuICB2YXIgdCA9IG5ldyBEYXRhVmlldyhpLmJ1ZmZlciwgaS5ieXRlT2Zmc2V0LCBpLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gdC5nZXRGbG9hdDY0KGUpO1xufVxub2UucmVhZEZsb2F0NjRCRSA9IFFsO1xuZnVuY3Rpb24gWGwoaSwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSAwKTtcbiAgdmFyIHQgPSBuZXcgRGF0YVZpZXcoaS5idWZmZXIsIGkuYnl0ZU9mZnNldCwgaS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHQuZ2V0RmxvYXQ2NChlLCAhMCk7XG59XG5vZS5yZWFkRmxvYXQ2NExFID0gWGw7XG5mdW5jdGlvbiBabChpLCBlLCB0KSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBVaW50OEFycmF5KDQpKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gMCk7XG4gIHZhciBzID0gbmV3IERhdGFWaWV3KGUuYnVmZmVyLCBlLmJ5dGVPZmZzZXQsIGUuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiBzLnNldEZsb2F0MzIodCwgaSksIGU7XG59XG5vZS53cml0ZUZsb2F0MzJCRSA9IFpsO1xuZnVuY3Rpb24gZWQoaSwgZSwgdCkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgVWludDhBcnJheSg0KSksIHQgPT09IHZvaWQgMCAmJiAodCA9IDApO1xuICB2YXIgcyA9IG5ldyBEYXRhVmlldyhlLmJ1ZmZlciwgZS5ieXRlT2Zmc2V0LCBlLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gcy5zZXRGbG9hdDMyKHQsIGksICEwKSwgZTtcbn1cbm9lLndyaXRlRmxvYXQzMkxFID0gZWQ7XG5mdW5jdGlvbiB0ZChpLCBlLCB0KSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IG5ldyBVaW50OEFycmF5KDgpKSwgdCA9PT0gdm9pZCAwICYmICh0ID0gMCk7XG4gIHZhciBzID0gbmV3IERhdGFWaWV3KGUuYnVmZmVyLCBlLmJ5dGVPZmZzZXQsIGUuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiBzLnNldEZsb2F0NjQodCwgaSksIGU7XG59XG5vZS53cml0ZUZsb2F0NjRCRSA9IHRkO1xuZnVuY3Rpb24gaWQoaSwgZSwgdCkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSBuZXcgVWludDhBcnJheSg4KSksIHQgPT09IHZvaWQgMCAmJiAodCA9IDApO1xuICB2YXIgcyA9IG5ldyBEYXRhVmlldyhlLmJ1ZmZlciwgZS5ieXRlT2Zmc2V0LCBlLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gcy5zZXRGbG9hdDY0KHQsIGksICEwKSwgZTtcbn1cbm9lLndyaXRlRmxvYXQ2NExFID0gaWQ7XG4oZnVuY3Rpb24oaSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBpLnJhbmRvbVN0cmluZ0ZvckVudHJvcHkgPSBpLnJhbmRvbVN0cmluZyA9IGkucmFuZG9tVWludDMyID0gaS5yYW5kb21CeXRlcyA9IGkuZGVmYXVsdFJhbmRvbVNvdXJjZSA9IHZvaWQgMDtcbiAgY29uc3QgZSA9IG5yLCB0ID0gb2UsIHMgPSBQdDtcbiAgaS5kZWZhdWx0UmFuZG9tU291cmNlID0gbmV3IGUuU3lzdGVtUmFuZG9tU291cmNlKCk7XG4gIGZ1bmN0aW9uIHIoZCwgcCA9IGkuZGVmYXVsdFJhbmRvbVNvdXJjZSkge1xuICAgIHJldHVybiBwLnJhbmRvbUJ5dGVzKGQpO1xuICB9XG4gIGkucmFuZG9tQnl0ZXMgPSByO1xuICBmdW5jdGlvbiBuKGQgPSBpLmRlZmF1bHRSYW5kb21Tb3VyY2UpIHtcbiAgICBjb25zdCBwID0gcig0LCBkKSwgYiA9ICgwLCB0LnJlYWRVaW50MzJMRSkocCk7XG4gICAgcmV0dXJuICgwLCBzLndpcGUpKHApLCBiO1xuICB9XG4gIGkucmFuZG9tVWludDMyID0gbjtcbiAgY29uc3QgbyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbiAgZnVuY3Rpb24gYyhkLCBwID0gbywgYiA9IGkuZGVmYXVsdFJhbmRvbVNvdXJjZSkge1xuICAgIGlmIChwLmxlbmd0aCA8IDIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb21TdHJpbmcgY2hhcnNldCBpcyB0b28gc2hvcnRcIik7XG4gICAgaWYgKHAubGVuZ3RoID4gMjU2KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmFuZG9tU3RyaW5nIGNoYXJzZXQgaXMgdG9vIGxvbmdcIik7XG4gICAgbGV0IHggPSBcIlwiO1xuICAgIGNvbnN0IE8gPSBwLmxlbmd0aCwgXyA9IDI1NiAtIDI1NiAlIE87XG4gICAgZm9yICg7IGQgPiAwOyApIHtcbiAgICAgIGNvbnN0IEMgPSByKE1hdGguY2VpbChkICogMjU2IC8gXyksIGIpO1xuICAgICAgZm9yIChsZXQgRiA9IDA7IEYgPCBDLmxlbmd0aCAmJiBkID4gMDsgRisrKSB7XG4gICAgICAgIGNvbnN0IEsgPSBDW0ZdO1xuICAgICAgICBLIDwgXyAmJiAoeCArPSBwLmNoYXJBdChLICUgTyksIGQtLSk7XG4gICAgICB9XG4gICAgICAoMCwgcy53aXBlKShDKTtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgaS5yYW5kb21TdHJpbmcgPSBjO1xuICBmdW5jdGlvbiB1KGQsIHAgPSBvLCBiID0gaS5kZWZhdWx0UmFuZG9tU291cmNlKSB7XG4gICAgY29uc3QgeCA9IE1hdGguY2VpbChkIC8gKE1hdGgubG9nKHAubGVuZ3RoKSAvIE1hdGguTE4yKSk7XG4gICAgcmV0dXJuIGMoeCwgcCwgYik7XG4gIH1cbiAgaS5yYW5kb21TdHJpbmdGb3JFbnRyb3B5ID0gdTtcbn0pKGxpKTtcbnZhciB5YyA9IHt9O1xuKGZ1bmN0aW9uKGkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgdmFyIGUgPSBvZSwgdCA9IFB0O1xuICBpLkRJR0VTVF9MRU5HVEggPSA2NCwgaS5CTE9DS19TSVpFID0gMTI4O1xuICB2YXIgcyA9IChcbiAgICAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBjKCkge1xuICAgICAgICB0aGlzLmRpZ2VzdExlbmd0aCA9IGkuRElHRVNUX0xFTkdUSCwgdGhpcy5ibG9ja1NpemUgPSBpLkJMT0NLX1NJWkUsIHRoaXMuX3N0YXRlSGkgPSBuZXcgSW50MzJBcnJheSg4KSwgdGhpcy5fc3RhdGVMbyA9IG5ldyBJbnQzMkFycmF5KDgpLCB0aGlzLl90ZW1wSGkgPSBuZXcgSW50MzJBcnJheSgxNiksIHRoaXMuX3RlbXBMbyA9IG5ldyBJbnQzMkFycmF5KDE2KSwgdGhpcy5fYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMjU2KSwgdGhpcy5fYnVmZmVyTGVuZ3RoID0gMCwgdGhpcy5fYnl0ZXNIYXNoZWQgPSAwLCB0aGlzLl9maW5pc2hlZCA9ICExLCB0aGlzLnJlc2V0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYy5wcm90b3R5cGUuX2luaXRTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9zdGF0ZUhpWzBdID0gMTc3OTAzMzcwMywgdGhpcy5fc3RhdGVIaVsxXSA9IDMxNDQxMzQyNzcsIHRoaXMuX3N0YXRlSGlbMl0gPSAxMDEzOTA0MjQyLCB0aGlzLl9zdGF0ZUhpWzNdID0gMjc3MzQ4MDc2MiwgdGhpcy5fc3RhdGVIaVs0XSA9IDEzNTk4OTMxMTksIHRoaXMuX3N0YXRlSGlbNV0gPSAyNjAwODIyOTI0LCB0aGlzLl9zdGF0ZUhpWzZdID0gNTI4NzM0NjM1LCB0aGlzLl9zdGF0ZUhpWzddID0gMTU0MTQ1OTIyNSwgdGhpcy5fc3RhdGVMb1swXSA9IDQwODkyMzU3MjAsIHRoaXMuX3N0YXRlTG9bMV0gPSAyMjI3ODczNTk1LCB0aGlzLl9zdGF0ZUxvWzJdID0gNDI3MTE3NTcyMywgdGhpcy5fc3RhdGVMb1szXSA9IDE1OTU3NTAxMjksIHRoaXMuX3N0YXRlTG9bNF0gPSAyOTE3NTY1MTM3LCB0aGlzLl9zdGF0ZUxvWzVdID0gNzI1NTExMTk5LCB0aGlzLl9zdGF0ZUxvWzZdID0gNDIxNTM4OTU0NywgdGhpcy5fc3RhdGVMb1s3XSA9IDMyNzAzMzIwOTtcbiAgICAgIH0sIGMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0U3RhdGUoKSwgdGhpcy5fYnVmZmVyTGVuZ3RoID0gMCwgdGhpcy5fYnl0ZXNIYXNoZWQgPSAwLCB0aGlzLl9maW5pc2hlZCA9ICExLCB0aGlzO1xuICAgICAgfSwgYy5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdC53aXBlKHRoaXMuX2J1ZmZlciksIHQud2lwZSh0aGlzLl90ZW1wSGkpLCB0LndpcGUodGhpcy5fdGVtcExvKSwgdGhpcy5yZXNldCgpO1xuICAgICAgfSwgYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24odSwgZCkge1xuICAgICAgICBpZiAoZCA9PT0gdm9pZCAwICYmIChkID0gdS5sZW5ndGgpLCB0aGlzLl9maW5pc2hlZClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTSEE1MTI6IGNhbid0IHVwZGF0ZSBiZWNhdXNlIGhhc2ggd2FzIGZpbmlzaGVkLlwiKTtcbiAgICAgICAgdmFyIHAgPSAwO1xuICAgICAgICBpZiAodGhpcy5fYnl0ZXNIYXNoZWQgKz0gZCwgdGhpcy5fYnVmZmVyTGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAoOyB0aGlzLl9idWZmZXJMZW5ndGggPCBpLkJMT0NLX1NJWkUgJiYgZCA+IDA7IClcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclt0aGlzLl9idWZmZXJMZW5ndGgrK10gPSB1W3ArK10sIGQtLTtcbiAgICAgICAgICB0aGlzLl9idWZmZXJMZW5ndGggPT09IHRoaXMuYmxvY2tTaXplICYmIChuKHRoaXMuX3RlbXBIaSwgdGhpcy5fdGVtcExvLCB0aGlzLl9zdGF0ZUhpLCB0aGlzLl9zdGF0ZUxvLCB0aGlzLl9idWZmZXIsIDAsIHRoaXMuYmxvY2tTaXplKSwgdGhpcy5fYnVmZmVyTGVuZ3RoID0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChkID49IHRoaXMuYmxvY2tTaXplICYmIChwID0gbih0aGlzLl90ZW1wSGksIHRoaXMuX3RlbXBMbywgdGhpcy5fc3RhdGVIaSwgdGhpcy5fc3RhdGVMbywgdSwgcCwgZCksIGQgJT0gdGhpcy5ibG9ja1NpemUpOyBkID4gMDsgKVxuICAgICAgICAgIHRoaXMuX2J1ZmZlclt0aGlzLl9idWZmZXJMZW5ndGgrK10gPSB1W3ArK10sIGQtLTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCBjLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICB2YXIgZCA9IHRoaXMuX2J5dGVzSGFzaGVkLCBwID0gdGhpcy5fYnVmZmVyTGVuZ3RoLCBiID0gZCAvIDUzNjg3MDkxMiB8IDAsIHggPSBkIDw8IDMsIE8gPSBkICUgMTI4IDwgMTEyID8gMTI4IDogMjU2O1xuICAgICAgICAgIHRoaXMuX2J1ZmZlcltwXSA9IDEyODtcbiAgICAgICAgICBmb3IgKHZhciBfID0gcCArIDE7IF8gPCBPIC0gODsgXysrKVxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyW19dID0gMDtcbiAgICAgICAgICBlLndyaXRlVWludDMyQkUoYiwgdGhpcy5fYnVmZmVyLCBPIC0gOCksIGUud3JpdGVVaW50MzJCRSh4LCB0aGlzLl9idWZmZXIsIE8gLSA0KSwgbih0aGlzLl90ZW1wSGksIHRoaXMuX3RlbXBMbywgdGhpcy5fc3RhdGVIaSwgdGhpcy5fc3RhdGVMbywgdGhpcy5fYnVmZmVyLCAwLCBPKSwgdGhpcy5fZmluaXNoZWQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfID0gMDsgXyA8IHRoaXMuZGlnZXN0TGVuZ3RoIC8gODsgXysrKVxuICAgICAgICAgIGUud3JpdGVVaW50MzJCRSh0aGlzLl9zdGF0ZUhpW19dLCB1LCBfICogOCksIGUud3JpdGVVaW50MzJCRSh0aGlzLl9zdGF0ZUxvW19dLCB1LCBfICogOCArIDQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIGMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdSA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGlnZXN0TGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKHUpLCB1O1xuICAgICAgfSwgYy5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9maW5pc2hlZClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTSEEyNTY6IGNhbm5vdCBzYXZlIGZpbmlzaGVkIHN0YXRlXCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXRlSGk6IG5ldyBJbnQzMkFycmF5KHRoaXMuX3N0YXRlSGkpLFxuICAgICAgICAgIHN0YXRlTG86IG5ldyBJbnQzMkFycmF5KHRoaXMuX3N0YXRlTG8pLFxuICAgICAgICAgIGJ1ZmZlcjogdGhpcy5fYnVmZmVyTGVuZ3RoID4gMCA/IG5ldyBVaW50OEFycmF5KHRoaXMuX2J1ZmZlcikgOiB2b2lkIDAsXG4gICAgICAgICAgYnVmZmVyTGVuZ3RoOiB0aGlzLl9idWZmZXJMZW5ndGgsXG4gICAgICAgICAgYnl0ZXNIYXNoZWQ6IHRoaXMuX2J5dGVzSGFzaGVkXG4gICAgICAgIH07XG4gICAgICB9LCBjLnByb3RvdHlwZS5yZXN0b3JlU3RhdGUgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZUhpLnNldCh1LnN0YXRlSGkpLCB0aGlzLl9zdGF0ZUxvLnNldCh1LnN0YXRlTG8pLCB0aGlzLl9idWZmZXJMZW5ndGggPSB1LmJ1ZmZlckxlbmd0aCwgdS5idWZmZXIgJiYgdGhpcy5fYnVmZmVyLnNldCh1LmJ1ZmZlciksIHRoaXMuX2J5dGVzSGFzaGVkID0gdS5ieXRlc0hhc2hlZCwgdGhpcy5fZmluaXNoZWQgPSAhMSwgdGhpcztcbiAgICAgIH0sIGMucHJvdG90eXBlLmNsZWFuU2F2ZWRTdGF0ZSA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgdC53aXBlKHUuc3RhdGVIaSksIHQud2lwZSh1LnN0YXRlTG8pLCB1LmJ1ZmZlciAmJiB0LndpcGUodS5idWZmZXIpLCB1LmJ1ZmZlckxlbmd0aCA9IDAsIHUuYnl0ZXNIYXNoZWQgPSAwO1xuICAgICAgfSwgYztcbiAgICB9KClcbiAgKTtcbiAgaS5TSEE1MTIgPSBzO1xuICB2YXIgciA9IG5ldyBJbnQzMkFycmF5KFtcbiAgICAxMTE2MzUyNDA4LFxuICAgIDM2MDk3Njc0NTgsXG4gICAgMTg5OTQ0NzQ0MSxcbiAgICA2MDI4OTE3MjUsXG4gICAgMzA0OTMyMzQ3MSxcbiAgICAzOTY0NDg0Mzk5LFxuICAgIDM5MjEwMDk1NzMsXG4gICAgMjE3MzI5NTU0OCxcbiAgICA5NjE5ODcxNjMsXG4gICAgNDA4MTYyODQ3MixcbiAgICAxNTA4OTcwOTkzLFxuICAgIDMwNTM4MzQyNjUsXG4gICAgMjQ1MzYzNTc0OCxcbiAgICAyOTM3NjcxNTc5LFxuICAgIDI4NzA3NjMyMjEsXG4gICAgMzY2NDYwOTU2MCxcbiAgICAzNjI0MzgxMDgwLFxuICAgIDI3MzQ4ODMzOTQsXG4gICAgMzEwNTk4NDAxLFxuICAgIDExNjQ5OTY1NDIsXG4gICAgNjA3MjI1Mjc4LFxuICAgIDEzMjM2MTA3NjQsXG4gICAgMTQyNjg4MTk4NyxcbiAgICAzNTkwMzA0OTk0LFxuICAgIDE5MjUwNzgzODgsXG4gICAgNDA2ODE4MjM4MyxcbiAgICAyMTYyMDc4MjA2LFxuICAgIDk5MTMzNjExMyxcbiAgICAyNjE0ODg4MTAzLFxuICAgIDYzMzgwMzMxNyxcbiAgICAzMjQ4MjIyNTgwLFxuICAgIDM0Nzk3NzQ4NjgsXG4gICAgMzgzNTM5MDQwMSxcbiAgICAyNjY2NjEzNDU4LFxuICAgIDQwMjIyMjQ3NzQsXG4gICAgOTQ0NzExMTM5LFxuICAgIDI2NDM0NzA3OCxcbiAgICAyMzQxMjYyNzczLFxuICAgIDYwNDgwNzYyOCxcbiAgICAyMDA3ODAwOTMzLFxuICAgIDc3MDI1NTk4MyxcbiAgICAxNDk1OTkwOTAxLFxuICAgIDEyNDkxNTAxMjIsXG4gICAgMTg1NjQzMTIzNSxcbiAgICAxNTU1MDgxNjkyLFxuICAgIDMxNzUyMTgxMzIsXG4gICAgMTk5NjA2NDk4NixcbiAgICAyMTk4OTUwODM3LFxuICAgIDI1NTQyMjA4ODIsXG4gICAgMzk5OTcxOTMzOSxcbiAgICAyODIxODM0MzQ5LFxuICAgIDc2Njc4NDAxNixcbiAgICAyOTUyOTk2ODA4LFxuICAgIDI1NjY1OTQ4NzksXG4gICAgMzIxMDMxMzY3MSxcbiAgICAzMjAzMzM3OTU2LFxuICAgIDMzMzY1NzE4OTEsXG4gICAgMTAzNDQ1NzAyNixcbiAgICAzNTg0NTI4NzExLFxuICAgIDI0NjY5NDg5MDEsXG4gICAgMTEzOTI2OTkzLFxuICAgIDM3NTgzMjYzODMsXG4gICAgMzM4MjQxODk1LFxuICAgIDE2ODcxNzkzNixcbiAgICA2NjYzMDcyMDUsXG4gICAgMTE4ODE3OTk2NCxcbiAgICA3NzM1Mjk5MTIsXG4gICAgMTU0NjA0NTczNCxcbiAgICAxMjk0NzU3MzcyLFxuICAgIDE1MjI4MDU0ODUsXG4gICAgMTM5NjE4MjI5MSxcbiAgICAyNjQzODMzODIzLFxuICAgIDE2OTUxODM3MDAsXG4gICAgMjM0MzUyNzM5MCxcbiAgICAxOTg2NjYxMDUxLFxuICAgIDEwMTQ0Nzc0ODAsXG4gICAgMjE3NzAyNjM1MCxcbiAgICAxMjA2NzU5MTQyLFxuICAgIDI0NTY5NTYwMzcsXG4gICAgMzQ0MDc3NjI3LFxuICAgIDI3MzA0ODU5MjEsXG4gICAgMTI5MDg2MzQ2MCxcbiAgICAyODIwMzAyNDExLFxuICAgIDMxNTg0NTQyNzMsXG4gICAgMzI1OTczMDgwMCxcbiAgICAzNTA1OTUyNjU3LFxuICAgIDMzNDU3NjQ3NzEsXG4gICAgMTA2MjE3MDA4LFxuICAgIDM1MTYwNjU4MTcsXG4gICAgMzYwNjAwODM0NCxcbiAgICAzNjAwMzUyODA0LFxuICAgIDE0MzI3MjU3NzYsXG4gICAgNDA5NDU3MTkwOSxcbiAgICAxNDY3MDMxNTk0LFxuICAgIDI3NTQyMzM0NCxcbiAgICA4NTExNjk3MjAsXG4gICAgNDMwMjI3NzM0LFxuICAgIDMxMDA4MjM3NTIsXG4gICAgNTA2OTQ4NjE2LFxuICAgIDEzNjMyNTgxOTUsXG4gICAgNjU5MDYwNTU2LFxuICAgIDM3NTA2ODU1OTMsXG4gICAgODgzOTk3ODc3LFxuICAgIDM3ODUwNTAyODAsXG4gICAgOTU4MTM5NTcxLFxuICAgIDMzMTgzMDc0MjcsXG4gICAgMTMyMjgyMjIxOCxcbiAgICAzODEyNzIzNDAzLFxuICAgIDE1MzcwMDIwNjMsXG4gICAgMjAwMzAzNDk5NSxcbiAgICAxNzQ3ODczNzc5LFxuICAgIDM2MDIwMzY4OTksXG4gICAgMTk1NTU2MjIyMixcbiAgICAxNTc1OTkwMDEyLFxuICAgIDIwMjQxMDQ4MTUsXG4gICAgMTEyNTU5MjkyOCxcbiAgICAyMjI3NzMwNDUyLFxuICAgIDI3MTY5MDQzMDYsXG4gICAgMjM2MTg1MjQyNCxcbiAgICA0NDI3NzYwNDQsXG4gICAgMjQyODQzNjQ3NCxcbiAgICA1OTM2OTgzNDQsXG4gICAgMjc1NjczNDE4NyxcbiAgICAzNzMzMTEwMjQ5LFxuICAgIDMyMDQwMzE0NzksXG4gICAgMjk5OTM1MTU3MyxcbiAgICAzMzI5MzI1Mjk4LFxuICAgIDM4MTU5MjA0MjcsXG4gICAgMzM5MTU2OTYxNCxcbiAgICAzOTI4MzgzOTAwLFxuICAgIDM1MTUyNjcyNzEsXG4gICAgNTY2MjgwNzExLFxuICAgIDM5NDAxODc2MDYsXG4gICAgMzQ1NDA2OTUzNCxcbiAgICA0MTE4NjMwMjcxLFxuICAgIDQwMDAyMzk5OTIsXG4gICAgMTE2NDE4NDc0LFxuICAgIDE5MTQxMzg1NTQsXG4gICAgMTc0MjkyNDIxLFxuICAgIDI3MzEwNTUyNzAsXG4gICAgMjg5MzgwMzU2LFxuICAgIDMyMDM5OTMwMDYsXG4gICAgNDYwMzkzMjY5LFxuICAgIDMyMDYyMDMxNSxcbiAgICA2ODU0NzE3MzMsXG4gICAgNTg3NDk2ODM2LFxuICAgIDg1MjE0Mjk3MSxcbiAgICAxMDg2NzkyODUxLFxuICAgIDEwMTcwMzYyOTgsXG4gICAgMzY1NTQzMTAwLFxuICAgIDExMjYwMDA1ODAsXG4gICAgMjYxODI5NzY3NixcbiAgICAxMjg4MDMzNDcwLFxuICAgIDM0MDk4NTUxNTgsXG4gICAgMTUwMTUwNTk0OCxcbiAgICA0MjM0NTA5ODY2LFxuICAgIDE2MDcxNjc5MTUsXG4gICAgOTg3MTY3NDY4LFxuICAgIDE4MTY0MDIzMTYsXG4gICAgMTI0NjE4OTU5MVxuICBdKTtcbiAgZnVuY3Rpb24gbihjLCB1LCBkLCBwLCBiLCB4LCBPKSB7XG4gICAgZm9yICh2YXIgXyA9IGRbMF0sIEMgPSBkWzFdLCBGID0gZFsyXSwgSyA9IGRbM10sIEkgPSBkWzRdLCBEID0gZFs1XSwgeSA9IGRbNl0sIHcgPSBkWzddLCBmID0gcFswXSwgYSA9IHBbMV0sIGwgPSBwWzJdLCBMID0gcFszXSwgdiA9IHBbNF0sIFIgPSBwWzVdLCAkID0gcFs2XSwgcSA9IHBbN10sIG0sIEUsIEIsIHosIGosIFUsIE0sIEg7IE8gPj0gMTI4OyApIHtcbiAgICAgIGZvciAodmFyIHRlID0gMDsgdGUgPCAxNjsgdGUrKykge1xuICAgICAgICB2YXIgRyA9IDggKiB0ZSArIHg7XG4gICAgICAgIGNbdGVdID0gZS5yZWFkVWludDMyQkUoYiwgRyksIHVbdGVdID0gZS5yZWFkVWludDMyQkUoYiwgRyArIDQpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgdGUgPSAwOyB0ZSA8IDgwOyB0ZSsrKSB7XG4gICAgICAgIHZhciBpZSA9IF8sIFEgPSBDLCBzZSA9IEYsIFQgPSBLLCBBID0gSSwgTiA9IEQsIGggPSB5LCBTID0gdywgVyA9IGYsIFggPSBhLCBmZSA9IGwsIHZlID0gTCwgZ2UgPSB2LCBTZSA9IFIsIE1lID0gJCwgJGUgPSBxO1xuICAgICAgICBpZiAobSA9IHcsIEUgPSBxLCBqID0gRSAmIDY1NTM1LCBVID0gRSA+Pj4gMTYsIE0gPSBtICYgNjU1MzUsIEggPSBtID4+PiAxNiwgbSA9IChJID4+PiAxNCB8IHYgPDwgMzIgLSAxNCkgXiAoSSA+Pj4gMTggfCB2IDw8IDMyIC0gMTgpIF4gKHYgPj4+IDQxIC0gMzIgfCBJIDw8IDMyIC0gKDQxIC0gMzIpKSwgRSA9ICh2ID4+PiAxNCB8IEkgPDwgMzIgLSAxNCkgXiAodiA+Pj4gMTggfCBJIDw8IDMyIC0gMTgpIF4gKEkgPj4+IDQxIC0gMzIgfCB2IDw8IDMyIC0gKDQxIC0gMzIpKSwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBtID0gSSAmIEQgXiB+SSAmIHksIEUgPSB2ICYgUiBeIH52ICYgJCwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBtID0gclt0ZSAqIDJdLCBFID0gclt0ZSAqIDIgKyAxXSwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBtID0gY1t0ZSAlIDE2XSwgRSA9IHVbdGUgJSAxNl0sIGogKz0gRSAmIDY1NTM1LCBVICs9IEUgPj4+IDE2LCBNICs9IG0gJiA2NTUzNSwgSCArPSBtID4+PiAxNiwgVSArPSBqID4+PiAxNiwgTSArPSBVID4+PiAxNiwgSCArPSBNID4+PiAxNiwgQiA9IE0gJiA2NTUzNSB8IEggPDwgMTYsIHogPSBqICYgNjU1MzUgfCBVIDw8IDE2LCBtID0gQiwgRSA9IHosIGogPSBFICYgNjU1MzUsIFUgPSBFID4+PiAxNiwgTSA9IG0gJiA2NTUzNSwgSCA9IG0gPj4+IDE2LCBtID0gKF8gPj4+IDI4IHwgZiA8PCAzMiAtIDI4KSBeIChmID4+PiAzNCAtIDMyIHwgXyA8PCAzMiAtICgzNCAtIDMyKSkgXiAoZiA+Pj4gMzkgLSAzMiB8IF8gPDwgMzIgLSAoMzkgLSAzMikpLCBFID0gKGYgPj4+IDI4IHwgXyA8PCAzMiAtIDI4KSBeIChfID4+PiAzNCAtIDMyIHwgZiA8PCAzMiAtICgzNCAtIDMyKSkgXiAoXyA+Pj4gMzkgLSAzMiB8IGYgPDwgMzIgLSAoMzkgLSAzMikpLCBqICs9IEUgJiA2NTUzNSwgVSArPSBFID4+PiAxNiwgTSArPSBtICYgNjU1MzUsIEggKz0gbSA+Pj4gMTYsIG0gPSBfICYgQyBeIF8gJiBGIF4gQyAmIEYsIEUgPSBmICYgYSBeIGYgJiBsIF4gYSAmIGwsIGogKz0gRSAmIDY1NTM1LCBVICs9IEUgPj4+IDE2LCBNICs9IG0gJiA2NTUzNSwgSCArPSBtID4+PiAxNiwgVSArPSBqID4+PiAxNiwgTSArPSBVID4+PiAxNiwgSCArPSBNID4+PiAxNiwgUyA9IE0gJiA2NTUzNSB8IEggPDwgMTYsICRlID0gaiAmIDY1NTM1IHwgVSA8PCAxNiwgbSA9IFQsIEUgPSB2ZSwgaiA9IEUgJiA2NTUzNSwgVSA9IEUgPj4+IDE2LCBNID0gbSAmIDY1NTM1LCBIID0gbSA+Pj4gMTYsIG0gPSBCLCBFID0geiwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBVICs9IGogPj4+IDE2LCBNICs9IFUgPj4+IDE2LCBIICs9IE0gPj4+IDE2LCBUID0gTSAmIDY1NTM1IHwgSCA8PCAxNiwgdmUgPSBqICYgNjU1MzUgfCBVIDw8IDE2LCBDID0gaWUsIEYgPSBRLCBLID0gc2UsIEkgPSBULCBEID0gQSwgeSA9IE4sIHcgPSBoLCBfID0gUywgYSA9IFcsIGwgPSBYLCBMID0gZmUsIHYgPSB2ZSwgUiA9IGdlLCAkID0gU2UsIHEgPSBNZSwgZiA9ICRlLCB0ZSAlIDE2ID09PSAxNSlcbiAgICAgICAgICBmb3IgKHZhciBHID0gMDsgRyA8IDE2OyBHKyspXG4gICAgICAgICAgICBtID0gY1tHXSwgRSA9IHVbR10sIGogPSBFICYgNjU1MzUsIFUgPSBFID4+PiAxNiwgTSA9IG0gJiA2NTUzNSwgSCA9IG0gPj4+IDE2LCBtID0gY1soRyArIDkpICUgMTZdLCBFID0gdVsoRyArIDkpICUgMTZdLCBqICs9IEUgJiA2NTUzNSwgVSArPSBFID4+PiAxNiwgTSArPSBtICYgNjU1MzUsIEggKz0gbSA+Pj4gMTYsIEIgPSBjWyhHICsgMSkgJSAxNl0sIHogPSB1WyhHICsgMSkgJSAxNl0sIG0gPSAoQiA+Pj4gMSB8IHogPDwgMzIgLSAxKSBeIChCID4+PiA4IHwgeiA8PCAzMiAtIDgpIF4gQiA+Pj4gNywgRSA9ICh6ID4+PiAxIHwgQiA8PCAzMiAtIDEpIF4gKHogPj4+IDggfCBCIDw8IDMyIC0gOCkgXiAoeiA+Pj4gNyB8IEIgPDwgMzIgLSA3KSwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBCID0gY1soRyArIDE0KSAlIDE2XSwgeiA9IHVbKEcgKyAxNCkgJSAxNl0sIG0gPSAoQiA+Pj4gMTkgfCB6IDw8IDMyIC0gMTkpIF4gKHogPj4+IDYxIC0gMzIgfCBCIDw8IDMyIC0gKDYxIC0gMzIpKSBeIEIgPj4+IDYsIEUgPSAoeiA+Pj4gMTkgfCBCIDw8IDMyIC0gMTkpIF4gKEIgPj4+IDYxIC0gMzIgfCB6IDw8IDMyIC0gKDYxIC0gMzIpKSBeICh6ID4+PiA2IHwgQiA8PCAzMiAtIDYpLCBqICs9IEUgJiA2NTUzNSwgVSArPSBFID4+PiAxNiwgTSArPSBtICYgNjU1MzUsIEggKz0gbSA+Pj4gMTYsIFUgKz0gaiA+Pj4gMTYsIE0gKz0gVSA+Pj4gMTYsIEggKz0gTSA+Pj4gMTYsIGNbR10gPSBNICYgNjU1MzUgfCBIIDw8IDE2LCB1W0ddID0gaiAmIDY1NTM1IHwgVSA8PCAxNjtcbiAgICAgIH1cbiAgICAgIG0gPSBfLCBFID0gZiwgaiA9IEUgJiA2NTUzNSwgVSA9IEUgPj4+IDE2LCBNID0gbSAmIDY1NTM1LCBIID0gbSA+Pj4gMTYsIG0gPSBkWzBdLCBFID0gcFswXSwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBVICs9IGogPj4+IDE2LCBNICs9IFUgPj4+IDE2LCBIICs9IE0gPj4+IDE2LCBkWzBdID0gXyA9IE0gJiA2NTUzNSB8IEggPDwgMTYsIHBbMF0gPSBmID0gaiAmIDY1NTM1IHwgVSA8PCAxNiwgbSA9IEMsIEUgPSBhLCBqID0gRSAmIDY1NTM1LCBVID0gRSA+Pj4gMTYsIE0gPSBtICYgNjU1MzUsIEggPSBtID4+PiAxNiwgbSA9IGRbMV0sIEUgPSBwWzFdLCBqICs9IEUgJiA2NTUzNSwgVSArPSBFID4+PiAxNiwgTSArPSBtICYgNjU1MzUsIEggKz0gbSA+Pj4gMTYsIFUgKz0gaiA+Pj4gMTYsIE0gKz0gVSA+Pj4gMTYsIEggKz0gTSA+Pj4gMTYsIGRbMV0gPSBDID0gTSAmIDY1NTM1IHwgSCA8PCAxNiwgcFsxXSA9IGEgPSBqICYgNjU1MzUgfCBVIDw8IDE2LCBtID0gRiwgRSA9IGwsIGogPSBFICYgNjU1MzUsIFUgPSBFID4+PiAxNiwgTSA9IG0gJiA2NTUzNSwgSCA9IG0gPj4+IDE2LCBtID0gZFsyXSwgRSA9IHBbMl0sIGogKz0gRSAmIDY1NTM1LCBVICs9IEUgPj4+IDE2LCBNICs9IG0gJiA2NTUzNSwgSCArPSBtID4+PiAxNiwgVSArPSBqID4+PiAxNiwgTSArPSBVID4+PiAxNiwgSCArPSBNID4+PiAxNiwgZFsyXSA9IEYgPSBNICYgNjU1MzUgfCBIIDw8IDE2LCBwWzJdID0gbCA9IGogJiA2NTUzNSB8IFUgPDwgMTYsIG0gPSBLLCBFID0gTCwgaiA9IEUgJiA2NTUzNSwgVSA9IEUgPj4+IDE2LCBNID0gbSAmIDY1NTM1LCBIID0gbSA+Pj4gMTYsIG0gPSBkWzNdLCBFID0gcFszXSwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBVICs9IGogPj4+IDE2LCBNICs9IFUgPj4+IDE2LCBIICs9IE0gPj4+IDE2LCBkWzNdID0gSyA9IE0gJiA2NTUzNSB8IEggPDwgMTYsIHBbM10gPSBMID0gaiAmIDY1NTM1IHwgVSA8PCAxNiwgbSA9IEksIEUgPSB2LCBqID0gRSAmIDY1NTM1LCBVID0gRSA+Pj4gMTYsIE0gPSBtICYgNjU1MzUsIEggPSBtID4+PiAxNiwgbSA9IGRbNF0sIEUgPSBwWzRdLCBqICs9IEUgJiA2NTUzNSwgVSArPSBFID4+PiAxNiwgTSArPSBtICYgNjU1MzUsIEggKz0gbSA+Pj4gMTYsIFUgKz0gaiA+Pj4gMTYsIE0gKz0gVSA+Pj4gMTYsIEggKz0gTSA+Pj4gMTYsIGRbNF0gPSBJID0gTSAmIDY1NTM1IHwgSCA8PCAxNiwgcFs0XSA9IHYgPSBqICYgNjU1MzUgfCBVIDw8IDE2LCBtID0gRCwgRSA9IFIsIGogPSBFICYgNjU1MzUsIFUgPSBFID4+PiAxNiwgTSA9IG0gJiA2NTUzNSwgSCA9IG0gPj4+IDE2LCBtID0gZFs1XSwgRSA9IHBbNV0sIGogKz0gRSAmIDY1NTM1LCBVICs9IEUgPj4+IDE2LCBNICs9IG0gJiA2NTUzNSwgSCArPSBtID4+PiAxNiwgVSArPSBqID4+PiAxNiwgTSArPSBVID4+PiAxNiwgSCArPSBNID4+PiAxNiwgZFs1XSA9IEQgPSBNICYgNjU1MzUgfCBIIDw8IDE2LCBwWzVdID0gUiA9IGogJiA2NTUzNSB8IFUgPDwgMTYsIG0gPSB5LCBFID0gJCwgaiA9IEUgJiA2NTUzNSwgVSA9IEUgPj4+IDE2LCBNID0gbSAmIDY1NTM1LCBIID0gbSA+Pj4gMTYsIG0gPSBkWzZdLCBFID0gcFs2XSwgaiArPSBFICYgNjU1MzUsIFUgKz0gRSA+Pj4gMTYsIE0gKz0gbSAmIDY1NTM1LCBIICs9IG0gPj4+IDE2LCBVICs9IGogPj4+IDE2LCBNICs9IFUgPj4+IDE2LCBIICs9IE0gPj4+IDE2LCBkWzZdID0geSA9IE0gJiA2NTUzNSB8IEggPDwgMTYsIHBbNl0gPSAkID0gaiAmIDY1NTM1IHwgVSA8PCAxNiwgbSA9IHcsIEUgPSBxLCBqID0gRSAmIDY1NTM1LCBVID0gRSA+Pj4gMTYsIE0gPSBtICYgNjU1MzUsIEggPSBtID4+PiAxNiwgbSA9IGRbN10sIEUgPSBwWzddLCBqICs9IEUgJiA2NTUzNSwgVSArPSBFID4+PiAxNiwgTSArPSBtICYgNjU1MzUsIEggKz0gbSA+Pj4gMTYsIFUgKz0gaiA+Pj4gMTYsIE0gKz0gVSA+Pj4gMTYsIEggKz0gTSA+Pj4gMTYsIGRbN10gPSB3ID0gTSAmIDY1NTM1IHwgSCA8PCAxNiwgcFs3XSA9IHEgPSBqICYgNjU1MzUgfCBVIDw8IDE2LCB4ICs9IDEyOCwgTyAtPSAxMjg7XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9XG4gIGZ1bmN0aW9uIG8oYykge1xuICAgIHZhciB1ID0gbmV3IHMoKTtcbiAgICB1LnVwZGF0ZShjKTtcbiAgICB2YXIgZCA9IHUuZGlnZXN0KCk7XG4gICAgcmV0dXJuIHUuY2xlYW4oKSwgZDtcbiAgfVxuICBpLmhhc2ggPSBvO1xufSkoeWMpO1xuKGZ1bmN0aW9uKGkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgaS5jb252ZXJ0U2VjcmV0S2V5VG9YMjU1MTkgPSBpLmNvbnZlcnRQdWJsaWNLZXlUb1gyNTUxOSA9IGkudmVyaWZ5ID0gaS5zaWduID0gaS5leHRyYWN0UHVibGljS2V5RnJvbVNlY3JldEtleSA9IGkuZ2VuZXJhdGVLZXlQYWlyID0gaS5nZW5lcmF0ZUtleVBhaXJGcm9tU2VlZCA9IGkuU0VFRF9MRU5HVEggPSBpLlNFQ1JFVF9LRVlfTEVOR1RIID0gaS5QVUJMSUNfS0VZX0xFTkdUSCA9IGkuU0lHTkFUVVJFX0xFTkdUSCA9IHZvaWQgMDtcbiAgY29uc3QgZSA9IGxpLCB0ID0geWMsIHMgPSBQdDtcbiAgaS5TSUdOQVRVUkVfTEVOR1RIID0gNjQsIGkuUFVCTElDX0tFWV9MRU5HVEggPSAzMiwgaS5TRUNSRVRfS0VZX0xFTkdUSCA9IDY0LCBpLlNFRURfTEVOR1RIID0gMzI7XG4gIGZ1bmN0aW9uIHIoVCkge1xuICAgIGNvbnN0IEEgPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgICBpZiAoVClcbiAgICAgIGZvciAobGV0IE4gPSAwOyBOIDwgVC5sZW5ndGg7IE4rKylcbiAgICAgICAgQVtOXSA9IFRbTl07XG4gICAgcmV0dXJuIEE7XG4gIH1cbiAgY29uc3QgbiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgblswXSA9IDk7XG4gIGNvbnN0IG8gPSByKCksIGMgPSByKFsxXSksIHUgPSByKFtcbiAgICAzMDg4MyxcbiAgICA0OTUzLFxuICAgIDE5OTE0LFxuICAgIDMwMTg3LFxuICAgIDU1NDY3LFxuICAgIDE2NzA1LFxuICAgIDI2MzcsXG4gICAgMTEyLFxuICAgIDU5NTQ0LFxuICAgIDMwNTg1LFxuICAgIDE2NTA1LFxuICAgIDM2MDM5LFxuICAgIDY1MTM5LFxuICAgIDExMTE5LFxuICAgIDI3ODg2LFxuICAgIDIwOTk1XG4gIF0pLCBkID0gcihbXG4gICAgNjE3ODUsXG4gICAgOTkwNixcbiAgICAzOTgyOCxcbiAgICA2MDM3NCxcbiAgICA0NTM5OCxcbiAgICAzMzQxMSxcbiAgICA1Mjc0LFxuICAgIDIyNCxcbiAgICA1MzU1MixcbiAgICA2MTE3MSxcbiAgICAzMzAxMCxcbiAgICA2NTQyLFxuICAgIDY0NzQzLFxuICAgIDIyMjM5LFxuICAgIDU1NzcyLFxuICAgIDkyMjJcbiAgXSksIHAgPSByKFtcbiAgICA1NDU1NCxcbiAgICAzNjY0NSxcbiAgICAxMTYxNixcbiAgICA1MTU0MixcbiAgICA0MjkzMCxcbiAgICAzODE4MSxcbiAgICA1MTA0MCxcbiAgICAyNjkyNCxcbiAgICA1NjQxMixcbiAgICA2NDk4MixcbiAgICA1NzkwNSxcbiAgICA0OTMxNixcbiAgICAyMTUwMixcbiAgICA1MjU5MCxcbiAgICAxNDAzNSxcbiAgICA4NTUzXG4gIF0pLCBiID0gcihbXG4gICAgMjYyMDAsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTQsXG4gICAgMjYyMTRcbiAgXSksIHggPSByKFtcbiAgICA0MTEzNixcbiAgICAxODk1OCxcbiAgICA2OTUxLFxuICAgIDUwNDE0LFxuICAgIDU4NDg4LFxuICAgIDQ0MzM1LFxuICAgIDYxNTAsXG4gICAgMTIwOTksXG4gICAgNTUyMDcsXG4gICAgMTU4NjcsXG4gICAgMTUzLFxuICAgIDExMDg1LFxuICAgIDU3MDk5LFxuICAgIDIwNDE3LFxuICAgIDkzNDQsXG4gICAgMTExMzlcbiAgXSk7XG4gIGZ1bmN0aW9uIE8oVCwgQSkge1xuICAgIGZvciAobGV0IE4gPSAwOyBOIDwgMTY7IE4rKylcbiAgICAgIFRbTl0gPSBBW05dIHwgMDtcbiAgfVxuICBmdW5jdGlvbiBfKFQpIHtcbiAgICBsZXQgQSA9IDE7XG4gICAgZm9yIChsZXQgTiA9IDA7IE4gPCAxNjsgTisrKSB7XG4gICAgICBsZXQgaCA9IFRbTl0gKyBBICsgNjU1MzU7XG4gICAgICBBID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBUW05dID0gaCAtIEEgKiA2NTUzNjtcbiAgICB9XG4gICAgVFswXSArPSBBIC0gMSArIDM3ICogKEEgLSAxKTtcbiAgfVxuICBmdW5jdGlvbiBDKFQsIEEsIE4pIHtcbiAgICBjb25zdCBoID0gfihOIC0gMSk7XG4gICAgZm9yIChsZXQgUyA9IDA7IFMgPCAxNjsgUysrKSB7XG4gICAgICBjb25zdCBXID0gaCAmIChUW1NdIF4gQVtTXSk7XG4gICAgICBUW1NdIF49IFcsIEFbU10gXj0gVztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gRihULCBBKSB7XG4gICAgY29uc3QgTiA9IHIoKSwgaCA9IHIoKTtcbiAgICBmb3IgKGxldCBTID0gMDsgUyA8IDE2OyBTKyspXG4gICAgICBoW1NdID0gQVtTXTtcbiAgICBfKGgpLCBfKGgpLCBfKGgpO1xuICAgIGZvciAobGV0IFMgPSAwOyBTIDwgMjsgUysrKSB7XG4gICAgICBOWzBdID0gaFswXSAtIDY1NTE3O1xuICAgICAgZm9yIChsZXQgWCA9IDE7IFggPCAxNTsgWCsrKVxuICAgICAgICBOW1hdID0gaFtYXSAtIDY1NTM1IC0gKE5bWCAtIDFdID4+IDE2ICYgMSksIE5bWCAtIDFdICY9IDY1NTM1O1xuICAgICAgTlsxNV0gPSBoWzE1XSAtIDMyNzY3IC0gKE5bMTRdID4+IDE2ICYgMSk7XG4gICAgICBjb25zdCBXID0gTlsxNV0gPj4gMTYgJiAxO1xuICAgICAgTlsxNF0gJj0gNjU1MzUsIEMoaCwgTiwgMSAtIFcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBTID0gMDsgUyA8IDE2OyBTKyspXG4gICAgICBUWzIgKiBTXSA9IGhbU10gJiAyNTUsIFRbMiAqIFMgKyAxXSA9IGhbU10gPj4gODtcbiAgfVxuICBmdW5jdGlvbiBLKFQsIEEpIHtcbiAgICBsZXQgTiA9IDA7XG4gICAgZm9yIChsZXQgaCA9IDA7IGggPCAzMjsgaCsrKVxuICAgICAgTiB8PSBUW2hdIF4gQVtoXTtcbiAgICByZXR1cm4gKDEgJiBOIC0gMSA+Pj4gOCkgLSAxO1xuICB9XG4gIGZ1bmN0aW9uIEkoVCwgQSkge1xuICAgIGNvbnN0IE4gPSBuZXcgVWludDhBcnJheSgzMiksIGggPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcmV0dXJuIEYoTiwgVCksIEYoaCwgQSksIEsoTiwgaCk7XG4gIH1cbiAgZnVuY3Rpb24gRChUKSB7XG4gICAgY29uc3QgQSA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICByZXR1cm4gRihBLCBUKSwgQVswXSAmIDE7XG4gIH1cbiAgZnVuY3Rpb24geShULCBBKSB7XG4gICAgZm9yIChsZXQgTiA9IDA7IE4gPCAxNjsgTisrKVxuICAgICAgVFtOXSA9IEFbMiAqIE5dICsgKEFbMiAqIE4gKyAxXSA8PCA4KTtcbiAgICBUWzE1XSAmPSAzMjc2NztcbiAgfVxuICBmdW5jdGlvbiB3KFQsIEEsIE4pIHtcbiAgICBmb3IgKGxldCBoID0gMDsgaCA8IDE2OyBoKyspXG4gICAgICBUW2hdID0gQVtoXSArIE5baF07XG4gIH1cbiAgZnVuY3Rpb24gZihULCBBLCBOKSB7XG4gICAgZm9yIChsZXQgaCA9IDA7IGggPCAxNjsgaCsrKVxuICAgICAgVFtoXSA9IEFbaF0gLSBOW2hdO1xuICB9XG4gIGZ1bmN0aW9uIGEoVCwgQSwgTikge1xuICAgIGxldCBoLCBTLCBXID0gMCwgWCA9IDAsIGZlID0gMCwgdmUgPSAwLCBnZSA9IDAsIFNlID0gMCwgTWUgPSAwLCAkZSA9IDAsIGJlID0gMCwgeWUgPSAwLCBwZSA9IDAsIGxlID0gMCwgdWUgPSAwLCBoZSA9IDAsIGNlID0gMCwgcmUgPSAwLCBkZSA9IDAsIG1lID0gMCwgbmUgPSAwLCBfZSA9IDAsIEVlID0gMCwgRGUgPSAwLCB4ZSA9IDAsIEllID0gMCwgVXQgPSAwLCBxdCA9IDAsIHNpID0gMCwgRHQgPSAwLCBmaSA9IDAsIEtpID0gMCwgT3MgPSAwLCBxZSA9IE5bMF0sIEZlID0gTlsxXSwgamUgPSBOWzJdLCB6ZSA9IE5bM10sIEtlID0gTls0XSwgVWUgPSBOWzVdLCBRZSA9IE5bNl0sIFhlID0gTls3XSwgWmUgPSBOWzhdLCBldCA9IE5bOV0sIHR0ID0gTlsxMF0sIFllID0gTlsxMV0sIFZlID0gTlsxMl0sIEFlID0gTlsxM10sIGl0ID0gTlsxNF0sIHN0ID0gTlsxNV07XG4gICAgaCA9IEFbMF0sIFcgKz0gaCAqIHFlLCBYICs9IGggKiBGZSwgZmUgKz0gaCAqIGplLCB2ZSArPSBoICogemUsIGdlICs9IGggKiBLZSwgU2UgKz0gaCAqIFVlLCBNZSArPSBoICogUWUsICRlICs9IGggKiBYZSwgYmUgKz0gaCAqIFplLCB5ZSArPSBoICogZXQsIHBlICs9IGggKiB0dCwgbGUgKz0gaCAqIFllLCB1ZSArPSBoICogVmUsIGhlICs9IGggKiBBZSwgY2UgKz0gaCAqIGl0LCByZSArPSBoICogc3QsIGggPSBBWzFdLCBYICs9IGggKiBxZSwgZmUgKz0gaCAqIEZlLCB2ZSArPSBoICogamUsIGdlICs9IGggKiB6ZSwgU2UgKz0gaCAqIEtlLCBNZSArPSBoICogVWUsICRlICs9IGggKiBRZSwgYmUgKz0gaCAqIFhlLCB5ZSArPSBoICogWmUsIHBlICs9IGggKiBldCwgbGUgKz0gaCAqIHR0LCB1ZSArPSBoICogWWUsIGhlICs9IGggKiBWZSwgY2UgKz0gaCAqIEFlLCByZSArPSBoICogaXQsIGRlICs9IGggKiBzdCwgaCA9IEFbMl0sIGZlICs9IGggKiBxZSwgdmUgKz0gaCAqIEZlLCBnZSArPSBoICogamUsIFNlICs9IGggKiB6ZSwgTWUgKz0gaCAqIEtlLCAkZSArPSBoICogVWUsIGJlICs9IGggKiBRZSwgeWUgKz0gaCAqIFhlLCBwZSArPSBoICogWmUsIGxlICs9IGggKiBldCwgdWUgKz0gaCAqIHR0LCBoZSArPSBoICogWWUsIGNlICs9IGggKiBWZSwgcmUgKz0gaCAqIEFlLCBkZSArPSBoICogaXQsIG1lICs9IGggKiBzdCwgaCA9IEFbM10sIHZlICs9IGggKiBxZSwgZ2UgKz0gaCAqIEZlLCBTZSArPSBoICogamUsIE1lICs9IGggKiB6ZSwgJGUgKz0gaCAqIEtlLCBiZSArPSBoICogVWUsIHllICs9IGggKiBRZSwgcGUgKz0gaCAqIFhlLCBsZSArPSBoICogWmUsIHVlICs9IGggKiBldCwgaGUgKz0gaCAqIHR0LCBjZSArPSBoICogWWUsIHJlICs9IGggKiBWZSwgZGUgKz0gaCAqIEFlLCBtZSArPSBoICogaXQsIG5lICs9IGggKiBzdCwgaCA9IEFbNF0sIGdlICs9IGggKiBxZSwgU2UgKz0gaCAqIEZlLCBNZSArPSBoICogamUsICRlICs9IGggKiB6ZSwgYmUgKz0gaCAqIEtlLCB5ZSArPSBoICogVWUsIHBlICs9IGggKiBRZSwgbGUgKz0gaCAqIFhlLCB1ZSArPSBoICogWmUsIGhlICs9IGggKiBldCwgY2UgKz0gaCAqIHR0LCByZSArPSBoICogWWUsIGRlICs9IGggKiBWZSwgbWUgKz0gaCAqIEFlLCBuZSArPSBoICogaXQsIF9lICs9IGggKiBzdCwgaCA9IEFbNV0sIFNlICs9IGggKiBxZSwgTWUgKz0gaCAqIEZlLCAkZSArPSBoICogamUsIGJlICs9IGggKiB6ZSwgeWUgKz0gaCAqIEtlLCBwZSArPSBoICogVWUsIGxlICs9IGggKiBRZSwgdWUgKz0gaCAqIFhlLCBoZSArPSBoICogWmUsIGNlICs9IGggKiBldCwgcmUgKz0gaCAqIHR0LCBkZSArPSBoICogWWUsIG1lICs9IGggKiBWZSwgbmUgKz0gaCAqIEFlLCBfZSArPSBoICogaXQsIEVlICs9IGggKiBzdCwgaCA9IEFbNl0sIE1lICs9IGggKiBxZSwgJGUgKz0gaCAqIEZlLCBiZSArPSBoICogamUsIHllICs9IGggKiB6ZSwgcGUgKz0gaCAqIEtlLCBsZSArPSBoICogVWUsIHVlICs9IGggKiBRZSwgaGUgKz0gaCAqIFhlLCBjZSArPSBoICogWmUsIHJlICs9IGggKiBldCwgZGUgKz0gaCAqIHR0LCBtZSArPSBoICogWWUsIG5lICs9IGggKiBWZSwgX2UgKz0gaCAqIEFlLCBFZSArPSBoICogaXQsIERlICs9IGggKiBzdCwgaCA9IEFbN10sICRlICs9IGggKiBxZSwgYmUgKz0gaCAqIEZlLCB5ZSArPSBoICogamUsIHBlICs9IGggKiB6ZSwgbGUgKz0gaCAqIEtlLCB1ZSArPSBoICogVWUsIGhlICs9IGggKiBRZSwgY2UgKz0gaCAqIFhlLCByZSArPSBoICogWmUsIGRlICs9IGggKiBldCwgbWUgKz0gaCAqIHR0LCBuZSArPSBoICogWWUsIF9lICs9IGggKiBWZSwgRWUgKz0gaCAqIEFlLCBEZSArPSBoICogaXQsIHhlICs9IGggKiBzdCwgaCA9IEFbOF0sIGJlICs9IGggKiBxZSwgeWUgKz0gaCAqIEZlLCBwZSArPSBoICogamUsIGxlICs9IGggKiB6ZSwgdWUgKz0gaCAqIEtlLCBoZSArPSBoICogVWUsIGNlICs9IGggKiBRZSwgcmUgKz0gaCAqIFhlLCBkZSArPSBoICogWmUsIG1lICs9IGggKiBldCwgbmUgKz0gaCAqIHR0LCBfZSArPSBoICogWWUsIEVlICs9IGggKiBWZSwgRGUgKz0gaCAqIEFlLCB4ZSArPSBoICogaXQsIEllICs9IGggKiBzdCwgaCA9IEFbOV0sIHllICs9IGggKiBxZSwgcGUgKz0gaCAqIEZlLCBsZSArPSBoICogamUsIHVlICs9IGggKiB6ZSwgaGUgKz0gaCAqIEtlLCBjZSArPSBoICogVWUsIHJlICs9IGggKiBRZSwgZGUgKz0gaCAqIFhlLCBtZSArPSBoICogWmUsIG5lICs9IGggKiBldCwgX2UgKz0gaCAqIHR0LCBFZSArPSBoICogWWUsIERlICs9IGggKiBWZSwgeGUgKz0gaCAqIEFlLCBJZSArPSBoICogaXQsIFV0ICs9IGggKiBzdCwgaCA9IEFbMTBdLCBwZSArPSBoICogcWUsIGxlICs9IGggKiBGZSwgdWUgKz0gaCAqIGplLCBoZSArPSBoICogemUsIGNlICs9IGggKiBLZSwgcmUgKz0gaCAqIFVlLCBkZSArPSBoICogUWUsIG1lICs9IGggKiBYZSwgbmUgKz0gaCAqIFplLCBfZSArPSBoICogZXQsIEVlICs9IGggKiB0dCwgRGUgKz0gaCAqIFllLCB4ZSArPSBoICogVmUsIEllICs9IGggKiBBZSwgVXQgKz0gaCAqIGl0LCBxdCArPSBoICogc3QsIGggPSBBWzExXSwgbGUgKz0gaCAqIHFlLCB1ZSArPSBoICogRmUsIGhlICs9IGggKiBqZSwgY2UgKz0gaCAqIHplLCByZSArPSBoICogS2UsIGRlICs9IGggKiBVZSwgbWUgKz0gaCAqIFFlLCBuZSArPSBoICogWGUsIF9lICs9IGggKiBaZSwgRWUgKz0gaCAqIGV0LCBEZSArPSBoICogdHQsIHhlICs9IGggKiBZZSwgSWUgKz0gaCAqIFZlLCBVdCArPSBoICogQWUsIHF0ICs9IGggKiBpdCwgc2kgKz0gaCAqIHN0LCBoID0gQVsxMl0sIHVlICs9IGggKiBxZSwgaGUgKz0gaCAqIEZlLCBjZSArPSBoICogamUsIHJlICs9IGggKiB6ZSwgZGUgKz0gaCAqIEtlLCBtZSArPSBoICogVWUsIG5lICs9IGggKiBRZSwgX2UgKz0gaCAqIFhlLCBFZSArPSBoICogWmUsIERlICs9IGggKiBldCwgeGUgKz0gaCAqIHR0LCBJZSArPSBoICogWWUsIFV0ICs9IGggKiBWZSwgcXQgKz0gaCAqIEFlLCBzaSArPSBoICogaXQsIER0ICs9IGggKiBzdCwgaCA9IEFbMTNdLCBoZSArPSBoICogcWUsIGNlICs9IGggKiBGZSwgcmUgKz0gaCAqIGplLCBkZSArPSBoICogemUsIG1lICs9IGggKiBLZSwgbmUgKz0gaCAqIFVlLCBfZSArPSBoICogUWUsIEVlICs9IGggKiBYZSwgRGUgKz0gaCAqIFplLCB4ZSArPSBoICogZXQsIEllICs9IGggKiB0dCwgVXQgKz0gaCAqIFllLCBxdCArPSBoICogVmUsIHNpICs9IGggKiBBZSwgRHQgKz0gaCAqIGl0LCBmaSArPSBoICogc3QsIGggPSBBWzE0XSwgY2UgKz0gaCAqIHFlLCByZSArPSBoICogRmUsIGRlICs9IGggKiBqZSwgbWUgKz0gaCAqIHplLCBuZSArPSBoICogS2UsIF9lICs9IGggKiBVZSwgRWUgKz0gaCAqIFFlLCBEZSArPSBoICogWGUsIHhlICs9IGggKiBaZSwgSWUgKz0gaCAqIGV0LCBVdCArPSBoICogdHQsIHF0ICs9IGggKiBZZSwgc2kgKz0gaCAqIFZlLCBEdCArPSBoICogQWUsIGZpICs9IGggKiBpdCwgS2kgKz0gaCAqIHN0LCBoID0gQVsxNV0sIHJlICs9IGggKiBxZSwgZGUgKz0gaCAqIEZlLCBtZSArPSBoICogamUsIG5lICs9IGggKiB6ZSwgX2UgKz0gaCAqIEtlLCBFZSArPSBoICogVWUsIERlICs9IGggKiBRZSwgeGUgKz0gaCAqIFhlLCBJZSArPSBoICogWmUsIFV0ICs9IGggKiBldCwgcXQgKz0gaCAqIHR0LCBzaSArPSBoICogWWUsIER0ICs9IGggKiBWZSwgZmkgKz0gaCAqIEFlLCBLaSArPSBoICogaXQsIE9zICs9IGggKiBzdCwgVyArPSAzOCAqIGRlLCBYICs9IDM4ICogbWUsIGZlICs9IDM4ICogbmUsIHZlICs9IDM4ICogX2UsIGdlICs9IDM4ICogRWUsIFNlICs9IDM4ICogRGUsIE1lICs9IDM4ICogeGUsICRlICs9IDM4ICogSWUsIGJlICs9IDM4ICogVXQsIHllICs9IDM4ICogcXQsIHBlICs9IDM4ICogc2ksIGxlICs9IDM4ICogRHQsIHVlICs9IDM4ICogZmksIGhlICs9IDM4ICogS2ksIGNlICs9IDM4ICogT3MsIFMgPSAxLCBoID0gVyArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgVyA9IGggLSBTICogNjU1MzYsIGggPSBYICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBYID0gaCAtIFMgKiA2NTUzNiwgaCA9IGZlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBmZSA9IGggLSBTICogNjU1MzYsIGggPSB2ZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgdmUgPSBoIC0gUyAqIDY1NTM2LCBoID0gZ2UgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIGdlID0gaCAtIFMgKiA2NTUzNiwgaCA9IFNlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBTZSA9IGggLSBTICogNjU1MzYsIGggPSBNZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgTWUgPSBoIC0gUyAqIDY1NTM2LCBoID0gJGUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksICRlID0gaCAtIFMgKiA2NTUzNiwgaCA9IGJlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBiZSA9IGggLSBTICogNjU1MzYsIGggPSB5ZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgeWUgPSBoIC0gUyAqIDY1NTM2LCBoID0gcGUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIHBlID0gaCAtIFMgKiA2NTUzNiwgaCA9IGxlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBsZSA9IGggLSBTICogNjU1MzYsIGggPSB1ZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgdWUgPSBoIC0gUyAqIDY1NTM2LCBoID0gaGUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIGhlID0gaCAtIFMgKiA2NTUzNiwgaCA9IGNlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBjZSA9IGggLSBTICogNjU1MzYsIGggPSByZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgcmUgPSBoIC0gUyAqIDY1NTM2LCBXICs9IFMgLSAxICsgMzcgKiAoUyAtIDEpLCBTID0gMSwgaCA9IFcgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIFcgPSBoIC0gUyAqIDY1NTM2LCBoID0gWCArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgWCA9IGggLSBTICogNjU1MzYsIGggPSBmZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgZmUgPSBoIC0gUyAqIDY1NTM2LCBoID0gdmUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIHZlID0gaCAtIFMgKiA2NTUzNiwgaCA9IGdlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBnZSA9IGggLSBTICogNjU1MzYsIGggPSBTZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgU2UgPSBoIC0gUyAqIDY1NTM2LCBoID0gTWUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIE1lID0gaCAtIFMgKiA2NTUzNiwgaCA9ICRlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCAkZSA9IGggLSBTICogNjU1MzYsIGggPSBiZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgYmUgPSBoIC0gUyAqIDY1NTM2LCBoID0geWUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIHllID0gaCAtIFMgKiA2NTUzNiwgaCA9IHBlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBwZSA9IGggLSBTICogNjU1MzYsIGggPSBsZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgbGUgPSBoIC0gUyAqIDY1NTM2LCBoID0gdWUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIHVlID0gaCAtIFMgKiA2NTUzNiwgaCA9IGhlICsgUyArIDY1NTM1LCBTID0gTWF0aC5mbG9vcihoIC8gNjU1MzYpLCBoZSA9IGggLSBTICogNjU1MzYsIGggPSBjZSArIFMgKyA2NTUzNSwgUyA9IE1hdGguZmxvb3IoaCAvIDY1NTM2KSwgY2UgPSBoIC0gUyAqIDY1NTM2LCBoID0gcmUgKyBTICsgNjU1MzUsIFMgPSBNYXRoLmZsb29yKGggLyA2NTUzNiksIHJlID0gaCAtIFMgKiA2NTUzNiwgVyArPSBTIC0gMSArIDM3ICogKFMgLSAxKSwgVFswXSA9IFcsIFRbMV0gPSBYLCBUWzJdID0gZmUsIFRbM10gPSB2ZSwgVFs0XSA9IGdlLCBUWzVdID0gU2UsIFRbNl0gPSBNZSwgVFs3XSA9ICRlLCBUWzhdID0gYmUsIFRbOV0gPSB5ZSwgVFsxMF0gPSBwZSwgVFsxMV0gPSBsZSwgVFsxMl0gPSB1ZSwgVFsxM10gPSBoZSwgVFsxNF0gPSBjZSwgVFsxNV0gPSByZTtcbiAgfVxuICBmdW5jdGlvbiBsKFQsIEEpIHtcbiAgICBhKFQsIEEsIEEpO1xuICB9XG4gIGZ1bmN0aW9uIEwoVCwgQSkge1xuICAgIGNvbnN0IE4gPSByKCk7XG4gICAgbGV0IGg7XG4gICAgZm9yIChoID0gMDsgaCA8IDE2OyBoKyspXG4gICAgICBOW2hdID0gQVtoXTtcbiAgICBmb3IgKGggPSAyNTM7IGggPj0gMDsgaC0tKVxuICAgICAgbChOLCBOKSwgaCAhPT0gMiAmJiBoICE9PSA0ICYmIGEoTiwgTiwgQSk7XG4gICAgZm9yIChoID0gMDsgaCA8IDE2OyBoKyspXG4gICAgICBUW2hdID0gTltoXTtcbiAgfVxuICBmdW5jdGlvbiB2KFQsIEEpIHtcbiAgICBjb25zdCBOID0gcigpO1xuICAgIGxldCBoO1xuICAgIGZvciAoaCA9IDA7IGggPCAxNjsgaCsrKVxuICAgICAgTltoXSA9IEFbaF07XG4gICAgZm9yIChoID0gMjUwOyBoID49IDA7IGgtLSlcbiAgICAgIGwoTiwgTiksIGggIT09IDEgJiYgYShOLCBOLCBBKTtcbiAgICBmb3IgKGggPSAwOyBoIDwgMTY7IGgrKylcbiAgICAgIFRbaF0gPSBOW2hdO1xuICB9XG4gIGZ1bmN0aW9uIFIoVCwgQSkge1xuICAgIGNvbnN0IE4gPSByKCksIGggPSByKCksIFMgPSByKCksIFcgPSByKCksIFggPSByKCksIGZlID0gcigpLCB2ZSA9IHIoKSwgZ2UgPSByKCksIFNlID0gcigpO1xuICAgIGYoTiwgVFsxXSwgVFswXSksIGYoU2UsIEFbMV0sIEFbMF0pLCBhKE4sIE4sIFNlKSwgdyhoLCBUWzBdLCBUWzFdKSwgdyhTZSwgQVswXSwgQVsxXSksIGEoaCwgaCwgU2UpLCBhKFMsIFRbM10sIEFbM10pLCBhKFMsIFMsIGQpLCBhKFcsIFRbMl0sIEFbMl0pLCB3KFcsIFcsIFcpLCBmKFgsIGgsIE4pLCBmKGZlLCBXLCBTKSwgdyh2ZSwgVywgUyksIHcoZ2UsIGgsIE4pLCBhKFRbMF0sIFgsIGZlKSwgYShUWzFdLCBnZSwgdmUpLCBhKFRbMl0sIHZlLCBmZSksIGEoVFszXSwgWCwgZ2UpO1xuICB9XG4gIGZ1bmN0aW9uICQoVCwgQSwgTikge1xuICAgIGZvciAobGV0IGggPSAwOyBoIDwgNDsgaCsrKVxuICAgICAgQyhUW2hdLCBBW2hdLCBOKTtcbiAgfVxuICBmdW5jdGlvbiBxKFQsIEEpIHtcbiAgICBjb25zdCBOID0gcigpLCBoID0gcigpLCBTID0gcigpO1xuICAgIEwoUywgQVsyXSksIGEoTiwgQVswXSwgUyksIGEoaCwgQVsxXSwgUyksIEYoVCwgaCksIFRbMzFdIF49IEQoTikgPDwgNztcbiAgfVxuICBmdW5jdGlvbiBtKFQsIEEsIE4pIHtcbiAgICBPKFRbMF0sIG8pLCBPKFRbMV0sIGMpLCBPKFRbMl0sIGMpLCBPKFRbM10sIG8pO1xuICAgIGZvciAobGV0IGggPSAyNTU7IGggPj0gMDsgLS1oKSB7XG4gICAgICBjb25zdCBTID0gTltoIC8gOCB8IDBdID4+IChoICYgNykgJiAxO1xuICAgICAgJChULCBBLCBTKSwgUihBLCBUKSwgUihULCBUKSwgJChULCBBLCBTKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gRShULCBBKSB7XG4gICAgY29uc3QgTiA9IFtyKCksIHIoKSwgcigpLCByKCldO1xuICAgIE8oTlswXSwgcCksIE8oTlsxXSwgYiksIE8oTlsyXSwgYyksIGEoTlszXSwgcCwgYiksIG0oVCwgTiwgQSk7XG4gIH1cbiAgZnVuY3Rpb24gQihUKSB7XG4gICAgaWYgKFQubGVuZ3RoICE9PSBpLlNFRURfTEVOR1RIKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBlZDI1NTE5OiBzZWVkIG11c3QgYmUgJHtpLlNFRURfTEVOR1RIfSBieXRlc2ApO1xuICAgIGNvbnN0IEEgPSAoMCwgdC5oYXNoKShUKTtcbiAgICBBWzBdICY9IDI0OCwgQVszMV0gJj0gMTI3LCBBWzMxXSB8PSA2NDtcbiAgICBjb25zdCBOID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBoID0gW3IoKSwgcigpLCByKCksIHIoKV07XG4gICAgRShoLCBBKSwgcShOLCBoKTtcbiAgICBjb25zdCBTID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgIHJldHVybiBTLnNldChUKSwgUy5zZXQoTiwgMzIpLCB7XG4gICAgICBwdWJsaWNLZXk6IE4sXG4gICAgICBzZWNyZXRLZXk6IFNcbiAgICB9O1xuICB9XG4gIGkuZ2VuZXJhdGVLZXlQYWlyRnJvbVNlZWQgPSBCO1xuICBmdW5jdGlvbiB6KFQpIHtcbiAgICBjb25zdCBBID0gKDAsIGUucmFuZG9tQnl0ZXMpKDMyLCBUKSwgTiA9IEIoQSk7XG4gICAgcmV0dXJuICgwLCBzLndpcGUpKEEpLCBOO1xuICB9XG4gIGkuZ2VuZXJhdGVLZXlQYWlyID0gejtcbiAgZnVuY3Rpb24gaihUKSB7XG4gICAgaWYgKFQubGVuZ3RoICE9PSBpLlNFQ1JFVF9LRVlfTEVOR1RIKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBlZDI1NTE5OiBzZWNyZXQga2V5IG11c3QgYmUgJHtpLlNFQ1JFVF9LRVlfTEVOR1RIfSBieXRlc2ApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShULnN1YmFycmF5KDMyKSk7XG4gIH1cbiAgaS5leHRyYWN0UHVibGljS2V5RnJvbVNlY3JldEtleSA9IGo7XG4gIGNvbnN0IFUgPSBuZXcgRmxvYXQ2NEFycmF5KFtcbiAgICAyMzcsXG4gICAgMjExLFxuICAgIDI0NSxcbiAgICA5MixcbiAgICAyNixcbiAgICA5OSxcbiAgICAxOCxcbiAgICA4OCxcbiAgICAyMTQsXG4gICAgMTU2LFxuICAgIDI0NyxcbiAgICAxNjIsXG4gICAgMjIyLFxuICAgIDI0OSxcbiAgICAyMjIsXG4gICAgMjAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMTZcbiAgXSk7XG4gIGZ1bmN0aW9uIE0oVCwgQSkge1xuICAgIGxldCBOLCBoLCBTLCBXO1xuICAgIGZvciAoaCA9IDYzOyBoID49IDMyOyAtLWgpIHtcbiAgICAgIGZvciAoTiA9IDAsIFMgPSBoIC0gMzIsIFcgPSBoIC0gMTI7IFMgPCBXOyArK1MpXG4gICAgICAgIEFbU10gKz0gTiAtIDE2ICogQVtoXSAqIFVbUyAtIChoIC0gMzIpXSwgTiA9IE1hdGguZmxvb3IoKEFbU10gKyAxMjgpIC8gMjU2KSwgQVtTXSAtPSBOICogMjU2O1xuICAgICAgQVtTXSArPSBOLCBBW2hdID0gMDtcbiAgICB9XG4gICAgZm9yIChOID0gMCwgUyA9IDA7IFMgPCAzMjsgUysrKVxuICAgICAgQVtTXSArPSBOIC0gKEFbMzFdID4+IDQpICogVVtTXSwgTiA9IEFbU10gPj4gOCwgQVtTXSAmPSAyNTU7XG4gICAgZm9yIChTID0gMDsgUyA8IDMyOyBTKyspXG4gICAgICBBW1NdIC09IE4gKiBVW1NdO1xuICAgIGZvciAoaCA9IDA7IGggPCAzMjsgaCsrKVxuICAgICAgQVtoICsgMV0gKz0gQVtoXSA+PiA4LCBUW2hdID0gQVtoXSAmIDI1NTtcbiAgfVxuICBmdW5jdGlvbiBIKFQpIHtcbiAgICBjb25zdCBBID0gbmV3IEZsb2F0NjRBcnJheSg2NCk7XG4gICAgZm9yIChsZXQgTiA9IDA7IE4gPCA2NDsgTisrKVxuICAgICAgQVtOXSA9IFRbTl07XG4gICAgZm9yIChsZXQgTiA9IDA7IE4gPCA2NDsgTisrKVxuICAgICAgVFtOXSA9IDA7XG4gICAgTShULCBBKTtcbiAgfVxuICBmdW5jdGlvbiB0ZShULCBBKSB7XG4gICAgY29uc3QgTiA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpLCBoID0gW3IoKSwgcigpLCByKCksIHIoKV0sIFMgPSAoMCwgdC5oYXNoKShULnN1YmFycmF5KDAsIDMyKSk7XG4gICAgU1swXSAmPSAyNDgsIFNbMzFdICY9IDEyNywgU1szMV0gfD0gNjQ7XG4gICAgY29uc3QgVyA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICBXLnNldChTLnN1YmFycmF5KDMyKSwgMzIpO1xuICAgIGNvbnN0IFggPSBuZXcgdC5TSEE1MTIoKTtcbiAgICBYLnVwZGF0ZShXLnN1YmFycmF5KDMyKSksIFgudXBkYXRlKEEpO1xuICAgIGNvbnN0IGZlID0gWC5kaWdlc3QoKTtcbiAgICBYLmNsZWFuKCksIEgoZmUpLCBFKGgsIGZlKSwgcShXLCBoKSwgWC5yZXNldCgpLCBYLnVwZGF0ZShXLnN1YmFycmF5KDAsIDMyKSksIFgudXBkYXRlKFQuc3ViYXJyYXkoMzIpKSwgWC51cGRhdGUoQSk7XG4gICAgY29uc3QgdmUgPSBYLmRpZ2VzdCgpO1xuICAgIEgodmUpO1xuICAgIGZvciAobGV0IGdlID0gMDsgZ2UgPCAzMjsgZ2UrKylcbiAgICAgIE5bZ2VdID0gZmVbZ2VdO1xuICAgIGZvciAobGV0IGdlID0gMDsgZ2UgPCAzMjsgZ2UrKylcbiAgICAgIGZvciAobGV0IFNlID0gMDsgU2UgPCAzMjsgU2UrKylcbiAgICAgICAgTltnZSArIFNlXSArPSB2ZVtnZV0gKiBTW1NlXTtcbiAgICByZXR1cm4gTShXLnN1YmFycmF5KDMyKSwgTiksIFc7XG4gIH1cbiAgaS5zaWduID0gdGU7XG4gIGZ1bmN0aW9uIEcoVCwgQSkge1xuICAgIGNvbnN0IE4gPSByKCksIGggPSByKCksIFMgPSByKCksIFcgPSByKCksIFggPSByKCksIGZlID0gcigpLCB2ZSA9IHIoKTtcbiAgICByZXR1cm4gTyhUWzJdLCBjKSwgeShUWzFdLCBBKSwgbChTLCBUWzFdKSwgYShXLCBTLCB1KSwgZihTLCBTLCBUWzJdKSwgdyhXLCBUWzJdLCBXKSwgbChYLCBXKSwgbChmZSwgWCksIGEodmUsIGZlLCBYKSwgYShOLCB2ZSwgUyksIGEoTiwgTiwgVyksIHYoTiwgTiksIGEoTiwgTiwgUyksIGEoTiwgTiwgVyksIGEoTiwgTiwgVyksIGEoVFswXSwgTiwgVyksIGwoaCwgVFswXSksIGEoaCwgaCwgVyksIEkoaCwgUykgJiYgYShUWzBdLCBUWzBdLCB4KSwgbChoLCBUWzBdKSwgYShoLCBoLCBXKSwgSShoLCBTKSA/IC0xIDogKEQoVFswXSkgPT09IEFbMzFdID4+IDcgJiYgZihUWzBdLCBvLCBUWzBdKSwgYShUWzNdLCBUWzBdLCBUWzFdKSwgMCk7XG4gIH1cbiAgZnVuY3Rpb24gaWUoVCwgQSwgTikge1xuICAgIGNvbnN0IGggPSBuZXcgVWludDhBcnJheSgzMiksIFMgPSBbcigpLCByKCksIHIoKSwgcigpXSwgVyA9IFtyKCksIHIoKSwgcigpLCByKCldO1xuICAgIGlmIChOLmxlbmd0aCAhPT0gaS5TSUdOQVRVUkVfTEVOR1RIKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBlZDI1NTE5OiBzaWduYXR1cmUgbXVzdCBiZSAke2kuU0lHTkFUVVJFX0xFTkdUSH0gYnl0ZXNgKTtcbiAgICBpZiAoRyhXLCBUKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBYID0gbmV3IHQuU0hBNTEyKCk7XG4gICAgWC51cGRhdGUoTi5zdWJhcnJheSgwLCAzMikpLCBYLnVwZGF0ZShUKSwgWC51cGRhdGUoQSk7XG4gICAgY29uc3QgZmUgPSBYLmRpZ2VzdCgpO1xuICAgIHJldHVybiBIKGZlKSwgbShTLCBXLCBmZSksIEUoVywgTi5zdWJhcnJheSgzMikpLCBSKFMsIFcpLCBxKGgsIFMpLCAhSyhOLCBoKTtcbiAgfVxuICBpLnZlcmlmeSA9IGllO1xuICBmdW5jdGlvbiBRKFQpIHtcbiAgICBsZXQgQSA9IFtyKCksIHIoKSwgcigpLCByKCldO1xuICAgIGlmIChHKEEsIFQpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWQyNTUxOTogaW52YWxpZCBwdWJsaWMga2V5XCIpO1xuICAgIGxldCBOID0gcigpLCBoID0gcigpLCBTID0gQVsxXTtcbiAgICB3KE4sIGMsIFMpLCBmKGgsIGMsIFMpLCBMKGgsIGgpLCBhKE4sIE4sIGgpO1xuICAgIGxldCBXID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHJldHVybiBGKFcsIE4pLCBXO1xuICB9XG4gIGkuY29udmVydFB1YmxpY0tleVRvWDI1NTE5ID0gUTtcbiAgZnVuY3Rpb24gc2UoVCkge1xuICAgIGNvbnN0IEEgPSAoMCwgdC5oYXNoKShULnN1YmFycmF5KDAsIDMyKSk7XG4gICAgQVswXSAmPSAyNDgsIEFbMzFdICY9IDEyNywgQVszMV0gfD0gNjQ7XG4gICAgY29uc3QgTiA9IG5ldyBVaW50OEFycmF5KEEuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICByZXR1cm4gKDAsIHMud2lwZSkoQSksIE47XG4gIH1cbiAgaS5jb252ZXJ0U2VjcmV0S2V5VG9YMjU1MTkgPSBzZTtcbn0pKG5uKTtcbmNvbnN0IHNkID0gXCJFZERTQVwiLCByZCA9IFwiSldUXCIsIG1jID0gXCIuXCIsIGJjID0gXCJiYXNlNjR1cmxcIiwgbmQgPSBcInV0ZjhcIiwgb2QgPSBcInV0ZjhcIiwgYWQgPSBcIjpcIiwgY2QgPSBcImRpZFwiLCBoZCA9IFwia2V5XCIsIG1vID0gXCJiYXNlNThidGNcIiwgdWQgPSBcInpcIiwgbGQgPSBcIkszNlwiLCBkZCA9IDMyO1xuZnVuY3Rpb24gb24oaSkge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCA/IG5ldyBVaW50OEFycmF5KGkuYnVmZmVyLCBpLmJ5dGVPZmZzZXQsIGkuYnl0ZUxlbmd0aCkgOiBpO1xufVxuZnVuY3Rpb24gd2MoaSA9IDApIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2NVbnNhZmUgIT0gbnVsbCA/IG9uKGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jVW5zYWZlKGkpKSA6IG5ldyBVaW50OEFycmF5KGkpO1xufVxuZnVuY3Rpb24gbHMoaSwgZSkge1xuICBlIHx8IChlID0gaS5yZWR1Y2UoKHIsIG4pID0+IHIgKyBuLmxlbmd0aCwgMCkpO1xuICBjb25zdCB0ID0gd2MoZSk7XG4gIGxldCBzID0gMDtcbiAgZm9yIChjb25zdCByIG9mIGkpXG4gICAgdC5zZXQociwgcyksIHMgKz0gci5sZW5ndGg7XG4gIHJldHVybiBvbih0KTtcbn1cbmZ1bmN0aW9uIGZkKGksIGUpIHtcbiAgaWYgKGkubGVuZ3RoID49IDI1NSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWxwaGFiZXQgdG9vIGxvbmdcIik7XG4gIGZvciAodmFyIHQgPSBuZXcgVWludDhBcnJheSgyNTYpLCBzID0gMDsgcyA8IHQubGVuZ3RoOyBzKyspXG4gICAgdFtzXSA9IDI1NTtcbiAgZm9yICh2YXIgciA9IDA7IHIgPCBpLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIG4gPSBpLmNoYXJBdChyKSwgbyA9IG4uY2hhckNvZGVBdCgwKTtcbiAgICBpZiAodFtvXSAhPT0gMjU1KVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuICsgXCIgaXMgYW1iaWd1b3VzXCIpO1xuICAgIHRbb10gPSByO1xuICB9XG4gIHZhciBjID0gaS5sZW5ndGgsIHUgPSBpLmNoYXJBdCgwKSwgZCA9IE1hdGgubG9nKGMpIC8gTWF0aC5sb2coMjU2KSwgcCA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhjKTtcbiAgZnVuY3Rpb24gYihfKSB7XG4gICAgaWYgKF8gaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoXykgPyBfID0gbmV3IFVpbnQ4QXJyYXkoXy5idWZmZXIsIF8uYnl0ZU9mZnNldCwgXy5ieXRlTGVuZ3RoKSA6IEFycmF5LmlzQXJyYXkoXykgJiYgKF8gPSBVaW50OEFycmF5LmZyb20oXykpKSwgIShfIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheVwiKTtcbiAgICBpZiAoXy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBmb3IgKHZhciBDID0gMCwgRiA9IDAsIEsgPSAwLCBJID0gXy5sZW5ndGg7IEsgIT09IEkgJiYgX1tLXSA9PT0gMDsgKVxuICAgICAgSysrLCBDKys7XG4gICAgZm9yICh2YXIgRCA9IChJIC0gSykgKiBwICsgMSA+Pj4gMCwgeSA9IG5ldyBVaW50OEFycmF5KEQpOyBLICE9PSBJOyApIHtcbiAgICAgIGZvciAodmFyIHcgPSBfW0tdLCBmID0gMCwgYSA9IEQgLSAxOyAodyAhPT0gMCB8fCBmIDwgRikgJiYgYSAhPT0gLTE7IGEtLSwgZisrKVxuICAgICAgICB3ICs9IDI1NiAqIHlbYV0gPj4+IDAsIHlbYV0gPSB3ICUgYyA+Pj4gMCwgdyA9IHcgLyBjID4+PiAwO1xuICAgICAgaWYgKHcgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi16ZXJvIGNhcnJ5XCIpO1xuICAgICAgRiA9IGYsIEsrKztcbiAgICB9XG4gICAgZm9yICh2YXIgbCA9IEQgLSBGOyBsICE9PSBEICYmIHlbbF0gPT09IDA7IClcbiAgICAgIGwrKztcbiAgICBmb3IgKHZhciBMID0gdS5yZXBlYXQoQyk7IGwgPCBEOyArK2wpXG4gICAgICBMICs9IGkuY2hhckF0KHlbbF0pO1xuICAgIHJldHVybiBMO1xuICB9XG4gIGZ1bmN0aW9uIHgoXykge1xuICAgIGlmICh0eXBlb2YgXyAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZ1wiKTtcbiAgICBpZiAoXy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB2YXIgQyA9IDA7XG4gICAgaWYgKF9bQ10gIT09IFwiIFwiKSB7XG4gICAgICBmb3IgKHZhciBGID0gMCwgSyA9IDA7IF9bQ10gPT09IHU7IClcbiAgICAgICAgRisrLCBDKys7XG4gICAgICBmb3IgKHZhciBJID0gKF8ubGVuZ3RoIC0gQykgKiBkICsgMSA+Pj4gMCwgRCA9IG5ldyBVaW50OEFycmF5KEkpOyBfW0NdOyApIHtcbiAgICAgICAgdmFyIHkgPSB0W18uY2hhckNvZGVBdChDKV07XG4gICAgICAgIGlmICh5ID09PSAyNTUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciB3ID0gMCwgZiA9IEkgLSAxOyAoeSAhPT0gMCB8fCB3IDwgSykgJiYgZiAhPT0gLTE7IGYtLSwgdysrKVxuICAgICAgICAgIHkgKz0gYyAqIERbZl0gPj4+IDAsIERbZl0gPSB5ICUgMjU2ID4+PiAwLCB5ID0geSAvIDI1NiA+Pj4gMDtcbiAgICAgICAgaWYgKHkgIT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLXplcm8gY2FycnlcIik7XG4gICAgICAgIEsgPSB3LCBDKys7XG4gICAgICB9XG4gICAgICBpZiAoX1tDXSAhPT0gXCIgXCIpIHtcbiAgICAgICAgZm9yICh2YXIgYSA9IEkgLSBLOyBhICE9PSBJICYmIERbYV0gPT09IDA7IClcbiAgICAgICAgICBhKys7XG4gICAgICAgIGZvciAodmFyIGwgPSBuZXcgVWludDhBcnJheShGICsgKEkgLSBhKSksIEwgPSBGOyBhICE9PSBJOyApXG4gICAgICAgICAgbFtMKytdID0gRFthKytdO1xuICAgICAgICByZXR1cm4gbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gTyhfKSB7XG4gICAgdmFyIEMgPSB4KF8pO1xuICAgIGlmIChDKVxuICAgICAgcmV0dXJuIEM7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb24tJHtlfSBjaGFyYWN0ZXJgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogYixcbiAgICBkZWNvZGVVbnNhZmU6IHgsXG4gICAgZGVjb2RlOiBPXG4gIH07XG59XG52YXIgcGQgPSBmZCwgZ2QgPSBwZDtcbmNvbnN0IHlkID0gKGkpID0+IHtcbiAgaWYgKGkgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGkuY29uc3RydWN0b3IubmFtZSA9PT0gXCJVaW50OEFycmF5XCIpXG4gICAgcmV0dXJuIGk7XG4gIGlmIChpIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGkpO1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGkpKVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShpLmJ1ZmZlciwgaS5ieXRlT2Zmc2V0LCBpLmJ5dGVMZW5ndGgpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGVcIik7XG59LCBtZCA9IChpKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoaSksIGJkID0gKGkpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShpKTtcbmNsYXNzIHdkIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcykge1xuICAgIHRoaXMubmFtZSA9IGUsIHRoaXMucHJlZml4ID0gdCwgdGhpcy5iYXNlRW5jb2RlID0gcztcbiAgfVxuICBlbmNvZGUoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgIHJldHVybiBgJHt0aGlzLnByZWZpeH0ke3RoaXMuYmFzZUVuY29kZShlKX1gO1xuICAgIHRocm93IEVycm9yKFwiVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlXCIpO1xuICB9XG59XG5jbGFzcyB2ZCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMpIHtcbiAgICBpZiAodGhpcy5uYW1lID0gZSwgdGhpcy5wcmVmaXggPSB0LCB0LmNvZGVQb2ludEF0KDApID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByZWZpeCBjaGFyYWN0ZXJcIik7XG4gICAgdGhpcy5wcmVmaXhDb2RlUG9pbnQgPSB0LmNvZGVQb2ludEF0KDApLCB0aGlzLmJhc2VEZWNvZGUgPSBzO1xuICB9XG4gIGRlY29kZShlKSB7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChlLmNvZGVQb2ludEF0KDApICE9PSB0aGlzLnByZWZpeENvZGVQb2ludClcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBkZWNvZGUgbXVsdGliYXNlIHN0cmluZyAke0pTT04uc3RyaW5naWZ5KGUpfSwgJHt0aGlzLm5hbWV9IGRlY29kZXIgb25seSBzdXBwb3J0cyBpbnB1dHMgcHJlZml4ZWQgd2l0aCAke3RoaXMucHJlZml4fWApO1xuICAgICAgcmV0dXJuIHRoaXMuYmFzZURlY29kZShlLnNsaWNlKHRoaXMucHJlZml4Lmxlbmd0aCkpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgRXJyb3IoXCJDYW4gb25seSBtdWx0aWJhc2UgZGVjb2RlIHN0cmluZ3NcIik7XG4gIH1cbiAgb3IoZSkge1xuICAgIHJldHVybiB2Yyh0aGlzLCBlKTtcbiAgfVxufVxuY2xhc3MgX2Qge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5kZWNvZGVycyA9IGU7XG4gIH1cbiAgb3IoZSkge1xuICAgIHJldHVybiB2Yyh0aGlzLCBlKTtcbiAgfVxuICBkZWNvZGUoZSkge1xuICAgIGNvbnN0IHQgPSBlWzBdLCBzID0gdGhpcy5kZWNvZGVyc1t0XTtcbiAgICBpZiAocylcbiAgICAgIHJldHVybiBzLmRlY29kZShlKTtcbiAgICB0aHJvdyBSYW5nZUVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShlKX0sIG9ubHkgaW5wdXRzIHByZWZpeGVkIHdpdGggJHtPYmplY3Qua2V5cyh0aGlzLmRlY29kZXJzKX0gYXJlIHN1cHBvcnRlZGApO1xuICB9XG59XG5jb25zdCB2YyA9IChpLCBlKSA9PiBuZXcgX2Qoe1xuICAuLi5pLmRlY29kZXJzIHx8IHsgW2kucHJlZml4XTogaSB9LFxuICAuLi5lLmRlY29kZXJzIHx8IHsgW2UucHJlZml4XTogZSB9XG59KTtcbmNsYXNzIEVkIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcywgcikge1xuICAgIHRoaXMubmFtZSA9IGUsIHRoaXMucHJlZml4ID0gdCwgdGhpcy5iYXNlRW5jb2RlID0gcywgdGhpcy5iYXNlRGVjb2RlID0gciwgdGhpcy5lbmNvZGVyID0gbmV3IHdkKGUsIHQsIHMpLCB0aGlzLmRlY29kZXIgPSBuZXcgdmQoZSwgdCwgcik7XG4gIH1cbiAgZW5jb2RlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGVyLmVuY29kZShlKTtcbiAgfVxuICBkZWNvZGUoZSkge1xuICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlKGUpO1xuICB9XG59XG5jb25zdCBjciA9ICh7IG5hbWU6IGksIHByZWZpeDogZSwgZW5jb2RlOiB0LCBkZWNvZGU6IHMgfSkgPT4gbmV3IEVkKGksIGUsIHQsIHMpLCBwcyA9ICh7IHByZWZpeDogaSwgbmFtZTogZSwgYWxwaGFiZXQ6IHQgfSkgPT4ge1xuICBjb25zdCB7IGVuY29kZTogcywgZGVjb2RlOiByIH0gPSBnZCh0LCBlKTtcbiAgcmV0dXJuIGNyKHtcbiAgICBwcmVmaXg6IGksXG4gICAgbmFtZTogZSxcbiAgICBlbmNvZGU6IHMsXG4gICAgZGVjb2RlOiAobikgPT4geWQocihuKSlcbiAgfSk7XG59LCBTZCA9IChpLCBlLCB0LCBzKSA9PiB7XG4gIGNvbnN0IHIgPSB7fTtcbiAgZm9yIChsZXQgcCA9IDA7IHAgPCBlLmxlbmd0aDsgKytwKVxuICAgIHJbZVtwXV0gPSBwO1xuICBsZXQgbiA9IGkubGVuZ3RoO1xuICBmb3IgKDsgaVtuIC0gMV0gPT09IFwiPVwiOyApXG4gICAgLS1uO1xuICBjb25zdCBvID0gbmV3IFVpbnQ4QXJyYXkobiAqIHQgLyA4IHwgMCk7XG4gIGxldCBjID0gMCwgdSA9IDAsIGQgPSAwO1xuICBmb3IgKGxldCBwID0gMDsgcCA8IG47ICsrcCkge1xuICAgIGNvbnN0IGIgPSByW2lbcF1dO1xuICAgIGlmIChiID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE5vbi0ke3N9IGNoYXJhY3RlcmApO1xuICAgIHUgPSB1IDw8IHQgfCBiLCBjICs9IHQsIGMgPj0gOCAmJiAoYyAtPSA4LCBvW2QrK10gPSAyNTUgJiB1ID4+IGMpO1xuICB9XG4gIGlmIChjID49IHQgfHwgMjU1ICYgdSA8PCA4IC0gYylcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBkYXRhXCIpO1xuICByZXR1cm4gbztcbn0sIElkID0gKGksIGUsIHQpID0+IHtcbiAgY29uc3QgcyA9IGVbZS5sZW5ndGggLSAxXSA9PT0gXCI9XCIsIHIgPSAoMSA8PCB0KSAtIDE7XG4gIGxldCBuID0gXCJcIiwgbyA9IDAsIGMgPSAwO1xuICBmb3IgKGxldCB1ID0gMDsgdSA8IGkubGVuZ3RoOyArK3UpXG4gICAgZm9yIChjID0gYyA8PCA4IHwgaVt1XSwgbyArPSA4OyBvID4gdDsgKVxuICAgICAgbyAtPSB0LCBuICs9IGVbciAmIGMgPj4gb107XG4gIGlmIChvICYmIChuICs9IGVbciAmIGMgPDwgdCAtIG9dKSwgcylcbiAgICBmb3IgKDsgbi5sZW5ndGggKiB0ICYgNzsgKVxuICAgICAgbiArPSBcIj1cIjtcbiAgcmV0dXJuIG47XG59LCB1dCA9ICh7IG5hbWU6IGksIHByZWZpeDogZSwgYml0c1BlckNoYXI6IHQsIGFscGhhYmV0OiBzIH0pID0+IGNyKHtcbiAgcHJlZml4OiBlLFxuICBuYW1lOiBpLFxuICBlbmNvZGUocikge1xuICAgIHJldHVybiBJZChyLCBzLCB0KTtcbiAgfSxcbiAgZGVjb2RlKHIpIHtcbiAgICByZXR1cm4gU2QociwgcywgdCwgaSk7XG4gIH1cbn0pLCBEZCA9IGNyKHtcbiAgcHJlZml4OiBcIlxcMFwiLFxuICBuYW1lOiBcImlkZW50aXR5XCIsXG4gIGVuY29kZTogKGkpID0+IGJkKGkpLFxuICBkZWNvZGU6IChpKSA9PiBtZChpKVxufSksIHhkID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgaWRlbnRpdHk6IERkXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBPZCA9IHV0KHtcbiAgcHJlZml4OiBcIjBcIixcbiAgbmFtZTogXCJiYXNlMlwiLFxuICBhbHBoYWJldDogXCIwMVwiLFxuICBiaXRzUGVyQ2hhcjogMVxufSksIE5kID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYmFzZTI6IE9kXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBQZCA9IHV0KHtcbiAgcHJlZml4OiBcIjdcIixcbiAgbmFtZTogXCJiYXNlOFwiLFxuICBhbHBoYWJldDogXCIwMTIzNDU2N1wiLFxuICBiaXRzUGVyQ2hhcjogM1xufSksIFJkID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYmFzZTg6IFBkXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBDZCA9IHBzKHtcbiAgcHJlZml4OiBcIjlcIixcbiAgbmFtZTogXCJiYXNlMTBcIixcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OVwiXG59KSwgQWQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBiYXNlMTA6IENkXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBUZCA9IHV0KHtcbiAgcHJlZml4OiBcImZcIixcbiAgbmFtZTogXCJiYXNlMTZcIixcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OWFiY2RlZlwiLFxuICBiaXRzUGVyQ2hhcjogNFxufSksICRkID0gdXQoe1xuICBwcmVmaXg6IFwiRlwiLFxuICBuYW1lOiBcImJhc2UxNnVwcGVyXCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZcIixcbiAgYml0c1BlckNoYXI6IDRcbn0pLCBGZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJhc2UxNjogVGQsXG4gIGJhc2UxNnVwcGVyOiAkZFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgVWQgPSB1dCh7XG4gIHByZWZpeDogXCJiXCIsXG4gIG5hbWU6IFwiYmFzZTMyXCIsXG4gIGFscGhhYmV0OiBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3XCIsXG4gIGJpdHNQZXJDaGFyOiA1XG59KSwgTGQgPSB1dCh7XG4gIHByZWZpeDogXCJCXCIsXG4gIG5hbWU6IFwiYmFzZTMydXBwZXJcIixcbiAgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjdcIixcbiAgYml0c1BlckNoYXI6IDVcbn0pLCBNZCA9IHV0KHtcbiAgcHJlZml4OiBcImNcIixcbiAgbmFtZTogXCJiYXNlMzJwYWRcIixcbiAgYWxwaGFiZXQ6IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1Njc9XCIsXG4gIGJpdHNQZXJDaGFyOiA1XG59KSwgcWQgPSB1dCh7XG4gIHByZWZpeDogXCJDXCIsXG4gIG5hbWU6IFwiYmFzZTMycGFkdXBwZXJcIixcbiAgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9XCIsXG4gIGJpdHNQZXJDaGFyOiA1XG59KSwgamQgPSB1dCh7XG4gIHByZWZpeDogXCJ2XCIsXG4gIG5hbWU6IFwiYmFzZTMyaGV4XCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2XCIsXG4gIGJpdHNQZXJDaGFyOiA1XG59KSwgemQgPSB1dCh7XG4gIHByZWZpeDogXCJWXCIsXG4gIG5hbWU6IFwiYmFzZTMyaGV4dXBwZXJcIixcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZcIixcbiAgYml0c1BlckNoYXI6IDVcbn0pLCBLZCA9IHV0KHtcbiAgcHJlZml4OiBcInRcIixcbiAgbmFtZTogXCJiYXNlMzJoZXhwYWRcIixcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXY9XCIsXG4gIGJpdHNQZXJDaGFyOiA1XG59KSwgVmQgPSB1dCh7XG4gIHByZWZpeDogXCJUXCIsXG4gIG5hbWU6IFwiYmFzZTMyaGV4cGFkdXBwZXJcIixcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9XCIsXG4gIGJpdHNQZXJDaGFyOiA1XG59KSwgQmQgPSB1dCh7XG4gIHByZWZpeDogXCJoXCIsXG4gIG5hbWU6IFwiYmFzZTMyelwiLFxuICBhbHBoYWJldDogXCJ5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OVwiLFxuICBiaXRzUGVyQ2hhcjogNVxufSksIGtkID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYmFzZTMyOiBVZCxcbiAgYmFzZTMyaGV4OiBqZCxcbiAgYmFzZTMyaGV4cGFkOiBLZCxcbiAgYmFzZTMyaGV4cGFkdXBwZXI6IFZkLFxuICBiYXNlMzJoZXh1cHBlcjogemQsXG4gIGJhc2UzMnBhZDogTWQsXG4gIGJhc2UzMnBhZHVwcGVyOiBxZCxcbiAgYmFzZTMydXBwZXI6IExkLFxuICBiYXNlMzJ6OiBCZFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgSGQgPSBwcyh7XG4gIHByZWZpeDogXCJrXCIsXG4gIG5hbWU6IFwiYmFzZTM2XCIsXG4gIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiXG59KSwgR2QgPSBwcyh7XG4gIHByZWZpeDogXCJLXCIsXG4gIG5hbWU6IFwiYmFzZTM2dXBwZXJcIixcbiAgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCJcbn0pLCBXZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJhc2UzNjogSGQsXG4gIGJhc2UzNnVwcGVyOiBHZFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgWWQgPSBwcyh7XG4gIG5hbWU6IFwiYmFzZTU4YnRjXCIsXG4gIHByZWZpeDogXCJ6XCIsXG4gIGFscGhhYmV0OiBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIlxufSksIEpkID0gcHMoe1xuICBuYW1lOiBcImJhc2U1OGZsaWNrclwiLFxuICBwcmVmaXg6IFwiWlwiLFxuICBhbHBoYWJldDogXCIxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaXCJcbn0pLCBRZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJhc2U1OGJ0YzogWWQsXG4gIGJhc2U1OGZsaWNrcjogSmRcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIFhkID0gdXQoe1xuICBwcmVmaXg6IFwibVwiLFxuICBuYW1lOiBcImJhc2U2NFwiLFxuICBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIsXG4gIGJpdHNQZXJDaGFyOiA2XG59KSwgWmQgPSB1dCh7XG4gIHByZWZpeDogXCJNXCIsXG4gIG5hbWU6IFwiYmFzZTY0cGFkXCIsXG4gIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCIsXG4gIGJpdHNQZXJDaGFyOiA2XG59KSwgZWYgPSB1dCh7XG4gIHByZWZpeDogXCJ1XCIsXG4gIG5hbWU6IFwiYmFzZTY0dXJsXCIsXG4gIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV9cIixcbiAgYml0c1BlckNoYXI6IDZcbn0pLCB0ZiA9IHV0KHtcbiAgcHJlZml4OiBcIlVcIixcbiAgbmFtZTogXCJiYXNlNjR1cmxwYWRcIixcbiAgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz1cIixcbiAgYml0c1BlckNoYXI6IDZcbn0pLCBzZiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJhc2U2NDogWGQsXG4gIGJhc2U2NHBhZDogWmQsXG4gIGJhc2U2NHVybDogZWYsXG4gIGJhc2U2NHVybHBhZDogdGZcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIF9jID0gQXJyYXkuZnJvbShcIvCfmoDwn6qQ4piE8J+bsPCfjIzwn4yR8J+MkvCfjJPwn4yU8J+MlfCfjJbwn4yX8J+MmPCfjI3wn4yP8J+MjvCfkInimIDwn5K78J+WpfCfkr7wn5K/8J+YguKdpPCfmI3wn6Sj8J+YivCfmY/wn5KV8J+YrfCfmJjwn5GN8J+YhfCfkY/wn5iB8J+UpfCfpbDwn5KU8J+SlvCfkpnwn5ii8J+klPCfmIbwn5mE8J+SqvCfmInimLrwn5GM8J+kl/Cfkpzwn5iU8J+YjvCfmIfwn4y58J+kpvCfjonwn5Ke4pyM4pyo8J+kt/CfmLHwn5iM8J+MuPCfmYzwn5iL8J+Sl/Cfkprwn5iP8J+Sm/CfmYLwn5KT8J+kqfCfmITwn5iA8J+WpPCfmIPwn5Kv8J+ZiPCfkYfwn4628J+YkvCfpK3inaPwn5ic8J+Si/CfkYDwn5iq8J+YkfCfkqXwn5mL8J+YnvCfmKnwn5ih8J+kqvCfkYrwn6Wz8J+YpfCfpKTwn5GJ8J+Sg/CfmLPinIvwn5ia8J+YnfCfmLTwn4yf8J+YrPCfmYPwn42A8J+Mt/CfmLvwn5iT4q2Q4pyF8J+luvCfjIjwn5iI8J+kmPCfkqbinJTwn5ij8J+Pg/CfkpDimLnwn46K8J+SmPCfmKDimJ3wn5iV8J+MuvCfjoLwn4y78J+YkPCflpXwn5Kd8J+ZivCfmLnwn5ej8J+Sq/CfkoDwn5GR8J+OtfCfpJ7wn5ib8J+UtPCfmKTwn4y88J+Yq+KavfCfpJnimJXwn4+G8J+kq/CfkYjwn5iu8J+ZhvCfjbvwn42D8J+QtvCfkoHwn5iy8J+Mv/Cfp6Hwn46B4pqh8J+MnvCfjojinYzinIrwn5GL8J+YsPCfpKjwn5i28J+knfCfmrbwn5Kw8J+Nk/CfkqLwn6Sf8J+ZgfCfmqjwn5Ko8J+krOKciPCfjoDwn4268J+kk/CfmJnwn5Kf8J+MsfCfmJbwn5G28J+ltOKWtuKeoeKdk/Cfko7wn5K44qyH8J+YqPCfjJrwn6aL8J+Yt/CflbrimqDwn5mF8J+Yn/CfmLXwn5GO8J+ksvCfpKDwn6Sn8J+TjPCflLXwn5KF8J+nkPCfkL7wn42S8J+Yl/CfpJHwn4yK8J+kr/CfkLfimI7wn5Kn8J+Yr/Cfkobwn5GG8J+OpPCfmYfwn42R4p2E8J+MtPCfkqPwn5C48J+SjPCfk43wn6WA8J+kovCfkYXwn5Kh8J+SqfCfkZDwn5O48J+Ru/CfpJDwn6Su8J+OvPCfpbXwn5qp8J+NjvCfjYrwn5G88J+SjfCfk6Pwn6WCXCIpLCByZiA9IF9jLnJlZHVjZSgoaSwgZSwgdCkgPT4gKGlbdF0gPSBlLCBpKSwgW10pLCBuZiA9IF9jLnJlZHVjZSgoaSwgZSwgdCkgPT4gKGlbZS5jb2RlUG9pbnRBdCgwKV0gPSB0LCBpKSwgW10pO1xuZnVuY3Rpb24gb2YoaSkge1xuICByZXR1cm4gaS5yZWR1Y2UoKGUsIHQpID0+IChlICs9IHJmW3RdLCBlKSwgXCJcIik7XG59XG5mdW5jdGlvbiBhZihpKSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgZm9yIChjb25zdCB0IG9mIGkpIHtcbiAgICBjb25zdCBzID0gbmZbdC5jb2RlUG9pbnRBdCgwKV07XG4gICAgaWYgKHMgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLWJhc2UyNTZlbW9qaSBjaGFyYWN0ZXI6ICR7dH1gKTtcbiAgICBlLnB1c2gocyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGUpO1xufVxuY29uc3QgY2YgPSBjcih7XG4gIHByZWZpeDogXCLwn5qAXCIsXG4gIG5hbWU6IFwiYmFzZTI1NmVtb2ppXCIsXG4gIGVuY29kZTogb2YsXG4gIGRlY29kZTogYWZcbn0pLCBoZiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJhc2UyNTZlbW9qaTogY2Zcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG5uZXcgVGV4dEVuY29kZXIoKTtcbm5ldyBUZXh0RGVjb2RlcigpO1xuY29uc3QgYm8gPSB7XG4gIC4uLnhkLFxuICAuLi5OZCxcbiAgLi4uUmQsXG4gIC4uLkFkLFxuICAuLi5GZCxcbiAgLi4ua2QsXG4gIC4uLldkLFxuICAuLi5RZCxcbiAgLi4uc2YsXG4gIC4uLmhmXG59O1xuZnVuY3Rpb24gRWMoaSwgZSwgdCwgcykge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IGksXG4gICAgcHJlZml4OiBlLFxuICAgIGVuY29kZXI6IHtcbiAgICAgIG5hbWU6IGksXG4gICAgICBwcmVmaXg6IGUsXG4gICAgICBlbmNvZGU6IHRcbiAgICB9LFxuICAgIGRlY29kZXI6IHsgZGVjb2RlOiBzIH1cbiAgfTtcbn1cbmNvbnN0IHdvID0gRWMoXCJ1dGY4XCIsIFwidVwiLCAoaSkgPT4gXCJ1XCIgKyBuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpLmRlY29kZShpKSwgKGkpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpLnN1YnN0cmluZygxKSkpLCBEciA9IEVjKFwiYXNjaWlcIiwgXCJhXCIsIChpKSA9PiB7XG4gIGxldCBlID0gXCJhXCI7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgaS5sZW5ndGg7IHQrKylcbiAgICBlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoaVt0XSk7XG4gIHJldHVybiBlO1xufSwgKGkpID0+IHtcbiAgaSA9IGkuc3Vic3RyaW5nKDEpO1xuICBjb25zdCBlID0gd2MoaS5sZW5ndGgpO1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IGkubGVuZ3RoOyB0KyspXG4gICAgZVt0XSA9IGkuY2hhckNvZGVBdCh0KTtcbiAgcmV0dXJuIGU7XG59KSwgU2MgPSB7XG4gIHV0Zjg6IHdvLFxuICBcInV0Zi04XCI6IHdvLFxuICBoZXg6IGJvLmJhc2UxNixcbiAgbGF0aW4xOiBEcixcbiAgYXNjaWk6IERyLFxuICBiaW5hcnk6IERyLFxuICAuLi5ib1xufTtcbmZ1bmN0aW9uIE5lKGksIGUgPSBcInV0ZjhcIikge1xuICBjb25zdCB0ID0gU2NbZV07XG4gIGlmICghdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGVuY29kaW5nIFwiJHtlfVwiYCk7XG4gIHJldHVybiAoZSA9PT0gXCJ1dGY4XCIgfHwgZSA9PT0gXCJ1dGYtOFwiKSAmJiBnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20gIT0gbnVsbCA/IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oaS5idWZmZXIsIGkuYnl0ZU9mZnNldCwgaS5ieXRlTGVuZ3RoKS50b1N0cmluZyhcInV0ZjhcIikgOiB0LmVuY29kZXIuZW5jb2RlKGkpLnN1YnN0cmluZygxKTtcbn1cbmZ1bmN0aW9uIENlKGksIGUgPSBcInV0ZjhcIikge1xuICBjb25zdCB0ID0gU2NbZV07XG4gIGlmICghdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGVuY29kaW5nIFwiJHtlfVwiYCk7XG4gIHJldHVybiAoZSA9PT0gXCJ1dGY4XCIgfHwgZSA9PT0gXCJ1dGYtOFwiKSAmJiBnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20gIT0gbnVsbCA/IG9uKGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oaSwgXCJ1dGYtOFwiKSkgOiB0LmRlY29kZXIuZGVjb2RlKGAke3QucHJlZml4fSR7aX1gKTtcbn1cbmZ1bmN0aW9uIEdzKGkpIHtcbiAgcmV0dXJuIE5lKENlKHJyKGkpLCBuZCksIGJjKTtcbn1cbmZ1bmN0aW9uIGFuKGkpIHtcbiAgY29uc3QgZSA9IENlKGxkLCBtbyksIHQgPSB1ZCArIE5lKGxzKFtlLCBpXSksIG1vKTtcbiAgcmV0dXJuIFtjZCwgaGQsIHRdLmpvaW4oYWQpO1xufVxuZnVuY3Rpb24gdWYoaSkge1xuICByZXR1cm4gTmUoaSwgYmMpO1xufVxuZnVuY3Rpb24gbGYoaSkge1xuICByZXR1cm4gQ2UoW0dzKGkuaGVhZGVyKSwgR3MoaS5wYXlsb2FkKV0uam9pbihtYyksIG9kKTtcbn1cbmZ1bmN0aW9uIGRmKGkpIHtcbiAgcmV0dXJuIFtcbiAgICBHcyhpLmhlYWRlciksXG4gICAgR3MoaS5wYXlsb2FkKSxcbiAgICB1ZihpLnNpZ25hdHVyZSlcbiAgXS5qb2luKG1jKTtcbn1cbmZ1bmN0aW9uIFdzKGkgPSBsaS5yYW5kb21CeXRlcyhkZCkpIHtcbiAgcmV0dXJuIG5uLmdlbmVyYXRlS2V5UGFpckZyb21TZWVkKGkpO1xufVxuYXN5bmMgZnVuY3Rpb24gSWMoaSwgZSwgdCwgcywgciA9IFYuZnJvbU1pbGlzZWNvbmRzKERhdGUubm93KCkpKSB7XG4gIGNvbnN0IG4gPSB7IGFsZzogc2QsIHR5cDogcmQgfSwgbyA9IGFuKHMucHVibGljS2V5KSwgYyA9IHIgKyB0LCB1ID0geyBpc3M6IG8sIHN1YjogaSwgYXVkOiBlLCBpYXQ6IHIsIGV4cDogYyB9LCBkID0gbGYoeyBoZWFkZXI6IG4sIHBheWxvYWQ6IHUgfSksIHAgPSBubi5zaWduKHMuc2VjcmV0S2V5LCBkKTtcbiAgcmV0dXJuIGRmKHsgaGVhZGVyOiBuLCBwYXlsb2FkOiB1LCBzaWduYXR1cmU6IHAgfSk7XG59XG52YXIgZ3MgPSB7fSwgaHIgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShociwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIHB0ID0gb2UsIEtyID0gUHQsIGZmID0gMjA7XG5mdW5jdGlvbiBwZihpLCBlLCB0KSB7XG4gIGZvciAodmFyIHMgPSAxNjM0NzYwODA1LCByID0gODU3NzYwODc4LCBuID0gMjAzNjQ3NzIzNCwgbyA9IDE3OTcyODUyMzYsIGMgPSB0WzNdIDw8IDI0IHwgdFsyXSA8PCAxNiB8IHRbMV0gPDwgOCB8IHRbMF0sIHUgPSB0WzddIDw8IDI0IHwgdFs2XSA8PCAxNiB8IHRbNV0gPDwgOCB8IHRbNF0sIGQgPSB0WzExXSA8PCAyNCB8IHRbMTBdIDw8IDE2IHwgdFs5XSA8PCA4IHwgdFs4XSwgcCA9IHRbMTVdIDw8IDI0IHwgdFsxNF0gPDwgMTYgfCB0WzEzXSA8PCA4IHwgdFsxMl0sIGIgPSB0WzE5XSA8PCAyNCB8IHRbMThdIDw8IDE2IHwgdFsxN10gPDwgOCB8IHRbMTZdLCB4ID0gdFsyM10gPDwgMjQgfCB0WzIyXSA8PCAxNiB8IHRbMjFdIDw8IDggfCB0WzIwXSwgTyA9IHRbMjddIDw8IDI0IHwgdFsyNl0gPDwgMTYgfCB0WzI1XSA8PCA4IHwgdFsyNF0sIF8gPSB0WzMxXSA8PCAyNCB8IHRbMzBdIDw8IDE2IHwgdFsyOV0gPDwgOCB8IHRbMjhdLCBDID0gZVszXSA8PCAyNCB8IGVbMl0gPDwgMTYgfCBlWzFdIDw8IDggfCBlWzBdLCBGID0gZVs3XSA8PCAyNCB8IGVbNl0gPDwgMTYgfCBlWzVdIDw8IDggfCBlWzRdLCBLID0gZVsxMV0gPDwgMjQgfCBlWzEwXSA8PCAxNiB8IGVbOV0gPDwgOCB8IGVbOF0sIEkgPSBlWzE1XSA8PCAyNCB8IGVbMTRdIDw8IDE2IHwgZVsxM10gPDwgOCB8IGVbMTJdLCBEID0gcywgeSA9IHIsIHcgPSBuLCBmID0gbywgYSA9IGMsIGwgPSB1LCBMID0gZCwgdiA9IHAsIFIgPSBiLCAkID0geCwgcSA9IE8sIG0gPSBfLCBFID0gQywgQiA9IEYsIHogPSBLLCBqID0gSSwgVSA9IDA7IFUgPCBmZjsgVSArPSAyKVxuICAgIEQgPSBEICsgYSB8IDAsIEUgXj0gRCwgRSA9IEUgPj4+IDMyIC0gMTYgfCBFIDw8IDE2LCBSID0gUiArIEUgfCAwLCBhIF49IFIsIGEgPSBhID4+PiAzMiAtIDEyIHwgYSA8PCAxMiwgeSA9IHkgKyBsIHwgMCwgQiBePSB5LCBCID0gQiA+Pj4gMzIgLSAxNiB8IEIgPDwgMTYsICQgPSAkICsgQiB8IDAsIGwgXj0gJCwgbCA9IGwgPj4+IDMyIC0gMTIgfCBsIDw8IDEyLCB3ID0gdyArIEwgfCAwLCB6IF49IHcsIHogPSB6ID4+PiAzMiAtIDE2IHwgeiA8PCAxNiwgcSA9IHEgKyB6IHwgMCwgTCBePSBxLCBMID0gTCA+Pj4gMzIgLSAxMiB8IEwgPDwgMTIsIGYgPSBmICsgdiB8IDAsIGogXj0gZiwgaiA9IGogPj4+IDMyIC0gMTYgfCBqIDw8IDE2LCBtID0gbSArIGogfCAwLCB2IF49IG0sIHYgPSB2ID4+PiAzMiAtIDEyIHwgdiA8PCAxMiwgdyA9IHcgKyBMIHwgMCwgeiBePSB3LCB6ID0geiA+Pj4gMzIgLSA4IHwgeiA8PCA4LCBxID0gcSArIHogfCAwLCBMIF49IHEsIEwgPSBMID4+PiAzMiAtIDcgfCBMIDw8IDcsIGYgPSBmICsgdiB8IDAsIGogXj0gZiwgaiA9IGogPj4+IDMyIC0gOCB8IGogPDwgOCwgbSA9IG0gKyBqIHwgMCwgdiBePSBtLCB2ID0gdiA+Pj4gMzIgLSA3IHwgdiA8PCA3LCB5ID0geSArIGwgfCAwLCBCIF49IHksIEIgPSBCID4+PiAzMiAtIDggfCBCIDw8IDgsICQgPSAkICsgQiB8IDAsIGwgXj0gJCwgbCA9IGwgPj4+IDMyIC0gNyB8IGwgPDwgNywgRCA9IEQgKyBhIHwgMCwgRSBePSBELCBFID0gRSA+Pj4gMzIgLSA4IHwgRSA8PCA4LCBSID0gUiArIEUgfCAwLCBhIF49IFIsIGEgPSBhID4+PiAzMiAtIDcgfCBhIDw8IDcsIEQgPSBEICsgbCB8IDAsIGogXj0gRCwgaiA9IGogPj4+IDMyIC0gMTYgfCBqIDw8IDE2LCBxID0gcSArIGogfCAwLCBsIF49IHEsIGwgPSBsID4+PiAzMiAtIDEyIHwgbCA8PCAxMiwgeSA9IHkgKyBMIHwgMCwgRSBePSB5LCBFID0gRSA+Pj4gMzIgLSAxNiB8IEUgPDwgMTYsIG0gPSBtICsgRSB8IDAsIEwgXj0gbSwgTCA9IEwgPj4+IDMyIC0gMTIgfCBMIDw8IDEyLCB3ID0gdyArIHYgfCAwLCBCIF49IHcsIEIgPSBCID4+PiAzMiAtIDE2IHwgQiA8PCAxNiwgUiA9IFIgKyBCIHwgMCwgdiBePSBSLCB2ID0gdiA+Pj4gMzIgLSAxMiB8IHYgPDwgMTIsIGYgPSBmICsgYSB8IDAsIHogXj0gZiwgeiA9IHogPj4+IDMyIC0gMTYgfCB6IDw8IDE2LCAkID0gJCArIHogfCAwLCBhIF49ICQsIGEgPSBhID4+PiAzMiAtIDEyIHwgYSA8PCAxMiwgdyA9IHcgKyB2IHwgMCwgQiBePSB3LCBCID0gQiA+Pj4gMzIgLSA4IHwgQiA8PCA4LCBSID0gUiArIEIgfCAwLCB2IF49IFIsIHYgPSB2ID4+PiAzMiAtIDcgfCB2IDw8IDcsIGYgPSBmICsgYSB8IDAsIHogXj0gZiwgeiA9IHogPj4+IDMyIC0gOCB8IHogPDwgOCwgJCA9ICQgKyB6IHwgMCwgYSBePSAkLCBhID0gYSA+Pj4gMzIgLSA3IHwgYSA8PCA3LCB5ID0geSArIEwgfCAwLCBFIF49IHksIEUgPSBFID4+PiAzMiAtIDggfCBFIDw8IDgsIG0gPSBtICsgRSB8IDAsIEwgXj0gbSwgTCA9IEwgPj4+IDMyIC0gNyB8IEwgPDwgNywgRCA9IEQgKyBsIHwgMCwgaiBePSBELCBqID0gaiA+Pj4gMzIgLSA4IHwgaiA8PCA4LCBxID0gcSArIGogfCAwLCBsIF49IHEsIGwgPSBsID4+PiAzMiAtIDcgfCBsIDw8IDc7XG4gIHB0LndyaXRlVWludDMyTEUoRCArIHMgfCAwLCBpLCAwKSwgcHQud3JpdGVVaW50MzJMRSh5ICsgciB8IDAsIGksIDQpLCBwdC53cml0ZVVpbnQzMkxFKHcgKyBuIHwgMCwgaSwgOCksIHB0LndyaXRlVWludDMyTEUoZiArIG8gfCAwLCBpLCAxMiksIHB0LndyaXRlVWludDMyTEUoYSArIGMgfCAwLCBpLCAxNiksIHB0LndyaXRlVWludDMyTEUobCArIHUgfCAwLCBpLCAyMCksIHB0LndyaXRlVWludDMyTEUoTCArIGQgfCAwLCBpLCAyNCksIHB0LndyaXRlVWludDMyTEUodiArIHAgfCAwLCBpLCAyOCksIHB0LndyaXRlVWludDMyTEUoUiArIGIgfCAwLCBpLCAzMiksIHB0LndyaXRlVWludDMyTEUoJCArIHggfCAwLCBpLCAzNiksIHB0LndyaXRlVWludDMyTEUocSArIE8gfCAwLCBpLCA0MCksIHB0LndyaXRlVWludDMyTEUobSArIF8gfCAwLCBpLCA0NCksIHB0LndyaXRlVWludDMyTEUoRSArIEMgfCAwLCBpLCA0OCksIHB0LndyaXRlVWludDMyTEUoQiArIEYgfCAwLCBpLCA1MiksIHB0LndyaXRlVWludDMyTEUoeiArIEsgfCAwLCBpLCA1NiksIHB0LndyaXRlVWludDMyTEUoaiArIEkgfCAwLCBpLCA2MCk7XG59XG5mdW5jdGlvbiBEYyhpLCBlLCB0LCBzLCByKSB7XG4gIGlmIChyID09PSB2b2lkIDAgJiYgKHIgPSAwKSwgaS5sZW5ndGggIT09IDMyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYToga2V5IHNpemUgbXVzdCBiZSAzMiBieXRlc1wiKTtcbiAgaWYgKHMubGVuZ3RoIDwgdC5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhQ2hhOiBkZXN0aW5hdGlvbiBpcyBzaG9ydGVyIHRoYW4gc291cmNlXCIpO1xuICB2YXIgbiwgbztcbiAgaWYgKHIgPT09IDApIHtcbiAgICBpZiAoZS5sZW5ndGggIT09IDggJiYgZS5sZW5ndGggIT09IDEyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhQ2hhIG5vbmNlIG11c3QgYmUgOCBvciAxMiBieXRlc1wiKTtcbiAgICBuID0gbmV3IFVpbnQ4QXJyYXkoMTYpLCBvID0gbi5sZW5ndGggLSBlLmxlbmd0aCwgbi5zZXQoZSwgbyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGUubGVuZ3RoICE9PSAxNilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYSBub25jZSB3aXRoIGNvdW50ZXIgbXVzdCBiZSAxNiBieXRlc1wiKTtcbiAgICBuID0gZSwgbyA9IHI7XG4gIH1cbiAgZm9yICh2YXIgYyA9IG5ldyBVaW50OEFycmF5KDY0KSwgdSA9IDA7IHUgPCB0Lmxlbmd0aDsgdSArPSA2NCkge1xuICAgIHBmKGMsIG4sIGkpO1xuICAgIGZvciAodmFyIGQgPSB1OyBkIDwgdSArIDY0ICYmIGQgPCB0Lmxlbmd0aDsgZCsrKVxuICAgICAgc1tkXSA9IHRbZF0gXiBjW2QgLSB1XTtcbiAgICB5ZihuLCAwLCBvKTtcbiAgfVxuICByZXR1cm4gS3Iud2lwZShjKSwgciA9PT0gMCAmJiBLci53aXBlKG4pLCBzO1xufVxuaHIuc3RyZWFtWE9SID0gRGM7XG5mdW5jdGlvbiBnZihpLCBlLCB0LCBzKSB7XG4gIHJldHVybiBzID09PSB2b2lkIDAgJiYgKHMgPSAwKSwgS3Iud2lwZSh0KSwgRGMoaSwgZSwgdCwgdCwgcyk7XG59XG5oci5zdHJlYW0gPSBnZjtcbmZ1bmN0aW9uIHlmKGksIGUsIHQpIHtcbiAgZm9yICh2YXIgcyA9IDE7IHQtLTsgKVxuICAgIHMgPSBzICsgKGlbZV0gJiAyNTUpIHwgMCwgaVtlXSA9IHMgJiAyNTUsIHMgPj4+PSA4LCBlKys7XG4gIGlmIChzID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFDaGE6IGNvdW50ZXIgb3ZlcmZsb3dcIik7XG59XG52YXIgeGMgPSB7fSwgZGkgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuZnVuY3Rpb24gbWYoaSwgZSwgdCkge1xuICByZXR1cm4gfihpIC0gMSkgJiBlIHwgaSAtIDEgJiB0O1xufVxuZGkuc2VsZWN0ID0gbWY7XG5mdW5jdGlvbiBiZihpLCBlKSB7XG4gIHJldHVybiAoaSB8IDApIC0gKGUgfCAwKSAtIDEgPj4+IDMxICYgMTtcbn1cbmRpLmxlc3NPckVxdWFsID0gYmY7XG5mdW5jdGlvbiBPYyhpLCBlKSB7XG4gIGlmIChpLmxlbmd0aCAhPT0gZS5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG4gIGZvciAodmFyIHQgPSAwLCBzID0gMDsgcyA8IGkubGVuZ3RoOyBzKyspXG4gICAgdCB8PSBpW3NdIF4gZVtzXTtcbiAgcmV0dXJuIDEgJiB0IC0gMSA+Pj4gODtcbn1cbmRpLmNvbXBhcmUgPSBPYztcbmZ1bmN0aW9uIHdmKGksIGUpIHtcbiAgcmV0dXJuIGkubGVuZ3RoID09PSAwIHx8IGUubGVuZ3RoID09PSAwID8gITEgOiBPYyhpLCBlKSAhPT0gMDtcbn1cbmRpLmVxdWFsID0gd2Y7XG4oZnVuY3Rpb24oaSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICB2YXIgZSA9IGRpLCB0ID0gUHQ7XG4gIGkuRElHRVNUX0xFTkdUSCA9IDE2O1xuICB2YXIgcyA9IChcbiAgICAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBvKGMpIHtcbiAgICAgICAgdGhpcy5kaWdlc3RMZW5ndGggPSBpLkRJR0VTVF9MRU5HVEgsIHRoaXMuX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KDE2KSwgdGhpcy5fciA9IG5ldyBVaW50MTZBcnJheSgxMCksIHRoaXMuX2ggPSBuZXcgVWludDE2QXJyYXkoMTApLCB0aGlzLl9wYWQgPSBuZXcgVWludDE2QXJyYXkoOCksIHRoaXMuX2xlZnRvdmVyID0gMCwgdGhpcy5fZmluID0gMCwgdGhpcy5fZmluaXNoZWQgPSAhMTtcbiAgICAgICAgdmFyIHUgPSBjWzBdIHwgY1sxXSA8PCA4O1xuICAgICAgICB0aGlzLl9yWzBdID0gdSAmIDgxOTE7XG4gICAgICAgIHZhciBkID0gY1syXSB8IGNbM10gPDwgODtcbiAgICAgICAgdGhpcy5fclsxXSA9ICh1ID4+PiAxMyB8IGQgPDwgMykgJiA4MTkxO1xuICAgICAgICB2YXIgcCA9IGNbNF0gfCBjWzVdIDw8IDg7XG4gICAgICAgIHRoaXMuX3JbMl0gPSAoZCA+Pj4gMTAgfCBwIDw8IDYpICYgNzkzOTtcbiAgICAgICAgdmFyIGIgPSBjWzZdIHwgY1s3XSA8PCA4O1xuICAgICAgICB0aGlzLl9yWzNdID0gKHAgPj4+IDcgfCBiIDw8IDkpICYgODE5MTtcbiAgICAgICAgdmFyIHggPSBjWzhdIHwgY1s5XSA8PCA4O1xuICAgICAgICB0aGlzLl9yWzRdID0gKGIgPj4+IDQgfCB4IDw8IDEyKSAmIDI1NSwgdGhpcy5fcls1XSA9IHggPj4+IDEgJiA4MTkwO1xuICAgICAgICB2YXIgTyA9IGNbMTBdIHwgY1sxMV0gPDwgODtcbiAgICAgICAgdGhpcy5fcls2XSA9ICh4ID4+PiAxNCB8IE8gPDwgMikgJiA4MTkxO1xuICAgICAgICB2YXIgXyA9IGNbMTJdIHwgY1sxM10gPDwgODtcbiAgICAgICAgdGhpcy5fcls3XSA9IChPID4+PiAxMSB8IF8gPDwgNSkgJiA4MDY1O1xuICAgICAgICB2YXIgQyA9IGNbMTRdIHwgY1sxNV0gPDwgODtcbiAgICAgICAgdGhpcy5fcls4XSA9IChfID4+PiA4IHwgQyA8PCA4KSAmIDgxOTEsIHRoaXMuX3JbOV0gPSBDID4+PiA1ICYgMTI3LCB0aGlzLl9wYWRbMF0gPSBjWzE2XSB8IGNbMTddIDw8IDgsIHRoaXMuX3BhZFsxXSA9IGNbMThdIHwgY1sxOV0gPDwgOCwgdGhpcy5fcGFkWzJdID0gY1syMF0gfCBjWzIxXSA8PCA4LCB0aGlzLl9wYWRbM10gPSBjWzIyXSB8IGNbMjNdIDw8IDgsIHRoaXMuX3BhZFs0XSA9IGNbMjRdIHwgY1syNV0gPDwgOCwgdGhpcy5fcGFkWzVdID0gY1syNl0gfCBjWzI3XSA8PCA4LCB0aGlzLl9wYWRbNl0gPSBjWzI4XSB8IGNbMjldIDw8IDgsIHRoaXMuX3BhZFs3XSA9IGNbMzBdIHwgY1szMV0gPDwgODtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvLnByb3RvdHlwZS5fYmxvY2tzID0gZnVuY3Rpb24oYywgdSwgZCkge1xuICAgICAgICBmb3IgKHZhciBwID0gdGhpcy5fZmluID8gMCA6IDIwNDgsIGIgPSB0aGlzLl9oWzBdLCB4ID0gdGhpcy5faFsxXSwgTyA9IHRoaXMuX2hbMl0sIF8gPSB0aGlzLl9oWzNdLCBDID0gdGhpcy5faFs0XSwgRiA9IHRoaXMuX2hbNV0sIEsgPSB0aGlzLl9oWzZdLCBJID0gdGhpcy5faFs3XSwgRCA9IHRoaXMuX2hbOF0sIHkgPSB0aGlzLl9oWzldLCB3ID0gdGhpcy5fclswXSwgZiA9IHRoaXMuX3JbMV0sIGEgPSB0aGlzLl9yWzJdLCBsID0gdGhpcy5fclszXSwgTCA9IHRoaXMuX3JbNF0sIHYgPSB0aGlzLl9yWzVdLCBSID0gdGhpcy5fcls2XSwgJCA9IHRoaXMuX3JbN10sIHEgPSB0aGlzLl9yWzhdLCBtID0gdGhpcy5fcls5XTsgZCA+PSAxNjsgKSB7XG4gICAgICAgICAgdmFyIEUgPSBjW3UgKyAwXSB8IGNbdSArIDFdIDw8IDg7XG4gICAgICAgICAgYiArPSBFICYgODE5MTtcbiAgICAgICAgICB2YXIgQiA9IGNbdSArIDJdIHwgY1t1ICsgM10gPDwgODtcbiAgICAgICAgICB4ICs9IChFID4+PiAxMyB8IEIgPDwgMykgJiA4MTkxO1xuICAgICAgICAgIHZhciB6ID0gY1t1ICsgNF0gfCBjW3UgKyA1XSA8PCA4O1xuICAgICAgICAgIE8gKz0gKEIgPj4+IDEwIHwgeiA8PCA2KSAmIDgxOTE7XG4gICAgICAgICAgdmFyIGogPSBjW3UgKyA2XSB8IGNbdSArIDddIDw8IDg7XG4gICAgICAgICAgXyArPSAoeiA+Pj4gNyB8IGogPDwgOSkgJiA4MTkxO1xuICAgICAgICAgIHZhciBVID0gY1t1ICsgOF0gfCBjW3UgKyA5XSA8PCA4O1xuICAgICAgICAgIEMgKz0gKGogPj4+IDQgfCBVIDw8IDEyKSAmIDgxOTEsIEYgKz0gVSA+Pj4gMSAmIDgxOTE7XG4gICAgICAgICAgdmFyIE0gPSBjW3UgKyAxMF0gfCBjW3UgKyAxMV0gPDwgODtcbiAgICAgICAgICBLICs9IChVID4+PiAxNCB8IE0gPDwgMikgJiA4MTkxO1xuICAgICAgICAgIHZhciBIID0gY1t1ICsgMTJdIHwgY1t1ICsgMTNdIDw8IDg7XG4gICAgICAgICAgSSArPSAoTSA+Pj4gMTEgfCBIIDw8IDUpICYgODE5MTtcbiAgICAgICAgICB2YXIgdGUgPSBjW3UgKyAxNF0gfCBjW3UgKyAxNV0gPDwgODtcbiAgICAgICAgICBEICs9IChIID4+PiA4IHwgdGUgPDwgOCkgJiA4MTkxLCB5ICs9IHRlID4+PiA1IHwgcDtcbiAgICAgICAgICB2YXIgRyA9IDAsIGllID0gRztcbiAgICAgICAgICBpZSArPSBiICogdywgaWUgKz0geCAqICg1ICogbSksIGllICs9IE8gKiAoNSAqIHEpLCBpZSArPSBfICogKDUgKiAkKSwgaWUgKz0gQyAqICg1ICogUiksIEcgPSBpZSA+Pj4gMTMsIGllICY9IDgxOTEsIGllICs9IEYgKiAoNSAqIHYpLCBpZSArPSBLICogKDUgKiBMKSwgaWUgKz0gSSAqICg1ICogbCksIGllICs9IEQgKiAoNSAqIGEpLCBpZSArPSB5ICogKDUgKiBmKSwgRyArPSBpZSA+Pj4gMTMsIGllICY9IDgxOTE7XG4gICAgICAgICAgdmFyIFEgPSBHO1xuICAgICAgICAgIFEgKz0gYiAqIGYsIFEgKz0geCAqIHcsIFEgKz0gTyAqICg1ICogbSksIFEgKz0gXyAqICg1ICogcSksIFEgKz0gQyAqICg1ICogJCksIEcgPSBRID4+PiAxMywgUSAmPSA4MTkxLCBRICs9IEYgKiAoNSAqIFIpLCBRICs9IEsgKiAoNSAqIHYpLCBRICs9IEkgKiAoNSAqIEwpLCBRICs9IEQgKiAoNSAqIGwpLCBRICs9IHkgKiAoNSAqIGEpLCBHICs9IFEgPj4+IDEzLCBRICY9IDgxOTE7XG4gICAgICAgICAgdmFyIHNlID0gRztcbiAgICAgICAgICBzZSArPSBiICogYSwgc2UgKz0geCAqIGYsIHNlICs9IE8gKiB3LCBzZSArPSBfICogKDUgKiBtKSwgc2UgKz0gQyAqICg1ICogcSksIEcgPSBzZSA+Pj4gMTMsIHNlICY9IDgxOTEsIHNlICs9IEYgKiAoNSAqICQpLCBzZSArPSBLICogKDUgKiBSKSwgc2UgKz0gSSAqICg1ICogdiksIHNlICs9IEQgKiAoNSAqIEwpLCBzZSArPSB5ICogKDUgKiBsKSwgRyArPSBzZSA+Pj4gMTMsIHNlICY9IDgxOTE7XG4gICAgICAgICAgdmFyIFQgPSBHO1xuICAgICAgICAgIFQgKz0gYiAqIGwsIFQgKz0geCAqIGEsIFQgKz0gTyAqIGYsIFQgKz0gXyAqIHcsIFQgKz0gQyAqICg1ICogbSksIEcgPSBUID4+PiAxMywgVCAmPSA4MTkxLCBUICs9IEYgKiAoNSAqIHEpLCBUICs9IEsgKiAoNSAqICQpLCBUICs9IEkgKiAoNSAqIFIpLCBUICs9IEQgKiAoNSAqIHYpLCBUICs9IHkgKiAoNSAqIEwpLCBHICs9IFQgPj4+IDEzLCBUICY9IDgxOTE7XG4gICAgICAgICAgdmFyIEEgPSBHO1xuICAgICAgICAgIEEgKz0gYiAqIEwsIEEgKz0geCAqIGwsIEEgKz0gTyAqIGEsIEEgKz0gXyAqIGYsIEEgKz0gQyAqIHcsIEcgPSBBID4+PiAxMywgQSAmPSA4MTkxLCBBICs9IEYgKiAoNSAqIG0pLCBBICs9IEsgKiAoNSAqIHEpLCBBICs9IEkgKiAoNSAqICQpLCBBICs9IEQgKiAoNSAqIFIpLCBBICs9IHkgKiAoNSAqIHYpLCBHICs9IEEgPj4+IDEzLCBBICY9IDgxOTE7XG4gICAgICAgICAgdmFyIE4gPSBHO1xuICAgICAgICAgIE4gKz0gYiAqIHYsIE4gKz0geCAqIEwsIE4gKz0gTyAqIGwsIE4gKz0gXyAqIGEsIE4gKz0gQyAqIGYsIEcgPSBOID4+PiAxMywgTiAmPSA4MTkxLCBOICs9IEYgKiB3LCBOICs9IEsgKiAoNSAqIG0pLCBOICs9IEkgKiAoNSAqIHEpLCBOICs9IEQgKiAoNSAqICQpLCBOICs9IHkgKiAoNSAqIFIpLCBHICs9IE4gPj4+IDEzLCBOICY9IDgxOTE7XG4gICAgICAgICAgdmFyIGggPSBHO1xuICAgICAgICAgIGggKz0gYiAqIFIsIGggKz0geCAqIHYsIGggKz0gTyAqIEwsIGggKz0gXyAqIGwsIGggKz0gQyAqIGEsIEcgPSBoID4+PiAxMywgaCAmPSA4MTkxLCBoICs9IEYgKiBmLCBoICs9IEsgKiB3LCBoICs9IEkgKiAoNSAqIG0pLCBoICs9IEQgKiAoNSAqIHEpLCBoICs9IHkgKiAoNSAqICQpLCBHICs9IGggPj4+IDEzLCBoICY9IDgxOTE7XG4gICAgICAgICAgdmFyIFMgPSBHO1xuICAgICAgICAgIFMgKz0gYiAqICQsIFMgKz0geCAqIFIsIFMgKz0gTyAqIHYsIFMgKz0gXyAqIEwsIFMgKz0gQyAqIGwsIEcgPSBTID4+PiAxMywgUyAmPSA4MTkxLCBTICs9IEYgKiBhLCBTICs9IEsgKiBmLCBTICs9IEkgKiB3LCBTICs9IEQgKiAoNSAqIG0pLCBTICs9IHkgKiAoNSAqIHEpLCBHICs9IFMgPj4+IDEzLCBTICY9IDgxOTE7XG4gICAgICAgICAgdmFyIFcgPSBHO1xuICAgICAgICAgIFcgKz0gYiAqIHEsIFcgKz0geCAqICQsIFcgKz0gTyAqIFIsIFcgKz0gXyAqIHYsIFcgKz0gQyAqIEwsIEcgPSBXID4+PiAxMywgVyAmPSA4MTkxLCBXICs9IEYgKiBsLCBXICs9IEsgKiBhLCBXICs9IEkgKiBmLCBXICs9IEQgKiB3LCBXICs9IHkgKiAoNSAqIG0pLCBHICs9IFcgPj4+IDEzLCBXICY9IDgxOTE7XG4gICAgICAgICAgdmFyIFggPSBHO1xuICAgICAgICAgIFggKz0gYiAqIG0sIFggKz0geCAqIHEsIFggKz0gTyAqICQsIFggKz0gXyAqIFIsIFggKz0gQyAqIHYsIEcgPSBYID4+PiAxMywgWCAmPSA4MTkxLCBYICs9IEYgKiBMLCBYICs9IEsgKiBsLCBYICs9IEkgKiBhLCBYICs9IEQgKiBmLCBYICs9IHkgKiB3LCBHICs9IFggPj4+IDEzLCBYICY9IDgxOTEsIEcgPSAoRyA8PCAyKSArIEcgfCAwLCBHID0gRyArIGllIHwgMCwgaWUgPSBHICYgODE5MSwgRyA9IEcgPj4+IDEzLCBRICs9IEcsIGIgPSBpZSwgeCA9IFEsIE8gPSBzZSwgXyA9IFQsIEMgPSBBLCBGID0gTiwgSyA9IGgsIEkgPSBTLCBEID0gVywgeSA9IFgsIHUgKz0gMTYsIGQgLT0gMTY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faFswXSA9IGIsIHRoaXMuX2hbMV0gPSB4LCB0aGlzLl9oWzJdID0gTywgdGhpcy5faFszXSA9IF8sIHRoaXMuX2hbNF0gPSBDLCB0aGlzLl9oWzVdID0gRiwgdGhpcy5faFs2XSA9IEssIHRoaXMuX2hbN10gPSBJLCB0aGlzLl9oWzhdID0gRCwgdGhpcy5faFs5XSA9IHk7XG4gICAgICB9LCBvLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihjLCB1KSB7XG4gICAgICAgIHUgPT09IHZvaWQgMCAmJiAodSA9IDApO1xuICAgICAgICB2YXIgZCA9IG5ldyBVaW50MTZBcnJheSgxMCksIHAsIGIsIHgsIE87XG4gICAgICAgIGlmICh0aGlzLl9sZWZ0b3Zlcikge1xuICAgICAgICAgIGZvciAoTyA9IHRoaXMuX2xlZnRvdmVyLCB0aGlzLl9idWZmZXJbTysrXSA9IDE7IE8gPCAxNjsgTysrKVxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyW09dID0gMDtcbiAgICAgICAgICB0aGlzLl9maW4gPSAxLCB0aGlzLl9ibG9ja3ModGhpcy5fYnVmZmVyLCAwLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwID0gdGhpcy5faFsxXSA+Pj4gMTMsIHRoaXMuX2hbMV0gJj0gODE5MSwgTyA9IDI7IE8gPCAxMDsgTysrKVxuICAgICAgICAgIHRoaXMuX2hbT10gKz0gcCwgcCA9IHRoaXMuX2hbT10gPj4+IDEzLCB0aGlzLl9oW09dICY9IDgxOTE7XG4gICAgICAgIGZvciAodGhpcy5faFswXSArPSBwICogNSwgcCA9IHRoaXMuX2hbMF0gPj4+IDEzLCB0aGlzLl9oWzBdICY9IDgxOTEsIHRoaXMuX2hbMV0gKz0gcCwgcCA9IHRoaXMuX2hbMV0gPj4+IDEzLCB0aGlzLl9oWzFdICY9IDgxOTEsIHRoaXMuX2hbMl0gKz0gcCwgZFswXSA9IHRoaXMuX2hbMF0gKyA1LCBwID0gZFswXSA+Pj4gMTMsIGRbMF0gJj0gODE5MSwgTyA9IDE7IE8gPCAxMDsgTysrKVxuICAgICAgICAgIGRbT10gPSB0aGlzLl9oW09dICsgcCwgcCA9IGRbT10gPj4+IDEzLCBkW09dICY9IDgxOTE7XG4gICAgICAgIGZvciAoZFs5XSAtPSA4MTkyLCBiID0gKHAgXiAxKSAtIDEsIE8gPSAwOyBPIDwgMTA7IE8rKylcbiAgICAgICAgICBkW09dICY9IGI7XG4gICAgICAgIGZvciAoYiA9IH5iLCBPID0gMDsgTyA8IDEwOyBPKyspXG4gICAgICAgICAgdGhpcy5faFtPXSA9IHRoaXMuX2hbT10gJiBiIHwgZFtPXTtcbiAgICAgICAgZm9yICh0aGlzLl9oWzBdID0gKHRoaXMuX2hbMF0gfCB0aGlzLl9oWzFdIDw8IDEzKSAmIDY1NTM1LCB0aGlzLl9oWzFdID0gKHRoaXMuX2hbMV0gPj4+IDMgfCB0aGlzLl9oWzJdIDw8IDEwKSAmIDY1NTM1LCB0aGlzLl9oWzJdID0gKHRoaXMuX2hbMl0gPj4+IDYgfCB0aGlzLl9oWzNdIDw8IDcpICYgNjU1MzUsIHRoaXMuX2hbM10gPSAodGhpcy5faFszXSA+Pj4gOSB8IHRoaXMuX2hbNF0gPDwgNCkgJiA2NTUzNSwgdGhpcy5faFs0XSA9ICh0aGlzLl9oWzRdID4+PiAxMiB8IHRoaXMuX2hbNV0gPDwgMSB8IHRoaXMuX2hbNl0gPDwgMTQpICYgNjU1MzUsIHRoaXMuX2hbNV0gPSAodGhpcy5faFs2XSA+Pj4gMiB8IHRoaXMuX2hbN10gPDwgMTEpICYgNjU1MzUsIHRoaXMuX2hbNl0gPSAodGhpcy5faFs3XSA+Pj4gNSB8IHRoaXMuX2hbOF0gPDwgOCkgJiA2NTUzNSwgdGhpcy5faFs3XSA9ICh0aGlzLl9oWzhdID4+PiA4IHwgdGhpcy5faFs5XSA8PCA1KSAmIDY1NTM1LCB4ID0gdGhpcy5faFswXSArIHRoaXMuX3BhZFswXSwgdGhpcy5faFswXSA9IHggJiA2NTUzNSwgTyA9IDE7IE8gPCA4OyBPKyspXG4gICAgICAgICAgeCA9ICh0aGlzLl9oW09dICsgdGhpcy5fcGFkW09dIHwgMCkgKyAoeCA+Pj4gMTYpIHwgMCwgdGhpcy5faFtPXSA9IHggJiA2NTUzNTtcbiAgICAgICAgcmV0dXJuIGNbdSArIDBdID0gdGhpcy5faFswXSA+Pj4gMCwgY1t1ICsgMV0gPSB0aGlzLl9oWzBdID4+PiA4LCBjW3UgKyAyXSA9IHRoaXMuX2hbMV0gPj4+IDAsIGNbdSArIDNdID0gdGhpcy5faFsxXSA+Pj4gOCwgY1t1ICsgNF0gPSB0aGlzLl9oWzJdID4+PiAwLCBjW3UgKyA1XSA9IHRoaXMuX2hbMl0gPj4+IDgsIGNbdSArIDZdID0gdGhpcy5faFszXSA+Pj4gMCwgY1t1ICsgN10gPSB0aGlzLl9oWzNdID4+PiA4LCBjW3UgKyA4XSA9IHRoaXMuX2hbNF0gPj4+IDAsIGNbdSArIDldID0gdGhpcy5faFs0XSA+Pj4gOCwgY1t1ICsgMTBdID0gdGhpcy5faFs1XSA+Pj4gMCwgY1t1ICsgMTFdID0gdGhpcy5faFs1XSA+Pj4gOCwgY1t1ICsgMTJdID0gdGhpcy5faFs2XSA+Pj4gMCwgY1t1ICsgMTNdID0gdGhpcy5faFs2XSA+Pj4gOCwgY1t1ICsgMTRdID0gdGhpcy5faFs3XSA+Pj4gMCwgY1t1ICsgMTVdID0gdGhpcy5faFs3XSA+Pj4gOCwgdGhpcy5fZmluaXNoZWQgPSAhMCwgdGhpcztcbiAgICAgIH0sIG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIHUgPSAwLCBkID0gYy5sZW5ndGgsIHA7XG4gICAgICAgIGlmICh0aGlzLl9sZWZ0b3Zlcikge1xuICAgICAgICAgIHAgPSAxNiAtIHRoaXMuX2xlZnRvdmVyLCBwID4gZCAmJiAocCA9IGQpO1xuICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgcDsgYisrKVxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyW3RoaXMuX2xlZnRvdmVyICsgYl0gPSBjW3UgKyBiXTtcbiAgICAgICAgICBpZiAoZCAtPSBwLCB1ICs9IHAsIHRoaXMuX2xlZnRvdmVyICs9IHAsIHRoaXMuX2xlZnRvdmVyIDwgMTYpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB0aGlzLl9ibG9ja3ModGhpcy5fYnVmZmVyLCAwLCAxNiksIHRoaXMuX2xlZnRvdmVyID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZCA+PSAxNiAmJiAocCA9IGQgLSBkICUgMTYsIHRoaXMuX2Jsb2NrcyhjLCB1LCBwKSwgdSArPSBwLCBkIC09IHApLCBkKSB7XG4gICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBkOyBiKyspXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJbdGhpcy5fbGVmdG92ZXIgKyBiXSA9IGNbdSArIGJdO1xuICAgICAgICAgIHRoaXMuX2xlZnRvdmVyICs9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCBvLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpbmlzaGVkKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHkxMzA1IHdhcyBmaW5pc2hlZFwiKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaChjKSwgYztcbiAgICAgIH0sIG8ucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0LndpcGUodGhpcy5fYnVmZmVyKSwgdC53aXBlKHRoaXMuX3IpLCB0LndpcGUodGhpcy5faCksIHQud2lwZSh0aGlzLl9wYWQpLCB0aGlzLl9sZWZ0b3ZlciA9IDAsIHRoaXMuX2ZpbiA9IDAsIHRoaXMuX2ZpbmlzaGVkID0gITAsIHRoaXM7XG4gICAgICB9LCBvO1xuICAgIH0oKVxuICApO1xuICBpLlBvbHkxMzA1ID0gcztcbiAgZnVuY3Rpb24gcihvLCBjKSB7XG4gICAgdmFyIHUgPSBuZXcgcyhvKTtcbiAgICB1LnVwZGF0ZShjKTtcbiAgICB2YXIgZCA9IHUuZGlnZXN0KCk7XG4gICAgcmV0dXJuIHUuY2xlYW4oKSwgZDtcbiAgfVxuICBpLm9uZVRpbWVBdXRoID0gcjtcbiAgZnVuY3Rpb24gbihvLCBjKSB7XG4gICAgcmV0dXJuIG8ubGVuZ3RoICE9PSBpLkRJR0VTVF9MRU5HVEggfHwgYy5sZW5ndGggIT09IGkuRElHRVNUX0xFTkdUSCA/ICExIDogZS5lcXVhbChvLCBjKTtcbiAgfVxuICBpLmVxdWFsID0gbjtcbn0pKHhjKTtcbihmdW5jdGlvbihpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIHZhciBlID0gaHIsIHQgPSB4YywgcyA9IFB0LCByID0gb2UsIG4gPSBkaTtcbiAgaS5LRVlfTEVOR1RIID0gMzIsIGkuTk9OQ0VfTEVOR1RIID0gMTIsIGkuVEFHX0xFTkdUSCA9IDE2O1xuICB2YXIgbyA9IG5ldyBVaW50OEFycmF5KDE2KSwgYyA9IChcbiAgICAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiB1KGQpIHtcbiAgICAgICAgaWYgKHRoaXMubm9uY2VMZW5ndGggPSBpLk5PTkNFX0xFTkdUSCwgdGhpcy50YWdMZW5ndGggPSBpLlRBR19MRU5HVEgsIGQubGVuZ3RoICE9PSBpLktFWV9MRU5HVEgpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhQ2hhMjBQb2x5MTMwNSBuZWVkcyAzMi1ieXRlIGtleVwiKTtcbiAgICAgICAgdGhpcy5fa2V5ID0gbmV3IFVpbnQ4QXJyYXkoZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdS5wcm90b3R5cGUuc2VhbCA9IGZ1bmN0aW9uKGQsIHAsIGIsIHgpIHtcbiAgICAgICAgaWYgKGQubGVuZ3RoID4gMTYpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhQ2hhMjBQb2x5MTMwNTogaW5jb3JyZWN0IG5vbmNlIGxlbmd0aFwiKTtcbiAgICAgICAgdmFyIE8gPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIE8uc2V0KGQsIE8ubGVuZ3RoIC0gZC5sZW5ndGgpO1xuICAgICAgICB2YXIgXyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgZS5zdHJlYW0odGhpcy5fa2V5LCBPLCBfLCA0KTtcbiAgICAgICAgdmFyIEMgPSBwLmxlbmd0aCArIHRoaXMudGFnTGVuZ3RoLCBGO1xuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgIGlmICh4Lmxlbmd0aCAhPT0gQylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYTIwUG9seTEzMDU6IGluY29ycmVjdCBkZXN0aW5hdGlvbiBsZW5ndGhcIik7XG4gICAgICAgICAgRiA9IHg7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIEYgPSBuZXcgVWludDhBcnJheShDKTtcbiAgICAgICAgcmV0dXJuIGUuc3RyZWFtWE9SKHRoaXMuX2tleSwgTywgcCwgRiwgNCksIHRoaXMuX2F1dGhlbnRpY2F0ZShGLnN1YmFycmF5KEYubGVuZ3RoIC0gdGhpcy50YWdMZW5ndGgsIEYubGVuZ3RoKSwgXywgRi5zdWJhcnJheSgwLCBGLmxlbmd0aCAtIHRoaXMudGFnTGVuZ3RoKSwgYiksIHMud2lwZShPKSwgRjtcbiAgICAgIH0sIHUucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihkLCBwLCBiLCB4KSB7XG4gICAgICAgIGlmIChkLmxlbmd0aCA+IDE2KVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYUNoYTIwUG9seTEzMDU6IGluY29ycmVjdCBub25jZSBsZW5ndGhcIik7XG4gICAgICAgIGlmIChwLmxlbmd0aCA8IHRoaXMudGFnTGVuZ3RoKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgTyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgTy5zZXQoZCwgTy5sZW5ndGggLSBkLmxlbmd0aCk7XG4gICAgICAgIHZhciBfID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgICAgICBlLnN0cmVhbSh0aGlzLl9rZXksIE8sIF8sIDQpO1xuICAgICAgICB2YXIgQyA9IG5ldyBVaW50OEFycmF5KHRoaXMudGFnTGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMuX2F1dGhlbnRpY2F0ZShDLCBfLCBwLnN1YmFycmF5KDAsIHAubGVuZ3RoIC0gdGhpcy50YWdMZW5ndGgpLCBiKSwgIW4uZXF1YWwoQywgcC5zdWJhcnJheShwLmxlbmd0aCAtIHRoaXMudGFnTGVuZ3RoLCBwLmxlbmd0aCkpKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgRiA9IHAubGVuZ3RoIC0gdGhpcy50YWdMZW5ndGgsIEs7XG4gICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgaWYgKHgubGVuZ3RoICE9PSBGKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhQ2hhMjBQb2x5MTMwNTogaW5jb3JyZWN0IGRlc3RpbmF0aW9uIGxlbmd0aFwiKTtcbiAgICAgICAgICBLID0geDtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgSyA9IG5ldyBVaW50OEFycmF5KEYpO1xuICAgICAgICByZXR1cm4gZS5zdHJlYW1YT1IodGhpcy5fa2V5LCBPLCBwLnN1YmFycmF5KDAsIHAubGVuZ3RoIC0gdGhpcy50YWdMZW5ndGgpLCBLLCA0KSwgcy53aXBlKE8pLCBLO1xuICAgICAgfSwgdS5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHMud2lwZSh0aGlzLl9rZXkpLCB0aGlzO1xuICAgICAgfSwgdS5wcm90b3R5cGUuX2F1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uKGQsIHAsIGIsIHgpIHtcbiAgICAgICAgdmFyIE8gPSBuZXcgdC5Qb2x5MTMwNShwKTtcbiAgICAgICAgeCAmJiAoTy51cGRhdGUoeCksIHgubGVuZ3RoICUgMTYgPiAwICYmIE8udXBkYXRlKG8uc3ViYXJyYXkoeC5sZW5ndGggJSAxNikpKSwgTy51cGRhdGUoYiksIGIubGVuZ3RoICUgMTYgPiAwICYmIE8udXBkYXRlKG8uc3ViYXJyYXkoYi5sZW5ndGggJSAxNikpO1xuICAgICAgICB2YXIgXyA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICB4ICYmIHIud3JpdGVVaW50NjRMRSh4Lmxlbmd0aCwgXyksIE8udXBkYXRlKF8pLCByLndyaXRlVWludDY0TEUoYi5sZW5ndGgsIF8pLCBPLnVwZGF0ZShfKTtcbiAgICAgICAgZm9yICh2YXIgQyA9IE8uZGlnZXN0KCksIEYgPSAwOyBGIDwgQy5sZW5ndGg7IEYrKylcbiAgICAgICAgICBkW0ZdID0gQ1tGXTtcbiAgICAgICAgTy5jbGVhbigpLCBzLndpcGUoQyksIHMud2lwZShfKTtcbiAgICAgIH0sIHU7XG4gICAgfSgpXG4gICk7XG4gIGkuQ2hhQ2hhMjBQb2x5MTMwNSA9IGM7XG59KShncyk7XG52YXIgTmMgPSB7fSwgeXMgPSB7fSwgY24gPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuZnVuY3Rpb24gdmYoaSkge1xuICByZXR1cm4gdHlwZW9mIGkuc2F2ZVN0YXRlIDwgXCJ1XCIgJiYgdHlwZW9mIGkucmVzdG9yZVN0YXRlIDwgXCJ1XCIgJiYgdHlwZW9mIGkuY2xlYW5TYXZlZFN0YXRlIDwgXCJ1XCI7XG59XG5jbi5pc1NlcmlhbGl6YWJsZUhhc2ggPSB2Zjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh5cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGp0ID0gY24sIF9mID0gZGksIEVmID0gUHQsIFBjID0gKFxuICAvKiogQGNsYXNzICovXG4gIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGkoZSwgdCkge1xuICAgICAgdGhpcy5fZmluaXNoZWQgPSAhMSwgdGhpcy5faW5uZXIgPSBuZXcgZSgpLCB0aGlzLl9vdXRlciA9IG5ldyBlKCksIHRoaXMuYmxvY2tTaXplID0gdGhpcy5fb3V0ZXIuYmxvY2tTaXplLCB0aGlzLmRpZ2VzdExlbmd0aCA9IHRoaXMuX291dGVyLmRpZ2VzdExlbmd0aDtcbiAgICAgIHZhciBzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5ibG9ja1NpemUpO1xuICAgICAgdC5sZW5ndGggPiB0aGlzLmJsb2NrU2l6ZSA/IHRoaXMuX2lubmVyLnVwZGF0ZSh0KS5maW5pc2gocykuY2xlYW4oKSA6IHMuc2V0KHQpO1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBzLmxlbmd0aDsgcisrKVxuICAgICAgICBzW3JdIF49IDU0O1xuICAgICAgdGhpcy5faW5uZXIudXBkYXRlKHMpO1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBzLmxlbmd0aDsgcisrKVxuICAgICAgICBzW3JdIF49IDEwNjtcbiAgICAgIHRoaXMuX291dGVyLnVwZGF0ZShzKSwganQuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX2lubmVyKSAmJiBqdC5pc1NlcmlhbGl6YWJsZUhhc2godGhpcy5fb3V0ZXIpICYmICh0aGlzLl9pbm5lcktleWVkU3RhdGUgPSB0aGlzLl9pbm5lci5zYXZlU3RhdGUoKSwgdGhpcy5fb3V0ZXJLZXllZFN0YXRlID0gdGhpcy5fb3V0ZXIuc2F2ZVN0YXRlKCkpLCBFZi53aXBlKHMpO1xuICAgIH1cbiAgICByZXR1cm4gaS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghanQuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX2lubmVyKSB8fCAhanQuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX291dGVyKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaG1hYzogY2FuJ3QgcmVzZXQoKSBiZWNhdXNlIGhhc2ggZG9lc24ndCBpbXBsZW1lbnQgcmVzdG9yZVN0YXRlKClcIik7XG4gICAgICByZXR1cm4gdGhpcy5faW5uZXIucmVzdG9yZVN0YXRlKHRoaXMuX2lubmVyS2V5ZWRTdGF0ZSksIHRoaXMuX291dGVyLnJlc3RvcmVTdGF0ZSh0aGlzLl9vdXRlcktleWVkU3RhdGUpLCB0aGlzLl9maW5pc2hlZCA9ICExLCB0aGlzO1xuICAgIH0sIGkucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgICBqdC5pc1NlcmlhbGl6YWJsZUhhc2godGhpcy5faW5uZXIpICYmIHRoaXMuX2lubmVyLmNsZWFuU2F2ZWRTdGF0ZSh0aGlzLl9pbm5lcktleWVkU3RhdGUpLCBqdC5pc1NlcmlhbGl6YWJsZUhhc2godGhpcy5fb3V0ZXIpICYmIHRoaXMuX291dGVyLmNsZWFuU2F2ZWRTdGF0ZSh0aGlzLl9vdXRlcktleWVkU3RhdGUpLCB0aGlzLl9pbm5lci5jbGVhbigpLCB0aGlzLl9vdXRlci5jbGVhbigpO1xuICAgIH0sIGkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbm5lci51cGRhdGUoZSksIHRoaXM7XG4gICAgfSwgaS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmlzaGVkID8gKHRoaXMuX291dGVyLmZpbmlzaChlKSwgdGhpcykgOiAodGhpcy5faW5uZXIuZmluaXNoKGUpLCB0aGlzLl9vdXRlci51cGRhdGUoZS5zdWJhcnJheSgwLCB0aGlzLmRpZ2VzdExlbmd0aCkpLmZpbmlzaChlKSwgdGhpcy5fZmluaXNoZWQgPSAhMCwgdGhpcyk7XG4gICAgfSwgaS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGlnZXN0TGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaChlKSwgZTtcbiAgICB9LCBpLnByb3RvdHlwZS5zYXZlU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghanQuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX2lubmVyKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaG1hYzogY2FuJ3Qgc2F2ZVN0YXRlKCkgYmVjYXVzZSBoYXNoIGRvZXNuJ3QgaW1wbGVtZW50IGl0XCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLnNhdmVTdGF0ZSgpO1xuICAgIH0sIGkucHJvdG90eXBlLnJlc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghanQuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX2lubmVyKSB8fCAhanQuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX291dGVyKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaG1hYzogY2FuJ3QgcmVzdG9yZVN0YXRlKCkgYmVjYXVzZSBoYXNoIGRvZXNuJ3QgaW1wbGVtZW50IGl0XCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLnJlc3RvcmVTdGF0ZShlKSwgdGhpcy5fb3V0ZXIucmVzdG9yZVN0YXRlKHRoaXMuX291dGVyS2V5ZWRTdGF0ZSksIHRoaXMuX2ZpbmlzaGVkID0gITEsIHRoaXM7XG4gICAgfSwgaS5wcm90b3R5cGUuY2xlYW5TYXZlZFN0YXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCFqdC5pc1NlcmlhbGl6YWJsZUhhc2godGhpcy5faW5uZXIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJobWFjOiBjYW4ndCBjbGVhblNhdmVkU3RhdGUoKSBiZWNhdXNlIGhhc2ggZG9lc24ndCBpbXBsZW1lbnQgaXRcIik7XG4gICAgICB0aGlzLl9pbm5lci5jbGVhblNhdmVkU3RhdGUoZSk7XG4gICAgfSwgaTtcbiAgfSgpXG4pO1xueXMuSE1BQyA9IFBjO1xuZnVuY3Rpb24gU2YoaSwgZSwgdCkge1xuICB2YXIgcyA9IG5ldyBQYyhpLCBlKTtcbiAgcy51cGRhdGUodCk7XG4gIHZhciByID0gcy5kaWdlc3QoKTtcbiAgcmV0dXJuIHMuY2xlYW4oKSwgcjtcbn1cbnlzLmhtYWMgPSBTZjtcbnlzLmVxdWFsID0gX2YuZXF1YWw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTmMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnZhciB2byA9IHlzLCBfbyA9IFB0LCBJZiA9IChcbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBpKGUsIHQsIHMsIHIpIHtcbiAgICAgIHMgPT09IHZvaWQgMCAmJiAocyA9IG5ldyBVaW50OEFycmF5KDApKSwgdGhpcy5fY291bnRlciA9IG5ldyBVaW50OEFycmF5KDEpLCB0aGlzLl9oYXNoID0gZSwgdGhpcy5faW5mbyA9IHI7XG4gICAgICB2YXIgbiA9IHZvLmhtYWModGhpcy5faGFzaCwgcywgdCk7XG4gICAgICB0aGlzLl9obWFjID0gbmV3IHZvLkhNQUMoZSwgbiksIHRoaXMuX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2htYWMuZGlnZXN0TGVuZ3RoKSwgdGhpcy5fYnVmcG9zID0gdGhpcy5fYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGkucHJvdG90eXBlLl9maWxsQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jb3VudGVyWzBdKys7XG4gICAgICB2YXIgZSA9IHRoaXMuX2NvdW50ZXJbMF07XG4gICAgICBpZiAoZSA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGtkZjogY2Fubm90IGV4cGFuZCBtb3JlXCIpO1xuICAgICAgdGhpcy5faG1hYy5yZXNldCgpLCBlID4gMSAmJiB0aGlzLl9obWFjLnVwZGF0ZSh0aGlzLl9idWZmZXIpLCB0aGlzLl9pbmZvICYmIHRoaXMuX2htYWMudXBkYXRlKHRoaXMuX2luZm8pLCB0aGlzLl9obWFjLnVwZGF0ZSh0aGlzLl9jb3VudGVyKSwgdGhpcy5faG1hYy5maW5pc2godGhpcy5fYnVmZmVyKSwgdGhpcy5fYnVmcG9zID0gMDtcbiAgICB9LCBpLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbihlKSB7XG4gICAgICBmb3IgKHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoZSksIHMgPSAwOyBzIDwgdC5sZW5ndGg7IHMrKylcbiAgICAgICAgdGhpcy5fYnVmcG9zID09PSB0aGlzLl9idWZmZXIubGVuZ3RoICYmIHRoaXMuX2ZpbGxCdWZmZXIoKSwgdFtzXSA9IHRoaXMuX2J1ZmZlclt0aGlzLl9idWZwb3MrK107XG4gICAgICByZXR1cm4gdDtcbiAgICB9LCBpLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5faG1hYy5jbGVhbigpLCBfby53aXBlKHRoaXMuX2J1ZmZlciksIF9vLndpcGUodGhpcy5fY291bnRlciksIHRoaXMuX2J1ZnBvcyA9IDA7XG4gICAgfSwgaTtcbiAgfSgpXG4pLCBSYyA9IE5jLkhLREYgPSBJZiwgU2kgPSB7fTtcbihmdW5jdGlvbihpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIHZhciBlID0gb2UsIHQgPSBQdDtcbiAgaS5ESUdFU1RfTEVOR1RIID0gMzIsIGkuQkxPQ0tfU0laRSA9IDY0O1xuICB2YXIgcyA9IChcbiAgICAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBjKCkge1xuICAgICAgICB0aGlzLmRpZ2VzdExlbmd0aCA9IGkuRElHRVNUX0xFTkdUSCwgdGhpcy5ibG9ja1NpemUgPSBpLkJMT0NLX1NJWkUsIHRoaXMuX3N0YXRlID0gbmV3IEludDMyQXJyYXkoOCksIHRoaXMuX3RlbXAgPSBuZXcgSW50MzJBcnJheSg2NCksIHRoaXMuX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEyOCksIHRoaXMuX2J1ZmZlckxlbmd0aCA9IDAsIHRoaXMuX2J5dGVzSGFzaGVkID0gMCwgdGhpcy5fZmluaXNoZWQgPSAhMSwgdGhpcy5yZXNldCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGMucHJvdG90eXBlLl9pbml0U3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc3RhdGVbMF0gPSAxNzc5MDMzNzAzLCB0aGlzLl9zdGF0ZVsxXSA9IDMxNDQxMzQyNzcsIHRoaXMuX3N0YXRlWzJdID0gMTAxMzkwNDI0MiwgdGhpcy5fc3RhdGVbM10gPSAyNzczNDgwNzYyLCB0aGlzLl9zdGF0ZVs0XSA9IDEzNTk4OTMxMTksIHRoaXMuX3N0YXRlWzVdID0gMjYwMDgyMjkyNCwgdGhpcy5fc3RhdGVbNl0gPSA1Mjg3MzQ2MzUsIHRoaXMuX3N0YXRlWzddID0gMTU0MTQ1OTIyNTtcbiAgICAgIH0sIGMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0U3RhdGUoKSwgdGhpcy5fYnVmZmVyTGVuZ3RoID0gMCwgdGhpcy5fYnl0ZXNIYXNoZWQgPSAwLCB0aGlzLl9maW5pc2hlZCA9ICExLCB0aGlzO1xuICAgICAgfSwgYy5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdC53aXBlKHRoaXMuX2J1ZmZlciksIHQud2lwZSh0aGlzLl90ZW1wKSwgdGhpcy5yZXNldCgpO1xuICAgICAgfSwgYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24odSwgZCkge1xuICAgICAgICBpZiAoZCA9PT0gdm9pZCAwICYmIChkID0gdS5sZW5ndGgpLCB0aGlzLl9maW5pc2hlZClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTSEEyNTY6IGNhbid0IHVwZGF0ZSBiZWNhdXNlIGhhc2ggd2FzIGZpbmlzaGVkLlwiKTtcbiAgICAgICAgdmFyIHAgPSAwO1xuICAgICAgICBpZiAodGhpcy5fYnl0ZXNIYXNoZWQgKz0gZCwgdGhpcy5fYnVmZmVyTGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAoOyB0aGlzLl9idWZmZXJMZW5ndGggPCB0aGlzLmJsb2NrU2l6ZSAmJiBkID4gMDsgKVxuICAgICAgICAgICAgdGhpcy5fYnVmZmVyW3RoaXMuX2J1ZmZlckxlbmd0aCsrXSA9IHVbcCsrXSwgZC0tO1xuICAgICAgICAgIHRoaXMuX2J1ZmZlckxlbmd0aCA9PT0gdGhpcy5ibG9ja1NpemUgJiYgKG4odGhpcy5fdGVtcCwgdGhpcy5fc3RhdGUsIHRoaXMuX2J1ZmZlciwgMCwgdGhpcy5ibG9ja1NpemUpLCB0aGlzLl9idWZmZXJMZW5ndGggPSAwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGQgPj0gdGhpcy5ibG9ja1NpemUgJiYgKHAgPSBuKHRoaXMuX3RlbXAsIHRoaXMuX3N0YXRlLCB1LCBwLCBkKSwgZCAlPSB0aGlzLmJsb2NrU2l6ZSk7IGQgPiAwOyApXG4gICAgICAgICAgdGhpcy5fYnVmZmVyW3RoaXMuX2J1ZmZlckxlbmd0aCsrXSA9IHVbcCsrXSwgZC0tO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIGMucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgIHZhciBkID0gdGhpcy5fYnl0ZXNIYXNoZWQsIHAgPSB0aGlzLl9idWZmZXJMZW5ndGgsIGIgPSBkIC8gNTM2ODcwOTEyIHwgMCwgeCA9IGQgPDwgMywgTyA9IGQgJSA2NCA8IDU2ID8gNjQgOiAxMjg7XG4gICAgICAgICAgdGhpcy5fYnVmZmVyW3BdID0gMTI4O1xuICAgICAgICAgIGZvciAodmFyIF8gPSBwICsgMTsgXyA8IE8gLSA4OyBfKyspXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJbX10gPSAwO1xuICAgICAgICAgIGUud3JpdGVVaW50MzJCRShiLCB0aGlzLl9idWZmZXIsIE8gLSA4KSwgZS53cml0ZVVpbnQzMkJFKHgsIHRoaXMuX2J1ZmZlciwgTyAtIDQpLCBuKHRoaXMuX3RlbXAsIHRoaXMuX3N0YXRlLCB0aGlzLl9idWZmZXIsIDAsIE8pLCB0aGlzLl9maW5pc2hlZCA9ICEwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF8gPSAwOyBfIDwgdGhpcy5kaWdlc3RMZW5ndGggLyA0OyBfKyspXG4gICAgICAgICAgZS53cml0ZVVpbnQzMkJFKHRoaXMuX3N0YXRlW19dLCB1LCBfICogNCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgYy5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kaWdlc3RMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2godSksIHU7XG4gICAgICB9LCBjLnByb3RvdHlwZS5zYXZlU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpbmlzaGVkKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNIQTI1NjogY2Fubm90IHNhdmUgZmluaXNoZWQgc3RhdGVcIik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6IG5ldyBJbnQzMkFycmF5KHRoaXMuX3N0YXRlKSxcbiAgICAgICAgICBidWZmZXI6IHRoaXMuX2J1ZmZlckxlbmd0aCA+IDAgPyBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIpIDogdm9pZCAwLFxuICAgICAgICAgIGJ1ZmZlckxlbmd0aDogdGhpcy5fYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgIGJ5dGVzSGFzaGVkOiB0aGlzLl9ieXRlc0hhc2hlZFxuICAgICAgICB9O1xuICAgICAgfSwgYy5wcm90b3R5cGUucmVzdG9yZVN0YXRlID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuc2V0KHUuc3RhdGUpLCB0aGlzLl9idWZmZXJMZW5ndGggPSB1LmJ1ZmZlckxlbmd0aCwgdS5idWZmZXIgJiYgdGhpcy5fYnVmZmVyLnNldCh1LmJ1ZmZlciksIHRoaXMuX2J5dGVzSGFzaGVkID0gdS5ieXRlc0hhc2hlZCwgdGhpcy5fZmluaXNoZWQgPSAhMSwgdGhpcztcbiAgICAgIH0sIGMucHJvdG90eXBlLmNsZWFuU2F2ZWRTdGF0ZSA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgdC53aXBlKHUuc3RhdGUpLCB1LmJ1ZmZlciAmJiB0LndpcGUodS5idWZmZXIpLCB1LmJ1ZmZlckxlbmd0aCA9IDAsIHUuYnl0ZXNIYXNoZWQgPSAwO1xuICAgICAgfSwgYztcbiAgICB9KClcbiAgKTtcbiAgaS5TSEEyNTYgPSBzO1xuICB2YXIgciA9IG5ldyBJbnQzMkFycmF5KFtcbiAgICAxMTE2MzUyNDA4LFxuICAgIDE4OTk0NDc0NDEsXG4gICAgMzA0OTMyMzQ3MSxcbiAgICAzOTIxMDA5NTczLFxuICAgIDk2MTk4NzE2MyxcbiAgICAxNTA4OTcwOTkzLFxuICAgIDI0NTM2MzU3NDgsXG4gICAgMjg3MDc2MzIyMSxcbiAgICAzNjI0MzgxMDgwLFxuICAgIDMxMDU5ODQwMSxcbiAgICA2MDcyMjUyNzgsXG4gICAgMTQyNjg4MTk4NyxcbiAgICAxOTI1MDc4Mzg4LFxuICAgIDIxNjIwNzgyMDYsXG4gICAgMjYxNDg4ODEwMyxcbiAgICAzMjQ4MjIyNTgwLFxuICAgIDM4MzUzOTA0MDEsXG4gICAgNDAyMjIyNDc3NCxcbiAgICAyNjQzNDcwNzgsXG4gICAgNjA0ODA3NjI4LFxuICAgIDc3MDI1NTk4MyxcbiAgICAxMjQ5MTUwMTIyLFxuICAgIDE1NTUwODE2OTIsXG4gICAgMTk5NjA2NDk4NixcbiAgICAyNTU0MjIwODgyLFxuICAgIDI4MjE4MzQzNDksXG4gICAgMjk1Mjk5NjgwOCxcbiAgICAzMjEwMzEzNjcxLFxuICAgIDMzMzY1NzE4OTEsXG4gICAgMzU4NDUyODcxMSxcbiAgICAxMTM5MjY5OTMsXG4gICAgMzM4MjQxODk1LFxuICAgIDY2NjMwNzIwNSxcbiAgICA3NzM1Mjk5MTIsXG4gICAgMTI5NDc1NzM3MixcbiAgICAxMzk2MTgyMjkxLFxuICAgIDE2OTUxODM3MDAsXG4gICAgMTk4NjY2MTA1MSxcbiAgICAyMTc3MDI2MzUwLFxuICAgIDI0NTY5NTYwMzcsXG4gICAgMjczMDQ4NTkyMSxcbiAgICAyODIwMzAyNDExLFxuICAgIDMyNTk3MzA4MDAsXG4gICAgMzM0NTc2NDc3MSxcbiAgICAzNTE2MDY1ODE3LFxuICAgIDM2MDAzNTI4MDQsXG4gICAgNDA5NDU3MTkwOSxcbiAgICAyNzU0MjMzNDQsXG4gICAgNDMwMjI3NzM0LFxuICAgIDUwNjk0ODYxNixcbiAgICA2NTkwNjA1NTYsXG4gICAgODgzOTk3ODc3LFxuICAgIDk1ODEzOTU3MSxcbiAgICAxMzIyODIyMjE4LFxuICAgIDE1MzcwMDIwNjMsXG4gICAgMTc0Nzg3Mzc3OSxcbiAgICAxOTU1NTYyMjIyLFxuICAgIDIwMjQxMDQ4MTUsXG4gICAgMjIyNzczMDQ1MixcbiAgICAyMzYxODUyNDI0LFxuICAgIDI0Mjg0MzY0NzQsXG4gICAgMjc1NjczNDE4NyxcbiAgICAzMjA0MDMxNDc5LFxuICAgIDMzMjkzMjUyOThcbiAgXSk7XG4gIGZ1bmN0aW9uIG4oYywgdSwgZCwgcCwgYikge1xuICAgIGZvciAoOyBiID49IDY0OyApIHtcbiAgICAgIGZvciAodmFyIHggPSB1WzBdLCBPID0gdVsxXSwgXyA9IHVbMl0sIEMgPSB1WzNdLCBGID0gdVs0XSwgSyA9IHVbNV0sIEkgPSB1WzZdLCBEID0gdVs3XSwgeSA9IDA7IHkgPCAxNjsgeSsrKSB7XG4gICAgICAgIHZhciB3ID0gcCArIHkgKiA0O1xuICAgICAgICBjW3ldID0gZS5yZWFkVWludDMyQkUoZCwgdyk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciB5ID0gMTY7IHkgPCA2NDsgeSsrKSB7XG4gICAgICAgIHZhciBmID0gY1t5IC0gMl0sIGEgPSAoZiA+Pj4gMTcgfCBmIDw8IDMyIC0gMTcpIF4gKGYgPj4+IDE5IHwgZiA8PCAzMiAtIDE5KSBeIGYgPj4+IDEwO1xuICAgICAgICBmID0gY1t5IC0gMTVdO1xuICAgICAgICB2YXIgbCA9IChmID4+PiA3IHwgZiA8PCAzMiAtIDcpIF4gKGYgPj4+IDE4IHwgZiA8PCAzMiAtIDE4KSBeIGYgPj4+IDM7XG4gICAgICAgIGNbeV0gPSAoYSArIGNbeSAtIDddIHwgMCkgKyAobCArIGNbeSAtIDE2XSB8IDApO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA2NDsgeSsrKSB7XG4gICAgICAgIHZhciBhID0gKCgoRiA+Pj4gNiB8IEYgPDwgMjYpIF4gKEYgPj4+IDExIHwgRiA8PCAyMSkgXiAoRiA+Pj4gMjUgfCBGIDw8IDcpKSArIChGICYgSyBeIH5GICYgSSkgfCAwKSArIChEICsgKHJbeV0gKyBjW3ldIHwgMCkgfCAwKSB8IDAsIGwgPSAoKHggPj4+IDIgfCB4IDw8IDMyIC0gMikgXiAoeCA+Pj4gMTMgfCB4IDw8IDMyIC0gMTMpIF4gKHggPj4+IDIyIHwgeCA8PCAzMiAtIDIyKSkgKyAoeCAmIE8gXiB4ICYgXyBeIE8gJiBfKSB8IDA7XG4gICAgICAgIEQgPSBJLCBJID0gSywgSyA9IEYsIEYgPSBDICsgYSB8IDAsIEMgPSBfLCBfID0gTywgTyA9IHgsIHggPSBhICsgbCB8IDA7XG4gICAgICB9XG4gICAgICB1WzBdICs9IHgsIHVbMV0gKz0gTywgdVsyXSArPSBfLCB1WzNdICs9IEMsIHVbNF0gKz0gRiwgdVs1XSArPSBLLCB1WzZdICs9IEksIHVbN10gKz0gRCwgcCArPSA2NCwgYiAtPSA2NDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgZnVuY3Rpb24gbyhjKSB7XG4gICAgdmFyIHUgPSBuZXcgcygpO1xuICAgIHUudXBkYXRlKGMpO1xuICAgIHZhciBkID0gdS5kaWdlc3QoKTtcbiAgICByZXR1cm4gdS5jbGVhbigpLCBkO1xuICB9XG4gIGkuaGFzaCA9IG87XG59KShTaSk7XG52YXIgbXMgPSB7fTtcbihmdW5jdGlvbihpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGkuc2hhcmVkS2V5ID0gaS5nZW5lcmF0ZUtleVBhaXIgPSBpLmdlbmVyYXRlS2V5UGFpckZyb21TZWVkID0gaS5zY2FsYXJNdWx0QmFzZSA9IGkuc2NhbGFyTXVsdCA9IGkuU0hBUkVEX0tFWV9MRU5HVEggPSBpLlNFQ1JFVF9LRVlfTEVOR1RIID0gaS5QVUJMSUNfS0VZX0xFTkdUSCA9IHZvaWQgMDtcbiAgY29uc3QgZSA9IGxpLCB0ID0gUHQ7XG4gIGkuUFVCTElDX0tFWV9MRU5HVEggPSAzMiwgaS5TRUNSRVRfS0VZX0xFTkdUSCA9IDMyLCBpLlNIQVJFRF9LRVlfTEVOR1RIID0gMzI7XG4gIGZ1bmN0aW9uIHMoeSkge1xuICAgIGNvbnN0IHcgPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgICBpZiAoeSlcbiAgICAgIGZvciAobGV0IGYgPSAwOyBmIDwgeS5sZW5ndGg7IGYrKylcbiAgICAgICAgd1tmXSA9IHlbZl07XG4gICAgcmV0dXJuIHc7XG4gIH1cbiAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgclswXSA9IDk7XG4gIGNvbnN0IG4gPSBzKFs1NjEyOSwgMV0pO1xuICBmdW5jdGlvbiBvKHkpIHtcbiAgICBsZXQgdyA9IDE7XG4gICAgZm9yIChsZXQgZiA9IDA7IGYgPCAxNjsgZisrKSB7XG4gICAgICBsZXQgYSA9IHlbZl0gKyB3ICsgNjU1MzU7XG4gICAgICB3ID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCB5W2ZdID0gYSAtIHcgKiA2NTUzNjtcbiAgICB9XG4gICAgeVswXSArPSB3IC0gMSArIDM3ICogKHcgLSAxKTtcbiAgfVxuICBmdW5jdGlvbiBjKHksIHcsIGYpIHtcbiAgICBjb25zdCBhID0gfihmIC0gMSk7XG4gICAgZm9yIChsZXQgbCA9IDA7IGwgPCAxNjsgbCsrKSB7XG4gICAgICBjb25zdCBMID0gYSAmICh5W2xdIF4gd1tsXSk7XG4gICAgICB5W2xdIF49IEwsIHdbbF0gXj0gTDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdSh5LCB3KSB7XG4gICAgY29uc3QgZiA9IHMoKSwgYSA9IHMoKTtcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IDE2OyBsKyspXG4gICAgICBhW2xdID0gd1tsXTtcbiAgICBvKGEpLCBvKGEpLCBvKGEpO1xuICAgIGZvciAobGV0IGwgPSAwOyBsIDwgMjsgbCsrKSB7XG4gICAgICBmWzBdID0gYVswXSAtIDY1NTE3O1xuICAgICAgZm9yIChsZXQgdiA9IDE7IHYgPCAxNTsgdisrKVxuICAgICAgICBmW3ZdID0gYVt2XSAtIDY1NTM1IC0gKGZbdiAtIDFdID4+IDE2ICYgMSksIGZbdiAtIDFdICY9IDY1NTM1O1xuICAgICAgZlsxNV0gPSBhWzE1XSAtIDMyNzY3IC0gKGZbMTRdID4+IDE2ICYgMSk7XG4gICAgICBjb25zdCBMID0gZlsxNV0gPj4gMTYgJiAxO1xuICAgICAgZlsxNF0gJj0gNjU1MzUsIGMoYSwgZiwgMSAtIEwpO1xuICAgIH1cbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IDE2OyBsKyspXG4gICAgICB5WzIgKiBsXSA9IGFbbF0gJiAyNTUsIHlbMiAqIGwgKyAxXSA9IGFbbF0gPj4gODtcbiAgfVxuICBmdW5jdGlvbiBkKHksIHcpIHtcbiAgICBmb3IgKGxldCBmID0gMDsgZiA8IDE2OyBmKyspXG4gICAgICB5W2ZdID0gd1syICogZl0gKyAod1syICogZiArIDFdIDw8IDgpO1xuICAgIHlbMTVdICY9IDMyNzY3O1xuICB9XG4gIGZ1bmN0aW9uIHAoeSwgdywgZikge1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgMTY7IGErKylcbiAgICAgIHlbYV0gPSB3W2FdICsgZlthXTtcbiAgfVxuICBmdW5jdGlvbiBiKHksIHcsIGYpIHtcbiAgICBmb3IgKGxldCBhID0gMDsgYSA8IDE2OyBhKyspXG4gICAgICB5W2FdID0gd1thXSAtIGZbYV07XG4gIH1cbiAgZnVuY3Rpb24geCh5LCB3LCBmKSB7XG4gICAgbGV0IGEsIGwsIEwgPSAwLCB2ID0gMCwgUiA9IDAsICQgPSAwLCBxID0gMCwgbSA9IDAsIEUgPSAwLCBCID0gMCwgeiA9IDAsIGogPSAwLCBVID0gMCwgTSA9IDAsIEggPSAwLCB0ZSA9IDAsIEcgPSAwLCBpZSA9IDAsIFEgPSAwLCBzZSA9IDAsIFQgPSAwLCBBID0gMCwgTiA9IDAsIGggPSAwLCBTID0gMCwgVyA9IDAsIFggPSAwLCBmZSA9IDAsIHZlID0gMCwgZ2UgPSAwLCBTZSA9IDAsIE1lID0gMCwgJGUgPSAwLCBiZSA9IGZbMF0sIHllID0gZlsxXSwgcGUgPSBmWzJdLCBsZSA9IGZbM10sIHVlID0gZls0XSwgaGUgPSBmWzVdLCBjZSA9IGZbNl0sIHJlID0gZls3XSwgZGUgPSBmWzhdLCBtZSA9IGZbOV0sIG5lID0gZlsxMF0sIF9lID0gZlsxMV0sIEVlID0gZlsxMl0sIERlID0gZlsxM10sIHhlID0gZlsxNF0sIEllID0gZlsxNV07XG4gICAgYSA9IHdbMF0sIEwgKz0gYSAqIGJlLCB2ICs9IGEgKiB5ZSwgUiArPSBhICogcGUsICQgKz0gYSAqIGxlLCBxICs9IGEgKiB1ZSwgbSArPSBhICogaGUsIEUgKz0gYSAqIGNlLCBCICs9IGEgKiByZSwgeiArPSBhICogZGUsIGogKz0gYSAqIG1lLCBVICs9IGEgKiBuZSwgTSArPSBhICogX2UsIEggKz0gYSAqIEVlLCB0ZSArPSBhICogRGUsIEcgKz0gYSAqIHhlLCBpZSArPSBhICogSWUsIGEgPSB3WzFdLCB2ICs9IGEgKiBiZSwgUiArPSBhICogeWUsICQgKz0gYSAqIHBlLCBxICs9IGEgKiBsZSwgbSArPSBhICogdWUsIEUgKz0gYSAqIGhlLCBCICs9IGEgKiBjZSwgeiArPSBhICogcmUsIGogKz0gYSAqIGRlLCBVICs9IGEgKiBtZSwgTSArPSBhICogbmUsIEggKz0gYSAqIF9lLCB0ZSArPSBhICogRWUsIEcgKz0gYSAqIERlLCBpZSArPSBhICogeGUsIFEgKz0gYSAqIEllLCBhID0gd1syXSwgUiArPSBhICogYmUsICQgKz0gYSAqIHllLCBxICs9IGEgKiBwZSwgbSArPSBhICogbGUsIEUgKz0gYSAqIHVlLCBCICs9IGEgKiBoZSwgeiArPSBhICogY2UsIGogKz0gYSAqIHJlLCBVICs9IGEgKiBkZSwgTSArPSBhICogbWUsIEggKz0gYSAqIG5lLCB0ZSArPSBhICogX2UsIEcgKz0gYSAqIEVlLCBpZSArPSBhICogRGUsIFEgKz0gYSAqIHhlLCBzZSArPSBhICogSWUsIGEgPSB3WzNdLCAkICs9IGEgKiBiZSwgcSArPSBhICogeWUsIG0gKz0gYSAqIHBlLCBFICs9IGEgKiBsZSwgQiArPSBhICogdWUsIHogKz0gYSAqIGhlLCBqICs9IGEgKiBjZSwgVSArPSBhICogcmUsIE0gKz0gYSAqIGRlLCBIICs9IGEgKiBtZSwgdGUgKz0gYSAqIG5lLCBHICs9IGEgKiBfZSwgaWUgKz0gYSAqIEVlLCBRICs9IGEgKiBEZSwgc2UgKz0gYSAqIHhlLCBUICs9IGEgKiBJZSwgYSA9IHdbNF0sIHEgKz0gYSAqIGJlLCBtICs9IGEgKiB5ZSwgRSArPSBhICogcGUsIEIgKz0gYSAqIGxlLCB6ICs9IGEgKiB1ZSwgaiArPSBhICogaGUsIFUgKz0gYSAqIGNlLCBNICs9IGEgKiByZSwgSCArPSBhICogZGUsIHRlICs9IGEgKiBtZSwgRyArPSBhICogbmUsIGllICs9IGEgKiBfZSwgUSArPSBhICogRWUsIHNlICs9IGEgKiBEZSwgVCArPSBhICogeGUsIEEgKz0gYSAqIEllLCBhID0gd1s1XSwgbSArPSBhICogYmUsIEUgKz0gYSAqIHllLCBCICs9IGEgKiBwZSwgeiArPSBhICogbGUsIGogKz0gYSAqIHVlLCBVICs9IGEgKiBoZSwgTSArPSBhICogY2UsIEggKz0gYSAqIHJlLCB0ZSArPSBhICogZGUsIEcgKz0gYSAqIG1lLCBpZSArPSBhICogbmUsIFEgKz0gYSAqIF9lLCBzZSArPSBhICogRWUsIFQgKz0gYSAqIERlLCBBICs9IGEgKiB4ZSwgTiArPSBhICogSWUsIGEgPSB3WzZdLCBFICs9IGEgKiBiZSwgQiArPSBhICogeWUsIHogKz0gYSAqIHBlLCBqICs9IGEgKiBsZSwgVSArPSBhICogdWUsIE0gKz0gYSAqIGhlLCBIICs9IGEgKiBjZSwgdGUgKz0gYSAqIHJlLCBHICs9IGEgKiBkZSwgaWUgKz0gYSAqIG1lLCBRICs9IGEgKiBuZSwgc2UgKz0gYSAqIF9lLCBUICs9IGEgKiBFZSwgQSArPSBhICogRGUsIE4gKz0gYSAqIHhlLCBoICs9IGEgKiBJZSwgYSA9IHdbN10sIEIgKz0gYSAqIGJlLCB6ICs9IGEgKiB5ZSwgaiArPSBhICogcGUsIFUgKz0gYSAqIGxlLCBNICs9IGEgKiB1ZSwgSCArPSBhICogaGUsIHRlICs9IGEgKiBjZSwgRyArPSBhICogcmUsIGllICs9IGEgKiBkZSwgUSArPSBhICogbWUsIHNlICs9IGEgKiBuZSwgVCArPSBhICogX2UsIEEgKz0gYSAqIEVlLCBOICs9IGEgKiBEZSwgaCArPSBhICogeGUsIFMgKz0gYSAqIEllLCBhID0gd1s4XSwgeiArPSBhICogYmUsIGogKz0gYSAqIHllLCBVICs9IGEgKiBwZSwgTSArPSBhICogbGUsIEggKz0gYSAqIHVlLCB0ZSArPSBhICogaGUsIEcgKz0gYSAqIGNlLCBpZSArPSBhICogcmUsIFEgKz0gYSAqIGRlLCBzZSArPSBhICogbWUsIFQgKz0gYSAqIG5lLCBBICs9IGEgKiBfZSwgTiArPSBhICogRWUsIGggKz0gYSAqIERlLCBTICs9IGEgKiB4ZSwgVyArPSBhICogSWUsIGEgPSB3WzldLCBqICs9IGEgKiBiZSwgVSArPSBhICogeWUsIE0gKz0gYSAqIHBlLCBIICs9IGEgKiBsZSwgdGUgKz0gYSAqIHVlLCBHICs9IGEgKiBoZSwgaWUgKz0gYSAqIGNlLCBRICs9IGEgKiByZSwgc2UgKz0gYSAqIGRlLCBUICs9IGEgKiBtZSwgQSArPSBhICogbmUsIE4gKz0gYSAqIF9lLCBoICs9IGEgKiBFZSwgUyArPSBhICogRGUsIFcgKz0gYSAqIHhlLCBYICs9IGEgKiBJZSwgYSA9IHdbMTBdLCBVICs9IGEgKiBiZSwgTSArPSBhICogeWUsIEggKz0gYSAqIHBlLCB0ZSArPSBhICogbGUsIEcgKz0gYSAqIHVlLCBpZSArPSBhICogaGUsIFEgKz0gYSAqIGNlLCBzZSArPSBhICogcmUsIFQgKz0gYSAqIGRlLCBBICs9IGEgKiBtZSwgTiArPSBhICogbmUsIGggKz0gYSAqIF9lLCBTICs9IGEgKiBFZSwgVyArPSBhICogRGUsIFggKz0gYSAqIHhlLCBmZSArPSBhICogSWUsIGEgPSB3WzExXSwgTSArPSBhICogYmUsIEggKz0gYSAqIHllLCB0ZSArPSBhICogcGUsIEcgKz0gYSAqIGxlLCBpZSArPSBhICogdWUsIFEgKz0gYSAqIGhlLCBzZSArPSBhICogY2UsIFQgKz0gYSAqIHJlLCBBICs9IGEgKiBkZSwgTiArPSBhICogbWUsIGggKz0gYSAqIG5lLCBTICs9IGEgKiBfZSwgVyArPSBhICogRWUsIFggKz0gYSAqIERlLCBmZSArPSBhICogeGUsIHZlICs9IGEgKiBJZSwgYSA9IHdbMTJdLCBIICs9IGEgKiBiZSwgdGUgKz0gYSAqIHllLCBHICs9IGEgKiBwZSwgaWUgKz0gYSAqIGxlLCBRICs9IGEgKiB1ZSwgc2UgKz0gYSAqIGhlLCBUICs9IGEgKiBjZSwgQSArPSBhICogcmUsIE4gKz0gYSAqIGRlLCBoICs9IGEgKiBtZSwgUyArPSBhICogbmUsIFcgKz0gYSAqIF9lLCBYICs9IGEgKiBFZSwgZmUgKz0gYSAqIERlLCB2ZSArPSBhICogeGUsIGdlICs9IGEgKiBJZSwgYSA9IHdbMTNdLCB0ZSArPSBhICogYmUsIEcgKz0gYSAqIHllLCBpZSArPSBhICogcGUsIFEgKz0gYSAqIGxlLCBzZSArPSBhICogdWUsIFQgKz0gYSAqIGhlLCBBICs9IGEgKiBjZSwgTiArPSBhICogcmUsIGggKz0gYSAqIGRlLCBTICs9IGEgKiBtZSwgVyArPSBhICogbmUsIFggKz0gYSAqIF9lLCBmZSArPSBhICogRWUsIHZlICs9IGEgKiBEZSwgZ2UgKz0gYSAqIHhlLCBTZSArPSBhICogSWUsIGEgPSB3WzE0XSwgRyArPSBhICogYmUsIGllICs9IGEgKiB5ZSwgUSArPSBhICogcGUsIHNlICs9IGEgKiBsZSwgVCArPSBhICogdWUsIEEgKz0gYSAqIGhlLCBOICs9IGEgKiBjZSwgaCArPSBhICogcmUsIFMgKz0gYSAqIGRlLCBXICs9IGEgKiBtZSwgWCArPSBhICogbmUsIGZlICs9IGEgKiBfZSwgdmUgKz0gYSAqIEVlLCBnZSArPSBhICogRGUsIFNlICs9IGEgKiB4ZSwgTWUgKz0gYSAqIEllLCBhID0gd1sxNV0sIGllICs9IGEgKiBiZSwgUSArPSBhICogeWUsIHNlICs9IGEgKiBwZSwgVCArPSBhICogbGUsIEEgKz0gYSAqIHVlLCBOICs9IGEgKiBoZSwgaCArPSBhICogY2UsIFMgKz0gYSAqIHJlLCBXICs9IGEgKiBkZSwgWCArPSBhICogbWUsIGZlICs9IGEgKiBuZSwgdmUgKz0gYSAqIF9lLCBnZSArPSBhICogRWUsIFNlICs9IGEgKiBEZSwgTWUgKz0gYSAqIHhlLCAkZSArPSBhICogSWUsIEwgKz0gMzggKiBRLCB2ICs9IDM4ICogc2UsIFIgKz0gMzggKiBULCAkICs9IDM4ICogQSwgcSArPSAzOCAqIE4sIG0gKz0gMzggKiBoLCBFICs9IDM4ICogUywgQiArPSAzOCAqIFcsIHogKz0gMzggKiBYLCBqICs9IDM4ICogZmUsIFUgKz0gMzggKiB2ZSwgTSArPSAzOCAqIGdlLCBIICs9IDM4ICogU2UsIHRlICs9IDM4ICogTWUsIEcgKz0gMzggKiAkZSwgbCA9IDEsIGEgPSBMICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBMID0gYSAtIGwgKiA2NTUzNiwgYSA9IHYgKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIHYgPSBhIC0gbCAqIDY1NTM2LCBhID0gUiArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgUiA9IGEgLSBsICogNjU1MzYsIGEgPSAkICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCAkID0gYSAtIGwgKiA2NTUzNiwgYSA9IHEgKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIHEgPSBhIC0gbCAqIDY1NTM2LCBhID0gbSArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgbSA9IGEgLSBsICogNjU1MzYsIGEgPSBFICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBFID0gYSAtIGwgKiA2NTUzNiwgYSA9IEIgKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIEIgPSBhIC0gbCAqIDY1NTM2LCBhID0geiArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgeiA9IGEgLSBsICogNjU1MzYsIGEgPSBqICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBqID0gYSAtIGwgKiA2NTUzNiwgYSA9IFUgKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIFUgPSBhIC0gbCAqIDY1NTM2LCBhID0gTSArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgTSA9IGEgLSBsICogNjU1MzYsIGEgPSBIICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBIID0gYSAtIGwgKiA2NTUzNiwgYSA9IHRlICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCB0ZSA9IGEgLSBsICogNjU1MzYsIGEgPSBHICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBHID0gYSAtIGwgKiA2NTUzNiwgYSA9IGllICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBpZSA9IGEgLSBsICogNjU1MzYsIEwgKz0gbCAtIDEgKyAzNyAqIChsIC0gMSksIGwgPSAxLCBhID0gTCArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgTCA9IGEgLSBsICogNjU1MzYsIGEgPSB2ICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCB2ID0gYSAtIGwgKiA2NTUzNiwgYSA9IFIgKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIFIgPSBhIC0gbCAqIDY1NTM2LCBhID0gJCArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgJCA9IGEgLSBsICogNjU1MzYsIGEgPSBxICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBxID0gYSAtIGwgKiA2NTUzNiwgYSA9IG0gKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIG0gPSBhIC0gbCAqIDY1NTM2LCBhID0gRSArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgRSA9IGEgLSBsICogNjU1MzYsIGEgPSBCICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBCID0gYSAtIGwgKiA2NTUzNiwgYSA9IHogKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIHogPSBhIC0gbCAqIDY1NTM2LCBhID0gaiArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgaiA9IGEgLSBsICogNjU1MzYsIGEgPSBVICsgbCArIDY1NTM1LCBsID0gTWF0aC5mbG9vcihhIC8gNjU1MzYpLCBVID0gYSAtIGwgKiA2NTUzNiwgYSA9IE0gKyBsICsgNjU1MzUsIGwgPSBNYXRoLmZsb29yKGEgLyA2NTUzNiksIE0gPSBhIC0gbCAqIDY1NTM2LCBhID0gSCArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgSCA9IGEgLSBsICogNjU1MzYsIGEgPSB0ZSArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgdGUgPSBhIC0gbCAqIDY1NTM2LCBhID0gRyArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgRyA9IGEgLSBsICogNjU1MzYsIGEgPSBpZSArIGwgKyA2NTUzNSwgbCA9IE1hdGguZmxvb3IoYSAvIDY1NTM2KSwgaWUgPSBhIC0gbCAqIDY1NTM2LCBMICs9IGwgLSAxICsgMzcgKiAobCAtIDEpLCB5WzBdID0gTCwgeVsxXSA9IHYsIHlbMl0gPSBSLCB5WzNdID0gJCwgeVs0XSA9IHEsIHlbNV0gPSBtLCB5WzZdID0gRSwgeVs3XSA9IEIsIHlbOF0gPSB6LCB5WzldID0gaiwgeVsxMF0gPSBVLCB5WzExXSA9IE0sIHlbMTJdID0gSCwgeVsxM10gPSB0ZSwgeVsxNF0gPSBHLCB5WzE1XSA9IGllO1xuICB9XG4gIGZ1bmN0aW9uIE8oeSwgdykge1xuICAgIHgoeSwgdywgdyk7XG4gIH1cbiAgZnVuY3Rpb24gXyh5LCB3KSB7XG4gICAgY29uc3QgZiA9IHMoKTtcbiAgICBmb3IgKGxldCBhID0gMDsgYSA8IDE2OyBhKyspXG4gICAgICBmW2FdID0gd1thXTtcbiAgICBmb3IgKGxldCBhID0gMjUzOyBhID49IDA7IGEtLSlcbiAgICAgIE8oZiwgZiksIGEgIT09IDIgJiYgYSAhPT0gNCAmJiB4KGYsIGYsIHcpO1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgMTY7IGErKylcbiAgICAgIHlbYV0gPSBmW2FdO1xuICB9XG4gIGZ1bmN0aW9uIEMoeSwgdykge1xuICAgIGNvbnN0IGYgPSBuZXcgVWludDhBcnJheSgzMiksIGEgPSBuZXcgRmxvYXQ2NEFycmF5KDgwKSwgbCA9IHMoKSwgTCA9IHMoKSwgdiA9IHMoKSwgUiA9IHMoKSwgJCA9IHMoKSwgcSA9IHMoKTtcbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IDMxOyB6KyspXG4gICAgICBmW3pdID0geVt6XTtcbiAgICBmWzMxXSA9IHlbMzFdICYgMTI3IHwgNjQsIGZbMF0gJj0gMjQ4LCBkKGEsIHcpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgMTY7IHorKylcbiAgICAgIExbel0gPSBhW3pdO1xuICAgIGxbMF0gPSBSWzBdID0gMTtcbiAgICBmb3IgKGxldCB6ID0gMjU0OyB6ID49IDA7IC0teikge1xuICAgICAgY29uc3QgaiA9IGZbeiA+Pj4gM10gPj4+ICh6ICYgNykgJiAxO1xuICAgICAgYyhsLCBMLCBqKSwgYyh2LCBSLCBqKSwgcCgkLCBsLCB2KSwgYihsLCBsLCB2KSwgcCh2LCBMLCBSKSwgYihMLCBMLCBSKSwgTyhSLCAkKSwgTyhxLCBsKSwgeChsLCB2LCBsKSwgeCh2LCBMLCAkKSwgcCgkLCBsLCB2KSwgYihsLCBsLCB2KSwgTyhMLCBsKSwgYih2LCBSLCBxKSwgeChsLCB2LCBuKSwgcChsLCBsLCBSKSwgeCh2LCB2LCBsKSwgeChsLCBSLCBxKSwgeChSLCBMLCBhKSwgTyhMLCAkKSwgYyhsLCBMLCBqKSwgYyh2LCBSLCBqKTtcbiAgICB9XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCAxNjsgeisrKVxuICAgICAgYVt6ICsgMTZdID0gbFt6XSwgYVt6ICsgMzJdID0gdlt6XSwgYVt6ICsgNDhdID0gTFt6XSwgYVt6ICsgNjRdID0gUlt6XTtcbiAgICBjb25zdCBtID0gYS5zdWJhcnJheSgzMiksIEUgPSBhLnN1YmFycmF5KDE2KTtcbiAgICBfKG0sIG0pLCB4KEUsIEUsIG0pO1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcmV0dXJuIHUoQiwgRSksIEI7XG4gIH1cbiAgaS5zY2FsYXJNdWx0ID0gQztcbiAgZnVuY3Rpb24gRih5KSB7XG4gICAgcmV0dXJuIEMoeSwgcik7XG4gIH1cbiAgaS5zY2FsYXJNdWx0QmFzZSA9IEY7XG4gIGZ1bmN0aW9uIEsoeSkge1xuICAgIGlmICh5Lmxlbmd0aCAhPT0gaS5TRUNSRVRfS0VZX0xFTkdUSClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgeDI1NTE5OiBzZWVkIG11c3QgYmUgJHtpLlNFQ1JFVF9LRVlfTEVOR1RIfSBieXRlc2ApO1xuICAgIGNvbnN0IHcgPSBuZXcgVWludDhBcnJheSh5KTtcbiAgICByZXR1cm4ge1xuICAgICAgcHVibGljS2V5OiBGKHcpLFxuICAgICAgc2VjcmV0S2V5OiB3XG4gICAgfTtcbiAgfVxuICBpLmdlbmVyYXRlS2V5UGFpckZyb21TZWVkID0gSztcbiAgZnVuY3Rpb24gSSh5KSB7XG4gICAgY29uc3QgdyA9ICgwLCBlLnJhbmRvbUJ5dGVzKSgzMiwgeSksIGYgPSBLKHcpO1xuICAgIHJldHVybiAoMCwgdC53aXBlKSh3KSwgZjtcbiAgfVxuICBpLmdlbmVyYXRlS2V5UGFpciA9IEk7XG4gIGZ1bmN0aW9uIEQoeSwgdywgZiA9ICExKSB7XG4gICAgaWYgKHkubGVuZ3RoICE9PSBpLlBVQkxJQ19LRVlfTEVOR1RIKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWDI1NTE5OiBpbmNvcnJlY3Qgc2VjcmV0IGtleSBsZW5ndGhcIik7XG4gICAgaWYgKHcubGVuZ3RoICE9PSBpLlBVQkxJQ19LRVlfTEVOR1RIKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWDI1NTE5OiBpbmNvcnJlY3QgcHVibGljIGtleSBsZW5ndGhcIik7XG4gICAgY29uc3QgYSA9IEMoeSwgdyk7XG4gICAgaWYgKGYpIHtcbiAgICAgIGxldCBsID0gMDtcbiAgICAgIGZvciAobGV0IEwgPSAwOyBMIDwgYS5sZW5ndGg7IEwrKylcbiAgICAgICAgbCB8PSBhW0xdO1xuICAgICAgaWYgKGwgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlgyNTUxOTogaW52YWxpZCBzaGFyZWQga2V5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxuICBpLnNoYXJlZEtleSA9IEQ7XG59KShtcyk7XG52YXIgRW8gPSBnbG9iYWxUaGlzICYmIGdsb2JhbFRoaXMuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbihpLCBlLCB0KSB7XG4gIGlmICh0IHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgZm9yICh2YXIgcyA9IDAsIHIgPSBlLmxlbmd0aCwgbjsgcyA8IHI7IHMrKylcbiAgICAgIChuIHx8ICEocyBpbiBlKSkgJiYgKG4gfHwgKG4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLCAwLCBzKSksIG5bc10gPSBlW3NdKTtcbiAgcmV0dXJuIGkuY29uY2F0KG4gfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSkpO1xufSwgRGYgPSAoXG4gIC8qKiBAY2xhc3MgKi9cbiAgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gaShlLCB0LCBzKSB7XG4gICAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLnZlcnNpb24gPSB0LCB0aGlzLm9zID0gcywgdGhpcy50eXBlID0gXCJicm93c2VyXCI7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9KClcbiksIHhmID0gKFxuICAvKiogQGNsYXNzICovXG4gIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgdGhpcy52ZXJzaW9uID0gZSwgdGhpcy50eXBlID0gXCJub2RlXCIsIHRoaXMubmFtZSA9IFwibm9kZVwiLCB0aGlzLm9zID0gcHJvY2Vzcy5wbGF0Zm9ybTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0oKVxuKSwgT2YgPSAoXG4gIC8qKiBAY2xhc3MgKi9cbiAgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gaShlLCB0LCBzLCByKSB7XG4gICAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLnZlcnNpb24gPSB0LCB0aGlzLm9zID0gcywgdGhpcy5ib3QgPSByLCB0aGlzLnR5cGUgPSBcImJvdC1kZXZpY2VcIjtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0oKVxuKSwgTmYgPSAoXG4gIC8qKiBAY2xhc3MgKi9cbiAgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgIHRoaXMudHlwZSA9IFwiYm90XCIsIHRoaXMuYm90ID0gITAsIHRoaXMubmFtZSA9IFwiYm90XCIsIHRoaXMudmVyc2lvbiA9IG51bGwsIHRoaXMub3MgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfSgpXG4pLCBQZiA9IChcbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBpKCkge1xuICAgICAgdGhpcy50eXBlID0gXCJyZWFjdC1uYXRpdmVcIiwgdGhpcy5uYW1lID0gXCJyZWFjdC1uYXRpdmVcIiwgdGhpcy52ZXJzaW9uID0gbnVsbCwgdGhpcy5vcyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9KClcbiksIFJmID0gL2FsZXhhfGJvdHxjcmF3bChlcnxpbmcpfGZhY2Vib29rZXh0ZXJuYWxoaXR8ZmVlZGJ1cm5lcnxnb29nbGUgd2ViIHByZXZpZXd8bmFnaW9zfHBvc3RyYW5rfHBpbmdkb218c2x1cnB8c3BpZGVyfHlhaG9vIXx5YW5kZXgvLCBDZiA9IC8obnVoa3xjdXJsfEdvb2dsZWJvdHxZYW1teWJvdHxPcGVuYm90fFNsdXJwfE1TTkJvdHxBc2tcXCBKZWV2ZXNcXC9UZW9tYXxpYV9hcmNoaXZlcikvLCBTbyA9IDMsIEFmID0gW1xuICBbXCJhb2xcIiwgL0FPTFNoaWVsZFxcLyhbMC05XFwuX10rKS9dLFxuICBbXCJlZGdlXCIsIC9FZGdlXFwvKFswLTlcXC5fXSspL10sXG4gIFtcImVkZ2UtaW9zXCIsIC9FZGdpT1NcXC8oWzAtOVxcLl9dKykvXSxcbiAgW1wieWFuZGV4YnJvd3NlclwiLCAvWWFCcm93c2VyXFwvKFswLTlcXC5fXSspL10sXG4gIFtcImtha2FvdGFsa1wiLCAvS0FLQU9UQUxLXFxzKFswLTlcXC5dKykvXSxcbiAgW1wic2Ftc3VuZ1wiLCAvU2Ftc3VuZ0Jyb3dzZXJcXC8oWzAtOVxcLl0rKS9dLFxuICBbXCJzaWxrXCIsIC9cXGJTaWxrXFwvKFswLTkuXy1dKylcXGIvXSxcbiAgW1wibWl1aVwiLCAvTWl1aUJyb3dzZXJcXC8oWzAtOVxcLl0rKSQvXSxcbiAgW1wiYmVha2VyXCIsIC9CZWFrZXJCcm93c2VyXFwvKFswLTlcXC5dKykvXSxcbiAgW1wiZWRnZS1jaHJvbWl1bVwiLCAvRWRnQT9cXC8oWzAtOVxcLl0rKS9dLFxuICBbXG4gICAgXCJjaHJvbWl1bS13ZWJ2aWV3XCIsXG4gICAgLyg/IUNocm9tLipPUFIpd3ZcXCkuKkNocm9tKD86ZXxpdW0pXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXG4gIF0sXG4gIFtcImNocm9tZVwiLCAvKD8hQ2hyb20uKk9QUilDaHJvbSg/OmV8aXVtKVxcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sXG4gIFtcInBoYW50b21qc1wiLCAvUGhhbnRvbUpTXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgW1wiY3Jpb3NcIiwgL0NyaU9TXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgW1wiZmlyZWZveFwiLCAvRmlyZWZveFxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sXG4gIFtcImZ4aW9zXCIsIC9GeGlPU1xcLyhbMC05XFwuXSspL10sXG4gIFtcIm9wZXJhLW1pbmlcIiwgL09wZXJhIE1pbmkuKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLFxuICBbXCJvcGVyYVwiLCAvT3BlcmFcXC8oWzAtOVxcLl0rKSg/Olxcc3wkKS9dLFxuICBbXCJvcGVyYVwiLCAvT1BSXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgW1wicGllXCIsIC9eTWljcm9zb2Z0IFBvY2tldCBJbnRlcm5ldCBFeHBsb3JlclxcLyhcXGQrXFwuXFxkKykkL10sXG4gIFtcInBpZVwiLCAvXk1vemlsbGFcXC9cXGRcXC5cXGQrXFxzXFwoY29tcGF0aWJsZTtcXHMoPzpNU1A/SUV8TVNJbnRlcm5ldCBFeHBsb3JlcikgKFxcZCtcXC5cXGQrKTsuKldpbmRvd3MgQ0UuKlxcKSQvXSxcbiAgW1wibmV0ZnJvbnRcIiwgL15Nb3ppbGxhXFwvXFxkXFwuXFxkKy4qTmV0RnJvbnRcXC8oXFxkLlxcZCkvXSxcbiAgW1wiaWVcIiwgL1RyaWRlbnRcXC83XFwuMC4qcnZcXDooWzAtOVxcLl0rKS4qXFwpLipHZWNrbyQvXSxcbiAgW1wiaWVcIiwgL01TSUVcXHMoWzAtOVxcLl0rKTsuKlRyaWRlbnRcXC9bNC03XS4wL10sXG4gIFtcImllXCIsIC9NU0lFXFxzKDdcXC4wKS9dLFxuICBbXCJiYjEwXCIsIC9CQjEwO1xcc1RvdWNoLipWZXJzaW9uXFwvKFswLTlcXC5dKykvXSxcbiAgW1wiYW5kcm9pZFwiLCAvQW5kcm9pZFxccyhbMC05XFwuXSspL10sXG4gIFtcImlvc1wiLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qTW9iaWxlLipTYWZhcmkuKi9dLFxuICBbXCJzYWZhcmlcIiwgL1ZlcnNpb25cXC8oWzAtOVxcLl9dKykuKlNhZmFyaS9dLFxuICBbXCJmYWNlYm9va1wiLCAvRkJbQVNdVlxcLyhbMC05XFwuXSspL10sXG4gIFtcImluc3RhZ3JhbVwiLCAvSW5zdGFncmFtXFxzKFswLTlcXC5dKykvXSxcbiAgW1wiaW9zLXdlYnZpZXdcIiwgL0FwcGxlV2ViS2l0XFwvKFswLTlcXC5dKykuKk1vYmlsZS9dLFxuICBbXCJpb3Mtd2Vidmlld1wiLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qR2Vja29cXCkkL10sXG4gIFtcImN1cmxcIiwgL15jdXJsXFwvKFswLTlcXC5dKykkL10sXG4gIFtcInNlYXJjaGJvdFwiLCBSZl1cbl0sIElvID0gW1xuICBbXCJpT1NcIiwgL2lQKGhvbmV8b2R8YWQpL10sXG4gIFtcIkFuZHJvaWQgT1NcIiwgL0FuZHJvaWQvXSxcbiAgW1wiQmxhY2tCZXJyeSBPU1wiLCAvQmxhY2tCZXJyeXxCQjEwL10sXG4gIFtcIldpbmRvd3MgTW9iaWxlXCIsIC9JRU1vYmlsZS9dLFxuICBbXCJBbWF6b24gT1NcIiwgL0tpbmRsZS9dLFxuICBbXCJXaW5kb3dzIDMuMTFcIiwgL1dpbjE2L10sXG4gIFtcIldpbmRvd3MgOTVcIiwgLyhXaW5kb3dzIDk1KXwoV2luOTUpfChXaW5kb3dzXzk1KS9dLFxuICBbXCJXaW5kb3dzIDk4XCIsIC8oV2luZG93cyA5OCl8KFdpbjk4KS9dLFxuICBbXCJXaW5kb3dzIDIwMDBcIiwgLyhXaW5kb3dzIE5UIDUuMCl8KFdpbmRvd3MgMjAwMCkvXSxcbiAgW1wiV2luZG93cyBYUFwiLCAvKFdpbmRvd3MgTlQgNS4xKXwoV2luZG93cyBYUCkvXSxcbiAgW1wiV2luZG93cyBTZXJ2ZXIgMjAwM1wiLCAvKFdpbmRvd3MgTlQgNS4yKS9dLFxuICBbXCJXaW5kb3dzIFZpc3RhXCIsIC8oV2luZG93cyBOVCA2LjApL10sXG4gIFtcIldpbmRvd3MgN1wiLCAvKFdpbmRvd3MgTlQgNi4xKS9dLFxuICBbXCJXaW5kb3dzIDhcIiwgLyhXaW5kb3dzIE5UIDYuMikvXSxcbiAgW1wiV2luZG93cyA4LjFcIiwgLyhXaW5kb3dzIE5UIDYuMykvXSxcbiAgW1wiV2luZG93cyAxMFwiLCAvKFdpbmRvd3MgTlQgMTAuMCkvXSxcbiAgW1wiV2luZG93cyBNRVwiLCAvV2luZG93cyBNRS9dLFxuICBbXCJXaW5kb3dzIENFXCIsIC9XaW5kb3dzIENFfFdpbkNFfE1pY3Jvc29mdCBQb2NrZXQgSW50ZXJuZXQgRXhwbG9yZXIvXSxcbiAgW1wiT3BlbiBCU0RcIiwgL09wZW5CU0QvXSxcbiAgW1wiU3VuIE9TXCIsIC9TdW5PUy9dLFxuICBbXCJDaHJvbWUgT1NcIiwgL0NyT1MvXSxcbiAgW1wiTGludXhcIiwgLyhMaW51eCl8KFgxMSkvXSxcbiAgW1wiTWFjIE9TXCIsIC8oTWFjX1Bvd2VyUEMpfChNYWNpbnRvc2gpL10sXG4gIFtcIlFOWFwiLCAvUU5YL10sXG4gIFtcIkJlT1NcIiwgL0JlT1MvXSxcbiAgW1wiT1MvMlwiLCAvT1NcXC8yL11cbl07XG5mdW5jdGlvbiBobihpKSB7XG4gIHJldHVybiBpID8gRG8oaSkgOiB0eXBlb2YgZG9jdW1lbnQgPiBcInVcIiAmJiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIiA/IG5ldyBQZigpIDogdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiID8gRG8obmF2aWdhdG9yLnVzZXJBZ2VudCkgOiBGZigpO1xufVxuZnVuY3Rpb24gVGYoaSkge1xuICByZXR1cm4gaSAhPT0gXCJcIiAmJiBBZi5yZWR1Y2UoZnVuY3Rpb24oZSwgdCkge1xuICAgIHZhciBzID0gdFswXSwgciA9IHRbMV07XG4gICAgaWYgKGUpXG4gICAgICByZXR1cm4gZTtcbiAgICB2YXIgbiA9IHIuZXhlYyhpKTtcbiAgICByZXR1cm4gISFuICYmIFtzLCBuXTtcbiAgfSwgITEpO1xufVxuZnVuY3Rpb24gRG8oaSkge1xuICB2YXIgZSA9IFRmKGkpO1xuICBpZiAoIWUpXG4gICAgcmV0dXJuIG51bGw7XG4gIHZhciB0ID0gZVswXSwgcyA9IGVbMV07XG4gIGlmICh0ID09PSBcInNlYXJjaGJvdFwiKVxuICAgIHJldHVybiBuZXcgTmYoKTtcbiAgdmFyIHIgPSBzWzFdICYmIHNbMV0uc3BsaXQoXCIuXCIpLmpvaW4oXCJfXCIpLnNwbGl0KFwiX1wiKS5zbGljZSgwLCAzKTtcbiAgciA/IHIubGVuZ3RoIDwgU28gJiYgKHIgPSBFbyhFbyhbXSwgciwgITApLCBVZihTbyAtIHIubGVuZ3RoKSwgITApKSA6IHIgPSBbXTtcbiAgdmFyIG4gPSByLmpvaW4oXCIuXCIpLCBvID0gJGYoaSksIGMgPSBDZi5leGVjKGkpO1xuICByZXR1cm4gYyAmJiBjWzFdID8gbmV3IE9mKHQsIG4sIG8sIGNbMV0pIDogbmV3IERmKHQsIG4sIG8pO1xufVxuZnVuY3Rpb24gJGYoaSkge1xuICBmb3IgKHZhciBlID0gMCwgdCA9IElvLmxlbmd0aDsgZSA8IHQ7IGUrKykge1xuICAgIHZhciBzID0gSW9bZV0sIHIgPSBzWzBdLCBuID0gc1sxXSwgbyA9IG4uZXhlYyhpKTtcbiAgICBpZiAobylcbiAgICAgIHJldHVybiByO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gRmYoKSB7XG4gIHZhciBpID0gdHlwZW9mIHByb2Nlc3MgPCBcInVcIiAmJiBwcm9jZXNzLnZlcnNpb247XG4gIHJldHVybiBpID8gbmV3IHhmKHByb2Nlc3MudmVyc2lvbi5zbGljZSgxKSkgOiBudWxsO1xufVxuZnVuY3Rpb24gVWYoaSkge1xuICBmb3IgKHZhciBlID0gW10sIHQgPSAwOyB0IDwgaTsgdCsrKVxuICAgIGUucHVzaChcIjBcIik7XG4gIHJldHVybiBlO1xufVxudmFyIFBlID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcblBlLmdldExvY2FsU3RvcmFnZSA9IFBlLmdldExvY2FsU3RvcmFnZU9yVGhyb3cgPSBQZS5nZXRDcnlwdG8gPSBQZS5nZXRDcnlwdG9PclRocm93ID0gbG4gPSBQZS5nZXRMb2NhdGlvbiA9IFBlLmdldExvY2F0aW9uT3JUaHJvdyA9IGJzID0gUGUuZ2V0TmF2aWdhdG9yID0gUGUuZ2V0TmF2aWdhdG9yT3JUaHJvdyA9IHVuID0gUGUuZ2V0RG9jdW1lbnQgPSBQZS5nZXREb2N1bWVudE9yVGhyb3cgPSBQZS5nZXRGcm9tV2luZG93T3JUaHJvdyA9IFBlLmdldEZyb21XaW5kb3cgPSB2b2lkIDA7XG5mdW5jdGlvbiBJaShpKSB7XG4gIGxldCBlO1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHR5cGVvZiB3aW5kb3dbaV0gPCBcInVcIiAmJiAoZSA9IHdpbmRvd1tpXSksIGU7XG59XG5QZS5nZXRGcm9tV2luZG93ID0gSWk7XG5mdW5jdGlvbiBMaShpKSB7XG4gIGNvbnN0IGUgPSBJaShpKTtcbiAgaWYgKCFlKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtpfSBpcyBub3QgZGVmaW5lZCBpbiBXaW5kb3dgKTtcbiAgcmV0dXJuIGU7XG59XG5QZS5nZXRGcm9tV2luZG93T3JUaHJvdyA9IExpO1xuZnVuY3Rpb24gTGYoKSB7XG4gIHJldHVybiBMaShcImRvY3VtZW50XCIpO1xufVxuUGUuZ2V0RG9jdW1lbnRPclRocm93ID0gTGY7XG5mdW5jdGlvbiBNZigpIHtcbiAgcmV0dXJuIElpKFwiZG9jdW1lbnRcIik7XG59XG52YXIgdW4gPSBQZS5nZXREb2N1bWVudCA9IE1mO1xuZnVuY3Rpb24gcWYoKSB7XG4gIHJldHVybiBMaShcIm5hdmlnYXRvclwiKTtcbn1cblBlLmdldE5hdmlnYXRvck9yVGhyb3cgPSBxZjtcbmZ1bmN0aW9uIGpmKCkge1xuICByZXR1cm4gSWkoXCJuYXZpZ2F0b3JcIik7XG59XG52YXIgYnMgPSBQZS5nZXROYXZpZ2F0b3IgPSBqZjtcbmZ1bmN0aW9uIHpmKCkge1xuICByZXR1cm4gTGkoXCJsb2NhdGlvblwiKTtcbn1cblBlLmdldExvY2F0aW9uT3JUaHJvdyA9IHpmO1xuZnVuY3Rpb24gS2YoKSB7XG4gIHJldHVybiBJaShcImxvY2F0aW9uXCIpO1xufVxudmFyIGxuID0gUGUuZ2V0TG9jYXRpb24gPSBLZjtcbmZ1bmN0aW9uIFZmKCkge1xuICByZXR1cm4gTGkoXCJjcnlwdG9cIik7XG59XG5QZS5nZXRDcnlwdG9PclRocm93ID0gVmY7XG5mdW5jdGlvbiBCZigpIHtcbiAgcmV0dXJuIElpKFwiY3J5cHRvXCIpO1xufVxuUGUuZ2V0Q3J5cHRvID0gQmY7XG5mdW5jdGlvbiBrZigpIHtcbiAgcmV0dXJuIExpKFwibG9jYWxTdG9yYWdlXCIpO1xufVxuUGUuZ2V0TG9jYWxTdG9yYWdlT3JUaHJvdyA9IGtmO1xuZnVuY3Rpb24gSGYoKSB7XG4gIHJldHVybiBJaShcImxvY2FsU3RvcmFnZVwiKTtcbn1cblBlLmdldExvY2FsU3RvcmFnZSA9IEhmO1xudmFyIGRuID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnZhciBmbiA9IGRuLmdldFdpbmRvd01ldGFkYXRhID0gdm9pZCAwO1xuY29uc3QgeG8gPSBQZTtcbmZ1bmN0aW9uIEdmKCkge1xuICBsZXQgaSwgZTtcbiAgdHJ5IHtcbiAgICBpID0geG8uZ2V0RG9jdW1lbnRPclRocm93KCksIGUgPSB4by5nZXRMb2NhdGlvbk9yVGhyb3coKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gdCgpIHtcbiAgICBjb25zdCBiID0gaS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpbmtcIiksIHggPSBbXTtcbiAgICBmb3IgKGxldCBPID0gMDsgTyA8IGIubGVuZ3RoOyBPKyspIHtcbiAgICAgIGNvbnN0IF8gPSBiW09dLCBDID0gXy5nZXRBdHRyaWJ1dGUoXCJyZWxcIik7XG4gICAgICBpZiAoQyAmJiBDLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImljb25cIikgPiAtMSkge1xuICAgICAgICBjb25zdCBGID0gXy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgICBpZiAoRilcbiAgICAgICAgICBpZiAoRi50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJodHRwczpcIikgPT09IC0xICYmIEYudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiaHR0cDpcIikgPT09IC0xICYmIEYuaW5kZXhPZihcIi8vXCIpICE9PSAwKSB7XG4gICAgICAgICAgICBsZXQgSyA9IGUucHJvdG9jb2wgKyBcIi8vXCIgKyBlLmhvc3Q7XG4gICAgICAgICAgICBpZiAoRi5pbmRleE9mKFwiL1wiKSA9PT0gMClcbiAgICAgICAgICAgICAgSyArPSBGO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IEkgPSBlLnBhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgSS5wb3AoKTtcbiAgICAgICAgICAgICAgY29uc3QgRCA9IEkuam9pbihcIi9cIik7XG4gICAgICAgICAgICAgIEsgKz0gRCArIFwiL1wiICsgRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHgucHVzaChLKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEYuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBLID0gZS5wcm90b2NvbCArIEY7XG4gICAgICAgICAgICB4LnB1c2goSyk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB4LnB1c2goRik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9XG4gIGZ1bmN0aW9uIHMoLi4uYikge1xuICAgIGNvbnN0IHggPSBpLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibWV0YVwiKTtcbiAgICBmb3IgKGxldCBPID0gMDsgTyA8IHgubGVuZ3RoOyBPKyspIHtcbiAgICAgIGNvbnN0IF8gPSB4W09dLCBDID0gW1wiaXRlbXByb3BcIiwgXCJwcm9wZXJ0eVwiLCBcIm5hbWVcIl0ubWFwKChGKSA9PiBfLmdldEF0dHJpYnV0ZShGKSkuZmlsdGVyKChGKSA9PiBGID8gYi5pbmNsdWRlcyhGKSA6ICExKTtcbiAgICAgIGlmIChDLmxlbmd0aCAmJiBDKSB7XG4gICAgICAgIGNvbnN0IEYgPSBfLmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIik7XG4gICAgICAgIGlmIChGKVxuICAgICAgICAgIHJldHVybiBGO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBmdW5jdGlvbiByKCkge1xuICAgIGxldCBiID0gcyhcIm5hbWVcIiwgXCJvZzpzaXRlX25hbWVcIiwgXCJvZzp0aXRsZVwiLCBcInR3aXR0ZXI6dGl0bGVcIik7XG4gICAgcmV0dXJuIGIgfHwgKGIgPSBpLnRpdGxlKSwgYjtcbiAgfVxuICBmdW5jdGlvbiBuKCkge1xuICAgIHJldHVybiBzKFwiZGVzY3JpcHRpb25cIiwgXCJvZzpkZXNjcmlwdGlvblwiLCBcInR3aXR0ZXI6ZGVzY3JpcHRpb25cIiwgXCJrZXl3b3Jkc1wiKTtcbiAgfVxuICBjb25zdCBvID0gcigpLCBjID0gbigpLCB1ID0gZS5vcmlnaW4sIGQgPSB0KCk7XG4gIHJldHVybiB7XG4gICAgZGVzY3JpcHRpb246IGMsXG4gICAgdXJsOiB1LFxuICAgIGljb25zOiBkLFxuICAgIG5hbWU6IG9cbiAgfTtcbn1cbmZuID0gZG4uZ2V0V2luZG93TWV0YWRhdGEgPSBHZjtcbnZhciBpaSA9IHt9LCBXZiA9IChpKSA9PiBlbmNvZGVVUklDb21wb25lbnQoaSkucmVwbGFjZSgvWyEnKCkqXS9nLCAoZSkgPT4gYCUke2UuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX1gKSwgQ2MgPSBcIiVbYS1mMC05XXsyfVwiLCBPbyA9IG5ldyBSZWdFeHAoXCIoXCIgKyBDYyArIFwiKXwoW14lXSs/KVwiLCBcImdpXCIpLCBObyA9IG5ldyBSZWdFeHAoXCIoXCIgKyBDYyArIFwiKStcIiwgXCJnaVwiKTtcbmZ1bmN0aW9uIFZyKGksIGUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gW2RlY29kZVVSSUNvbXBvbmVudChpLmpvaW4oXCJcIikpXTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgaWYgKGkubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiBpO1xuICBlID0gZSB8fCAxO1xuICB2YXIgdCA9IGkuc2xpY2UoMCwgZSksIHMgPSBpLnNsaWNlKGUpO1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5jYWxsKFtdLCBWcih0KSwgVnIocykpO1xufVxuZnVuY3Rpb24gWWYoaSkge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaSk7XG4gIH0gY2F0Y2gge1xuICAgIGZvciAodmFyIGUgPSBpLm1hdGNoKE9vKSB8fCBbXSwgdCA9IDE7IHQgPCBlLmxlbmd0aDsgdCsrKVxuICAgICAgaSA9IFZyKGUsIHQpLmpvaW4oXCJcIiksIGUgPSBpLm1hdGNoKE9vKSB8fCBbXTtcbiAgICByZXR1cm4gaTtcbiAgfVxufVxuZnVuY3Rpb24gSmYoaSkge1xuICBmb3IgKHZhciBlID0ge1xuICAgIFwiJUZFJUZGXCI6IFwi77+977+9XCIsXG4gICAgXCIlRkYlRkVcIjogXCLvv73vv71cIlxuICB9LCB0ID0gTm8uZXhlYyhpKTsgdDsgKSB7XG4gICAgdHJ5IHtcbiAgICAgIGVbdFswXV0gPSBkZWNvZGVVUklDb21wb25lbnQodFswXSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB2YXIgcyA9IFlmKHRbMF0pO1xuICAgICAgcyAhPT0gdFswXSAmJiAoZVt0WzBdXSA9IHMpO1xuICAgIH1cbiAgICB0ID0gTm8uZXhlYyhpKTtcbiAgfVxuICBlW1wiJUMyXCJdID0gXCLvv71cIjtcbiAgZm9yICh2YXIgciA9IE9iamVjdC5rZXlzKGUpLCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspIHtcbiAgICB2YXIgbyA9IHJbbl07XG4gICAgaSA9IGkucmVwbGFjZShuZXcgUmVnRXhwKG8sIFwiZ1wiKSwgZVtvXSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG52YXIgUWYgPSBmdW5jdGlvbihpKSB7XG4gIGlmICh0eXBlb2YgaSAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBgZW5jb2RlZFVSSWAgdG8gYmUgb2YgdHlwZSBgc3RyaW5nYCwgZ290IGBcIiArIHR5cGVvZiBpICsgXCJgXCIpO1xuICB0cnkge1xuICAgIHJldHVybiBpID0gaS5yZXBsYWNlKC9cXCsvZywgXCIgXCIpLCBkZWNvZGVVUklDb21wb25lbnQoaSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBKZihpKTtcbiAgfVxufSwgWGYgPSAoaSwgZSkgPT4ge1xuICBpZiAoISh0eXBlb2YgaSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlID09IFwic3RyaW5nXCIpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB0aGUgYXJndW1lbnRzIHRvIGJlIG9mIHR5cGUgYHN0cmluZ2BcIik7XG4gIGlmIChlID09PSBcIlwiKVxuICAgIHJldHVybiBbaV07XG4gIGNvbnN0IHQgPSBpLmluZGV4T2YoZSk7XG4gIHJldHVybiB0ID09PSAtMSA/IFtpXSA6IFtcbiAgICBpLnNsaWNlKDAsIHQpLFxuICAgIGkuc2xpY2UodCArIGUubGVuZ3RoKVxuICBdO1xufSwgWmYgPSBmdW5jdGlvbihpLCBlKSB7XG4gIGZvciAodmFyIHQgPSB7fSwgcyA9IE9iamVjdC5rZXlzKGkpLCByID0gQXJyYXkuaXNBcnJheShlKSwgbiA9IDA7IG4gPCBzLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIG8gPSBzW25dLCBjID0gaVtvXTtcbiAgICAociA/IGUuaW5kZXhPZihvKSAhPT0gLTEgOiBlKG8sIGMsIGkpKSAmJiAodFtvXSA9IGMpO1xuICB9XG4gIHJldHVybiB0O1xufTtcbihmdW5jdGlvbihpKSB7XG4gIGNvbnN0IGUgPSBXZiwgdCA9IFFmLCBzID0gWGYsIHIgPSBaZiwgbiA9IChJKSA9PiBJID09IG51bGwsIG8gPSBTeW1ib2woXCJlbmNvZGVGcmFnbWVudElkZW50aWZpZXJcIik7XG4gIGZ1bmN0aW9uIGMoSSkge1xuICAgIHN3aXRjaCAoSS5hcnJheUZvcm1hdCkge1xuICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgIHJldHVybiAoRCkgPT4gKHksIHcpID0+IHtcbiAgICAgICAgICBjb25zdCBmID0geS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHcgPT09IHZvaWQgMCB8fCBJLnNraXBOdWxsICYmIHcgPT09IG51bGwgfHwgSS5za2lwRW1wdHlTdHJpbmcgJiYgdyA9PT0gXCJcIiA/IHkgOiB3ID09PSBudWxsID8gWy4uLnksIFtwKEQsIEkpLCBcIltcIiwgZiwgXCJdXCJdLmpvaW4oXCJcIildIDogW1xuICAgICAgICAgICAgLi4ueSxcbiAgICAgICAgICAgIFtwKEQsIEkpLCBcIltcIiwgcChmLCBJKSwgXCJdPVwiLCBwKHcsIEkpXS5qb2luKFwiXCIpXG4gICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJicmFja2V0XCI6XG4gICAgICAgIHJldHVybiAoRCkgPT4gKHksIHcpID0+IHcgPT09IHZvaWQgMCB8fCBJLnNraXBOdWxsICYmIHcgPT09IG51bGwgfHwgSS5za2lwRW1wdHlTdHJpbmcgJiYgdyA9PT0gXCJcIiA/IHkgOiB3ID09PSBudWxsID8gWy4uLnksIFtwKEQsIEkpLCBcIltdXCJdLmpvaW4oXCJcIildIDogWy4uLnksIFtwKEQsIEkpLCBcIltdPVwiLCBwKHcsIEkpXS5qb2luKFwiXCIpXTtcbiAgICAgIGNhc2UgXCJjb2xvbi1saXN0LXNlcGFyYXRvclwiOlxuICAgICAgICByZXR1cm4gKEQpID0+ICh5LCB3KSA9PiB3ID09PSB2b2lkIDAgfHwgSS5za2lwTnVsbCAmJiB3ID09PSBudWxsIHx8IEkuc2tpcEVtcHR5U3RyaW5nICYmIHcgPT09IFwiXCIgPyB5IDogdyA9PT0gbnVsbCA/IFsuLi55LCBbcChELCBJKSwgXCI6bGlzdD1cIl0uam9pbihcIlwiKV0gOiBbLi4ueSwgW3AoRCwgSSksIFwiOmxpc3Q9XCIsIHAodywgSSldLmpvaW4oXCJcIildO1xuICAgICAgY2FzZSBcImNvbW1hXCI6XG4gICAgICBjYXNlIFwic2VwYXJhdG9yXCI6XG4gICAgICBjYXNlIFwiYnJhY2tldC1zZXBhcmF0b3JcIjoge1xuICAgICAgICBjb25zdCBEID0gSS5hcnJheUZvcm1hdCA9PT0gXCJicmFja2V0LXNlcGFyYXRvclwiID8gXCJbXT1cIiA6IFwiPVwiO1xuICAgICAgICByZXR1cm4gKHkpID0+ICh3LCBmKSA9PiBmID09PSB2b2lkIDAgfHwgSS5za2lwTnVsbCAmJiBmID09PSBudWxsIHx8IEkuc2tpcEVtcHR5U3RyaW5nICYmIGYgPT09IFwiXCIgPyB3IDogKGYgPSBmID09PSBudWxsID8gXCJcIiA6IGYsIHcubGVuZ3RoID09PSAwID8gW1twKHksIEkpLCBELCBwKGYsIEkpXS5qb2luKFwiXCIpXSA6IFtbdywgcChmLCBJKV0uam9pbihJLmFycmF5Rm9ybWF0U2VwYXJhdG9yKV0pO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIChEKSA9PiAoeSwgdykgPT4gdyA9PT0gdm9pZCAwIHx8IEkuc2tpcE51bGwgJiYgdyA9PT0gbnVsbCB8fCBJLnNraXBFbXB0eVN0cmluZyAmJiB3ID09PSBcIlwiID8geSA6IHcgPT09IG51bGwgPyBbLi4ueSwgcChELCBJKV0gOiBbLi4ueSwgW3AoRCwgSSksIFwiPVwiLCBwKHcsIEkpXS5qb2luKFwiXCIpXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdShJKSB7XG4gICAgbGV0IEQ7XG4gICAgc3dpdGNoIChJLmFycmF5Rm9ybWF0KSB7XG4gICAgICBjYXNlIFwiaW5kZXhcIjpcbiAgICAgICAgcmV0dXJuICh5LCB3LCBmKSA9PiB7XG4gICAgICAgICAgaWYgKEQgPSAvXFxbKFxcZCopXFxdJC8uZXhlYyh5KSwgeSA9IHkucmVwbGFjZSgvXFxbXFxkKlxcXSQvLCBcIlwiKSwgIUQpIHtcbiAgICAgICAgICAgIGZbeV0gPSB3O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmW3ldID09PSB2b2lkIDAgJiYgKGZbeV0gPSB7fSksIGZbeV1bRFsxXV0gPSB3O1xuICAgICAgICB9O1xuICAgICAgY2FzZSBcImJyYWNrZXRcIjpcbiAgICAgICAgcmV0dXJuICh5LCB3LCBmKSA9PiB7XG4gICAgICAgICAgaWYgKEQgPSAvKFxcW1xcXSkkLy5leGVjKHkpLCB5ID0geS5yZXBsYWNlKC9cXFtcXF0kLywgXCJcIiksICFEKSB7XG4gICAgICAgICAgICBmW3ldID0gdztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZbeV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZlt5XSA9IFt3XTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZlt5XSA9IFtdLmNvbmNhdChmW3ldLCB3KTtcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJjb2xvbi1saXN0LXNlcGFyYXRvclwiOlxuICAgICAgICByZXR1cm4gKHksIHcsIGYpID0+IHtcbiAgICAgICAgICBpZiAoRCA9IC8oOmxpc3QpJC8uZXhlYyh5KSwgeSA9IHkucmVwbGFjZSgvOmxpc3QkLywgXCJcIiksICFEKSB7XG4gICAgICAgICAgICBmW3ldID0gdztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZbeV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZlt5XSA9IFt3XTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZlt5XSA9IFtdLmNvbmNhdChmW3ldLCB3KTtcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJjb21tYVwiOlxuICAgICAgY2FzZSBcInNlcGFyYXRvclwiOlxuICAgICAgICByZXR1cm4gKHksIHcsIGYpID0+IHtcbiAgICAgICAgICBjb25zdCBhID0gdHlwZW9mIHcgPT0gXCJzdHJpbmdcIiAmJiB3LmluY2x1ZGVzKEkuYXJyYXlGb3JtYXRTZXBhcmF0b3IpLCBsID0gdHlwZW9mIHcgPT0gXCJzdHJpbmdcIiAmJiAhYSAmJiBiKHcsIEkpLmluY2x1ZGVzKEkuYXJyYXlGb3JtYXRTZXBhcmF0b3IpO1xuICAgICAgICAgIHcgPSBsID8gYih3LCBJKSA6IHc7XG4gICAgICAgICAgY29uc3QgTCA9IGEgfHwgbCA/IHcuc3BsaXQoSS5hcnJheUZvcm1hdFNlcGFyYXRvcikubWFwKCh2KSA9PiBiKHYsIEkpKSA6IHcgPT09IG51bGwgPyB3IDogYih3LCBJKTtcbiAgICAgICAgICBmW3ldID0gTDtcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJicmFja2V0LXNlcGFyYXRvclwiOlxuICAgICAgICByZXR1cm4gKHksIHcsIGYpID0+IHtcbiAgICAgICAgICBjb25zdCBhID0gLyhcXFtcXF0pJC8udGVzdCh5KTtcbiAgICAgICAgICBpZiAoeSA9IHkucmVwbGFjZSgvXFxbXFxdJC8sIFwiXCIpLCAhYSkge1xuICAgICAgICAgICAgZlt5XSA9IHcgJiYgYih3LCBJKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbCA9IHcgPT09IG51bGwgPyBbXSA6IHcuc3BsaXQoSS5hcnJheUZvcm1hdFNlcGFyYXRvcikubWFwKChMKSA9PiBiKEwsIEkpKTtcbiAgICAgICAgICBpZiAoZlt5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBmW3ldID0gbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZlt5XSA9IFtdLmNvbmNhdChmW3ldLCBsKTtcbiAgICAgICAgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoeSwgdywgZikgPT4ge1xuICAgICAgICAgIGlmIChmW3ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGZbeV0gPSB3O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmW3ldID0gW10uY29uY2F0KGZbeV0sIHcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkKEkpIHtcbiAgICBpZiAodHlwZW9mIEkgIT0gXCJzdHJpbmdcIiB8fCBJLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcnJheUZvcm1hdFNlcGFyYXRvciBtdXN0IGJlIHNpbmdsZSBjaGFyYWN0ZXIgc3RyaW5nXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHAoSSwgRCkge1xuICAgIHJldHVybiBELmVuY29kZSA/IEQuc3RyaWN0ID8gZShJKSA6IGVuY29kZVVSSUNvbXBvbmVudChJKSA6IEk7XG4gIH1cbiAgZnVuY3Rpb24gYihJLCBEKSB7XG4gICAgcmV0dXJuIEQuZGVjb2RlID8gdChJKSA6IEk7XG4gIH1cbiAgZnVuY3Rpb24geChJKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoSSkgPyBJLnNvcnQoKSA6IHR5cGVvZiBJID09IFwib2JqZWN0XCIgPyB4KE9iamVjdC5rZXlzKEkpKS5zb3J0KChELCB5KSA9PiBOdW1iZXIoRCkgLSBOdW1iZXIoeSkpLm1hcCgoRCkgPT4gSVtEXSkgOiBJO1xuICB9XG4gIGZ1bmN0aW9uIE8oSSkge1xuICAgIGNvbnN0IEQgPSBJLmluZGV4T2YoXCIjXCIpO1xuICAgIHJldHVybiBEICE9PSAtMSAmJiAoSSA9IEkuc2xpY2UoMCwgRCkpLCBJO1xuICB9XG4gIGZ1bmN0aW9uIF8oSSkge1xuICAgIGxldCBEID0gXCJcIjtcbiAgICBjb25zdCB5ID0gSS5pbmRleE9mKFwiI1wiKTtcbiAgICByZXR1cm4geSAhPT0gLTEgJiYgKEQgPSBJLnNsaWNlKHkpKSwgRDtcbiAgfVxuICBmdW5jdGlvbiBDKEkpIHtcbiAgICBJID0gTyhJKTtcbiAgICBjb25zdCBEID0gSS5pbmRleE9mKFwiP1wiKTtcbiAgICByZXR1cm4gRCA9PT0gLTEgPyBcIlwiIDogSS5zbGljZShEICsgMSk7XG4gIH1cbiAgZnVuY3Rpb24gRihJLCBEKSB7XG4gICAgcmV0dXJuIEQucGFyc2VOdW1iZXJzICYmICFOdW1iZXIuaXNOYU4oTnVtYmVyKEkpKSAmJiB0eXBlb2YgSSA9PSBcInN0cmluZ1wiICYmIEkudHJpbSgpICE9PSBcIlwiID8gSSA9IE51bWJlcihJKSA6IEQucGFyc2VCb29sZWFucyAmJiBJICE9PSBudWxsICYmIChJLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiIHx8IEkudG9Mb3dlckNhc2UoKSA9PT0gXCJmYWxzZVwiKSAmJiAoSSA9IEkudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCIpLCBJO1xuICB9XG4gIGZ1bmN0aW9uIEsoSSwgRCkge1xuICAgIEQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGRlY29kZTogITAsXG4gICAgICBzb3J0OiAhMCxcbiAgICAgIGFycmF5Rm9ybWF0OiBcIm5vbmVcIixcbiAgICAgIGFycmF5Rm9ybWF0U2VwYXJhdG9yOiBcIixcIixcbiAgICAgIHBhcnNlTnVtYmVyczogITEsXG4gICAgICBwYXJzZUJvb2xlYW5zOiAhMVxuICAgIH0sIEQpLCBkKEQuYXJyYXlGb3JtYXRTZXBhcmF0b3IpO1xuICAgIGNvbnN0IHkgPSB1KEQpLCB3ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKHR5cGVvZiBJICE9IFwic3RyaW5nXCIgfHwgKEkgPSBJLnRyaW0oKS5yZXBsYWNlKC9eWz8jJl0vLCBcIlwiKSwgIUkpKVxuICAgICAgcmV0dXJuIHc7XG4gICAgZm9yIChjb25zdCBmIG9mIEkuc3BsaXQoXCImXCIpKSB7XG4gICAgICBpZiAoZiA9PT0gXCJcIilcbiAgICAgICAgY29udGludWU7XG4gICAgICBsZXQgW2EsIGxdID0gcyhELmRlY29kZSA/IGYucmVwbGFjZSgvXFwrL2csIFwiIFwiKSA6IGYsIFwiPVwiKTtcbiAgICAgIGwgPSBsID09PSB2b2lkIDAgPyBudWxsIDogW1wiY29tbWFcIiwgXCJzZXBhcmF0b3JcIiwgXCJicmFja2V0LXNlcGFyYXRvclwiXS5pbmNsdWRlcyhELmFycmF5Rm9ybWF0KSA/IGwgOiBiKGwsIEQpLCB5KGIoYSwgRCksIGwsIHcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGYgb2YgT2JqZWN0LmtleXModykpIHtcbiAgICAgIGNvbnN0IGEgPSB3W2ZdO1xuICAgICAgaWYgKHR5cGVvZiBhID09IFwib2JqZWN0XCIgJiYgYSAhPT0gbnVsbClcbiAgICAgICAgZm9yIChjb25zdCBsIG9mIE9iamVjdC5rZXlzKGEpKVxuICAgICAgICAgIGFbbF0gPSBGKGFbbF0sIEQpO1xuICAgICAgZWxzZVxuICAgICAgICB3W2ZdID0gRihhLCBEKTtcbiAgICB9XG4gICAgcmV0dXJuIEQuc29ydCA9PT0gITEgPyB3IDogKEQuc29ydCA9PT0gITAgPyBPYmplY3Qua2V5cyh3KS5zb3J0KCkgOiBPYmplY3Qua2V5cyh3KS5zb3J0KEQuc29ydCkpLnJlZHVjZSgoZiwgYSkgPT4ge1xuICAgICAgY29uc3QgbCA9IHdbYV07XG4gICAgICByZXR1cm4gbCAmJiB0eXBlb2YgbCA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGwpID8gZlthXSA9IHgobCkgOiBmW2FdID0gbCwgZjtcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgaS5leHRyYWN0ID0gQywgaS5wYXJzZSA9IEssIGkuc3RyaW5naWZ5ID0gKEksIEQpID0+IHtcbiAgICBpZiAoIUkpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBEID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBlbmNvZGU6ICEwLFxuICAgICAgc3RyaWN0OiAhMCxcbiAgICAgIGFycmF5Rm9ybWF0OiBcIm5vbmVcIixcbiAgICAgIGFycmF5Rm9ybWF0U2VwYXJhdG9yOiBcIixcIlxuICAgIH0sIEQpLCBkKEQuYXJyYXlGb3JtYXRTZXBhcmF0b3IpO1xuICAgIGNvbnN0IHkgPSAobCkgPT4gRC5za2lwTnVsbCAmJiBuKElbbF0pIHx8IEQuc2tpcEVtcHR5U3RyaW5nICYmIElbbF0gPT09IFwiXCIsIHcgPSBjKEQpLCBmID0ge307XG4gICAgZm9yIChjb25zdCBsIG9mIE9iamVjdC5rZXlzKEkpKVxuICAgICAgeShsKSB8fCAoZltsXSA9IElbbF0pO1xuICAgIGNvbnN0IGEgPSBPYmplY3Qua2V5cyhmKTtcbiAgICByZXR1cm4gRC5zb3J0ICE9PSAhMSAmJiBhLnNvcnQoRC5zb3J0KSwgYS5tYXAoKGwpID0+IHtcbiAgICAgIGNvbnN0IEwgPSBJW2xdO1xuICAgICAgcmV0dXJuIEwgPT09IHZvaWQgMCA/IFwiXCIgOiBMID09PSBudWxsID8gcChsLCBEKSA6IEFycmF5LmlzQXJyYXkoTCkgPyBMLmxlbmd0aCA9PT0gMCAmJiBELmFycmF5Rm9ybWF0ID09PSBcImJyYWNrZXQtc2VwYXJhdG9yXCIgPyBwKGwsIEQpICsgXCJbXVwiIDogTC5yZWR1Y2UodyhsKSwgW10pLmpvaW4oXCImXCIpIDogcChsLCBEKSArIFwiPVwiICsgcChMLCBEKTtcbiAgICB9KS5maWx0ZXIoKGwpID0+IGwubGVuZ3RoID4gMCkuam9pbihcIiZcIik7XG4gIH0sIGkucGFyc2VVcmwgPSAoSSwgRCkgPT4ge1xuICAgIEQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGRlY29kZTogITBcbiAgICB9LCBEKTtcbiAgICBjb25zdCBbeSwgd10gPSBzKEksIFwiI1wiKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgdXJsOiB5LnNwbGl0KFwiP1wiKVswXSB8fCBcIlwiLFxuICAgICAgICBxdWVyeTogSyhDKEkpLCBEKVxuICAgICAgfSxcbiAgICAgIEQgJiYgRC5wYXJzZUZyYWdtZW50SWRlbnRpZmllciAmJiB3ID8geyBmcmFnbWVudElkZW50aWZpZXI6IGIodywgRCkgfSA6IHt9XG4gICAgKTtcbiAgfSwgaS5zdHJpbmdpZnlVcmwgPSAoSSwgRCkgPT4ge1xuICAgIEQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGVuY29kZTogITAsXG4gICAgICBzdHJpY3Q6ICEwLFxuICAgICAgW29dOiAhMFxuICAgIH0sIEQpO1xuICAgIGNvbnN0IHkgPSBPKEkudXJsKS5zcGxpdChcIj9cIilbMF0gfHwgXCJcIiwgdyA9IGkuZXh0cmFjdChJLnVybCksIGYgPSBpLnBhcnNlKHcsIHsgc29ydDogITEgfSksIGEgPSBPYmplY3QuYXNzaWduKGYsIEkucXVlcnkpO1xuICAgIGxldCBsID0gaS5zdHJpbmdpZnkoYSwgRCk7XG4gICAgbCAmJiAobCA9IGA/JHtsfWApO1xuICAgIGxldCBMID0gXyhJLnVybCk7XG4gICAgcmV0dXJuIEkuZnJhZ21lbnRJZGVudGlmaWVyICYmIChMID0gYCMke0Rbb10gPyBwKEkuZnJhZ21lbnRJZGVudGlmaWVyLCBEKSA6IEkuZnJhZ21lbnRJZGVudGlmaWVyfWApLCBgJHt5fSR7bH0ke0x9YDtcbiAgfSwgaS5waWNrID0gKEksIEQsIHkpID0+IHtcbiAgICB5ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBwYXJzZUZyYWdtZW50SWRlbnRpZmllcjogITAsXG4gICAgICBbb106ICExXG4gICAgfSwgeSk7XG4gICAgY29uc3QgeyB1cmw6IHcsIHF1ZXJ5OiBmLCBmcmFnbWVudElkZW50aWZpZXI6IGEgfSA9IGkucGFyc2VVcmwoSSwgeSk7XG4gICAgcmV0dXJuIGkuc3RyaW5naWZ5VXJsKHtcbiAgICAgIHVybDogdyxcbiAgICAgIHF1ZXJ5OiByKGYsIEQpLFxuICAgICAgZnJhZ21lbnRJZGVudGlmaWVyOiBhXG4gICAgfSwgeSk7XG4gIH0sIGkuZXhjbHVkZSA9IChJLCBELCB5KSA9PiB7XG4gICAgY29uc3QgdyA9IEFycmF5LmlzQXJyYXkoRCkgPyAoZikgPT4gIUQuaW5jbHVkZXMoZikgOiAoZiwgYSkgPT4gIUQoZiwgYSk7XG4gICAgcmV0dXJuIGkucGljayhJLCB3LCB5KTtcbiAgfTtcbn0pKGlpKTtcbmNvbnN0IEFjID0ge1xuICB3YWt1OiB7XG4gICAgcHVibGlzaDogXCJ3YWt1X3B1Ymxpc2hcIixcbiAgICBiYXRjaFB1Ymxpc2g6IFwid2FrdV9iYXRjaFB1Ymxpc2hcIixcbiAgICBzdWJzY3JpYmU6IFwid2FrdV9zdWJzY3JpYmVcIixcbiAgICBiYXRjaFN1YnNjcmliZTogXCJ3YWt1X2JhdGNoU3Vic2NyaWJlXCIsXG4gICAgc3Vic2NyaXB0aW9uOiBcIndha3Vfc3Vic2NyaXB0aW9uXCIsXG4gICAgdW5zdWJzY3JpYmU6IFwid2FrdV91bnN1YnNjcmliZVwiLFxuICAgIGJhdGNoVW5zdWJzY3JpYmU6IFwid2FrdV9iYXRjaFVuc3Vic2NyaWJlXCJcbiAgfSxcbiAgaXJuOiB7XG4gICAgcHVibGlzaDogXCJpcm5fcHVibGlzaFwiLFxuICAgIGJhdGNoUHVibGlzaDogXCJpcm5fYmF0Y2hQdWJsaXNoXCIsXG4gICAgc3Vic2NyaWJlOiBcImlybl9zdWJzY3JpYmVcIixcbiAgICBiYXRjaFN1YnNjcmliZTogXCJpcm5fYmF0Y2hTdWJzY3JpYmVcIixcbiAgICBzdWJzY3JpcHRpb246IFwiaXJuX3N1YnNjcmlwdGlvblwiLFxuICAgIHVuc3Vic2NyaWJlOiBcImlybl91bnN1YnNjcmliZVwiLFxuICAgIGJhdGNoVW5zdWJzY3JpYmU6IFwiaXJuX2JhdGNoVW5zdWJzY3JpYmVcIlxuICB9LFxuICBpcmlkaXVtOiB7XG4gICAgcHVibGlzaDogXCJpcmlkaXVtX3B1Ymxpc2hcIixcbiAgICBiYXRjaFB1Ymxpc2g6IFwiaXJpZGl1bV9iYXRjaFB1Ymxpc2hcIixcbiAgICBzdWJzY3JpYmU6IFwiaXJpZGl1bV9zdWJzY3JpYmVcIixcbiAgICBiYXRjaFN1YnNjcmliZTogXCJpcmlkaXVtX2JhdGNoU3Vic2NyaWJlXCIsXG4gICAgc3Vic2NyaXB0aW9uOiBcImlyaWRpdW1fc3Vic2NyaXB0aW9uXCIsXG4gICAgdW5zdWJzY3JpYmU6IFwiaXJpZGl1bV91bnN1YnNjcmliZVwiLFxuICAgIGJhdGNoVW5zdWJzY3JpYmU6IFwiaXJpZGl1bV9iYXRjaFVuc3Vic2NyaWJlXCJcbiAgfVxufTtcbmZ1bmN0aW9uIFRjKGksIGUpIHtcbiAgcmV0dXJuIGkuaW5jbHVkZXMoXCI6XCIpID8gW2ldIDogZS5jaGFpbnMgfHwgW107XG59XG5jb25zdCAkYyA9IFwiYmFzZTEwXCIsIHZ0ID0gXCJiYXNlMTZcIiwgQnIgPSBcImJhc2U2NHBhZFwiLCBwbiA9IFwidXRmOFwiLCBGYyA9IDAsIERpID0gMSwgZXAgPSAwLCBQbyA9IDEsIGtyID0gMTIsIGduID0gMzI7XG5mdW5jdGlvbiB0cCgpIHtcbiAgY29uc3QgaSA9IG1zLmdlbmVyYXRlS2V5UGFpcigpO1xuICByZXR1cm4geyBwcml2YXRlS2V5OiBOZShpLnNlY3JldEtleSwgdnQpLCBwdWJsaWNLZXk6IE5lKGkucHVibGljS2V5LCB2dCkgfTtcbn1cbmZ1bmN0aW9uIEhyKCkge1xuICBjb25zdCBpID0gbGkucmFuZG9tQnl0ZXMoZ24pO1xuICByZXR1cm4gTmUoaSwgdnQpO1xufVxuZnVuY3Rpb24gaXAoaSwgZSkge1xuICBjb25zdCB0ID0gbXMuc2hhcmVkS2V5KENlKGksIHZ0KSwgQ2UoZSwgdnQpLCAhMCksIHMgPSBuZXcgUmMoU2kuU0hBMjU2LCB0KS5leHBhbmQoZ24pO1xuICByZXR1cm4gTmUocywgdnQpO1xufVxuZnVuY3Rpb24gc3AoaSkge1xuICBjb25zdCBlID0gU2kuaGFzaChDZShpLCB2dCkpO1xuICByZXR1cm4gTmUoZSwgdnQpO1xufVxuZnVuY3Rpb24gRmkoaSkge1xuICBjb25zdCBlID0gU2kuaGFzaChDZShpLCBwbikpO1xuICByZXR1cm4gTmUoZSwgdnQpO1xufVxuZnVuY3Rpb24gcnAoaSkge1xuICByZXR1cm4gQ2UoYCR7aX1gLCAkYyk7XG59XG5mdW5jdGlvbiB3cyhpKSB7XG4gIHJldHVybiBOdW1iZXIoTmUoaSwgJGMpKTtcbn1cbmZ1bmN0aW9uIG5wKGkpIHtcbiAgY29uc3QgZSA9IHJwKHR5cGVvZiBpLnR5cGUgPCBcInVcIiA/IGkudHlwZSA6IEZjKTtcbiAgaWYgKHdzKGUpID09PSBEaSAmJiB0eXBlb2YgaS5zZW5kZXJQdWJsaWNLZXkgPiBcInVcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHNlbmRlciBwdWJsaWMga2V5IGZvciB0eXBlIDEgZW52ZWxvcGVcIik7XG4gIGNvbnN0IHQgPSB0eXBlb2YgaS5zZW5kZXJQdWJsaWNLZXkgPCBcInVcIiA/IENlKGkuc2VuZGVyUHVibGljS2V5LCB2dCkgOiB2b2lkIDAsIHMgPSB0eXBlb2YgaS5pdiA8IFwidVwiID8gQ2UoaS5pdiwgdnQpIDogbGkucmFuZG9tQnl0ZXMoa3IpLCByID0gbmV3IGdzLkNoYUNoYTIwUG9seTEzMDUoQ2UoaS5zeW1LZXksIHZ0KSkuc2VhbChzLCBDZShpLm1lc3NhZ2UsIHBuKSk7XG4gIHJldHVybiBhcCh7IHR5cGU6IGUsIHNlYWxlZDogciwgaXY6IHMsIHNlbmRlclB1YmxpY0tleTogdCB9KTtcbn1cbmZ1bmN0aW9uIG9wKGkpIHtcbiAgY29uc3QgZSA9IG5ldyBncy5DaGFDaGEyMFBvbHkxMzA1KENlKGkuc3ltS2V5LCB2dCkpLCB7IHNlYWxlZDogdCwgaXY6IHMgfSA9IFlzKGkuZW5jb2RlZCksIHIgPSBlLm9wZW4ocywgdCk7XG4gIGlmIChyID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0XCIpO1xuICByZXR1cm4gTmUociwgcG4pO1xufVxuZnVuY3Rpb24gYXAoaSkge1xuICBpZiAod3MoaS50eXBlKSA9PT0gRGkpIHtcbiAgICBpZiAodHlwZW9mIGkuc2VuZGVyUHVibGljS2V5ID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHNlbmRlciBwdWJsaWMga2V5IGZvciB0eXBlIDEgZW52ZWxvcGVcIik7XG4gICAgcmV0dXJuIE5lKGxzKFtpLnR5cGUsIGkuc2VuZGVyUHVibGljS2V5LCBpLml2LCBpLnNlYWxlZF0pLCBCcik7XG4gIH1cbiAgcmV0dXJuIE5lKGxzKFtpLnR5cGUsIGkuaXYsIGkuc2VhbGVkXSksIEJyKTtcbn1cbmZ1bmN0aW9uIFlzKGkpIHtcbiAgY29uc3QgZSA9IENlKGksIEJyKSwgdCA9IGUuc2xpY2UoZXAsIFBvKSwgcyA9IFBvO1xuICBpZiAod3ModCkgPT09IERpKSB7XG4gICAgY29uc3QgYyA9IHMgKyBnbiwgdSA9IGMgKyBrciwgZCA9IGUuc2xpY2UocywgYyksIHAgPSBlLnNsaWNlKGMsIHUpLCBiID0gZS5zbGljZSh1KTtcbiAgICByZXR1cm4geyB0eXBlOiB0LCBzZWFsZWQ6IGIsIGl2OiBwLCBzZW5kZXJQdWJsaWNLZXk6IGQgfTtcbiAgfVxuICBjb25zdCByID0gcyArIGtyLCBuID0gZS5zbGljZShzLCByKSwgbyA9IGUuc2xpY2Uocik7XG4gIHJldHVybiB7IHR5cGU6IHQsIHNlYWxlZDogbywgaXY6IG4gfTtcbn1cbmZ1bmN0aW9uIGNwKGksIGUpIHtcbiAgY29uc3QgdCA9IFlzKGkpO1xuICByZXR1cm4gVWMoeyB0eXBlOiB3cyh0LnR5cGUpLCBzZW5kZXJQdWJsaWNLZXk6IHR5cGVvZiB0LnNlbmRlclB1YmxpY0tleSA8IFwidVwiID8gTmUodC5zZW5kZXJQdWJsaWNLZXksIHZ0KSA6IHZvaWQgMCwgcmVjZWl2ZXJQdWJsaWNLZXk6IGU/LnJlY2VpdmVyUHVibGljS2V5IH0pO1xufVxuZnVuY3Rpb24gVWMoaSkge1xuICBjb25zdCBlID0gaT8udHlwZSB8fCBGYztcbiAgaWYgKGUgPT09IERpKSB7XG4gICAgaWYgKHR5cGVvZiBpPy5zZW5kZXJQdWJsaWNLZXkgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgc2VuZGVyIHB1YmxpYyBrZXlcIik7XG4gICAgaWYgKHR5cGVvZiBpPy5yZWNlaXZlclB1YmxpY0tleSA+IFwidVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyByZWNlaXZlciBwdWJsaWMga2V5XCIpO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IGUsIHNlbmRlclB1YmxpY0tleTogaT8uc2VuZGVyUHVibGljS2V5LCByZWNlaXZlclB1YmxpY0tleTogaT8ucmVjZWl2ZXJQdWJsaWNLZXkgfTtcbn1cbmZ1bmN0aW9uIFJvKGkpIHtcbiAgcmV0dXJuIGkudHlwZSA9PT0gRGkgJiYgdHlwZW9mIGkuc2VuZGVyUHVibGljS2V5ID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGkucmVjZWl2ZXJQdWJsaWNLZXkgPT0gXCJzdHJpbmdcIjtcbn1cbnZhciBocCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgQ28gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCB1cCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGxwID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgQW8gPSAoaSwgZSwgdCkgPT4gZSBpbiBpID8gaHAoaSwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IGlbZV0gPSB0LCBUbyA9IChpLCBlKSA9PiB7XG4gIGZvciAodmFyIHQgaW4gZSB8fCAoZSA9IHt9KSlcbiAgICB1cC5jYWxsKGUsIHQpICYmIEFvKGksIHQsIGVbdF0pO1xuICBpZiAoQ28pXG4gICAgZm9yICh2YXIgdCBvZiBDbyhlKSlcbiAgICAgIGxwLmNhbGwoZSwgdCkgJiYgQW8oaSwgdCwgZVt0XSk7XG4gIHJldHVybiBpO1xufTtcbmNvbnN0IGRwID0gXCJSZWFjdE5hdGl2ZVwiLCBPdCA9IHsgcmVhY3ROYXRpdmU6IFwicmVhY3QtbmF0aXZlXCIsIG5vZGU6IFwibm9kZVwiLCBicm93c2VyOiBcImJyb3dzZXJcIiwgdW5rbm93bjogXCJ1bmtub3duXCIgfSwgZnAgPSBcImpzXCI7XG5mdW5jdGlvbiB5bigpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzIDwgXCJ1XCIgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgPCBcInVcIiAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlIDwgXCJ1XCI7XG59XG5mdW5jdGlvbiB1cigpIHtcbiAgcmV0dXJuICF1bigpICYmICEhYnMoKSAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gZHA7XG59XG5mdW5jdGlvbiB2cygpIHtcbiAgcmV0dXJuICF5bigpICYmICEhYnMoKTtcbn1cbmZ1bmN0aW9uIF9zKCkge1xuICByZXR1cm4gdXIoKSA/IE90LnJlYWN0TmF0aXZlIDogeW4oKSA/IE90Lm5vZGUgOiB2cygpID8gT3QuYnJvd3NlciA6IE90LnVua25vd247XG59XG5mdW5jdGlvbiBwcChpLCBlKSB7XG4gIGxldCB0ID0gaWkucGFyc2UoaSk7XG4gIHJldHVybiB0ID0gVG8oVG8oe30sIHQpLCBlKSwgaSA9IGlpLnN0cmluZ2lmeSh0KSwgaTtcbn1cbmZ1bmN0aW9uIGdwKCkge1xuICByZXR1cm4gZm4oKSB8fCB7IG5hbWU6IFwiXCIsIGRlc2NyaXB0aW9uOiBcIlwiLCB1cmw6IFwiXCIsIGljb25zOiBbXCJcIl0gfTtcbn1cbmZ1bmN0aW9uIHlwKCkge1xuICBpZiAoX3MoKSA9PT0gT3QucmVhY3ROYXRpdmUgJiYgdHlwZW9mIGdsb2JhbCA8IFwidVwiICYmIHR5cGVvZiAoZ2xvYmFsID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWwuUGxhdGZvcm0pIDwgXCJ1XCIpIHtcbiAgICBjb25zdCB7IE9TOiB0LCBWZXJzaW9uOiBzIH0gPSBnbG9iYWwuUGxhdGZvcm07XG4gICAgcmV0dXJuIFt0LCBzXS5qb2luKFwiLVwiKTtcbiAgfVxuICBjb25zdCBpID0gaG4oKTtcbiAgaWYgKGkgPT09IG51bGwpXG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xuICBjb25zdCBlID0gaS5vcyA/IGkub3MucmVwbGFjZShcIiBcIiwgXCJcIikudG9Mb3dlckNhc2UoKSA6IFwidW5rbm93blwiO1xuICByZXR1cm4gaS50eXBlID09PSBcImJyb3dzZXJcIiA/IFtlLCBpLm5hbWUsIGkudmVyc2lvbl0uam9pbihcIi1cIikgOiBbZSwgaS52ZXJzaW9uXS5qb2luKFwiLVwiKTtcbn1cbmZ1bmN0aW9uIG1wKCkge1xuICB2YXIgaTtcbiAgY29uc3QgZSA9IF9zKCk7XG4gIHJldHVybiBlID09PSBPdC5icm93c2VyID8gW2UsICgoaSA9IGxuKCkpID09IG51bGwgPyB2b2lkIDAgOiBpLmhvc3QpIHx8IFwidW5rbm93blwiXS5qb2luKFwiOlwiKSA6IGU7XG59XG5mdW5jdGlvbiBicChpLCBlLCB0KSB7XG4gIGNvbnN0IHMgPSB5cCgpLCByID0gbXAoKTtcbiAgcmV0dXJuIFtbaSwgZV0uam9pbihcIi1cIiksIFtmcCwgdF0uam9pbihcIi1cIiksIHMsIHJdLmpvaW4oXCIvXCIpO1xufVxuZnVuY3Rpb24gd3AoeyBwcm90b2NvbDogaSwgdmVyc2lvbjogZSwgcmVsYXlVcmw6IHQsIHNka1ZlcnNpb246IHMsIGF1dGg6IHIsIHByb2plY3RJZDogbiwgdXNlT25DbG9zZUV2ZW50OiBvIH0pIHtcbiAgY29uc3QgYyA9IHQuc3BsaXQoXCI/XCIpLCB1ID0gYnAoaSwgZSwgcyksIGQgPSB7IGF1dGg6IHIsIHVhOiB1LCBwcm9qZWN0SWQ6IG4sIHVzZU9uQ2xvc2VFdmVudDogbyB8fCB2b2lkIDAgfSwgcCA9IHBwKGNbMV0gfHwgXCJcIiwgZCk7XG4gIHJldHVybiBjWzBdICsgXCI/XCIgKyBwO1xufVxuZnVuY3Rpb24gX2koaSwgZSkge1xuICByZXR1cm4gaS5maWx0ZXIoKHQpID0+IGUuaW5jbHVkZXModCkpLmxlbmd0aCA9PT0gaS5sZW5ndGg7XG59XG5mdW5jdGlvbiBMYyhpKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoaS5lbnRyaWVzKCkpO1xufVxuZnVuY3Rpb24gTWMoaSkge1xuICByZXR1cm4gbmV3IE1hcChPYmplY3QuZW50cmllcyhpKSk7XG59XG5mdW5jdGlvbiBBaShpID0gVi5GSVZFX01JTlVURVMsIGUpIHtcbiAgY29uc3QgdCA9IFYudG9NaWxpc2Vjb25kcyhpIHx8IFYuRklWRV9NSU5VVEVTKTtcbiAgbGV0IHMsIHIsIG47XG4gIHJldHVybiB7IHJlc29sdmU6IChvKSA9PiB7XG4gICAgbiAmJiBzICYmIChjbGVhclRpbWVvdXQobiksIHMobykpO1xuICB9LCByZWplY3Q6IChvKSA9PiB7XG4gICAgbiAmJiByICYmIChjbGVhclRpbWVvdXQobiksIHIobykpO1xuICB9LCBkb25lOiAoKSA9PiBuZXcgUHJvbWlzZSgobywgYykgPT4ge1xuICAgIG4gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGMobmV3IEVycm9yKGUpKTtcbiAgICB9LCB0KSwgcyA9IG8sIHIgPSBjO1xuICB9KSB9O1xufVxuZnVuY3Rpb24gZHMoaSwgZSwgdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHMsIHIpID0+IHtcbiAgICBjb25zdCBuID0gc2V0VGltZW91dCgoKSA9PiByKG5ldyBFcnJvcih0KSksIGUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvID0gYXdhaXQgaTtcbiAgICAgIHMobyk7XG4gICAgfSBjYXRjaCAobykge1xuICAgICAgcihvKTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KG4pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHFjKGksIGUpIHtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIgJiYgZS5zdGFydHNXaXRoKGAke2l9OmApKVxuICAgIHJldHVybiBlO1xuICBpZiAoaS50b0xvd2VyQ2FzZSgpID09PSBcInRvcGljXCIpIHtcbiAgICBpZiAodHlwZW9mIGUgIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgbXVzdCBiZSBcInN0cmluZ1wiIGZvciBleHBpcmVyIHRhcmdldCB0eXBlOiB0b3BpYycpO1xuICAgIHJldHVybiBgdG9waWM6JHtlfWA7XG4gIH0gZWxzZSBpZiAoaS50b0xvd2VyQ2FzZSgpID09PSBcImlkXCIpIHtcbiAgICBpZiAodHlwZW9mIGUgIT0gXCJudW1iZXJcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgbXVzdCBiZSBcIm51bWJlclwiIGZvciBleHBpcmVyIHRhcmdldCB0eXBlOiBpZCcpO1xuICAgIHJldHVybiBgaWQ6JHtlfWA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGV4cGlyZXIgdGFyZ2V0IHR5cGU6ICR7aX1gKTtcbn1cbmZ1bmN0aW9uIHZwKGkpIHtcbiAgcmV0dXJuIHFjKFwidG9waWNcIiwgaSk7XG59XG5mdW5jdGlvbiBfcChpKSB7XG4gIHJldHVybiBxYyhcImlkXCIsIGkpO1xufVxuZnVuY3Rpb24gamMoaSkge1xuICBjb25zdCBbZSwgdF0gPSBpLnNwbGl0KFwiOlwiKSwgcyA9IHsgaWQ6IHZvaWQgMCwgdG9waWM6IHZvaWQgMCB9O1xuICBpZiAoZSA9PT0gXCJ0b3BpY1wiICYmIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpXG4gICAgcy50b3BpYyA9IHQ7XG4gIGVsc2UgaWYgKGUgPT09IFwiaWRcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcih0KSkpXG4gICAgcy5pZCA9IE51bWJlcih0KTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0YXJnZXQsIGV4cGVjdGVkIGlkOm51bWJlciBvciB0b3BpYzpzdHJpbmcsIGdvdCAke2V9OiR7dH1gKTtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBNdChpLCBlKSB7XG4gIHJldHVybiBWLmZyb21NaWxpc2Vjb25kcygoZSB8fCBEYXRlLm5vdygpKSArIFYudG9NaWxpc2Vjb25kcyhpKSk7XG59XG5mdW5jdGlvbiBhaShpKSB7XG4gIHJldHVybiBEYXRlLm5vdygpID49IFYudG9NaWxpc2Vjb25kcyhpKTtcbn1cbmZ1bmN0aW9uIEJlKGksIGUpIHtcbiAgcmV0dXJuIGAke2l9JHtlID8gYDoke2V9YCA6IFwiXCJ9YDtcbn1cbmFzeW5jIGZ1bmN0aW9uIEVwKHsgaWQ6IGksIHRvcGljOiBlLCB3Y0RlZXBMaW5rOiB0IH0pIHtcbiAgdHJ5IHtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHIgPSAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UodCkgOiB0KT8uaHJlZjtcbiAgICBpZiAodHlwZW9mIHIgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybjtcbiAgICByLmVuZHNXaXRoKFwiL1wiKSAmJiAociA9IHIuc2xpY2UoMCwgLTEpKTtcbiAgICBjb25zdCBuID0gYCR7cn0vd2M/cmVxdWVzdElkPSR7aX0mc2Vzc2lvblRvcGljPSR7ZX1gLCBvID0gX3MoKTtcbiAgICBvID09PSBPdC5icm93c2VyID8gbi5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikgPyB3aW5kb3cub3BlbihuLCBcIl9ibGFua1wiLCBcIm5vcmVmZXJyZXIgbm9vcGVuZXJcIikgOiB3aW5kb3cub3BlbihuLCBcIl9zZWxmXCIsIFwibm9yZWZlcnJlciBub29wZW5lclwiKSA6IG8gPT09IE90LnJlYWN0TmF0aXZlICYmIHR5cGVvZiAoZ2xvYmFsID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWwuTGlua2luZykgPCBcInVcIiAmJiBhd2FpdCBnbG9iYWwuTGlua2luZy5vcGVuVVJMKG4pO1xuICB9IGNhdGNoIChzKSB7XG4gICAgY29uc29sZS5lcnJvcihzKTtcbiAgfVxufVxuY29uc3QgU3AgPSBcImlyblwiO1xuZnVuY3Rpb24gR3IoaSkge1xuICByZXR1cm4gaT8ucmVsYXkgfHwgeyBwcm90b2NvbDogU3AgfTtcbn1cbmZ1bmN0aW9uIGpzKGkpIHtcbiAgY29uc3QgZSA9IEFjW2ldO1xuICBpZiAodHlwZW9mIGUgPiBcInVcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJlbGF5IFByb3RvY29sIG5vdCBzdXBwb3J0ZWQ6ICR7aX1gKTtcbiAgcmV0dXJuIGU7XG59XG52YXIgSXAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksICRvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgRHAgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCB4cCA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIEZvID0gKGksIGUsIHQpID0+IGUgaW4gaSA/IElwKGksIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBpW2VdID0gdCwgT3AgPSAoaSwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgRHAuY2FsbChlLCB0KSAmJiBGbyhpLCB0LCBlW3RdKTtcbiAgaWYgKCRvKVxuICAgIGZvciAodmFyIHQgb2YgJG8oZSkpXG4gICAgICB4cC5jYWxsKGUsIHQpICYmIEZvKGksIHQsIGVbdF0pO1xuICByZXR1cm4gaTtcbn07XG5mdW5jdGlvbiBOcChpLCBlID0gXCItXCIpIHtcbiAgY29uc3QgdCA9IHt9LCBzID0gXCJyZWxheVwiICsgZTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGkpLmZvckVhY2goKHIpID0+IHtcbiAgICBpZiAoci5zdGFydHNXaXRoKHMpKSB7XG4gICAgICBjb25zdCBuID0gci5yZXBsYWNlKHMsIFwiXCIpLCBvID0gaVtyXTtcbiAgICAgIHRbbl0gPSBvO1xuICAgIH1cbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBQcChpKSB7XG4gIGNvbnN0IGUgPSBpLmluZGV4T2YoXCI6XCIpLCB0ID0gaS5pbmRleE9mKFwiP1wiKSAhPT0gLTEgPyBpLmluZGV4T2YoXCI/XCIpIDogdm9pZCAwLCBzID0gaS5zdWJzdHJpbmcoMCwgZSksIHIgPSBpLnN1YnN0cmluZyhlICsgMSwgdCkuc3BsaXQoXCJAXCIpLCBuID0gdHlwZW9mIHQgPCBcInVcIiA/IGkuc3Vic3RyaW5nKHQpIDogXCJcIiwgbyA9IGlpLnBhcnNlKG4pO1xuICByZXR1cm4geyBwcm90b2NvbDogcywgdG9waWM6IFJwKHJbMF0pLCB2ZXJzaW9uOiBwYXJzZUludChyWzFdLCAxMCksIHN5bUtleTogby5zeW1LZXksIHJlbGF5OiBOcChvKSB9O1xufVxuZnVuY3Rpb24gUnAoaSkge1xuICByZXR1cm4gaS5zdGFydHNXaXRoKFwiLy9cIikgPyBpLnN1YnN0cmluZygyKSA6IGk7XG59XG5mdW5jdGlvbiBDcChpLCBlID0gXCItXCIpIHtcbiAgY29uc3QgdCA9IFwicmVsYXlcIiwgcyA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMoaSkuZm9yRWFjaCgocikgPT4ge1xuICAgIGNvbnN0IG4gPSB0ICsgZSArIHI7XG4gICAgaVtyXSAmJiAoc1tuXSA9IGlbcl0pO1xuICB9KSwgcztcbn1cbmZ1bmN0aW9uIEFwKGkpIHtcbiAgcmV0dXJuIGAke2kucHJvdG9jb2x9OiR7aS50b3BpY31AJHtpLnZlcnNpb259P2AgKyBpaS5zdHJpbmdpZnkoT3AoeyBzeW1LZXk6IGkuc3ltS2V5IH0sIENwKGkucmVsYXkpKSk7XG59XG5mdW5jdGlvbiBNaShpKSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgcmV0dXJuIGkuZm9yRWFjaCgodCkgPT4ge1xuICAgIGNvbnN0IFtzLCByXSA9IHQuc3BsaXQoXCI6XCIpO1xuICAgIGUucHVzaChgJHtzfToke3J9YCk7XG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gVHAoaSkge1xuICBjb25zdCBlID0gW107XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGkpLmZvckVhY2goKHQpID0+IHtcbiAgICBlLnB1c2goLi4uTWkodC5hY2NvdW50cykpO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uICRwKGksIGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgTWkocy5hY2NvdW50cykuaW5jbHVkZXMoZSkgJiYgdC5wdXNoKC4uLnMubWV0aG9kcyk7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gRnAoaSwgZSkge1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGkpLmZvckVhY2goKHMpID0+IHtcbiAgICBNaShzLmFjY291bnRzKS5pbmNsdWRlcyhlKSAmJiB0LnB1c2goLi4ucy5ldmVudHMpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIFVwKGksIGUpIHtcbiAgY29uc3QgdCA9IHpzKGksIGUpO1xuICBpZiAodClcbiAgICB0aHJvdyBuZXcgRXJyb3IodC5tZXNzYWdlKTtcbiAgY29uc3QgcyA9IHt9O1xuICBmb3IgKGNvbnN0IFtyLCBuXSBvZiBPYmplY3QuZW50cmllcyhpKSlcbiAgICBzW3JdID0geyBtZXRob2RzOiBuLm1ldGhvZHMsIGV2ZW50czogbi5ldmVudHMsIGNoYWluczogbi5hY2NvdW50cy5tYXAoKG8pID0+IGAke28uc3BsaXQoXCI6XCIpWzBdfToke28uc3BsaXQoXCI6XCIpWzFdfWApIH07XG4gIHJldHVybiBzO1xufVxuY29uc3QgTHAgPSB7IElOVkFMSURfTUVUSE9EOiB7IG1lc3NhZ2U6IFwiSW52YWxpZCBtZXRob2QuXCIsIGNvZGU6IDEwMDEgfSwgSU5WQUxJRF9FVkVOVDogeyBtZXNzYWdlOiBcIkludmFsaWQgZXZlbnQuXCIsIGNvZGU6IDEwMDIgfSwgSU5WQUxJRF9VUERBVEVfUkVRVUVTVDogeyBtZXNzYWdlOiBcIkludmFsaWQgdXBkYXRlIHJlcXVlc3QuXCIsIGNvZGU6IDEwMDMgfSwgSU5WQUxJRF9FWFRFTkRfUkVRVUVTVDogeyBtZXNzYWdlOiBcIkludmFsaWQgZXh0ZW5kIHJlcXVlc3QuXCIsIGNvZGU6IDEwMDQgfSwgSU5WQUxJRF9TRVNTSU9OX1NFVFRMRV9SRVFVRVNUOiB7IG1lc3NhZ2U6IFwiSW52YWxpZCBzZXNzaW9uIHNldHRsZSByZXF1ZXN0LlwiLCBjb2RlOiAxMDA1IH0sIFVOQVVUSE9SSVpFRF9NRVRIT0Q6IHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWQgbWV0aG9kLlwiLCBjb2RlOiAzMDAxIH0sIFVOQVVUSE9SSVpFRF9FVkVOVDogeyBtZXNzYWdlOiBcIlVuYXV0aG9yaXplZCBldmVudC5cIiwgY29kZTogMzAwMiB9LCBVTkFVVEhPUklaRURfVVBEQVRFX1JFUVVFU1Q6IHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWQgdXBkYXRlIHJlcXVlc3QuXCIsIGNvZGU6IDMwMDMgfSwgVU5BVVRIT1JJWkVEX0VYVEVORF9SRVFVRVNUOiB7IG1lc3NhZ2U6IFwiVW5hdXRob3JpemVkIGV4dGVuZCByZXF1ZXN0LlwiLCBjb2RlOiAzMDA0IH0sIFVTRVJfUkVKRUNURUQ6IHsgbWVzc2FnZTogXCJVc2VyIHJlamVjdGVkLlwiLCBjb2RlOiA1ZTMgfSwgVVNFUl9SRUpFQ1RFRF9DSEFJTlM6IHsgbWVzc2FnZTogXCJVc2VyIHJlamVjdGVkIGNoYWlucy5cIiwgY29kZTogNTAwMSB9LCBVU0VSX1JFSkVDVEVEX01FVEhPRFM6IHsgbWVzc2FnZTogXCJVc2VyIHJlamVjdGVkIG1ldGhvZHMuXCIsIGNvZGU6IDUwMDIgfSwgVVNFUl9SRUpFQ1RFRF9FVkVOVFM6IHsgbWVzc2FnZTogXCJVc2VyIHJlamVjdGVkIGV2ZW50cy5cIiwgY29kZTogNTAwMyB9LCBVTlNVUFBPUlRFRF9DSEFJTlM6IHsgbWVzc2FnZTogXCJVbnN1cHBvcnRlZCBjaGFpbnMuXCIsIGNvZGU6IDUxMDAgfSwgVU5TVVBQT1JURURfTUVUSE9EUzogeyBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIG1ldGhvZHMuXCIsIGNvZGU6IDUxMDEgfSwgVU5TVVBQT1JURURfRVZFTlRTOiB7IG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgZXZlbnRzLlwiLCBjb2RlOiA1MTAyIH0sIFVOU1VQUE9SVEVEX0FDQ09VTlRTOiB7IG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgYWNjb3VudHMuXCIsIGNvZGU6IDUxMDMgfSwgVU5TVVBQT1JURURfTkFNRVNQQUNFX0tFWTogeyBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIG5hbWVzcGFjZSBrZXkuXCIsIGNvZGU6IDUxMDQgfSwgVVNFUl9ESVNDT05ORUNURUQ6IHsgbWVzc2FnZTogXCJVc2VyIGRpc2Nvbm5lY3RlZC5cIiwgY29kZTogNmUzIH0sIFNFU1NJT05fU0VUVExFTUVOVF9GQUlMRUQ6IHsgbWVzc2FnZTogXCJTZXNzaW9uIHNldHRsZW1lbnQgZmFpbGVkLlwiLCBjb2RlOiA3ZTMgfSwgV0NfTUVUSE9EX1VOU1VQUE9SVEVEOiB7IG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgd2NfIG1ldGhvZC5cIiwgY29kZTogMTAwMDEgfSB9LCBNcCA9IHsgTk9UX0lOSVRJQUxJWkVEOiB7IG1lc3NhZ2U6IFwiTm90IGluaXRpYWxpemVkLlwiLCBjb2RlOiAxIH0sIE5PX01BVENISU5HX0tFWTogeyBtZXNzYWdlOiBcIk5vIG1hdGNoaW5nIGtleS5cIiwgY29kZTogMiB9LCBSRVNUT1JFX1dJTExfT1ZFUlJJREU6IHsgbWVzc2FnZTogXCJSZXN0b3JlIHdpbGwgb3ZlcnJpZGUuXCIsIGNvZGU6IDMgfSwgUkVTVUJTQ1JJQkVEOiB7IG1lc3NhZ2U6IFwiUmVzdWJzY3JpYmVkLlwiLCBjb2RlOiA0IH0sIE1JU1NJTkdfT1JfSU5WQUxJRDogeyBtZXNzYWdlOiBcIk1pc3Npbmcgb3IgaW52YWxpZC5cIiwgY29kZTogNSB9LCBFWFBJUkVEOiB7IG1lc3NhZ2U6IFwiRXhwaXJlZC5cIiwgY29kZTogNiB9LCBVTktOT1dOX1RZUEU6IHsgbWVzc2FnZTogXCJVbmtub3duIHR5cGUuXCIsIGNvZGU6IDcgfSwgTUlTTUFUQ0hFRF9UT1BJQzogeyBtZXNzYWdlOiBcIk1pc21hdGNoZWQgdG9waWMuXCIsIGNvZGU6IDggfSwgTk9OX0NPTkZPUk1JTkdfTkFNRVNQQUNFUzogeyBtZXNzYWdlOiBcIk5vbiBjb25mb3JtaW5nIG5hbWVzcGFjZXMuXCIsIGNvZGU6IDkgfSB9O1xuZnVuY3Rpb24gWShpLCBlKSB7XG4gIGNvbnN0IHsgbWVzc2FnZTogdCwgY29kZTogcyB9ID0gTXBbaV07XG4gIHJldHVybiB7IG1lc3NhZ2U6IGUgPyBgJHt0fSAke2V9YCA6IHQsIGNvZGU6IHMgfTtcbn1cbmZ1bmN0aW9uIG50KGksIGUpIHtcbiAgY29uc3QgeyBtZXNzYWdlOiB0LCBjb2RlOiBzIH0gPSBMcFtpXTtcbiAgcmV0dXJuIHsgbWVzc2FnZTogZSA/IGAke3R9ICR7ZX1gIDogdCwgY29kZTogcyB9O1xufVxuZnVuY3Rpb24gRXMoaSwgZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpKSA/IHR5cGVvZiBlIDwgXCJ1XCIgJiYgaS5sZW5ndGggPyBpLmV2ZXJ5KGUpIDogITAgOiAhMTtcbn1cbmZ1bmN0aW9uIGNzKGkpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihpKSA9PT0gT2JqZWN0LnByb3RvdHlwZSAmJiBPYmplY3Qua2V5cyhpKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBidChpKSB7XG4gIHJldHVybiB0eXBlb2YgaSA+IFwidVwiO1xufVxuZnVuY3Rpb24gb3QoaSwgZSkge1xuICByZXR1cm4gZSAmJiBidChpKSA/ICEwIDogdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiAmJiAhIWkudHJpbSgpLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIG1uKGksIGUpIHtcbiAgcmV0dXJuIGUgJiYgYnQoaSkgPyAhMCA6IHR5cGVvZiBpID09IFwibnVtYmVyXCIgJiYgIWlzTmFOKGkpO1xufVxuZnVuY3Rpb24gcXAoaSwgZSkge1xuICBjb25zdCB7IHJlcXVpcmVkTmFtZXNwYWNlczogdCB9ID0gZSwgcyA9IE9iamVjdC5rZXlzKGkubmFtZXNwYWNlcyksIHIgPSBPYmplY3Qua2V5cyh0KTtcbiAgbGV0IG4gPSAhMDtcbiAgcmV0dXJuIF9pKHIsIHMpID8gKHMuZm9yRWFjaCgobykgPT4ge1xuICAgIGNvbnN0IHsgYWNjb3VudHM6IGMsIG1ldGhvZHM6IHUsIGV2ZW50czogZCB9ID0gaS5uYW1lc3BhY2VzW29dLCBwID0gTWkoYyksIGIgPSB0W29dO1xuICAgICghX2koVGMobywgYiksIHApIHx8ICFfaShiLm1ldGhvZHMsIHUpIHx8ICFfaShiLmV2ZW50cywgZCkpICYmIChuID0gITEpO1xuICB9KSwgbikgOiAhMTtcbn1cbmZ1bmN0aW9uIEpzKGkpIHtcbiAgcmV0dXJuIG90KGksICExKSAmJiBpLmluY2x1ZGVzKFwiOlwiKSA/IGkuc3BsaXQoXCI6XCIpLmxlbmd0aCA9PT0gMiA6ICExO1xufVxuZnVuY3Rpb24ganAoaSkge1xuICBpZiAob3QoaSwgITEpICYmIGkuaW5jbHVkZXMoXCI6XCIpKSB7XG4gICAgY29uc3QgZSA9IGkuc3BsaXQoXCI6XCIpO1xuICAgIGlmIChlLmxlbmd0aCA9PT0gMykge1xuICAgICAgY29uc3QgdCA9IGVbMF0gKyBcIjpcIiArIGVbMV07XG4gICAgICByZXR1cm4gISFlWzJdICYmIEpzKHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiB6cChpKSB7XG4gIGlmIChvdChpLCAhMSkpXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0eXBlb2YgbmV3IFVSTChpKSA8IFwidVwiO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gS3AoaSkge1xuICB2YXIgZTtcbiAgcmV0dXJuIChlID0gaT8ucHJvcG9zZXIpID09IG51bGwgPyB2b2lkIDAgOiBlLnB1YmxpY0tleTtcbn1cbmZ1bmN0aW9uIFZwKGkpIHtcbiAgcmV0dXJuIGk/LnRvcGljO1xufVxuZnVuY3Rpb24gQnAoaSwgZSkge1xuICBsZXQgdCA9IG51bGw7XG4gIHJldHVybiBvdChpPy5wdWJsaWNLZXksICExKSB8fCAodCA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYCR7ZX0gY29udHJvbGxlciBwdWJsaWMga2V5IHNob3VsZCBiZSBhIHN0cmluZ2ApKSwgdDtcbn1cbmZ1bmN0aW9uIFVvKGkpIHtcbiAgbGV0IGUgPSAhMDtcbiAgcmV0dXJuIEVzKGkpID8gaS5sZW5ndGggJiYgKGUgPSBpLmV2ZXJ5KCh0KSA9PiBvdCh0LCAhMSkpKSA6IGUgPSAhMSwgZTtcbn1cbmZ1bmN0aW9uIGtwKGksIGUsIHQpIHtcbiAgbGV0IHMgPSBudWxsO1xuICByZXR1cm4gRXMoZSkgJiYgZS5sZW5ndGggPyBlLmZvckVhY2goKHIpID0+IHtcbiAgICBzIHx8IEpzKHIpIHx8IChzID0gbnQoXCJVTlNVUFBPUlRFRF9DSEFJTlNcIiwgYCR7dH0sIGNoYWluICR7cn0gc2hvdWxkIGJlIGEgc3RyaW5nIGFuZCBjb25mb3JtIHRvIFwibmFtZXNwYWNlOmNoYWluSWRcIiBmb3JtYXRgKSk7XG4gIH0pIDogSnMoaSkgfHwgKHMgPSBudChcIlVOU1VQUE9SVEVEX0NIQUlOU1wiLCBgJHt0fSwgY2hhaW5zIG11c3QgYmUgZGVmaW5lZCBhcyBcIm5hbWVzcGFjZTpjaGFpbklkXCIgZS5nLiBcImVpcDE1NToxXCI6IHsuLi59IGluIHRoZSBuYW1lc3BhY2Uga2V5IE9SIGFzIGFuIGFycmF5IG9mIENBSVAtMiBjaGFpbklkcyBlLmcuIGVpcDE1NTogeyBjaGFpbnM6IFtcImVpcDE1NToxXCIsIFwiZWlwMTU1OjVcIl0gfWApKSwgcztcbn1cbmZ1bmN0aW9uIEhwKGksIGUsIHQpIHtcbiAgbGV0IHMgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoaSkuZm9yRWFjaCgoW3IsIG5dKSA9PiB7XG4gICAgaWYgKHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9IGtwKHIsIFRjKHIsIG4pLCBgJHtlfSAke3R9YCk7XG4gICAgbyAmJiAocyA9IG8pO1xuICB9KSwgcztcbn1cbmZ1bmN0aW9uIEdwKGksIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICByZXR1cm4gRXMoaSkgPyBpLmZvckVhY2goKHMpID0+IHtcbiAgICB0IHx8IGpwKHMpIHx8ICh0ID0gbnQoXCJVTlNVUFBPUlRFRF9BQ0NPVU5UU1wiLCBgJHtlfSwgYWNjb3VudCAke3N9IHNob3VsZCBiZSBhIHN0cmluZyBhbmQgY29uZm9ybSB0byBcIm5hbWVzcGFjZTpjaGFpbklkOmFkZHJlc3NcIiBmb3JtYXRgKSk7XG4gIH0pIDogdCA9IG50KFwiVU5TVVBQT1JURURfQUNDT1VOVFNcIiwgYCR7ZX0sIGFjY291bnRzIHNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIGNvbmZvcm1pbmcgdG8gXCJuYW1lc3BhY2U6Y2hhaW5JZDphZGRyZXNzXCIgZm9ybWF0YCksIHQ7XG59XG5mdW5jdGlvbiBXcChpLCBlKSB7XG4gIGxldCB0ID0gbnVsbDtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaSkuZm9yRWFjaCgocykgPT4ge1xuICAgIGlmICh0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSBHcChzPy5hY2NvdW50cywgYCR7ZX0gbmFtZXNwYWNlYCk7XG4gICAgciAmJiAodCA9IHIpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIFlwKGksIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICByZXR1cm4gVW8oaT8ubWV0aG9kcykgPyBVbyhpPy5ldmVudHMpIHx8ICh0ID0gbnQoXCJVTlNVUFBPUlRFRF9FVkVOVFNcIiwgYCR7ZX0sIGV2ZW50cyBzaG91bGQgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncyBvciBlbXB0eSBhcnJheSBmb3Igbm8gZXZlbnRzYCkpIDogdCA9IG50KFwiVU5TVVBQT1JURURfTUVUSE9EU1wiLCBgJHtlfSwgbWV0aG9kcyBzaG91bGQgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncyBvciBlbXB0eSBhcnJheSBmb3Igbm8gbWV0aG9kc2ApLCB0O1xufVxuZnVuY3Rpb24gemMoaSwgZSkge1xuICBsZXQgdCA9IG51bGw7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGkpLmZvckVhY2goKHMpID0+IHtcbiAgICBpZiAodClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gWXAocywgYCR7ZX0sIG5hbWVzcGFjZWApO1xuICAgIHIgJiYgKHQgPSByKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBKcChpLCBlLCB0KSB7XG4gIGxldCBzID0gbnVsbDtcbiAgaWYgKGkgJiYgY3MoaSkpIHtcbiAgICBjb25zdCByID0gemMoaSwgZSk7XG4gICAgciAmJiAocyA9IHIpO1xuICAgIGNvbnN0IG4gPSBIcChpLCBlLCB0KTtcbiAgICBuICYmIChzID0gbik7XG4gIH0gZWxzZVxuICAgIHMgPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGAke2V9LCAke3R9IHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBkYXRhYCk7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24genMoaSwgZSkge1xuICBsZXQgdCA9IG51bGw7XG4gIGlmIChpICYmIGNzKGkpKSB7XG4gICAgY29uc3QgcyA9IHpjKGksIGUpO1xuICAgIHMgJiYgKHQgPSBzKTtcbiAgICBjb25zdCByID0gV3AoaSwgZSk7XG4gICAgciAmJiAodCA9IHIpO1xuICB9IGVsc2VcbiAgICB0ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgJHtlfSwgbmFtZXNwYWNlcyBzaG91bGQgYmUgYW4gb2JqZWN0IHdpdGggZGF0YWApO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIEtjKGkpIHtcbiAgcmV0dXJuIG90KGkucHJvdG9jb2wsICEwKTtcbn1cbmZ1bmN0aW9uIFFwKGksIGUpIHtcbiAgbGV0IHQgPSAhMTtcbiAgcmV0dXJuIGUgJiYgIWkgPyB0ID0gITAgOiBpICYmIEVzKGkpICYmIGkubGVuZ3RoICYmIGkuZm9yRWFjaCgocykgPT4ge1xuICAgIHQgPSBLYyhzKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBYcChpKSB7XG4gIHJldHVybiB0eXBlb2YgaSA9PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gU3QoaSkge1xuICByZXR1cm4gdHlwZW9mIGkgPCBcInVcIiAmJiB0eXBlb2YgaSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIFpwKGkpIHtcbiAgcmV0dXJuICEoIWkgfHwgdHlwZW9mIGkgIT0gXCJvYmplY3RcIiB8fCAhaS5jb2RlIHx8ICFtbihpLmNvZGUsICExKSB8fCAhaS5tZXNzYWdlIHx8ICFvdChpLm1lc3NhZ2UsICExKSk7XG59XG5mdW5jdGlvbiBlZyhpKSB7XG4gIHJldHVybiAhKGJ0KGkpIHx8ICFvdChpLm1ldGhvZCwgITEpKTtcbn1cbmZ1bmN0aW9uIHRnKGkpIHtcbiAgcmV0dXJuICEoYnQoaSkgfHwgYnQoaS5yZXN1bHQpICYmIGJ0KGkuZXJyb3IpIHx8ICFtbihpLmlkLCAhMSkgfHwgIW90KGkuanNvbnJwYywgITEpKTtcbn1cbmZ1bmN0aW9uIGlnKGkpIHtcbiAgcmV0dXJuICEoYnQoaSkgfHwgIW90KGkubmFtZSwgITEpKTtcbn1cbmZ1bmN0aW9uIExvKGksIGUpIHtcbiAgcmV0dXJuICEoIUpzKGUpIHx8ICFUcChpKS5pbmNsdWRlcyhlKSk7XG59XG5mdW5jdGlvbiBzZyhpLCBlLCB0KSB7XG4gIHJldHVybiBvdCh0LCAhMSkgPyAkcChpLCBlKS5pbmNsdWRlcyh0KSA6ICExO1xufVxuZnVuY3Rpb24gcmcoaSwgZSwgdCkge1xuICByZXR1cm4gb3QodCwgITEpID8gRnAoaSwgZSkuaW5jbHVkZXModCkgOiAhMTtcbn1cbmZ1bmN0aW9uIE1vKGksIGUsIHQpIHtcbiAgbGV0IHMgPSBudWxsO1xuICBjb25zdCByID0gbmcoaSksIG4gPSBvZyhlKSwgbyA9IE9iamVjdC5rZXlzKHIpLCBjID0gT2JqZWN0LmtleXMobiksIHUgPSBxbyhPYmplY3Qua2V5cyhpKSksIGQgPSBxbyhPYmplY3Qua2V5cyhlKSksIHAgPSB1LmZpbHRlcigoYikgPT4gIWQuaW5jbHVkZXMoYikpO1xuICByZXR1cm4gcC5sZW5ndGggJiYgKHMgPSBZKFwiTk9OX0NPTkZPUk1JTkdfTkFNRVNQQUNFU1wiLCBgJHt0fSBuYW1lc3BhY2VzIGtleXMgZG9uJ3Qgc2F0aXNmeSByZXF1aXJlZE5hbWVzcGFjZXMuXG4gICAgICBSZXF1aXJlZDogJHtwLnRvU3RyaW5nKCl9XG4gICAgICBSZWNlaXZlZDogJHtPYmplY3Qua2V5cyhlKS50b1N0cmluZygpfWApKSwgX2kobywgYykgfHwgKHMgPSBZKFwiTk9OX0NPTkZPUk1JTkdfTkFNRVNQQUNFU1wiLCBgJHt0fSBuYW1lc3BhY2VzIGNoYWlucyBkb24ndCBzYXRpc2Z5IHJlcXVpcmVkIG5hbWVzcGFjZXMuXG4gICAgICBSZXF1aXJlZDogJHtvLnRvU3RyaW5nKCl9XG4gICAgICBBcHByb3ZlZDogJHtjLnRvU3RyaW5nKCl9YCkpLCBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChiKSA9PiB7XG4gICAgaWYgKCFiLmluY2x1ZGVzKFwiOlwiKSB8fCBzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHggPSBNaShlW2JdLmFjY291bnRzKTtcbiAgICB4LmluY2x1ZGVzKGIpIHx8IChzID0gWShcIk5PTl9DT05GT1JNSU5HX05BTUVTUEFDRVNcIiwgYCR7dH0gbmFtZXNwYWNlcyBhY2NvdW50cyBkb24ndCBzYXRpc2Z5IG5hbWVzcGFjZSBhY2NvdW50cyBmb3IgJHtifVxuICAgICAgICBSZXF1aXJlZDogJHtifVxuICAgICAgICBBcHByb3ZlZDogJHt4LnRvU3RyaW5nKCl9YCkpO1xuICB9KSwgby5mb3JFYWNoKChiKSA9PiB7XG4gICAgcyB8fCAoX2kocltiXS5tZXRob2RzLCBuW2JdLm1ldGhvZHMpID8gX2kocltiXS5ldmVudHMsIG5bYl0uZXZlbnRzKSB8fCAocyA9IFkoXCJOT05fQ09ORk9STUlOR19OQU1FU1BBQ0VTXCIsIGAke3R9IG5hbWVzcGFjZXMgZXZlbnRzIGRvbid0IHNhdGlzZnkgbmFtZXNwYWNlIGV2ZW50cyBmb3IgJHtifWApKSA6IHMgPSBZKFwiTk9OX0NPTkZPUk1JTkdfTkFNRVNQQUNFU1wiLCBgJHt0fSBuYW1lc3BhY2VzIG1ldGhvZHMgZG9uJ3Qgc2F0aXNmeSBuYW1lc3BhY2UgbWV0aG9kcyBmb3IgJHtifWApKTtcbiAgfSksIHM7XG59XG5mdW5jdGlvbiBuZyhpKSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGkpLmZvckVhY2goKHQpID0+IHtcbiAgICB2YXIgcztcbiAgICB0LmluY2x1ZGVzKFwiOlwiKSA/IGVbdF0gPSBpW3RdIDogKHMgPSBpW3RdLmNoYWlucykgPT0gbnVsbCB8fCBzLmZvckVhY2goKHIpID0+IHtcbiAgICAgIGVbcl0gPSB7IG1ldGhvZHM6IGlbdF0ubWV0aG9kcywgZXZlbnRzOiBpW3RdLmV2ZW50cyB9O1xuICAgIH0pO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIHFvKGkpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGkubWFwKChlKSA9PiBlLmluY2x1ZGVzKFwiOlwiKSA/IGUuc3BsaXQoXCI6XCIpWzBdIDogZSkpXTtcbn1cbmZ1bmN0aW9uIG9nKGkpIHtcbiAgY29uc3QgZSA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMoaSkuZm9yRWFjaCgodCkgPT4ge1xuICAgIHQuaW5jbHVkZXMoXCI6XCIpID8gZVt0XSA9IGlbdF0gOiBNaShpW3RdLmFjY291bnRzKT8uZm9yRWFjaCgocikgPT4ge1xuICAgICAgZVtyXSA9IHsgYWNjb3VudHM6IGlbdF0uYWNjb3VudHMuZmlsdGVyKChuKSA9PiBuLmluY2x1ZGVzKGAke3J9OmApKSwgbWV0aG9kczogaVt0XS5tZXRob2RzLCBldmVudHM6IGlbdF0uZXZlbnRzIH07XG4gICAgfSk7XG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gYWcoaSwgZSkge1xuICByZXR1cm4gbW4oaSwgITEpICYmIGkgPD0gZS5tYXggJiYgaSA+PSBlLm1pbjtcbn1cbmZ1bmN0aW9uIGpvKCkge1xuICBjb25zdCBpID0gX3MoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChlKSA9PiB7XG4gICAgc3dpdGNoIChpKSB7XG4gICAgICBjYXNlIE90LmJyb3dzZXI6XG4gICAgICAgIGUoY2coKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBPdC5yZWFjdE5hdGl2ZTpcbiAgICAgICAgZShoZygpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE90Lm5vZGU6XG4gICAgICAgIGUodWcoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZSghMCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNnKCkge1xuICByZXR1cm4gdnMoKSAmJiBuYXZpZ2F0b3I/Lm9uTGluZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhnKCkge1xuICByZXR1cm4gdXIoKSAmJiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgJiYgZ2xvYmFsICE9IG51bGwgJiYgZ2xvYmFsLk5ldEluZm8gPyAoYXdhaXQgKGdsb2JhbCA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsLk5ldEluZm8uZmV0Y2goKSkpPy5pc0Nvbm5lY3RlZCA6ICEwO1xufVxuZnVuY3Rpb24gdWcoKSB7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGxnKGkpIHtcbiAgc3dpdGNoIChfcygpKSB7XG4gICAgY2FzZSBPdC5icm93c2VyOlxuICAgICAgZGcoaSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIE90LnJlYWN0TmF0aXZlOlxuICAgICAgZmcoaSk7XG4gICAgICBicmVhaztcbiAgfVxufVxuZnVuY3Rpb24gZGcoaSkge1xuICB2cygpICYmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCAoKSA9PiBpKCEwKSksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCAoKSA9PiBpKCExKSkpO1xufVxuZnVuY3Rpb24gZmcoaSkge1xuICB1cigpICYmIHR5cGVvZiBnbG9iYWwgPCBcInVcIiAmJiBnbG9iYWwgIT0gbnVsbCAmJiBnbG9iYWwuTmV0SW5mbyAmJiBnbG9iYWw/Lk5ldEluZm8uYWRkRXZlbnRMaXN0ZW5lcigoZSkgPT4gaShlPy5pc0Nvbm5lY3RlZCkpO1xufVxuY29uc3QgeHIgPSB7fTtcbmxldCAkcyA9IGNsYXNzIHtcbiAgc3RhdGljIGdldChlKSB7XG4gICAgcmV0dXJuIHhyW2VdO1xuICB9XG4gIHN0YXRpYyBzZXQoZSwgdCkge1xuICAgIHhyW2VdID0gdDtcbiAgfVxuICBzdGF0aWMgZGVsZXRlKGUpIHtcbiAgICBkZWxldGUgeHJbZV07XG4gIH1cbn07XG5jb25zdCBwZyA9IFwiUEFSU0VfRVJST1JcIiwgZ2cgPSBcIklOVkFMSURfUkVRVUVTVFwiLCB5ZyA9IFwiTUVUSE9EX05PVF9GT1VORFwiLCBtZyA9IFwiSU5WQUxJRF9QQVJBTVNcIiwgVmMgPSBcIklOVEVSTkFMX0VSUk9SXCIsIGJuID0gXCJTRVJWRVJfRVJST1JcIiwgYmcgPSBbLTMyNzAwLCAtMzI2MDAsIC0zMjYwMSwgLTMyNjAyLCAtMzI2MDNdLCBocyA9IHtcbiAgW3BnXTogeyBjb2RlOiAtMzI3MDAsIG1lc3NhZ2U6IFwiUGFyc2UgZXJyb3JcIiB9LFxuICBbZ2ddOiB7IGNvZGU6IC0zMjYwMCwgbWVzc2FnZTogXCJJbnZhbGlkIFJlcXVlc3RcIiB9LFxuICBbeWddOiB7IGNvZGU6IC0zMjYwMSwgbWVzc2FnZTogXCJNZXRob2Qgbm90IGZvdW5kXCIgfSxcbiAgW21nXTogeyBjb2RlOiAtMzI2MDIsIG1lc3NhZ2U6IFwiSW52YWxpZCBwYXJhbXNcIiB9LFxuICBbVmNdOiB7IGNvZGU6IC0zMjYwMywgbWVzc2FnZTogXCJJbnRlcm5hbCBlcnJvclwiIH0sXG4gIFtibl06IHsgY29kZTogLTMyZTMsIG1lc3NhZ2U6IFwiU2VydmVyIGVycm9yXCIgfVxufSwgQmMgPSBibjtcbmZ1bmN0aW9uIHdnKGkpIHtcbiAgcmV0dXJuIGJnLmluY2x1ZGVzKGkpO1xufVxuZnVuY3Rpb24gem8oaSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaHMpLmluY2x1ZGVzKGkpID8gaHNbaV0gOiBoc1tCY107XG59XG5mdW5jdGlvbiB2ZyhpKSB7XG4gIGNvbnN0IGUgPSBPYmplY3QudmFsdWVzKGhzKS5maW5kKCh0KSA9PiB0LmNvZGUgPT09IGkpO1xuICByZXR1cm4gZSB8fCBoc1tCY107XG59XG5mdW5jdGlvbiBfZyhpLCBlLCB0KSB7XG4gIHJldHVybiBpLm1lc3NhZ2UuaW5jbHVkZXMoXCJnZXRhZGRyaW5mbyBFTk9URk9VTkRcIikgfHwgaS5tZXNzYWdlLmluY2x1ZGVzKFwiY29ubmVjdCBFQ09OTlJFRlVTRURcIikgPyBuZXcgRXJyb3IoYFVuYXZhaWxhYmxlICR7dH0gUlBDIHVybCBhdCAke2V9YCkgOiBpO1xufVxudmFyIGtjID0ge30sIFF0ID0ge30sIEtvO1xuZnVuY3Rpb24gRWcoKSB7XG4gIGlmIChLbylcbiAgICByZXR1cm4gUXQ7XG4gIEtvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFF0LmlzQnJvd3NlckNyeXB0b0F2YWlsYWJsZSA9IFF0LmdldFN1YnRsZUNyeXB0byA9IFF0LmdldEJyb3dlckNyeXB0byA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gaSgpIHtcbiAgICByZXR1cm4gKG10ID09PSBudWxsIHx8IG10ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtdC5jcnlwdG8pIHx8IChtdCA9PT0gbnVsbCB8fCBtdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXQubXNDcnlwdG8pIHx8IHt9O1xuICB9XG4gIFF0LmdldEJyb3dlckNyeXB0byA9IGk7XG4gIGZ1bmN0aW9uIGUoKSB7XG4gICAgY29uc3QgcyA9IGkoKTtcbiAgICByZXR1cm4gcy5zdWJ0bGUgfHwgcy53ZWJraXRTdWJ0bGU7XG4gIH1cbiAgUXQuZ2V0U3VidGxlQ3J5cHRvID0gZTtcbiAgZnVuY3Rpb24gdCgpIHtcbiAgICByZXR1cm4gISFpKCkgJiYgISFlKCk7XG4gIH1cbiAgcmV0dXJuIFF0LmlzQnJvd3NlckNyeXB0b0F2YWlsYWJsZSA9IHQsIFF0O1xufVxudmFyIFh0ID0ge30sIFZvO1xuZnVuY3Rpb24gU2coKSB7XG4gIGlmIChWbylcbiAgICByZXR1cm4gWHQ7XG4gIFZvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFh0LmlzQnJvd3NlciA9IFh0LmlzTm9kZSA9IFh0LmlzUmVhY3ROYXRpdmUgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIGkoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCA+IFwidVwiICYmIHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiO1xuICB9XG4gIFh0LmlzUmVhY3ROYXRpdmUgPSBpO1xuICBmdW5jdGlvbiBlKCkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvY2VzcyA8IFwidVwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zIDwgXCJ1XCIgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSA8IFwidVwiO1xuICB9XG4gIFh0LmlzTm9kZSA9IGU7XG4gIGZ1bmN0aW9uIHQoKSB7XG4gICAgcmV0dXJuICFpKCkgJiYgIWUoKTtcbiAgfVxuICByZXR1cm4gWHQuaXNCcm93c2VyID0gdCwgWHQ7XG59XG4oZnVuY3Rpb24oaSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICBjb25zdCBlID0gRnQ7XG4gIGUuX19leHBvcnRTdGFyKEVnKCksIGkpLCBlLl9fZXhwb3J0U3RhcihTZygpLCBpKTtcbn0pKGtjKTtcbmZ1bmN0aW9uIHduKGkgPSAzKSB7XG4gIGNvbnN0IGUgPSBEYXRlLm5vdygpICogTWF0aC5wb3coMTAsIGkpLCB0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMTAsIGkpKTtcbiAgcmV0dXJuIGUgKyB0O1xufVxuZnVuY3Rpb24gdm4oaSA9IDYpIHtcbiAgcmV0dXJuIEJpZ0ludCh3bihpKSk7XG59XG5mdW5jdGlvbiB0aShpLCBlLCB0KSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IHQgfHwgd24oKSxcbiAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgIG1ldGhvZDogaSxcbiAgICBwYXJhbXM6IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHhpKGksIGUpIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogaSxcbiAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgIHJlc3VsdDogZVxuICB9O1xufVxuZnVuY3Rpb24gcWkoaSwgZSwgdCkge1xuICByZXR1cm4ge1xuICAgIGlkOiBpLFxuICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgZXJyb3I6IElnKGUsIHQpXG4gIH07XG59XG5mdW5jdGlvbiBJZyhpLCBlKSB7XG4gIHJldHVybiB0eXBlb2YgaSA+IFwidVwiID8gem8oVmMpIDogKHR5cGVvZiBpID09IFwic3RyaW5nXCIgJiYgKGkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHpvKGJuKSksIHsgbWVzc2FnZTogaSB9KSksIHR5cGVvZiBlIDwgXCJ1XCIgJiYgKGkuZGF0YSA9IGUpLCB3ZyhpLmNvZGUpICYmIChpID0gdmcoaS5jb2RlKSksIGkpO1xufVxuY2xhc3MgSGMge1xufVxuY2xhc3MgRGcgZXh0ZW5kcyBIYyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpO1xuICB9XG59XG5jbGFzcyB4ZyBleHRlbmRzIEhjIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufVxuY2xhc3MgT2cgZXh0ZW5kcyB4ZyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpO1xuICB9XG59XG5jb25zdCBOZyA9IFwiXndzcz86XCI7XG5mdW5jdGlvbiBQZyhpKSB7XG4gIGNvbnN0IGUgPSBpLm1hdGNoKG5ldyBSZWdFeHAoL15cXHcrOi8sIFwiZ2lcIikpO1xuICBpZiAoISghZSB8fCAhZS5sZW5ndGgpKVxuICAgIHJldHVybiBlWzBdO1xufVxuZnVuY3Rpb24gUmcoaSwgZSkge1xuICBjb25zdCB0ID0gUGcoaSk7XG4gIHJldHVybiB0eXBlb2YgdCA+IFwidVwiID8gITEgOiBuZXcgUmVnRXhwKGUpLnRlc3QodCk7XG59XG5mdW5jdGlvbiBCbyhpKSB7XG4gIHJldHVybiBSZyhpLCBOZyk7XG59XG5mdW5jdGlvbiBDZyhpKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwid3NzPzovL2xvY2FsaG9zdCg6ZHsyLDV9KT9cIikudGVzdChpKTtcbn1cbmZ1bmN0aW9uIEdjKGkpIHtcbiAgcmV0dXJuIHR5cGVvZiBpID09IFwib2JqZWN0XCIgJiYgXCJpZFwiIGluIGkgJiYgXCJqc29ucnBjXCIgaW4gaSAmJiBpLmpzb25ycGMgPT09IFwiMi4wXCI7XG59XG5mdW5jdGlvbiBqaShpKSB7XG4gIHJldHVybiBHYyhpKSAmJiBcIm1ldGhvZFwiIGluIGk7XG59XG5mdW5jdGlvbiBPaShpKSB7XG4gIHJldHVybiBHYyhpKSAmJiAoaHQoaSkgfHwgR2UoaSkpO1xufVxuZnVuY3Rpb24gaHQoaSkge1xuICByZXR1cm4gXCJyZXN1bHRcIiBpbiBpO1xufVxuZnVuY3Rpb24gR2UoaSkge1xuICByZXR1cm4gXCJlcnJvclwiIGluIGk7XG59XG5jbGFzcyBfbiBleHRlbmRzIE9nIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5oYXNSZWdpc3RlcmVkRXZlbnRMaXN0ZW5lcnMgPSAhMSwgdGhpcy5jb25uZWN0aW9uID0gdGhpcy5zZXRDb25uZWN0aW9uKGUpLCB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdGVkICYmIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoZSA9IHRoaXMuY29ubmVjdGlvbikge1xuICAgIGF3YWl0IHRoaXMub3BlbihlKTtcbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIGF3YWl0IHRoaXMuY2xvc2UoKTtcbiAgfVxuICBvbihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMub24oZSwgdCk7XG4gIH1cbiAgb25jZShlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMub25jZShlLCB0KTtcbiAgfVxuICBvZmYoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9mZihlLCB0KTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIoZSwgdCk7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFN0cmljdCh0aShlLm1ldGhvZCwgZS5wYXJhbXMgfHwgW10sIGUuaWQgfHwgdm4oKS50b1N0cmluZygpKSwgdCk7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdFN0cmljdChlLCB0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChzLCByKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuY29ubmVjdGlvbi5jb25uZWN0ZWQpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5vcGVuKCk7XG4gICAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgICByKG4pO1xuICAgICAgICB9XG4gICAgICB0aGlzLmV2ZW50cy5vbihgJHtlLmlkfWAsIChuKSA9PiB7XG4gICAgICAgIEdlKG4pID8gcihuLmVycm9yKSA6IHMobi5yZXN1bHQpO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZChlLCB0KTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgcihuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZXRDb25uZWN0aW9uKGUgPSB0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBvblBheWxvYWQoZSkge1xuICAgIHRoaXMuZXZlbnRzLmVtaXQoXCJwYXlsb2FkXCIsIGUpLCBPaShlKSA/IHRoaXMuZXZlbnRzLmVtaXQoYCR7ZS5pZH1gLCBlKSA6IHRoaXMuZXZlbnRzLmVtaXQoXCJtZXNzYWdlXCIsIHtcbiAgICAgIHR5cGU6IGUubWV0aG9kLFxuICAgICAgZGF0YTogZS5wYXJhbXNcbiAgICB9KTtcbiAgfVxuICBvbkNsb3NlKGUpIHtcbiAgICBlICYmIGUuY29kZSA9PT0gM2UzICYmIHRoaXMuZXZlbnRzLmVtaXQoXCJlcnJvclwiLCBuZXcgRXJyb3IoYFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlZCBhYm5vcm1hbGx5IHdpdGggY29kZTogJHtlLmNvZGV9ICR7ZS5yZWFzb24gPyBgKCR7ZS5yZWFzb259KWAgOiBcIlwifWApKSwgdGhpcy5ldmVudHMuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gIH1cbiAgYXN5bmMgb3BlbihlID0gdGhpcy5jb25uZWN0aW9uKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uID09PSBlICYmIHRoaXMuY29ubmVjdGlvbi5jb25uZWN0ZWQgfHwgKHRoaXMuY29ubmVjdGlvbi5jb25uZWN0ZWQgJiYgdGhpcy5jbG9zZSgpLCB0eXBlb2YgZSA9PSBcInN0cmluZ1wiICYmIChhd2FpdCB0aGlzLmNvbm5lY3Rpb24ub3BlbihlKSwgZSA9IHRoaXMuY29ubmVjdGlvbiksIHRoaXMuY29ubmVjdGlvbiA9IHRoaXMuc2V0Q29ubmVjdGlvbihlKSwgYXdhaXQgdGhpcy5jb25uZWN0aW9uLm9wZW4oKSwgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCksIHRoaXMuZXZlbnRzLmVtaXQoXCJjb25uZWN0XCIpKTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgfVxuICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGFzUmVnaXN0ZXJlZEV2ZW50TGlzdGVuZXJzIHx8ICh0aGlzLmNvbm5lY3Rpb24ub24oXCJwYXlsb2FkXCIsIChlKSA9PiB0aGlzLm9uUGF5bG9hZChlKSksIHRoaXMuY29ubmVjdGlvbi5vbihcImNsb3NlXCIsIChlKSA9PiB0aGlzLm9uQ2xvc2UoZSkpLCB0aGlzLmNvbm5lY3Rpb24ub24oXCJlcnJvclwiLCAoZSkgPT4gdGhpcy5ldmVudHMuZW1pdChcImVycm9yXCIsIGUpKSwgdGhpcy5jb25uZWN0aW9uLm9uKFwicmVnaXN0ZXJfZXJyb3JcIiwgKGUpID0+IHRoaXMub25DbG9zZSgpKSwgdGhpcy5oYXNSZWdpc3RlcmVkRXZlbnRMaXN0ZW5lcnMgPSAhMCk7XG4gIH1cbn1cbmNvbnN0IEFnID0gKCkgPT4gdHlwZW9mIFdlYlNvY2tldCA8IFwidVwiID8gV2ViU29ja2V0IDogdHlwZW9mIGdsb2JhbCA8IFwidVwiICYmIHR5cGVvZiBnbG9iYWwuV2ViU29ja2V0IDwgXCJ1XCIgPyBnbG9iYWwuV2ViU29ja2V0IDogdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHR5cGVvZiB3aW5kb3cuV2ViU29ja2V0IDwgXCJ1XCIgPyB3aW5kb3cuV2ViU29ja2V0IDogdHlwZW9mIHNlbGYgPCBcInVcIiAmJiB0eXBlb2Ygc2VsZi5XZWJTb2NrZXQgPCBcInVcIiA/IHNlbGYuV2ViU29ja2V0IDogcmVxdWlyZShcIndzXCIpLCBUZyA9ICgpID0+IHR5cGVvZiBXZWJTb2NrZXQgPCBcInVcIiB8fCB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgJiYgdHlwZW9mIGdsb2JhbC5XZWJTb2NrZXQgPCBcInVcIiB8fCB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgdHlwZW9mIHdpbmRvdy5XZWJTb2NrZXQgPCBcInVcIiB8fCB0eXBlb2Ygc2VsZiA8IFwidVwiICYmIHR5cGVvZiBzZWxmLldlYlNvY2tldCA8IFwidVwiLCBrbyA9IChpKSA9PiBpLnNwbGl0KFwiP1wiKVswXSwgSG8gPSAxMCwgJGcgPSBBZygpO1xuY2xhc3MgV2Mge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgaWYgKHRoaXMudXJsID0gZSwgdGhpcy5ldmVudHMgPSBuZXcgV2UuRXZlbnRFbWl0dGVyKCksIHRoaXMucmVnaXN0ZXJpbmcgPSAhMSwgIUJvKGUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm92aWRlZCBVUkwgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBXZWJTb2NrZXQgY29ubmVjdGlvbjogJHtlfWApO1xuICAgIHRoaXMudXJsID0gZTtcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5zb2NrZXQgPCBcInVcIjtcbiAgfVxuICBnZXQgY29ubmVjdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmluZztcbiAgfVxuICBvbihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMub24oZSwgdCk7XG4gIH1cbiAgb25jZShlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMub25jZShlLCB0KTtcbiAgfVxuICBvZmYoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9mZihlLCB0KTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIoZSwgdCk7XG4gIH1cbiAgYXN5bmMgb3BlbihlID0gdGhpcy51cmwpIHtcbiAgICBhd2FpdCB0aGlzLnJlZ2lzdGVyKGUpO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZSwgdCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNvY2tldCA+IFwidVwiKSB7XG4gICAgICAgIHQobmV3IEVycm9yKFwiQ29ubmVjdGlvbiBhbHJlYWR5IGNsb3NlZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSAocykgPT4ge1xuICAgICAgICB0aGlzLm9uQ2xvc2UocyksIGUoKTtcbiAgICAgIH0sIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc2VuZChlLCB0KSB7XG4gICAgdHlwZW9mIHRoaXMuc29ja2V0ID4gXCJ1XCIgJiYgKHRoaXMuc29ja2V0ID0gYXdhaXQgdGhpcy5yZWdpc3RlcigpKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zb2NrZXQuc2VuZChycihlKSk7XG4gICAgfSBjYXRjaCAocykge1xuICAgICAgdGhpcy5vbkVycm9yKGUuaWQsIHMpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlcihlID0gdGhpcy51cmwpIHtcbiAgICBpZiAoIUJvKGUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm92aWRlZCBVUkwgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBXZWJTb2NrZXQgY29ubmVjdGlvbjogJHtlfWApO1xuICAgIGlmICh0aGlzLnJlZ2lzdGVyaW5nKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5ldmVudHMuZ2V0TWF4TGlzdGVuZXJzKCk7XG4gICAgICByZXR1cm4gKHRoaXMuZXZlbnRzLmxpc3RlbmVyQ291bnQoXCJyZWdpc3Rlcl9lcnJvclwiKSA+PSB0IHx8IHRoaXMuZXZlbnRzLmxpc3RlbmVyQ291bnQoXCJvcGVuXCIpID49IHQpICYmIHRoaXMuZXZlbnRzLnNldE1heExpc3RlbmVycyh0ICsgMSksIG5ldyBQcm9taXNlKChzLCByKSA9PiB7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uY2UoXCJyZWdpc3Rlcl9lcnJvclwiLCAobikgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRNYXhMaXN0ZW5lcnMoKSwgcihuKTtcbiAgICAgICAgfSksIHRoaXMuZXZlbnRzLm9uY2UoXCJvcGVuXCIsICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5yZXNldE1heExpc3RlbmVycygpLCB0eXBlb2YgdGhpcy5zb2NrZXQgPiBcInVcIilcbiAgICAgICAgICAgIHJldHVybiByKG5ldyBFcnJvcihcIldlYlNvY2tldCBjb25uZWN0aW9uIGlzIG1pc3Npbmcgb3IgaW52YWxpZFwiKSk7XG4gICAgICAgICAgcyh0aGlzLnNvY2tldCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVybCA9IGUsIHRoaXMucmVnaXN0ZXJpbmcgPSAhMCwgbmV3IFByb21pc2UoKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBrYy5pc1JlYWN0TmF0aXZlKCkgPyB2b2lkIDAgOiB7IHJlamVjdFVuYXV0aG9yaXplZDogIUNnKGUpIH0sIG4gPSBuZXcgJGcoZSwgW10sIHIpO1xuICAgICAgVGcoKSA/IG4ub25lcnJvciA9IChvKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBvO1xuICAgICAgICBzKHRoaXMuZW1pdEVycm9yKGMuZXJyb3IpKTtcbiAgICAgIH0gOiBuLm9uKFwiZXJyb3JcIiwgKG8pID0+IHtcbiAgICAgICAgcyh0aGlzLmVtaXRFcnJvcihvKSk7XG4gICAgICB9KSwgbi5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub25PcGVuKG4pLCB0KG4pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBvbk9wZW4oZSkge1xuICAgIGUub25tZXNzYWdlID0gKHQpID0+IHRoaXMub25QYXlsb2FkKHQpLCBlLm9uY2xvc2UgPSAodCkgPT4gdGhpcy5vbkNsb3NlKHQpLCB0aGlzLnNvY2tldCA9IGUsIHRoaXMucmVnaXN0ZXJpbmcgPSAhMSwgdGhpcy5ldmVudHMuZW1pdChcIm9wZW5cIik7XG4gIH1cbiAgb25DbG9zZShlKSB7XG4gICAgdGhpcy5zb2NrZXQgPSB2b2lkIDAsIHRoaXMucmVnaXN0ZXJpbmcgPSAhMSwgdGhpcy5ldmVudHMuZW1pdChcImNsb3NlXCIsIGUpO1xuICB9XG4gIG9uUGF5bG9hZChlKSB7XG4gICAgaWYgKHR5cGVvZiBlLmRhdGEgPiBcInVcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGUuZGF0YSA9PSBcInN0cmluZ1wiID8gcm4oZS5kYXRhKSA6IGUuZGF0YTtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KFwicGF5bG9hZFwiLCB0KTtcbiAgfVxuICBvbkVycm9yKGUsIHQpIHtcbiAgICBjb25zdCBzID0gdGhpcy5wYXJzZUVycm9yKHQpLCByID0gcy5tZXNzYWdlIHx8IHMudG9TdHJpbmcoKSwgbiA9IHFpKGUsIHIpO1xuICAgIHRoaXMuZXZlbnRzLmVtaXQoXCJwYXlsb2FkXCIsIG4pO1xuICB9XG4gIHBhcnNlRXJyb3IoZSwgdCA9IHRoaXMudXJsKSB7XG4gICAgcmV0dXJuIF9nKGUsIGtvKHQpLCBcIldTXCIpO1xuICB9XG4gIHJlc2V0TWF4TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZXZlbnRzLmdldE1heExpc3RlbmVycygpID4gSG8gJiYgdGhpcy5ldmVudHMuc2V0TWF4TGlzdGVuZXJzKEhvKTtcbiAgfVxuICBlbWl0RXJyb3IoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnBhcnNlRXJyb3IobmV3IEVycm9yKGU/Lm1lc3NhZ2UgfHwgYFdlYlNvY2tldCBjb25uZWN0aW9uIGZhaWxlZCBmb3IgaG9zdDogJHtrbyh0aGlzLnVybCl9YCkpO1xuICAgIHJldHVybiB0aGlzLmV2ZW50cy5lbWl0KFwicmVnaXN0ZXJfZXJyb3JcIiwgdCksIHQ7XG4gIH1cbn1cbnZhciBRcyA9IHsgZXhwb3J0czoge30gfTtcblFzLmV4cG9ydHM7XG4oZnVuY3Rpb24oaSwgZSkge1xuICB2YXIgdCA9IDIwMCwgcyA9IFwiX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfX1wiLCByID0gMSwgbiA9IDIsIG8gPSA5MDA3MTk5MjU0NzQwOTkxLCBjID0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIiwgdSA9IFwiW29iamVjdCBBcnJheV1cIiwgZCA9IFwiW29iamVjdCBBc3luY0Z1bmN0aW9uXVwiLCBwID0gXCJbb2JqZWN0IEJvb2xlYW5dXCIsIGIgPSBcIltvYmplY3QgRGF0ZV1cIiwgeCA9IFwiW29iamVjdCBFcnJvcl1cIiwgTyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIiwgXyA9IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiwgQyA9IFwiW29iamVjdCBNYXBdXCIsIEYgPSBcIltvYmplY3QgTnVtYmVyXVwiLCBLID0gXCJbb2JqZWN0IE51bGxdXCIsIEkgPSBcIltvYmplY3QgT2JqZWN0XVwiLCBEID0gXCJbb2JqZWN0IFByb21pc2VdXCIsIHkgPSBcIltvYmplY3QgUHJveHldXCIsIHcgPSBcIltvYmplY3QgUmVnRXhwXVwiLCBmID0gXCJbb2JqZWN0IFNldF1cIiwgYSA9IFwiW29iamVjdCBTdHJpbmddXCIsIGwgPSBcIltvYmplY3QgU3ltYm9sXVwiLCBMID0gXCJbb2JqZWN0IFVuZGVmaW5lZF1cIiwgdiA9IFwiW29iamVjdCBXZWFrTWFwXVwiLCBSID0gXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiLCAkID0gXCJbb2JqZWN0IERhdGFWaWV3XVwiLCBxID0gXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIiwgbSA9IFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCIsIEUgPSBcIltvYmplY3QgSW50OEFycmF5XVwiLCBCID0gXCJbb2JqZWN0IEludDE2QXJyYXldXCIsIHogPSBcIltvYmplY3QgSW50MzJBcnJheV1cIiwgaiA9IFwiW29iamVjdCBVaW50OEFycmF5XVwiLCBVID0gXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiLCBNID0gXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiLCBIID0gXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiLCB0ZSA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgRyA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC8sIGllID0gL14oPzowfFsxLTldXFxkKikkLywgUSA9IHt9O1xuICBRW3FdID0gUVttXSA9IFFbRV0gPSBRW0JdID0gUVt6XSA9IFFbal0gPSBRW1VdID0gUVtNXSA9IFFbSF0gPSAhMCwgUVtjXSA9IFFbdV0gPSBRW1JdID0gUVtwXSA9IFFbJF0gPSBRW2JdID0gUVt4XSA9IFFbT10gPSBRW0NdID0gUVtGXSA9IFFbSV0gPSBRW3ddID0gUVtmXSA9IFFbYV0gPSBRW3ZdID0gITE7XG4gIHZhciBzZSA9IHR5cGVvZiBtdCA9PSBcIm9iamVjdFwiICYmIG10ICYmIG10Lk9iamVjdCA9PT0gT2JqZWN0ICYmIG10LCBUID0gdHlwZW9mIHNlbGYgPT0gXCJvYmplY3RcIiAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZiwgQSA9IHNlIHx8IFQgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpLCBOID0gZSAmJiAhZS5ub2RlVHlwZSAmJiBlLCBoID0gTiAmJiAhMCAmJiBpICYmICFpLm5vZGVUeXBlICYmIGksIFMgPSBoICYmIGguZXhwb3J0cyA9PT0gTiwgVyA9IFMgJiYgc2UucHJvY2VzcywgWCA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gVyAmJiBXLmJpbmRpbmcgJiYgVy5iaW5kaW5nKFwidXRpbFwiKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH0oKSwgZmUgPSBYICYmIFguaXNUeXBlZEFycmF5O1xuICBmdW5jdGlvbiB2ZShnLCBQKSB7XG4gICAgZm9yICh2YXIgayA9IC0xLCBaID0gZyA9PSBudWxsID8gMCA6IGcubGVuZ3RoLCBSZSA9IDAsIGFlID0gW107ICsrayA8IFo7ICkge1xuICAgICAgdmFyIExlID0gZ1trXTtcbiAgICAgIFAoTGUsIGssIGcpICYmIChhZVtSZSsrXSA9IExlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFlO1xuICB9XG4gIGZ1bmN0aW9uIGdlKGcsIFApIHtcbiAgICBmb3IgKHZhciBrID0gLTEsIFogPSBQLmxlbmd0aCwgUmUgPSBnLmxlbmd0aDsgKytrIDwgWjsgKVxuICAgICAgZ1tSZSArIGtdID0gUFtrXTtcbiAgICByZXR1cm4gZztcbiAgfVxuICBmdW5jdGlvbiBTZShnLCBQKSB7XG4gICAgZm9yICh2YXIgayA9IC0xLCBaID0gZyA9PSBudWxsID8gMCA6IGcubGVuZ3RoOyArK2sgPCBaOyApXG4gICAgICBpZiAoUChnW2tdLCBrLCBnKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBmdW5jdGlvbiBNZShnLCBQKSB7XG4gICAgZm9yICh2YXIgayA9IC0xLCBaID0gQXJyYXkoZyk7ICsrayA8IGc7IClcbiAgICAgIFpba10gPSBQKGspO1xuICAgIHJldHVybiBaO1xuICB9XG4gIGZ1bmN0aW9uICRlKGcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oUCkge1xuICAgICAgcmV0dXJuIGcoUCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBiZShnLCBQKSB7XG4gICAgcmV0dXJuIGcuaGFzKFApO1xuICB9XG4gIGZ1bmN0aW9uIHllKGcsIFApIHtcbiAgICByZXR1cm4gZz8uW1BdO1xuICB9XG4gIGZ1bmN0aW9uIHBlKGcpIHtcbiAgICB2YXIgUCA9IC0xLCBrID0gQXJyYXkoZy5zaXplKTtcbiAgICByZXR1cm4gZy5mb3JFYWNoKGZ1bmN0aW9uKFosIFJlKSB7XG4gICAgICBrWysrUF0gPSBbUmUsIFpdO1xuICAgIH0pLCBrO1xuICB9XG4gIGZ1bmN0aW9uIGxlKGcsIFApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oaykge1xuICAgICAgcmV0dXJuIGcoUChrKSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1ZShnKSB7XG4gICAgdmFyIFAgPSAtMSwgayA9IEFycmF5KGcuc2l6ZSk7XG4gICAgcmV0dXJuIGcuZm9yRWFjaChmdW5jdGlvbihaKSB7XG4gICAgICBrWysrUF0gPSBaO1xuICAgIH0pLCBrO1xuICB9XG4gIHZhciBoZSA9IEFycmF5LnByb3RvdHlwZSwgY2UgPSBGdW5jdGlvbi5wcm90b3R5cGUsIHJlID0gT2JqZWN0LnByb3RvdHlwZSwgZGUgPSBBW1wiX19jb3JlLWpzX3NoYXJlZF9fXCJdLCBtZSA9IGNlLnRvU3RyaW5nLCBuZSA9IHJlLmhhc093blByb3BlcnR5LCBfZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnID0gL1teLl0rJC8uZXhlYyhkZSAmJiBkZS5rZXlzICYmIGRlLmtleXMuSUVfUFJPVE8gfHwgXCJcIik7XG4gICAgcmV0dXJuIGcgPyBcIlN5bWJvbChzcmMpXzEuXCIgKyBnIDogXCJcIjtcbiAgfSgpLCBFZSA9IHJlLnRvU3RyaW5nLCBEZSA9IFJlZ0V4cChcbiAgICBcIl5cIiArIG1lLmNhbGwobmUpLnJlcGxhY2UodGUsIFwiXFxcXCQmXCIpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csIFwiJDEuKj9cIikgKyBcIiRcIlxuICApLCB4ZSA9IFMgPyBBLkJ1ZmZlciA6IHZvaWQgMCwgSWUgPSBBLlN5bWJvbCwgVXQgPSBBLlVpbnQ4QXJyYXksIHF0ID0gcmUucHJvcGVydHlJc0VudW1lcmFibGUsIHNpID0gaGUuc3BsaWNlLCBEdCA9IEllID8gSWUudG9TdHJpbmdUYWcgOiB2b2lkIDAsIGZpID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgS2kgPSB4ZSA/IHhlLmlzQnVmZmVyIDogdm9pZCAwLCBPcyA9IGxlKE9iamVjdC5rZXlzLCBPYmplY3QpLCBxZSA9IFBpKEEsIFwiRGF0YVZpZXdcIiksIEZlID0gUGkoQSwgXCJNYXBcIiksIGplID0gUGkoQSwgXCJQcm9taXNlXCIpLCB6ZSA9IFBpKEEsIFwiU2V0XCIpLCBLZSA9IFBpKEEsIFwiV2Vha01hcFwiKSwgVWUgPSBQaShPYmplY3QsIFwiY3JlYXRlXCIpLCBRZSA9IGdpKHFlKSwgWGUgPSBnaShGZSksIFplID0gZ2koamUpLCBldCA9IGdpKHplKSwgdHQgPSBnaShLZSksIFllID0gSWUgPyBJZS5wcm90b3R5cGUgOiB2b2lkIDAsIFZlID0gWWUgPyBZZS52YWx1ZU9mIDogdm9pZCAwO1xuICBmdW5jdGlvbiBBZShnKSB7XG4gICAgdmFyIFAgPSAtMSwgayA9IGcgPT0gbnVsbCA/IDAgOiBnLmxlbmd0aDtcbiAgICBmb3IgKHRoaXMuY2xlYXIoKTsgKytQIDwgazsgKSB7XG4gICAgICB2YXIgWiA9IGdbUF07XG4gICAgICB0aGlzLnNldChaWzBdLCBaWzFdKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXQoKSB7XG4gICAgdGhpcy5fX2RhdGFfXyA9IFVlID8gVWUobnVsbCkgOiB7fSwgdGhpcy5zaXplID0gMDtcbiAgfVxuICBmdW5jdGlvbiBzdChnKSB7XG4gICAgdmFyIFAgPSB0aGlzLmhhcyhnKSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1tnXTtcbiAgICByZXR1cm4gdGhpcy5zaXplIC09IFAgPyAxIDogMCwgUDtcbiAgfVxuICBmdW5jdGlvbiBraChnKSB7XG4gICAgdmFyIFAgPSB0aGlzLl9fZGF0YV9fO1xuICAgIGlmIChVZSkge1xuICAgICAgdmFyIGsgPSBQW2ddO1xuICAgICAgcmV0dXJuIGsgPT09IHMgPyB2b2lkIDAgOiBrO1xuICAgIH1cbiAgICByZXR1cm4gbmUuY2FsbChQLCBnKSA/IFBbZ10gOiB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gSGgoZykge1xuICAgIHZhciBQID0gdGhpcy5fX2RhdGFfXztcbiAgICByZXR1cm4gVWUgPyBQW2ddICE9PSB2b2lkIDAgOiBuZS5jYWxsKFAsIGcpO1xuICB9XG4gIGZ1bmN0aW9uIEdoKGcsIFApIHtcbiAgICB2YXIgayA9IHRoaXMuX19kYXRhX187XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhnKSA/IDAgOiAxLCBrW2ddID0gVWUgJiYgUCA9PT0gdm9pZCAwID8gcyA6IFAsIHRoaXM7XG4gIH1cbiAgQWUucHJvdG90eXBlLmNsZWFyID0gaXQsIEFlLnByb3RvdHlwZS5kZWxldGUgPSBzdCwgQWUucHJvdG90eXBlLmdldCA9IGtoLCBBZS5wcm90b3R5cGUuaGFzID0gSGgsIEFlLnByb3RvdHlwZS5zZXQgPSBHaDtcbiAgZnVuY3Rpb24gWXQoZykge1xuICAgIHZhciBQID0gLTEsIGsgPSBnID09IG51bGwgPyAwIDogZy5sZW5ndGg7XG4gICAgZm9yICh0aGlzLmNsZWFyKCk7ICsrUCA8IGs7ICkge1xuICAgICAgdmFyIFogPSBnW1BdO1xuICAgICAgdGhpcy5zZXQoWlswXSwgWlsxXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFdoKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBbXSwgdGhpcy5zaXplID0gMDtcbiAgfVxuICBmdW5jdGlvbiBZaChnKSB7XG4gICAgdmFyIFAgPSB0aGlzLl9fZGF0YV9fLCBrID0gUHMoUCwgZyk7XG4gICAgaWYgKGsgPCAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIHZhciBaID0gUC5sZW5ndGggLSAxO1xuICAgIHJldHVybiBrID09IFogPyBQLnBvcCgpIDogc2kuY2FsbChQLCBrLCAxKSwgLS10aGlzLnNpemUsICEwO1xuICB9XG4gIGZ1bmN0aW9uIEpoKGcpIHtcbiAgICB2YXIgUCA9IHRoaXMuX19kYXRhX18sIGsgPSBQcyhQLCBnKTtcbiAgICByZXR1cm4gayA8IDAgPyB2b2lkIDAgOiBQW2tdWzFdO1xuICB9XG4gIGZ1bmN0aW9uIFFoKGcpIHtcbiAgICByZXR1cm4gUHModGhpcy5fX2RhdGFfXywgZykgPiAtMTtcbiAgfVxuICBmdW5jdGlvbiBYaChnLCBQKSB7XG4gICAgdmFyIGsgPSB0aGlzLl9fZGF0YV9fLCBaID0gUHMoaywgZyk7XG4gICAgcmV0dXJuIFogPCAwID8gKCsrdGhpcy5zaXplLCBrLnB1c2goW2csIFBdKSkgOiBrW1pdWzFdID0gUCwgdGhpcztcbiAgfVxuICBZdC5wcm90b3R5cGUuY2xlYXIgPSBXaCwgWXQucHJvdG90eXBlLmRlbGV0ZSA9IFloLCBZdC5wcm90b3R5cGUuZ2V0ID0gSmgsIFl0LnByb3RvdHlwZS5oYXMgPSBRaCwgWXQucHJvdG90eXBlLnNldCA9IFhoO1xuICBmdW5jdGlvbiBwaShnKSB7XG4gICAgdmFyIFAgPSAtMSwgayA9IGcgPT0gbnVsbCA/IDAgOiBnLmxlbmd0aDtcbiAgICBmb3IgKHRoaXMuY2xlYXIoKTsgKytQIDwgazsgKSB7XG4gICAgICB2YXIgWiA9IGdbUF07XG4gICAgICB0aGlzLnNldChaWzBdLCBaWzFdKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gWmgoKSB7XG4gICAgdGhpcy5zaXplID0gMCwgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAgIGhhc2g6IG5ldyBBZSgpLFxuICAgICAgbWFwOiBuZXcgKEZlIHx8IFl0KSgpLFxuICAgICAgc3RyaW5nOiBuZXcgQWUoKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZXUoZykge1xuICAgIHZhciBQID0gUnModGhpcywgZykuZGVsZXRlKGcpO1xuICAgIHJldHVybiB0aGlzLnNpemUgLT0gUCA/IDEgOiAwLCBQO1xuICB9XG4gIGZ1bmN0aW9uIHR1KGcpIHtcbiAgICByZXR1cm4gUnModGhpcywgZykuZ2V0KGcpO1xuICB9XG4gIGZ1bmN0aW9uIGl1KGcpIHtcbiAgICByZXR1cm4gUnModGhpcywgZykuaGFzKGcpO1xuICB9XG4gIGZ1bmN0aW9uIHN1KGcsIFApIHtcbiAgICB2YXIgayA9IFJzKHRoaXMsIGcpLCBaID0gay5zaXplO1xuICAgIHJldHVybiBrLnNldChnLCBQKSwgdGhpcy5zaXplICs9IGsuc2l6ZSA9PSBaID8gMCA6IDEsIHRoaXM7XG4gIH1cbiAgcGkucHJvdG90eXBlLmNsZWFyID0gWmgsIHBpLnByb3RvdHlwZS5kZWxldGUgPSBldSwgcGkucHJvdG90eXBlLmdldCA9IHR1LCBwaS5wcm90b3R5cGUuaGFzID0gaXUsIHBpLnByb3RvdHlwZS5zZXQgPSBzdTtcbiAgZnVuY3Rpb24gTnMoZykge1xuICAgIHZhciBQID0gLTEsIGsgPSBnID09IG51bGwgPyAwIDogZy5sZW5ndGg7XG4gICAgZm9yICh0aGlzLl9fZGF0YV9fID0gbmV3IHBpKCk7ICsrUCA8IGs7IClcbiAgICAgIHRoaXMuYWRkKGdbUF0pO1xuICB9XG4gIGZ1bmN0aW9uIHJ1KGcpIHtcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5zZXQoZywgcyksIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gbnUoZykge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhnKTtcbiAgfVxuICBOcy5wcm90b3R5cGUuYWRkID0gTnMucHJvdG90eXBlLnB1c2ggPSBydSwgTnMucHJvdG90eXBlLmhhcyA9IG51O1xuICBmdW5jdGlvbiByaShnKSB7XG4gICAgdmFyIFAgPSB0aGlzLl9fZGF0YV9fID0gbmV3IFl0KGcpO1xuICAgIHRoaXMuc2l6ZSA9IFAuc2l6ZTtcbiAgfVxuICBmdW5jdGlvbiBvdSgpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gbmV3IFl0KCksIHRoaXMuc2l6ZSA9IDA7XG4gIH1cbiAgZnVuY3Rpb24gYXUoZykge1xuICAgIHZhciBQID0gdGhpcy5fX2RhdGFfXywgayA9IFAuZGVsZXRlKGcpO1xuICAgIHJldHVybiB0aGlzLnNpemUgPSBQLnNpemUsIGs7XG4gIH1cbiAgZnVuY3Rpb24gY3UoZykge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChnKTtcbiAgfVxuICBmdW5jdGlvbiBodShnKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGcpO1xuICB9XG4gIGZ1bmN0aW9uIHV1KGcsIFApIHtcbiAgICB2YXIgayA9IHRoaXMuX19kYXRhX187XG4gICAgaWYgKGsgaW5zdGFuY2VvZiBZdCkge1xuICAgICAgdmFyIFogPSBrLl9fZGF0YV9fO1xuICAgICAgaWYgKCFGZSB8fCBaLmxlbmd0aCA8IHQgLSAxKVxuICAgICAgICByZXR1cm4gWi5wdXNoKFtnLCBQXSksIHRoaXMuc2l6ZSA9ICsray5zaXplLCB0aGlzO1xuICAgICAgayA9IHRoaXMuX19kYXRhX18gPSBuZXcgcGkoWik7XG4gICAgfVxuICAgIHJldHVybiBrLnNldChnLCBQKSwgdGhpcy5zaXplID0gay5zaXplLCB0aGlzO1xuICB9XG4gIHJpLnByb3RvdHlwZS5jbGVhciA9IG91LCByaS5wcm90b3R5cGUuZGVsZXRlID0gYXUsIHJpLnByb3RvdHlwZS5nZXQgPSBjdSwgcmkucHJvdG90eXBlLmhhcyA9IGh1LCByaS5wcm90b3R5cGUuc2V0ID0gdXU7XG4gIGZ1bmN0aW9uIGx1KGcsIFApIHtcbiAgICB2YXIgayA9IENzKGcpLCBaID0gIWsgJiYgeHUoZyksIFJlID0gIWsgJiYgIVogJiYgZ3IoZyksIGFlID0gIWsgJiYgIVogJiYgIVJlICYmIEtuKGcpLCBMZSA9IGsgfHwgWiB8fCBSZSB8fCBhZSwgcnQgPSBMZSA/IE1lKGcubGVuZ3RoLCBTdHJpbmcpIDogW10sIGN0ID0gcnQubGVuZ3RoO1xuICAgIGZvciAodmFyIFRlIGluIGcpXG4gICAgICAoUCB8fCBuZS5jYWxsKGcsIFRlKSkgJiYgIShMZSAmJiAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAoVGUgPT0gXCJsZW5ndGhcIiB8fCAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgIFJlICYmIChUZSA9PSBcIm9mZnNldFwiIHx8IFRlID09IFwicGFyZW50XCIpIHx8IC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgIGFlICYmIChUZSA9PSBcImJ1ZmZlclwiIHx8IFRlID09IFwiYnl0ZUxlbmd0aFwiIHx8IFRlID09IFwiYnl0ZU9mZnNldFwiKSB8fCAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICBfdShUZSwgY3QpKSkgJiYgcnQucHVzaChUZSk7XG4gICAgcmV0dXJuIHJ0O1xuICB9XG4gIGZ1bmN0aW9uIFBzKGcsIFApIHtcbiAgICBmb3IgKHZhciBrID0gZy5sZW5ndGg7IGstLTsgKVxuICAgICAgaWYgKE1uKGdba11bMF0sIFApKVxuICAgICAgICByZXR1cm4gaztcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZnVuY3Rpb24gZHUoZywgUCwgaykge1xuICAgIHZhciBaID0gUChnKTtcbiAgICByZXR1cm4gQ3MoZykgPyBaIDogZ2UoWiwgayhnKSk7XG4gIH1cbiAgZnVuY3Rpb24gVmkoZykge1xuICAgIHJldHVybiBnID09IG51bGwgPyBnID09PSB2b2lkIDAgPyBMIDogSyA6IER0ICYmIER0IGluIE9iamVjdChnKSA/IHd1KGcpIDogRHUoZyk7XG4gIH1cbiAgZnVuY3Rpb24gJG4oZykge1xuICAgIHJldHVybiBCaShnKSAmJiBWaShnKSA9PSBjO1xuICB9XG4gIGZ1bmN0aW9uIEZuKGcsIFAsIGssIFosIFJlKSB7XG4gICAgcmV0dXJuIGcgPT09IFAgPyAhMCA6IGcgPT0gbnVsbCB8fCBQID09IG51bGwgfHwgIUJpKGcpICYmICFCaShQKSA/IGcgIT09IGcgJiYgUCAhPT0gUCA6IGZ1KGcsIFAsIGssIFosIEZuLCBSZSk7XG4gIH1cbiAgZnVuY3Rpb24gZnUoZywgUCwgaywgWiwgUmUsIGFlKSB7XG4gICAgdmFyIExlID0gQ3MoZyksIHJ0ID0gQ3MoUCksIGN0ID0gTGUgPyB1IDogbmkoZyksIFRlID0gcnQgPyB1IDogbmkoUCk7XG4gICAgY3QgPSBjdCA9PSBjID8gSSA6IGN0LCBUZSA9IFRlID09IGMgPyBJIDogVGU7XG4gICAgdmFyIHh0ID0gY3QgPT0gSSwgTHQgPSBUZSA9PSBJLCBmdCA9IGN0ID09IFRlO1xuICAgIGlmIChmdCAmJiBncihnKSkge1xuICAgICAgaWYgKCFncihQKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgTGUgPSAhMCwgeHQgPSAhMTtcbiAgICB9XG4gICAgaWYgKGZ0ICYmICF4dClcbiAgICAgIHJldHVybiBhZSB8fCAoYWUgPSBuZXcgcmkoKSksIExlIHx8IEtuKGcpID8gVW4oZywgUCwgaywgWiwgUmUsIGFlKSA6IG11KGcsIFAsIGN0LCBrLCBaLCBSZSwgYWUpO1xuICAgIGlmICghKGsgJiByKSkge1xuICAgICAgdmFyIFJ0ID0geHQgJiYgbmUuY2FsbChnLCBcIl9fd3JhcHBlZF9fXCIpLCBDdCA9IEx0ICYmIG5lLmNhbGwoUCwgXCJfX3dyYXBwZWRfX1wiKTtcbiAgICAgIGlmIChSdCB8fCBDdCkge1xuICAgICAgICB2YXIgb2kgPSBSdCA/IGcudmFsdWUoKSA6IGcsIEp0ID0gQ3QgPyBQLnZhbHVlKCkgOiBQO1xuICAgICAgICByZXR1cm4gYWUgfHwgKGFlID0gbmV3IHJpKCkpLCBSZShvaSwgSnQsIGssIFosIGFlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ0ID8gKGFlIHx8IChhZSA9IG5ldyByaSgpKSwgYnUoZywgUCwgaywgWiwgUmUsIGFlKSkgOiAhMTtcbiAgfVxuICBmdW5jdGlvbiBwdShnKSB7XG4gICAgaWYgKCF6bihnKSB8fCBTdShnKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICB2YXIgUCA9IHFuKGcpID8gRGUgOiBHO1xuICAgIHJldHVybiBQLnRlc3QoZ2koZykpO1xuICB9XG4gIGZ1bmN0aW9uIGd1KGcpIHtcbiAgICByZXR1cm4gQmkoZykgJiYgam4oZy5sZW5ndGgpICYmICEhUVtWaShnKV07XG4gIH1cbiAgZnVuY3Rpb24geXUoZykge1xuICAgIGlmICghSXUoZykpXG4gICAgICByZXR1cm4gT3MoZyk7XG4gICAgdmFyIFAgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIE9iamVjdChnKSlcbiAgICAgIG5lLmNhbGwoZywgaykgJiYgayAhPSBcImNvbnN0cnVjdG9yXCIgJiYgUC5wdXNoKGspO1xuICAgIHJldHVybiBQO1xuICB9XG4gIGZ1bmN0aW9uIFVuKGcsIFAsIGssIFosIFJlLCBhZSkge1xuICAgIHZhciBMZSA9IGsgJiByLCBydCA9IGcubGVuZ3RoLCBjdCA9IFAubGVuZ3RoO1xuICAgIGlmIChydCAhPSBjdCAmJiAhKExlICYmIGN0ID4gcnQpKVxuICAgICAgcmV0dXJuICExO1xuICAgIHZhciBUZSA9IGFlLmdldChnKTtcbiAgICBpZiAoVGUgJiYgYWUuZ2V0KFApKVxuICAgICAgcmV0dXJuIFRlID09IFA7XG4gICAgdmFyIHh0ID0gLTEsIEx0ID0gITAsIGZ0ID0gayAmIG4gPyBuZXcgTnMoKSA6IHZvaWQgMDtcbiAgICBmb3IgKGFlLnNldChnLCBQKSwgYWUuc2V0KFAsIGcpOyArK3h0IDwgcnQ7ICkge1xuICAgICAgdmFyIFJ0ID0gZ1t4dF0sIEN0ID0gUFt4dF07XG4gICAgICBpZiAoWilcbiAgICAgICAgdmFyIG9pID0gTGUgPyBaKEN0LCBSdCwgeHQsIFAsIGcsIGFlKSA6IFooUnQsIEN0LCB4dCwgZywgUCwgYWUpO1xuICAgICAgaWYgKG9pICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKG9pKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBMdCA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChmdCkge1xuICAgICAgICBpZiAoIVNlKFAsIGZ1bmN0aW9uKEp0LCB5aSkge1xuICAgICAgICAgIGlmICghYmUoZnQsIHlpKSAmJiAoUnQgPT09IEp0IHx8IFJlKFJ0LCBKdCwgaywgWiwgYWUpKSlcbiAgICAgICAgICAgIHJldHVybiBmdC5wdXNoKHlpKTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBMdCA9ICExO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEoUnQgPT09IEN0IHx8IFJlKFJ0LCBDdCwgaywgWiwgYWUpKSkge1xuICAgICAgICBMdCA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFlLmRlbGV0ZShnKSwgYWUuZGVsZXRlKFApLCBMdDtcbiAgfVxuICBmdW5jdGlvbiBtdShnLCBQLCBrLCBaLCBSZSwgYWUsIExlKSB7XG4gICAgc3dpdGNoIChrKSB7XG4gICAgICBjYXNlICQ6XG4gICAgICAgIGlmIChnLmJ5dGVMZW5ndGggIT0gUC5ieXRlTGVuZ3RoIHx8IGcuYnl0ZU9mZnNldCAhPSBQLmJ5dGVPZmZzZXQpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBnID0gZy5idWZmZXIsIFAgPSBQLmJ1ZmZlcjtcbiAgICAgIGNhc2UgUjpcbiAgICAgICAgcmV0dXJuICEoZy5ieXRlTGVuZ3RoICE9IFAuYnl0ZUxlbmd0aCB8fCAhYWUobmV3IFV0KGcpLCBuZXcgVXQoUCkpKTtcbiAgICAgIGNhc2UgcDpcbiAgICAgIGNhc2UgYjpcbiAgICAgIGNhc2UgRjpcbiAgICAgICAgcmV0dXJuIE1uKCtnLCArUCk7XG4gICAgICBjYXNlIHg6XG4gICAgICAgIHJldHVybiBnLm5hbWUgPT0gUC5uYW1lICYmIGcubWVzc2FnZSA9PSBQLm1lc3NhZ2U7XG4gICAgICBjYXNlIHc6XG4gICAgICBjYXNlIGE6XG4gICAgICAgIHJldHVybiBnID09IFAgKyBcIlwiO1xuICAgICAgY2FzZSBDOlxuICAgICAgICB2YXIgcnQgPSBwZTtcbiAgICAgIGNhc2UgZjpcbiAgICAgICAgdmFyIGN0ID0gWiAmIHI7XG4gICAgICAgIGlmIChydCB8fCAocnQgPSB1ZSksIGcuc2l6ZSAhPSBQLnNpemUgJiYgIWN0KVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgdmFyIFRlID0gTGUuZ2V0KGcpO1xuICAgICAgICBpZiAoVGUpXG4gICAgICAgICAgcmV0dXJuIFRlID09IFA7XG4gICAgICAgIFogfD0gbiwgTGUuc2V0KGcsIFApO1xuICAgICAgICB2YXIgeHQgPSBVbihydChnKSwgcnQoUCksIFosIFJlLCBhZSwgTGUpO1xuICAgICAgICByZXR1cm4gTGUuZGVsZXRlKGcpLCB4dDtcbiAgICAgIGNhc2UgbDpcbiAgICAgICAgaWYgKFZlKVxuICAgICAgICAgIHJldHVybiBWZS5jYWxsKGcpID09IFZlLmNhbGwoUCk7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBmdW5jdGlvbiBidShnLCBQLCBrLCBaLCBSZSwgYWUpIHtcbiAgICB2YXIgTGUgPSBrICYgciwgcnQgPSBMbihnKSwgY3QgPSBydC5sZW5ndGgsIFRlID0gTG4oUCksIHh0ID0gVGUubGVuZ3RoO1xuICAgIGlmIChjdCAhPSB4dCAmJiAhTGUpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yICh2YXIgTHQgPSBjdDsgTHQtLTsgKSB7XG4gICAgICB2YXIgZnQgPSBydFtMdF07XG4gICAgICBpZiAoIShMZSA/IGZ0IGluIFAgOiBuZS5jYWxsKFAsIGZ0KSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgdmFyIFJ0ID0gYWUuZ2V0KGcpO1xuICAgIGlmIChSdCAmJiBhZS5nZXQoUCkpXG4gICAgICByZXR1cm4gUnQgPT0gUDtcbiAgICB2YXIgQ3QgPSAhMDtcbiAgICBhZS5zZXQoZywgUCksIGFlLnNldChQLCBnKTtcbiAgICBmb3IgKHZhciBvaSA9IExlOyArK0x0IDwgY3Q7ICkge1xuICAgICAgZnQgPSBydFtMdF07XG4gICAgICB2YXIgSnQgPSBnW2Z0XSwgeWkgPSBQW2Z0XTtcbiAgICAgIGlmIChaKVxuICAgICAgICB2YXIgVm4gPSBMZSA/IFooeWksIEp0LCBmdCwgUCwgZywgYWUpIDogWihKdCwgeWksIGZ0LCBnLCBQLCBhZSk7XG4gICAgICBpZiAoIShWbiA9PT0gdm9pZCAwID8gSnQgPT09IHlpIHx8IFJlKEp0LCB5aSwgaywgWiwgYWUpIDogVm4pKSB7XG4gICAgICAgIEN0ID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb2kgfHwgKG9pID0gZnQgPT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgICB9XG4gICAgaWYgKEN0ICYmICFvaSkge1xuICAgICAgdmFyIEFzID0gZy5jb25zdHJ1Y3RvciwgVHMgPSBQLmNvbnN0cnVjdG9yO1xuICAgICAgQXMgIT0gVHMgJiYgXCJjb25zdHJ1Y3RvclwiIGluIGcgJiYgXCJjb25zdHJ1Y3RvclwiIGluIFAgJiYgISh0eXBlb2YgQXMgPT0gXCJmdW5jdGlvblwiICYmIEFzIGluc3RhbmNlb2YgQXMgJiYgdHlwZW9mIFRzID09IFwiZnVuY3Rpb25cIiAmJiBUcyBpbnN0YW5jZW9mIFRzKSAmJiAoQ3QgPSAhMSk7XG4gICAgfVxuICAgIHJldHVybiBhZS5kZWxldGUoZyksIGFlLmRlbGV0ZShQKSwgQ3Q7XG4gIH1cbiAgZnVuY3Rpb24gTG4oZykge1xuICAgIHJldHVybiBkdShnLCBQdSwgdnUpO1xuICB9XG4gIGZ1bmN0aW9uIFJzKGcsIFApIHtcbiAgICB2YXIgayA9IGcuX19kYXRhX187XG4gICAgcmV0dXJuIEV1KFApID8ga1t0eXBlb2YgUCA9PSBcInN0cmluZ1wiID8gXCJzdHJpbmdcIiA6IFwiaGFzaFwiXSA6IGsubWFwO1xuICB9XG4gIGZ1bmN0aW9uIFBpKGcsIFApIHtcbiAgICB2YXIgayA9IHllKGcsIFApO1xuICAgIHJldHVybiBwdShrKSA/IGsgOiB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gd3UoZykge1xuICAgIHZhciBQID0gbmUuY2FsbChnLCBEdCksIGsgPSBnW0R0XTtcbiAgICB0cnkge1xuICAgICAgZ1tEdF0gPSB2b2lkIDA7XG4gICAgICB2YXIgWiA9ICEwO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICB2YXIgUmUgPSBFZS5jYWxsKGcpO1xuICAgIHJldHVybiBaICYmIChQID8gZ1tEdF0gPSBrIDogZGVsZXRlIGdbRHRdKSwgUmU7XG4gIH1cbiAgdmFyIHZ1ID0gZmkgPyBmdW5jdGlvbihnKSB7XG4gICAgcmV0dXJuIGcgPT0gbnVsbCA/IFtdIDogKGcgPSBPYmplY3QoZyksIHZlKGZpKGcpLCBmdW5jdGlvbihQKSB7XG4gICAgICByZXR1cm4gcXQuY2FsbChnLCBQKTtcbiAgICB9KSk7XG4gIH0gOiBSdSwgbmkgPSBWaTtcbiAgKHFlICYmIG5pKG5ldyBxZShuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSAkIHx8IEZlICYmIG5pKG5ldyBGZSgpKSAhPSBDIHx8IGplICYmIG5pKGplLnJlc29sdmUoKSkgIT0gRCB8fCB6ZSAmJiBuaShuZXcgemUoKSkgIT0gZiB8fCBLZSAmJiBuaShuZXcgS2UoKSkgIT0gdikgJiYgKG5pID0gZnVuY3Rpb24oZykge1xuICAgIHZhciBQID0gVmkoZyksIGsgPSBQID09IEkgPyBnLmNvbnN0cnVjdG9yIDogdm9pZCAwLCBaID0gayA/IGdpKGspIDogXCJcIjtcbiAgICBpZiAoWilcbiAgICAgIHN3aXRjaCAoWikge1xuICAgICAgICBjYXNlIFFlOlxuICAgICAgICAgIHJldHVybiAkO1xuICAgICAgICBjYXNlIFhlOlxuICAgICAgICAgIHJldHVybiBDO1xuICAgICAgICBjYXNlIFplOlxuICAgICAgICAgIHJldHVybiBEO1xuICAgICAgICBjYXNlIGV0OlxuICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICBjYXNlIHR0OlxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgfVxuICAgIHJldHVybiBQO1xuICB9KTtcbiAgZnVuY3Rpb24gX3UoZywgUCkge1xuICAgIHJldHVybiBQID0gUCA/PyBvLCAhIVAgJiYgKHR5cGVvZiBnID09IFwibnVtYmVyXCIgfHwgaWUudGVzdChnKSkgJiYgZyA+IC0xICYmIGcgJSAxID09IDAgJiYgZyA8IFA7XG4gIH1cbiAgZnVuY3Rpb24gRXUoZykge1xuICAgIHZhciBQID0gdHlwZW9mIGc7XG4gICAgcmV0dXJuIFAgPT0gXCJzdHJpbmdcIiB8fCBQID09IFwibnVtYmVyXCIgfHwgUCA9PSBcInN5bWJvbFwiIHx8IFAgPT0gXCJib29sZWFuXCIgPyBnICE9PSBcIl9fcHJvdG9fX1wiIDogZyA9PT0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBTdShnKSB7XG4gICAgcmV0dXJuICEhX2UgJiYgX2UgaW4gZztcbiAgfVxuICBmdW5jdGlvbiBJdShnKSB7XG4gICAgdmFyIFAgPSBnICYmIGcuY29uc3RydWN0b3IsIGsgPSB0eXBlb2YgUCA9PSBcImZ1bmN0aW9uXCIgJiYgUC5wcm90b3R5cGUgfHwgcmU7XG4gICAgcmV0dXJuIGcgPT09IGs7XG4gIH1cbiAgZnVuY3Rpb24gRHUoZykge1xuICAgIHJldHVybiBFZS5jYWxsKGcpO1xuICB9XG4gIGZ1bmN0aW9uIGdpKGcpIHtcbiAgICBpZiAoZyAhPSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbWUuY2FsbChnKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGcgKyBcIlwiO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIE1uKGcsIFApIHtcbiAgICByZXR1cm4gZyA9PT0gUCB8fCBnICE9PSBnICYmIFAgIT09IFA7XG4gIH1cbiAgdmFyIHh1ID0gJG4oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgfSgpKSA/ICRuIDogZnVuY3Rpb24oZykge1xuICAgIHJldHVybiBCaShnKSAmJiBuZS5jYWxsKGcsIFwiY2FsbGVlXCIpICYmICFxdC5jYWxsKGcsIFwiY2FsbGVlXCIpO1xuICB9LCBDcyA9IEFycmF5LmlzQXJyYXk7XG4gIGZ1bmN0aW9uIE91KGcpIHtcbiAgICByZXR1cm4gZyAhPSBudWxsICYmIGpuKGcubGVuZ3RoKSAmJiAhcW4oZyk7XG4gIH1cbiAgdmFyIGdyID0gS2kgfHwgQ3U7XG4gIGZ1bmN0aW9uIE51KGcsIFApIHtcbiAgICByZXR1cm4gRm4oZywgUCk7XG4gIH1cbiAgZnVuY3Rpb24gcW4oZykge1xuICAgIGlmICghem4oZykpXG4gICAgICByZXR1cm4gITE7XG4gICAgdmFyIFAgPSBWaShnKTtcbiAgICByZXR1cm4gUCA9PSBPIHx8IFAgPT0gXyB8fCBQID09IGQgfHwgUCA9PSB5O1xuICB9XG4gIGZ1bmN0aW9uIGpuKGcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGcgPT0gXCJudW1iZXJcIiAmJiBnID4gLTEgJiYgZyAlIDEgPT0gMCAmJiBnIDw9IG87XG4gIH1cbiAgZnVuY3Rpb24gem4oZykge1xuICAgIHZhciBQID0gdHlwZW9mIGc7XG4gICAgcmV0dXJuIGcgIT0gbnVsbCAmJiAoUCA9PSBcIm9iamVjdFwiIHx8IFAgPT0gXCJmdW5jdGlvblwiKTtcbiAgfVxuICBmdW5jdGlvbiBCaShnKSB7XG4gICAgcmV0dXJuIGcgIT0gbnVsbCAmJiB0eXBlb2YgZyA9PSBcIm9iamVjdFwiO1xuICB9XG4gIHZhciBLbiA9IGZlID8gJGUoZmUpIDogZ3U7XG4gIGZ1bmN0aW9uIFB1KGcpIHtcbiAgICByZXR1cm4gT3UoZykgPyBsdShnKSA6IHl1KGcpO1xuICB9XG4gIGZ1bmN0aW9uIFJ1KCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBmdW5jdGlvbiBDdSgpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgaS5leHBvcnRzID0gTnU7XG59KShRcywgUXMuZXhwb3J0cyk7XG52YXIgRmcgPSBRcy5leHBvcnRzO1xuY29uc3QgWWMgPSAvKiBAX19QVVJFX18gKi8gR2EoRmcpO1xuZnVuY3Rpb24gVWcoaSwgZSkge1xuICBpZiAoaS5sZW5ndGggPj0gMjU1KVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBbHBoYWJldCB0b28gbG9uZ1wiKTtcbiAgZm9yICh2YXIgdCA9IG5ldyBVaW50OEFycmF5KDI1NiksIHMgPSAwOyBzIDwgdC5sZW5ndGg7IHMrKylcbiAgICB0W3NdID0gMjU1O1xuICBmb3IgKHZhciByID0gMDsgciA8IGkubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgbiA9IGkuY2hhckF0KHIpLCBvID0gbi5jaGFyQ29kZUF0KDApO1xuICAgIGlmICh0W29dICE9PSAyNTUpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG4gKyBcIiBpcyBhbWJpZ3VvdXNcIik7XG4gICAgdFtvXSA9IHI7XG4gIH1cbiAgdmFyIGMgPSBpLmxlbmd0aCwgdSA9IGkuY2hhckF0KDApLCBkID0gTWF0aC5sb2coYykgLyBNYXRoLmxvZygyNTYpLCBwID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKGMpO1xuICBmdW5jdGlvbiBiKF8pIHtcbiAgICBpZiAoXyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhfKSA/IF8gPSBuZXcgVWludDhBcnJheShfLmJ1ZmZlciwgXy5ieXRlT2Zmc2V0LCBfLmJ5dGVMZW5ndGgpIDogQXJyYXkuaXNBcnJheShfKSAmJiAoXyA9IFVpbnQ4QXJyYXkuZnJvbShfKSkpLCAhKF8gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBVaW50OEFycmF5XCIpO1xuICAgIGlmIChfLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIGZvciAodmFyIEMgPSAwLCBGID0gMCwgSyA9IDAsIEkgPSBfLmxlbmd0aDsgSyAhPT0gSSAmJiBfW0tdID09PSAwOyApXG4gICAgICBLKyssIEMrKztcbiAgICBmb3IgKHZhciBEID0gKEkgLSBLKSAqIHAgKyAxID4+PiAwLCB5ID0gbmV3IFVpbnQ4QXJyYXkoRCk7IEsgIT09IEk7ICkge1xuICAgICAgZm9yICh2YXIgdyA9IF9bS10sIGYgPSAwLCBhID0gRCAtIDE7ICh3ICE9PSAwIHx8IGYgPCBGKSAmJiBhICE9PSAtMTsgYS0tLCBmKyspXG4gICAgICAgIHcgKz0gMjU2ICogeVthXSA+Pj4gMCwgeVthXSA9IHcgJSBjID4+PiAwLCB3ID0gdyAvIGMgPj4+IDA7XG4gICAgICBpZiAodyAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLXplcm8gY2FycnlcIik7XG4gICAgICBGID0gZiwgSysrO1xuICAgIH1cbiAgICBmb3IgKHZhciBsID0gRCAtIEY7IGwgIT09IEQgJiYgeVtsXSA9PT0gMDsgKVxuICAgICAgbCsrO1xuICAgIGZvciAodmFyIEwgPSB1LnJlcGVhdChDKTsgbCA8IEQ7ICsrbClcbiAgICAgIEwgKz0gaS5jaGFyQXQoeVtsXSk7XG4gICAgcmV0dXJuIEw7XG4gIH1cbiAgZnVuY3Rpb24geChfKSB7XG4gICAgaWYgKHR5cGVvZiBfICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgU3RyaW5nXCIpO1xuICAgIGlmIChfLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIHZhciBDID0gMDtcbiAgICBpZiAoX1tDXSAhPT0gXCIgXCIpIHtcbiAgICAgIGZvciAodmFyIEYgPSAwLCBLID0gMDsgX1tDXSA9PT0gdTsgKVxuICAgICAgICBGKyssIEMrKztcbiAgICAgIGZvciAodmFyIEkgPSAoXy5sZW5ndGggLSBDKSAqIGQgKyAxID4+PiAwLCBEID0gbmV3IFVpbnQ4QXJyYXkoSSk7IF9bQ107ICkge1xuICAgICAgICB2YXIgeSA9IHRbXy5jaGFyQ29kZUF0KEMpXTtcbiAgICAgICAgaWYgKHkgPT09IDI1NSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAodmFyIHcgPSAwLCBmID0gSSAtIDE7ICh5ICE9PSAwIHx8IHcgPCBLKSAmJiBmICE9PSAtMTsgZi0tLCB3KyspXG4gICAgICAgICAgeSArPSBjICogRFtmXSA+Pj4gMCwgRFtmXSA9IHkgJSAyNTYgPj4+IDAsIHkgPSB5IC8gMjU2ID4+PiAwO1xuICAgICAgICBpZiAoeSAhPT0gMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24temVybyBjYXJyeVwiKTtcbiAgICAgICAgSyA9IHcsIEMrKztcbiAgICAgIH1cbiAgICAgIGlmIChfW0NdICE9PSBcIiBcIikge1xuICAgICAgICBmb3IgKHZhciBhID0gSSAtIEs7IGEgIT09IEkgJiYgRFthXSA9PT0gMDsgKVxuICAgICAgICAgIGErKztcbiAgICAgICAgZm9yICh2YXIgbCA9IG5ldyBVaW50OEFycmF5KEYgKyAoSSAtIGEpKSwgTCA9IEY7IGEgIT09IEk7IClcbiAgICAgICAgICBsW0wrK10gPSBEW2ErK107XG4gICAgICAgIHJldHVybiBsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBPKF8pIHtcbiAgICB2YXIgQyA9IHgoXyk7XG4gICAgaWYgKEMpXG4gICAgICByZXR1cm4gQztcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi0ke2V9IGNoYXJhY3RlcmApO1xuICB9XG4gIHJldHVybiB7IGVuY29kZTogYiwgZGVjb2RlVW5zYWZlOiB4LCBkZWNvZGU6IE8gfTtcbn1cbnZhciBMZyA9IFVnLCBNZyA9IExnO1xuY29uc3QgSmMgPSAoaSkgPT4ge1xuICBpZiAoaSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgaS5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlVpbnQ4QXJyYXlcIilcbiAgICByZXR1cm4gaTtcbiAgaWYgKGkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaSk7XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoaSkpXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGkuYnVmZmVyLCBpLmJ5dGVPZmZzZXQsIGkuYnl0ZUxlbmd0aCk7XG4gIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZVwiKTtcbn0sIHFnID0gKGkpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpKSwgamcgPSAoaSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGkpO1xubGV0IHpnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzKSB7XG4gICAgdGhpcy5uYW1lID0gZSwgdGhpcy5wcmVmaXggPSB0LCB0aGlzLmJhc2VFbmNvZGUgPSBzO1xuICB9XG4gIGVuY29kZShlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgcmV0dXJuIGAke3RoaXMucHJlZml4fSR7dGhpcy5iYXNlRW5jb2RlKGUpfWA7XG4gICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGVcIik7XG4gIH1cbn0sIEtnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzKSB7XG4gICAgaWYgKHRoaXMubmFtZSA9IGUsIHRoaXMucHJlZml4ID0gdCwgdC5jb2RlUG9pbnRBdCgwKSA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcmVmaXggY2hhcmFjdGVyXCIpO1xuICAgIHRoaXMucHJlZml4Q29kZVBvaW50ID0gdC5jb2RlUG9pbnRBdCgwKSwgdGhpcy5iYXNlRGVjb2RlID0gcztcbiAgfVxuICBkZWNvZGUoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoZS5jb2RlUG9pbnRBdCgwKSAhPT0gdGhpcy5wcmVmaXhDb2RlUG9pbnQpXG4gICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShlKX0sICR7dGhpcy5uYW1lfSBkZWNvZGVyIG9ubHkgc3VwcG9ydHMgaW5wdXRzIHByZWZpeGVkIHdpdGggJHt0aGlzLnByZWZpeH1gKTtcbiAgICAgIHJldHVybiB0aGlzLmJhc2VEZWNvZGUoZS5zbGljZSh0aGlzLnByZWZpeC5sZW5ndGgpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IEVycm9yKFwiQ2FuIG9ubHkgbXVsdGliYXNlIGRlY29kZSBzdHJpbmdzXCIpO1xuICB9XG4gIG9yKGUpIHtcbiAgICByZXR1cm4gUWModGhpcywgZSk7XG4gIH1cbn0sIFZnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5kZWNvZGVycyA9IGU7XG4gIH1cbiAgb3IoZSkge1xuICAgIHJldHVybiBRYyh0aGlzLCBlKTtcbiAgfVxuICBkZWNvZGUoZSkge1xuICAgIGNvbnN0IHQgPSBlWzBdLCBzID0gdGhpcy5kZWNvZGVyc1t0XTtcbiAgICBpZiAocylcbiAgICAgIHJldHVybiBzLmRlY29kZShlKTtcbiAgICB0aHJvdyBSYW5nZUVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShlKX0sIG9ubHkgaW5wdXRzIHByZWZpeGVkIHdpdGggJHtPYmplY3Qua2V5cyh0aGlzLmRlY29kZXJzKX0gYXJlIHN1cHBvcnRlZGApO1xuICB9XG59O1xuY29uc3QgUWMgPSAoaSwgZSkgPT4gbmV3IFZnKHsgLi4uaS5kZWNvZGVycyB8fCB7IFtpLnByZWZpeF06IGkgfSwgLi4uZS5kZWNvZGVycyB8fCB7IFtlLnByZWZpeF06IGUgfSB9KTtcbmxldCBCZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcywgcikge1xuICAgIHRoaXMubmFtZSA9IGUsIHRoaXMucHJlZml4ID0gdCwgdGhpcy5iYXNlRW5jb2RlID0gcywgdGhpcy5iYXNlRGVjb2RlID0gciwgdGhpcy5lbmNvZGVyID0gbmV3IHpnKGUsIHQsIHMpLCB0aGlzLmRlY29kZXIgPSBuZXcgS2coZSwgdCwgcik7XG4gIH1cbiAgZW5jb2RlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGVyLmVuY29kZShlKTtcbiAgfVxuICBkZWNvZGUoZSkge1xuICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlKGUpO1xuICB9XG59O1xuY29uc3QgbHIgPSAoeyBuYW1lOiBpLCBwcmVmaXg6IGUsIGVuY29kZTogdCwgZGVjb2RlOiBzIH0pID0+IG5ldyBCZyhpLCBlLCB0LCBzKSwgU3MgPSAoeyBwcmVmaXg6IGksIG5hbWU6IGUsIGFscGhhYmV0OiB0IH0pID0+IHtcbiAgY29uc3QgeyBlbmNvZGU6IHMsIGRlY29kZTogciB9ID0gTWcodCwgZSk7XG4gIHJldHVybiBscih7IHByZWZpeDogaSwgbmFtZTogZSwgZW5jb2RlOiBzLCBkZWNvZGU6IChuKSA9PiBKYyhyKG4pKSB9KTtcbn0sIGtnID0gKGksIGUsIHQsIHMpID0+IHtcbiAgY29uc3QgciA9IHt9O1xuICBmb3IgKGxldCBwID0gMDsgcCA8IGUubGVuZ3RoOyArK3ApXG4gICAgcltlW3BdXSA9IHA7XG4gIGxldCBuID0gaS5sZW5ndGg7XG4gIGZvciAoOyBpW24gLSAxXSA9PT0gXCI9XCI7IClcbiAgICAtLW47XG4gIGNvbnN0IG8gPSBuZXcgVWludDhBcnJheShuICogdCAvIDggfCAwKTtcbiAgbGV0IGMgPSAwLCB1ID0gMCwgZCA9IDA7XG4gIGZvciAobGV0IHAgPSAwOyBwIDwgbjsgKytwKSB7XG4gICAgY29uc3QgYiA9IHJbaVtwXV07XG4gICAgaWYgKGIgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgTm9uLSR7c30gY2hhcmFjdGVyYCk7XG4gICAgdSA9IHUgPDwgdCB8IGIsIGMgKz0gdCwgYyA+PSA4ICYmIChjIC09IDgsIG9bZCsrXSA9IDI1NSAmIHUgPj4gYyk7XG4gIH1cbiAgaWYgKGMgPj0gdCB8fCAyNTUgJiB1IDw8IDggLSBjKVxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGRhdGFcIik7XG4gIHJldHVybiBvO1xufSwgSGcgPSAoaSwgZSwgdCkgPT4ge1xuICBjb25zdCBzID0gZVtlLmxlbmd0aCAtIDFdID09PSBcIj1cIiwgciA9ICgxIDw8IHQpIC0gMTtcbiAgbGV0IG4gPSBcIlwiLCBvID0gMCwgYyA9IDA7XG4gIGZvciAobGV0IHUgPSAwOyB1IDwgaS5sZW5ndGg7ICsrdSlcbiAgICBmb3IgKGMgPSBjIDw8IDggfCBpW3VdLCBvICs9IDg7IG8gPiB0OyApXG4gICAgICBvIC09IHQsIG4gKz0gZVtyICYgYyA+PiBvXTtcbiAgaWYgKG8gJiYgKG4gKz0gZVtyICYgYyA8PCB0IC0gb10pLCBzKVxuICAgIGZvciAoOyBuLmxlbmd0aCAqIHQgJiA3OyApXG4gICAgICBuICs9IFwiPVwiO1xuICByZXR1cm4gbjtcbn0sIGx0ID0gKHsgbmFtZTogaSwgcHJlZml4OiBlLCBiaXRzUGVyQ2hhcjogdCwgYWxwaGFiZXQ6IHMgfSkgPT4gbHIoeyBwcmVmaXg6IGUsIG5hbWU6IGksIGVuY29kZShyKSB7XG4gIHJldHVybiBIZyhyLCBzLCB0KTtcbn0sIGRlY29kZShyKSB7XG4gIHJldHVybiBrZyhyLCBzLCB0LCBpKTtcbn0gfSksIEdnID0gbHIoeyBwcmVmaXg6IFwiXFwwXCIsIG5hbWU6IFwiaWRlbnRpdHlcIiwgZW5jb2RlOiAoaSkgPT4gamcoaSksIGRlY29kZTogKGkpID0+IHFnKGkpIH0pO1xudmFyIFdnID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgaWRlbnRpdHk6IEdnIH0pO1xuY29uc3QgWWcgPSBsdCh7IHByZWZpeDogXCIwXCIsIG5hbWU6IFwiYmFzZTJcIiwgYWxwaGFiZXQ6IFwiMDFcIiwgYml0c1BlckNoYXI6IDEgfSk7XG52YXIgSmcgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlMjogWWcgfSk7XG5jb25zdCBRZyA9IGx0KHsgcHJlZml4OiBcIjdcIiwgbmFtZTogXCJiYXNlOFwiLCBhbHBoYWJldDogXCIwMTIzNDU2N1wiLCBiaXRzUGVyQ2hhcjogMyB9KTtcbnZhciBYZyA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2U4OiBRZyB9KTtcbmNvbnN0IFpnID0gU3MoeyBwcmVmaXg6IFwiOVwiLCBuYW1lOiBcImJhc2UxMFwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5XCIgfSk7XG52YXIgZXkgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlMTA6IFpnIH0pO1xuY29uc3QgdHkgPSBsdCh7IHByZWZpeDogXCJmXCIsIG5hbWU6IFwiYmFzZTE2XCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlhYmNkZWZcIiwgYml0c1BlckNoYXI6IDQgfSksIGl5ID0gbHQoeyBwcmVmaXg6IFwiRlwiLCBuYW1lOiBcImJhc2UxNnVwcGVyXCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZcIiwgYml0c1BlckNoYXI6IDQgfSk7XG52YXIgc3kgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlMTY6IHR5LCBiYXNlMTZ1cHBlcjogaXkgfSk7XG5jb25zdCByeSA9IGx0KHsgcHJlZml4OiBcImJcIiwgbmFtZTogXCJiYXNlMzJcIiwgYWxwaGFiZXQ6IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjdcIiwgYml0c1BlckNoYXI6IDUgfSksIG55ID0gbHQoeyBwcmVmaXg6IFwiQlwiLCBuYW1lOiBcImJhc2UzMnVwcGVyXCIsIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3XCIsIGJpdHNQZXJDaGFyOiA1IH0pLCBveSA9IGx0KHsgcHJlZml4OiBcImNcIiwgbmFtZTogXCJiYXNlMzJwYWRcIiwgYWxwaGFiZXQ6IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1Njc9XCIsIGJpdHNQZXJDaGFyOiA1IH0pLCBheSA9IGx0KHsgcHJlZml4OiBcIkNcIiwgbmFtZTogXCJiYXNlMzJwYWR1cHBlclwiLCBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2Nz1cIiwgYml0c1BlckNoYXI6IDUgfSksIGN5ID0gbHQoeyBwcmVmaXg6IFwidlwiLCBuYW1lOiBcImJhc2UzMmhleFwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dlwiLCBiaXRzUGVyQ2hhcjogNSB9KSwgaHkgPSBsdCh7IHByZWZpeDogXCJWXCIsIG5hbWU6IFwiYmFzZTMyaGV4dXBwZXJcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZcIiwgYml0c1BlckNoYXI6IDUgfSksIHV5ID0gbHQoeyBwcmVmaXg6IFwidFwiLCBuYW1lOiBcImJhc2UzMmhleHBhZFwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj1cIiwgYml0c1BlckNoYXI6IDUgfSksIGx5ID0gbHQoeyBwcmVmaXg6IFwiVFwiLCBuYW1lOiBcImJhc2UzMmhleHBhZHVwcGVyXCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWPVwiLCBiaXRzUGVyQ2hhcjogNSB9KSwgZHkgPSBsdCh7IHByZWZpeDogXCJoXCIsIG5hbWU6IFwiYmFzZTMyelwiLCBhbHBoYWJldDogXCJ5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OVwiLCBiaXRzUGVyQ2hhcjogNSB9KTtcbnZhciBmeSA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2UzMjogcnksIGJhc2UzMnVwcGVyOiBueSwgYmFzZTMycGFkOiBveSwgYmFzZTMycGFkdXBwZXI6IGF5LCBiYXNlMzJoZXg6IGN5LCBiYXNlMzJoZXh1cHBlcjogaHksIGJhc2UzMmhleHBhZDogdXksIGJhc2UzMmhleHBhZHVwcGVyOiBseSwgYmFzZTMyejogZHkgfSk7XG5jb25zdCBweSA9IFNzKHsgcHJlZml4OiBcImtcIiwgbmFtZTogXCJiYXNlMzZcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIgfSksIGd5ID0gU3MoeyBwcmVmaXg6IFwiS1wiLCBuYW1lOiBcImJhc2UzNnVwcGVyXCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiIH0pO1xudmFyIHl5ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTM2OiBweSwgYmFzZTM2dXBwZXI6IGd5IH0pO1xuY29uc3QgbXkgPSBTcyh7IG5hbWU6IFwiYmFzZTU4YnRjXCIsIHByZWZpeDogXCJ6XCIsIGFscGhhYmV0OiBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIiB9KSwgYnkgPSBTcyh7IG5hbWU6IFwiYmFzZTU4ZmxpY2tyXCIsIHByZWZpeDogXCJaXCIsIGFscGhhYmV0OiBcIjEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVpcIiB9KTtcbnZhciB3eSA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2U1OGJ0YzogbXksIGJhc2U1OGZsaWNrcjogYnkgfSk7XG5jb25zdCB2eSA9IGx0KHsgcHJlZml4OiBcIm1cIiwgbmFtZTogXCJiYXNlNjRcIiwgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLCBiaXRzUGVyQ2hhcjogNiB9KSwgX3kgPSBsdCh7IHByZWZpeDogXCJNXCIsIG5hbWU6IFwiYmFzZTY0cGFkXCIsIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCIsIGJpdHNQZXJDaGFyOiA2IH0pLCBFeSA9IGx0KHsgcHJlZml4OiBcInVcIiwgbmFtZTogXCJiYXNlNjR1cmxcIiwgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktX1wiLCBiaXRzUGVyQ2hhcjogNiB9KSwgU3kgPSBsdCh7IHByZWZpeDogXCJVXCIsIG5hbWU6IFwiYmFzZTY0dXJscGFkXCIsIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV89XCIsIGJpdHNQZXJDaGFyOiA2IH0pO1xudmFyIEl5ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTY0OiB2eSwgYmFzZTY0cGFkOiBfeSwgYmFzZTY0dXJsOiBFeSwgYmFzZTY0dXJscGFkOiBTeSB9KTtcbmNvbnN0IFhjID0gQXJyYXkuZnJvbShcIvCfmoDwn6qQ4piE8J+bsPCfjIzwn4yR8J+MkvCfjJPwn4yU8J+MlfCfjJbwn4yX8J+MmPCfjI3wn4yP8J+MjvCfkInimIDwn5K78J+WpfCfkr7wn5K/8J+YguKdpPCfmI3wn6Sj8J+YivCfmY/wn5KV8J+YrfCfmJjwn5GN8J+YhfCfkY/wn5iB8J+UpfCfpbDwn5KU8J+SlvCfkpnwn5ii8J+klPCfmIbwn5mE8J+SqvCfmInimLrwn5GM8J+kl/Cfkpzwn5iU8J+YjvCfmIfwn4y58J+kpvCfjonwn5Ke4pyM4pyo8J+kt/CfmLHwn5iM8J+MuPCfmYzwn5iL8J+Sl/Cfkprwn5iP8J+Sm/CfmYLwn5KT8J+kqfCfmITwn5iA8J+WpPCfmIPwn5Kv8J+ZiPCfkYfwn4628J+YkvCfpK3inaPwn5ic8J+Si/CfkYDwn5iq8J+YkfCfkqXwn5mL8J+YnvCfmKnwn5ih8J+kqvCfkYrwn6Wz8J+YpfCfpKTwn5GJ8J+Sg/CfmLPinIvwn5ia8J+YnfCfmLTwn4yf8J+YrPCfmYPwn42A8J+Mt/CfmLvwn5iT4q2Q4pyF8J+luvCfjIjwn5iI8J+kmPCfkqbinJTwn5ij8J+Pg/CfkpDimLnwn46K8J+SmPCfmKDimJ3wn5iV8J+MuvCfjoLwn4y78J+YkPCflpXwn5Kd8J+ZivCfmLnwn5ej8J+Sq/CfkoDwn5GR8J+OtfCfpJ7wn5ib8J+UtPCfmKTwn4y88J+Yq+KavfCfpJnimJXwn4+G8J+kq/CfkYjwn5iu8J+ZhvCfjbvwn42D8J+QtvCfkoHwn5iy8J+Mv/Cfp6Hwn46B4pqh8J+MnvCfjojinYzinIrwn5GL8J+YsPCfpKjwn5i28J+knfCfmrbwn5Kw8J+Nk/CfkqLwn6Sf8J+ZgfCfmqjwn5Ko8J+krOKciPCfjoDwn4268J+kk/CfmJnwn5Kf8J+MsfCfmJbwn5G28J+ltOKWtuKeoeKdk/Cfko7wn5K44qyH8J+YqPCfjJrwn6aL8J+Yt/CflbrimqDwn5mF8J+Yn/CfmLXwn5GO8J+ksvCfpKDwn6Sn8J+TjPCflLXwn5KF8J+nkPCfkL7wn42S8J+Yl/CfpJHwn4yK8J+kr/CfkLfimI7wn5Kn8J+Yr/Cfkobwn5GG8J+OpPCfmYfwn42R4p2E8J+MtPCfkqPwn5C48J+SjPCfk43wn6WA8J+kovCfkYXwn5Kh8J+SqfCfkZDwn5O48J+Ru/CfpJDwn6Su8J+OvPCfpbXwn5qp8J+NjvCfjYrwn5G88J+SjfCfk6Pwn6WCXCIpLCBEeSA9IFhjLnJlZHVjZSgoaSwgZSwgdCkgPT4gKGlbdF0gPSBlLCBpKSwgW10pLCB4eSA9IFhjLnJlZHVjZSgoaSwgZSwgdCkgPT4gKGlbZS5jb2RlUG9pbnRBdCgwKV0gPSB0LCBpKSwgW10pO1xuZnVuY3Rpb24gT3koaSkge1xuICByZXR1cm4gaS5yZWR1Y2UoKGUsIHQpID0+IChlICs9IER5W3RdLCBlKSwgXCJcIik7XG59XG5mdW5jdGlvbiBOeShpKSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgZm9yIChjb25zdCB0IG9mIGkpIHtcbiAgICBjb25zdCBzID0geHlbdC5jb2RlUG9pbnRBdCgwKV07XG4gICAgaWYgKHMgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLWJhc2UyNTZlbW9qaSBjaGFyYWN0ZXI6ICR7dH1gKTtcbiAgICBlLnB1c2gocyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGUpO1xufVxuY29uc3QgUHkgPSBscih7IHByZWZpeDogXCLwn5qAXCIsIG5hbWU6IFwiYmFzZTI1NmVtb2ppXCIsIGVuY29kZTogT3ksIGRlY29kZTogTnkgfSk7XG52YXIgUnkgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlMjU2ZW1vamk6IFB5IH0pLCBDeSA9IFpjLCBHbyA9IDEyOCwgQXkgPSAxMjcsIFR5ID0gfkF5LCAkeSA9IE1hdGgucG93KDIsIDMxKTtcbmZ1bmN0aW9uIFpjKGksIGUsIHQpIHtcbiAgZSA9IGUgfHwgW10sIHQgPSB0IHx8IDA7XG4gIGZvciAodmFyIHMgPSB0OyBpID49ICR5OyApXG4gICAgZVt0KytdID0gaSAmIDI1NSB8IEdvLCBpIC89IDEyODtcbiAgZm9yICg7IGkgJiBUeTsgKVxuICAgIGVbdCsrXSA9IGkgJiAyNTUgfCBHbywgaSA+Pj49IDc7XG4gIHJldHVybiBlW3RdID0gaSB8IDAsIFpjLmJ5dGVzID0gdCAtIHMgKyAxLCBlO1xufVxudmFyIEZ5ID0gV3IsIFV5ID0gMTI4LCBXbyA9IDEyNztcbmZ1bmN0aW9uIFdyKGksIHMpIHtcbiAgdmFyIHQgPSAwLCBzID0gcyB8fCAwLCByID0gMCwgbiA9IHMsIG8sIGMgPSBpLmxlbmd0aDtcbiAgZG8ge1xuICAgIGlmIChuID49IGMpXG4gICAgICB0aHJvdyBXci5ieXRlcyA9IDAsIG5ldyBSYW5nZUVycm9yKFwiQ291bGQgbm90IGRlY29kZSB2YXJpbnRcIik7XG4gICAgbyA9IGlbbisrXSwgdCArPSByIDwgMjggPyAobyAmIFdvKSA8PCByIDogKG8gJiBXbykgKiBNYXRoLnBvdygyLCByKSwgciArPSA3O1xuICB9IHdoaWxlIChvID49IFV5KTtcbiAgcmV0dXJuIFdyLmJ5dGVzID0gbiAtIHMsIHQ7XG59XG52YXIgTHkgPSBNYXRoLnBvdygyLCA3KSwgTXkgPSBNYXRoLnBvdygyLCAxNCksIHF5ID0gTWF0aC5wb3coMiwgMjEpLCBqeSA9IE1hdGgucG93KDIsIDI4KSwgenkgPSBNYXRoLnBvdygyLCAzNSksIEt5ID0gTWF0aC5wb3coMiwgNDIpLCBWeSA9IE1hdGgucG93KDIsIDQ5KSwgQnkgPSBNYXRoLnBvdygyLCA1NiksIGt5ID0gTWF0aC5wb3coMiwgNjMpLCBIeSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIGkgPCBMeSA/IDEgOiBpIDwgTXkgPyAyIDogaSA8IHF5ID8gMyA6IGkgPCBqeSA/IDQgOiBpIDwgenkgPyA1IDogaSA8IEt5ID8gNiA6IGkgPCBWeSA/IDcgOiBpIDwgQnkgPyA4IDogaSA8IGt5ID8gOSA6IDEwO1xufSwgR3kgPSB7IGVuY29kZTogQ3ksIGRlY29kZTogRnksIGVuY29kaW5nTGVuZ3RoOiBIeSB9LCBlaCA9IEd5O1xuY29uc3QgWW8gPSAoaSwgZSwgdCA9IDApID0+IChlaC5lbmNvZGUoaSwgZSwgdCksIGUpLCBKbyA9IChpKSA9PiBlaC5lbmNvZGluZ0xlbmd0aChpKSwgWXIgPSAoaSwgZSkgPT4ge1xuICBjb25zdCB0ID0gZS5ieXRlTGVuZ3RoLCBzID0gSm8oaSksIHIgPSBzICsgSm8odCksIG4gPSBuZXcgVWludDhBcnJheShyICsgdCk7XG4gIHJldHVybiBZbyhpLCBuLCAwKSwgWW8odCwgbiwgcyksIG4uc2V0KGUsIHIpLCBuZXcgV3koaSwgdCwgZSwgbik7XG59O1xubGV0IFd5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzLCByKSB7XG4gICAgdGhpcy5jb2RlID0gZSwgdGhpcy5zaXplID0gdCwgdGhpcy5kaWdlc3QgPSBzLCB0aGlzLmJ5dGVzID0gcjtcbiAgfVxufTtcbmNvbnN0IHRoID0gKHsgbmFtZTogaSwgY29kZTogZSwgZW5jb2RlOiB0IH0pID0+IG5ldyBZeShpLCBlLCB0KTtcbmxldCBZeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcykge1xuICAgIHRoaXMubmFtZSA9IGUsIHRoaXMuY29kZSA9IHQsIHRoaXMuZW5jb2RlID0gcztcbiAgfVxuICBkaWdlc3QoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuZW5jb2RlKGUpO1xuICAgICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gWXIodGhpcy5jb2RlLCB0KSA6IHQudGhlbigocykgPT4gWXIodGhpcy5jb2RlLCBzKSk7XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZVwiKTtcbiAgfVxufTtcbmNvbnN0IGloID0gKGkpID0+IGFzeW5jIChlKSA9PiBuZXcgVWludDhBcnJheShhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChpLCBlKSksIEp5ID0gdGgoeyBuYW1lOiBcInNoYTItMjU2XCIsIGNvZGU6IDE4LCBlbmNvZGU6IGloKFwiU0hBLTI1NlwiKSB9KSwgUXkgPSB0aCh7IG5hbWU6IFwic2hhMi01MTJcIiwgY29kZTogMTksIGVuY29kZTogaWgoXCJTSEEtNTEyXCIpIH0pO1xudmFyIFh5ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgc2hhMjU2OiBKeSwgc2hhNTEyOiBReSB9KTtcbmNvbnN0IHNoID0gMCwgWnkgPSBcImlkZW50aXR5XCIsIHJoID0gSmMsIGUxID0gKGkpID0+IFlyKHNoLCByaChpKSksIHQxID0geyBjb2RlOiBzaCwgbmFtZTogWnksIGVuY29kZTogcmgsIGRpZ2VzdDogZTEgfTtcbnZhciBpMSA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGlkZW50aXR5OiB0MSB9KTtcbm5ldyBUZXh0RW5jb2RlcigpLCBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IFFvID0geyAuLi5XZywgLi4uSmcsIC4uLlhnLCAuLi5leSwgLi4uc3ksIC4uLmZ5LCAuLi55eSwgLi4ud3ksIC4uLkl5LCAuLi5SeSB9O1xuKHsgLi4uWHksIC4uLmkxIH0pO1xuZnVuY3Rpb24gbmgoaSkge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCA/IG5ldyBVaW50OEFycmF5KGkuYnVmZmVyLCBpLmJ5dGVPZmZzZXQsIGkuYnl0ZUxlbmd0aCkgOiBpO1xufVxuZnVuY3Rpb24gczEoaSA9IDApIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2NVbnNhZmUgIT0gbnVsbCA/IG5oKGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jVW5zYWZlKGkpKSA6IG5ldyBVaW50OEFycmF5KGkpO1xufVxuZnVuY3Rpb24gb2goaSwgZSwgdCwgcykge1xuICByZXR1cm4geyBuYW1lOiBpLCBwcmVmaXg6IGUsIGVuY29kZXI6IHsgbmFtZTogaSwgcHJlZml4OiBlLCBlbmNvZGU6IHQgfSwgZGVjb2RlcjogeyBkZWNvZGU6IHMgfSB9O1xufVxuY29uc3QgWG8gPSBvaChcInV0ZjhcIiwgXCJ1XCIsIChpKSA9PiBcInVcIiArIG5ldyBUZXh0RGVjb2RlcihcInV0ZjhcIikuZGVjb2RlKGkpLCAoaSkgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGkuc3Vic3RyaW5nKDEpKSksIE9yID0gb2goXCJhc2NpaVwiLCBcImFcIiwgKGkpID0+IHtcbiAgbGV0IGUgPSBcImFcIjtcbiAgZm9yIChsZXQgdCA9IDA7IHQgPCBpLmxlbmd0aDsgdCsrKVxuICAgIGUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShpW3RdKTtcbiAgcmV0dXJuIGU7XG59LCAoaSkgPT4ge1xuICBpID0gaS5zdWJzdHJpbmcoMSk7XG4gIGNvbnN0IGUgPSBzMShpLmxlbmd0aCk7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgaS5sZW5ndGg7IHQrKylcbiAgICBlW3RdID0gaS5jaGFyQ29kZUF0KHQpO1xuICByZXR1cm4gZTtcbn0pLCByMSA9IHsgdXRmODogWG8sIFwidXRmLThcIjogWG8sIGhleDogUW8uYmFzZTE2LCBsYXRpbjE6IE9yLCBhc2NpaTogT3IsIGJpbmFyeTogT3IsIC4uLlFvIH07XG5mdW5jdGlvbiBuMShpLCBlID0gXCJ1dGY4XCIpIHtcbiAgY29uc3QgdCA9IHIxW2VdO1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7ZX1cImApO1xuICByZXR1cm4gKGUgPT09IFwidXRmOFwiIHx8IGUgPT09IFwidXRmLThcIikgJiYgZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tICE9IG51bGwgPyBuaChnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGksIFwidXRmLThcIikpIDogdC5kZWNvZGVyLmRlY29kZShgJHt0LnByZWZpeH0ke2l9YCk7XG59XG5jb25zdCBhaCA9IFwid2NcIiwgbzEgPSAyLCBFbiA9IFwiY29yZVwiLCBoaSA9IGAke2FofUAyOiR7RW59OmAsIGExID0geyBuYW1lOiBFbiwgbG9nZ2VyOiBcImVycm9yXCIgfSwgYzEgPSB7IGRhdGFiYXNlOiBcIjptZW1vcnk6XCIgfSwgaDEgPSBcImNyeXB0b1wiLCBabyA9IFwiY2xpZW50X2VkMjU1MTlfc2VlZFwiLCB1MSA9IFYuT05FX0RBWSwgbDEgPSBcImtleWNoYWluXCIsIGQxID0gXCIwLjNcIiwgZjEgPSBcIm1lc3NhZ2VzXCIsIHAxID0gXCIwLjNcIiwgZzEgPSBWLlNJWF9IT1VSUywgeTEgPSBcInB1Ymxpc2hlclwiLCBjaCA9IFwiaXJuXCIsIG0xID0gXCJlcnJvclwiLCBoaCA9IFwid3NzOi8vcmVsYXkud2FsbGV0Y29ubmVjdC5jb21cIiwgZWEgPSBcIndzczovL3JlbGF5LndhbGxldGNvbm5lY3Qub3JnXCIsIGIxID0gXCJyZWxheWVyXCIsIGd0ID0geyBtZXNzYWdlOiBcInJlbGF5ZXJfbWVzc2FnZVwiLCBtZXNzYWdlX2FjazogXCJyZWxheWVyX21lc3NhZ2VfYWNrXCIsIGNvbm5lY3Q6IFwicmVsYXllcl9jb25uZWN0XCIsIGRpc2Nvbm5lY3Q6IFwicmVsYXllcl9kaXNjb25uZWN0XCIsIGVycm9yOiBcInJlbGF5ZXJfZXJyb3JcIiwgY29ubmVjdGlvbl9zdGFsbGVkOiBcInJlbGF5ZXJfY29ubmVjdGlvbl9zdGFsbGVkXCIsIHRyYW5zcG9ydF9jbG9zZWQ6IFwicmVsYXllcl90cmFuc3BvcnRfY2xvc2VkXCIsIHB1Ymxpc2g6IFwicmVsYXllcl9wdWJsaXNoXCIgfSwgdzEgPSBcIl9zdWJzY3JpcHRpb25cIiwgWnQgPSB7IHBheWxvYWQ6IFwicGF5bG9hZFwiLCBjb25uZWN0OiBcImNvbm5lY3RcIiwgZGlzY29ubmVjdDogXCJkaXNjb25uZWN0XCIsIGVycm9yOiBcImVycm9yXCIgfSwgdjEgPSBWLk9ORV9TRUNPTkQsIF8xID0gXCIyLjEwLjFcIiwgRTEgPSAxZTQsIFMxID0gXCIwLjNcIiwgSTEgPSBcIldBTExFVENPTk5FQ1RfQ0xJRU5UX0lEXCIsIFZ0ID0geyBjcmVhdGVkOiBcInN1YnNjcmlwdGlvbl9jcmVhdGVkXCIsIGRlbGV0ZWQ6IFwic3Vic2NyaXB0aW9uX2RlbGV0ZWRcIiwgZXhwaXJlZDogXCJzdWJzY3JpcHRpb25fZXhwaXJlZFwiLCBkaXNhYmxlZDogXCJzdWJzY3JpcHRpb25fZGlzYWJsZWRcIiwgc3luYzogXCJzdWJzY3JpcHRpb25fc3luY1wiLCByZXN1YnNjcmliZWQ6IFwic3Vic2NyaXB0aW9uX3Jlc3Vic2NyaWJlZFwiIH0sIEQxID0gXCJzdWJzY3JpcHRpb25cIiwgeDEgPSBcIjAuM1wiLCBPMSA9IFYuRklWRV9TRUNPTkRTICogMWUzLCBOMSA9IFwicGFpcmluZ1wiLCBQMSA9IFwiMC4zXCIsIFhpID0geyB3Y19wYWlyaW5nRGVsZXRlOiB7IHJlcTogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxZTMgfSwgcmVzOiB7IHR0bDogVi5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDEwMDEgfSB9LCB3Y19wYWlyaW5nUGluZzogeyByZXE6IHsgdHRsOiBWLlRISVJUWV9TRUNPTkRTLCBwcm9tcHQ6ICExLCB0YWc6IDEwMDIgfSwgcmVzOiB7IHR0bDogVi5USElSVFlfU0VDT05EUywgcHJvbXB0OiAhMSwgdGFnOiAxMDAzIH0gfSwgdW5yZWdpc3RlcmVkX21ldGhvZDogeyByZXE6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMCB9LCByZXM6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMCB9IH0gfSwgb3MgPSB7IGNyZWF0ZTogXCJwYWlyaW5nX2NyZWF0ZVwiLCBleHBpcmU6IFwicGFpcmluZ19leHBpcmVcIiwgZGVsZXRlOiBcInBhaXJpbmdfZGVsZXRlXCIsIHBpbmc6IFwicGFpcmluZ19waW5nXCIgfSwgenQgPSB7IGNyZWF0ZWQ6IFwiaGlzdG9yeV9jcmVhdGVkXCIsIHVwZGF0ZWQ6IFwiaGlzdG9yeV91cGRhdGVkXCIsIGRlbGV0ZWQ6IFwiaGlzdG9yeV9kZWxldGVkXCIsIHN5bmM6IFwiaGlzdG9yeV9zeW5jXCIgfSwgUjEgPSBcImhpc3RvcnlcIiwgQzEgPSBcIjAuM1wiLCBBMSA9IFwiZXhwaXJlclwiLCBUdCA9IHsgY3JlYXRlZDogXCJleHBpcmVyX2NyZWF0ZWRcIiwgZGVsZXRlZDogXCJleHBpcmVyX2RlbGV0ZWRcIiwgZXhwaXJlZDogXCJleHBpcmVyX2V4cGlyZWRcIiwgc3luYzogXCJleHBpcmVyX3N5bmNcIiB9LCBUMSA9IFwiMC4zXCIsIE5yID0gXCJ2ZXJpZnktYXBpXCIsIEtzID0gXCJodHRwczovL3ZlcmlmeS53YWxsZXRjb25uZWN0LmNvbVwiLCB0YSA9IFwiaHR0cHM6Ly92ZXJpZnkud2FsbGV0Y29ubmVjdC5vcmdcIjtcbmxldCAkMSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5rZXljaGFpbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMubmFtZSA9IGwxLCB0aGlzLnZlcnNpb24gPSBkMSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSBoaSwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IHMgPSBhd2FpdCB0aGlzLmdldEtleUNoYWluKCk7XG4gICAgICAgIHR5cGVvZiBzIDwgXCJ1XCIgJiYgKHRoaXMua2V5Y2hhaW4gPSBzKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaGFzID0gKHMpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5rZXljaGFpbi5oYXMocykpLCB0aGlzLnNldCA9IGFzeW5jIChzLCByKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5rZXljaGFpbi5zZXQocywgciksIGF3YWl0IHRoaXMucGVyc2lzdCgpO1xuICAgIH0sIHRoaXMuZ2V0ID0gKHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgciA9IHRoaXMua2V5Y2hhaW4uZ2V0KHMpO1xuICAgICAgaWYgKHR5cGVvZiByID4gXCJ1XCIpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBZKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGAke3RoaXMubmFtZX06ICR7c31gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgdGhpcy5kZWwgPSBhc3luYyAocykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMua2V5Y2hhaW4uZGVsZXRlKHMpLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9LCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHN0b3JhZ2VLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByZWZpeCArIHRoaXMudmVyc2lvbiArIFwiLy9cIiArIHRoaXMubmFtZTtcbiAgfVxuICBhc3luYyBzZXRLZXlDaGFpbihlKSB7XG4gICAgYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIExjKGUpKTtcbiAgfVxuICBhc3luYyBnZXRLZXlDaGFpbigpIHtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgIHJldHVybiB0eXBlb2YgZSA8IFwidVwiID8gTWMoZSkgOiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldEtleUNoYWluKHRoaXMua2V5Y2hhaW4pO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IFkoXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbn0sIEYxID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzKSB7XG4gICAgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLm5hbWUgPSBoMSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkIHx8IChhd2FpdCB0aGlzLmtleWNoYWluLmluaXQoKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwKTtcbiAgICB9LCB0aGlzLmhhc0tleXMgPSAocikgPT4gKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmtleWNoYWluLmhhcyhyKSksIHRoaXMuZ2V0Q2xpZW50SWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLmdldENsaWVudFNlZWQoKSwgbiA9IFdzKHIpO1xuICAgICAgcmV0dXJuIGFuKG4ucHVibGljS2V5KTtcbiAgICB9LCB0aGlzLmdlbmVyYXRlS2V5UGFpciA9ICgpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgciA9IHRwKCk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRQcml2YXRlS2V5KHIucHVibGljS2V5LCByLnByaXZhdGVLZXkpO1xuICAgIH0sIHRoaXMuc2lnbkpXVCA9IGFzeW5jIChyKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IG4gPSBhd2FpdCB0aGlzLmdldENsaWVudFNlZWQoKSwgbyA9IFdzKG4pLCBjID0gSHIoKTtcbiAgICAgIHJldHVybiBhd2FpdCBJYyhjLCByLCB1MSwgbyk7XG4gICAgfSwgdGhpcy5nZW5lcmF0ZVNoYXJlZEtleSA9IChyLCBuLCBvKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmdldFByaXZhdGVLZXkociksIHUgPSBpcChjLCBuKTtcbiAgICAgIHJldHVybiB0aGlzLnNldFN5bUtleSh1LCBvKTtcbiAgICB9LCB0aGlzLnNldFN5bUtleSA9IGFzeW5jIChyLCBuKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IG8gPSBuIHx8IHNwKHIpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMua2V5Y2hhaW4uc2V0KG8sIHIpLCBvO1xuICAgIH0sIHRoaXMuZGVsZXRlS2V5UGFpciA9IGFzeW5jIChyKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5rZXljaGFpbi5kZWwocik7XG4gICAgfSwgdGhpcy5kZWxldGVTeW1LZXkgPSBhc3luYyAocikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMua2V5Y2hhaW4uZGVsKHIpO1xuICAgIH0sIHRoaXMuZW5jb2RlID0gYXN5bmMgKHIsIG4sIG8pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgYyA9IFVjKG8pLCB1ID0gcnIobik7XG4gICAgICBpZiAoUm8oYykpIHtcbiAgICAgICAgY29uc3QgeCA9IGMuc2VuZGVyUHVibGljS2V5LCBPID0gYy5yZWNlaXZlclB1YmxpY0tleTtcbiAgICAgICAgciA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVTaGFyZWRLZXkoeCwgTyk7XG4gICAgICB9XG4gICAgICBjb25zdCBkID0gdGhpcy5nZXRTeW1LZXkociksIHsgdHlwZTogcCwgc2VuZGVyUHVibGljS2V5OiBiIH0gPSBjO1xuICAgICAgcmV0dXJuIG5wKHsgdHlwZTogcCwgc3ltS2V5OiBkLCBtZXNzYWdlOiB1LCBzZW5kZXJQdWJsaWNLZXk6IGIgfSk7XG4gICAgfSwgdGhpcy5kZWNvZGUgPSBhc3luYyAociwgbiwgbykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBjID0gY3Aobiwgbyk7XG4gICAgICBpZiAoUm8oYykpIHtcbiAgICAgICAgY29uc3QgdSA9IGMucmVjZWl2ZXJQdWJsaWNLZXksIGQgPSBjLnNlbmRlclB1YmxpY0tleTtcbiAgICAgICAgciA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVTaGFyZWRLZXkodSwgZCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB1ID0gdGhpcy5nZXRTeW1LZXkociksIGQgPSBvcCh7IHN5bUtleTogdSwgZW5jb2RlZDogbiB9KTtcbiAgICAgICAgcmV0dXJuIHJuKGQpO1xuICAgICAgfSBjYXRjaCAodSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGRlY29kZSBtZXNzYWdlIGZyb20gdG9waWM6ICcke3J9JywgY2xpZW50SWQ6ICcke2F3YWl0IHRoaXMuZ2V0Q2xpZW50SWQoKX0nYCksIHRoaXMubG9nZ2VyLmVycm9yKHUpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuZ2V0UGF5bG9hZFR5cGUgPSAocikgPT4ge1xuICAgICAgY29uc3QgbiA9IFlzKHIpO1xuICAgICAgcmV0dXJuIHdzKG4udHlwZSk7XG4gICAgfSwgdGhpcy5nZXRQYXlsb2FkU2VuZGVyUHVibGljS2V5ID0gKHIpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBZcyhyKTtcbiAgICAgIHJldHVybiBuLnNlbmRlclB1YmxpY0tleSA/IE5lKG4uc2VuZGVyUHVibGljS2V5LCB2dCkgOiB2b2lkIDA7XG4gICAgfSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSBlZS5nZW5lcmF0ZUNoaWxkTG9nZ2VyKHQsIHRoaXMubmFtZSksIHRoaXMua2V5Y2hhaW4gPSBzIHx8IG5ldyAkMSh0aGlzLmNvcmUsIHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgYXN5bmMgc2V0UHJpdmF0ZUtleShlLCB0KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMua2V5Y2hhaW4uc2V0KGUsIHQpLCBlO1xuICB9XG4gIGdldFByaXZhdGVLZXkoZSkge1xuICAgIHJldHVybiB0aGlzLmtleWNoYWluLmdldChlKTtcbiAgfVxuICBhc3luYyBnZXRDbGllbnRTZWVkKCkge1xuICAgIGxldCBlID0gXCJcIjtcbiAgICB0cnkge1xuICAgICAgZSA9IHRoaXMua2V5Y2hhaW4uZ2V0KFpvKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGUgPSBIcigpLCBhd2FpdCB0aGlzLmtleWNoYWluLnNldChabywgZSk7XG4gICAgfVxuICAgIHJldHVybiBuMShlLCBcImJhc2UxNlwiKTtcbiAgfVxuICBnZXRTeW1LZXkoZSkge1xuICAgIHJldHVybiB0aGlzLmtleWNoYWluLmdldChlKTtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBZKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG59LCBVMSA9IGNsYXNzIGV4dGVuZHMgZ2wge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCksIHRoaXMubG9nZ2VyID0gZSwgdGhpcy5jb3JlID0gdCwgdGhpcy5tZXNzYWdlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMubmFtZSA9IGYxLCB0aGlzLnZlcnNpb24gPSBwMSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSBoaSwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcyA9IGF3YWl0IHRoaXMuZ2V0UmVsYXllck1lc3NhZ2VzKCk7XG4gICAgICAgICAgdHlwZW9mIHMgPCBcInVcIiAmJiAodGhpcy5tZXNzYWdlcyA9IHMpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIHJlY29yZHMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJyZXN0b3JlXCIsIHNpemU6IHRoaXMubWVzc2FnZXMuc2l6ZSB9KTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGYWlsZWQgdG8gUmVzdG9yZSByZWNvcmRzIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3Iocyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9ICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcy5zZXQgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBuID0gRmkocik7XG4gICAgICBsZXQgbyA9IHRoaXMubWVzc2FnZXMuZ2V0KHMpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBvID4gXCJ1XCIgJiYgKG8gPSB7fSksIHR5cGVvZiBvW25dIDwgXCJ1XCIgfHwgKG9bbl0gPSByLCB0aGlzLm1lc3NhZ2VzLnNldChzLCBvKSwgYXdhaXQgdGhpcy5wZXJzaXN0KCkpLCBuO1xuICAgIH0sIHRoaXMuZ2V0ID0gKHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgbGV0IHIgPSB0aGlzLm1lc3NhZ2VzLmdldChzKTtcbiAgICAgIHJldHVybiB0eXBlb2YgciA+IFwidVwiICYmIChyID0ge30pLCByO1xuICAgIH0sIHRoaXMuaGFzID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgbiA9IHRoaXMuZ2V0KHMpLCBvID0gRmkocik7XG4gICAgICByZXR1cm4gdHlwZW9mIG5bb10gPCBcInVcIjtcbiAgICB9LCB0aGlzLmRlbCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5tZXNzYWdlcy5kZWxldGUocyksIGF3YWl0IHRoaXMucGVyc2lzdCgpO1xuICAgIH0sIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcihlLCB0aGlzLm5hbWUpLCB0aGlzLmNvcmUgPSB0O1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgc3RvcmFnZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJlZml4ICsgdGhpcy52ZXJzaW9uICsgXCIvL1wiICsgdGhpcy5uYW1lO1xuICB9XG4gIGFzeW5jIHNldFJlbGF5ZXJNZXNzYWdlcyhlKSB7XG4gICAgYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIExjKGUpKTtcbiAgfVxuICBhc3luYyBnZXRSZWxheWVyTWVzc2FnZXMoKSB7XG4gICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICByZXR1cm4gdHlwZW9mIGUgPCBcInVcIiA/IE1jKGUpIDogdm9pZCAwO1xuICB9XG4gIGFzeW5jIHBlcnNpc3QoKSB7XG4gICAgYXdhaXQgdGhpcy5zZXRSZWxheWVyTWVzc2FnZXModGhpcy5tZXNzYWdlcyk7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gWShcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxufSwgTDEgPSBjbGFzcyBleHRlbmRzIHlsIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLnJlbGF5ZXIgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMuZXZlbnRzID0gbmV3IFdlLkV2ZW50RW1pdHRlcigpLCB0aGlzLm5hbWUgPSB5MSwgdGhpcy5xdWV1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMucHVibGlzaFRpbWVvdXQgPSBWLnRvTWlsaXNlY29uZHMoVi5URU5fU0VDT05EUyksIHRoaXMubmVlZHNUcmFuc3BvcnRSZXN0YXJ0ID0gITEsIHRoaXMucHVibGlzaCA9IGFzeW5jIChzLCByLCBuKSA9PiB7XG4gICAgICB2YXIgbztcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiUHVibGlzaGluZyBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJwdWJsaXNoXCIsIHBhcmFtczogeyB0b3BpYzogcywgbWVzc2FnZTogciwgb3B0czogbiB9IH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYyA9IG4/LnR0bCB8fCBnMSwgdSA9IEdyKG4pLCBkID0gbj8ucHJvbXB0IHx8ICExLCBwID0gbj8udGFnIHx8IDAsIGIgPSBuPy5pZCB8fCB2bigpLnRvU3RyaW5nKCksIHggPSB7IHRvcGljOiBzLCBtZXNzYWdlOiByLCBvcHRzOiB7IHR0bDogYywgcmVsYXk6IHUsIHByb21wdDogZCwgdGFnOiBwLCBpZDogYiB9IH0sIE8gPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMucXVldWUuc2V0KGIsIHgpLCB0aGlzLnB1Ymxpc2hUaW1lb3V0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBhd2FpdCBkcyh0aGlzLnJwY1B1Ymxpc2gocywgciwgYywgdSwgZCwgcCwgYiksIHRoaXMucHVibGlzaFRpbWVvdXQsIFwiRmFpbGVkIHRvIHB1Ymxpc2ggcGF5bG9hZCwgcGxlYXNlIHRyeSBhZ2Fpbi5cIiksIHRoaXMucmVtb3ZlUmVxdWVzdEZyb21RdWV1ZShiKSwgdGhpcy5yZWxheWVyLmV2ZW50cy5lbWl0KGd0LnB1Ymxpc2gsIHgpO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgaWYgKHRoaXMubG9nZ2VyLmRlYnVnKFwiUHVibGlzaGluZyBQYXlsb2FkIHN0YWxsZWRcIiksIHRoaXMubmVlZHNUcmFuc3BvcnRSZXN0YXJ0ID0gITAsIChvID0gbj8uaW50ZXJuYWwpICE9IG51bGwgJiYgby50aHJvd09uRmFpbGVkUHVibGlzaClcbiAgICAgICAgICAgIHRocm93IHRoaXMucmVtb3ZlUmVxdWVzdEZyb21RdWV1ZShiKSwgXztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KE8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3VjY2Vzc2Z1bGx5IFB1Ymxpc2hlZCBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJwdWJsaXNoXCIsIHBhcmFtczogeyB0b3BpYzogcywgbWVzc2FnZTogciwgb3B0czogbiB9IH0pO1xuICAgICAgfSBjYXRjaCAoYykge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkZhaWxlZCB0byBQdWJsaXNoIFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLmVycm9yKGMpLCBjO1xuICAgICAgfVxuICAgIH0sIHRoaXMub24gPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub24ocywgcik7XG4gICAgfSwgdGhpcy5vbmNlID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uY2Uocywgcik7XG4gICAgfSwgdGhpcy5vZmYgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub2ZmKHMsIHIpO1xuICAgIH0sIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIocywgcik7XG4gICAgfSwgdGhpcy5yZWxheWVyID0gZSwgdGhpcy5sb2dnZXIgPSBlZS5nZW5lcmF0ZUNoaWxkTG9nZ2VyKHQsIHRoaXMubmFtZSksIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBycGNQdWJsaXNoKGUsIHQsIHMsIHIsIG4sIG8sIGMpIHtcbiAgICB2YXIgdSwgZCwgcCwgYjtcbiAgICBjb25zdCB4ID0geyBtZXRob2Q6IGpzKHIucHJvdG9jb2wpLnB1Ymxpc2gsIHBhcmFtczogeyB0b3BpYzogZSwgbWVzc2FnZTogdCwgdHRsOiBzLCBwcm9tcHQ6IG4sIHRhZzogbyB9LCBpZDogYyB9O1xuICAgIHJldHVybiBidCgodSA9IHgucGFyYW1zKSA9PSBudWxsID8gdm9pZCAwIDogdS5wcm9tcHQpICYmICgoZCA9IHgucGFyYW1zKSA9PSBudWxsIHx8IGRlbGV0ZSBkLnByb21wdCksIGJ0KChwID0geC5wYXJhbXMpID09IG51bGwgPyB2b2lkIDAgOiBwLnRhZykgJiYgKChiID0geC5wYXJhbXMpID09IG51bGwgfHwgZGVsZXRlIGIudGFnKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJPdXRnb2luZyBSZWxheSBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWVzc2FnZVwiLCBkaXJlY3Rpb246IFwib3V0Z29pbmdcIiwgcmVxdWVzdDogeCB9KSwgdGhpcy5yZWxheWVyLnJlcXVlc3QoeCk7XG4gIH1cbiAgcmVtb3ZlUmVxdWVzdEZyb21RdWV1ZShlKSB7XG4gICAgdGhpcy5xdWV1ZS5kZWxldGUoZSk7XG4gIH1cbiAgY2hlY2tRdWV1ZSgpIHtcbiAgICB0aGlzLnF1ZXVlLmZvckVhY2goYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHQsIG1lc3NhZ2U6IHMsIG9wdHM6IHIgfSA9IGU7XG4gICAgICBhd2FpdCB0aGlzLnB1Ymxpc2godCwgcywgcik7XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLnJlbGF5ZXIuY29yZS5oZWFydGJlYXQub24oV3QuSEVBUlRCRUFUX0VWRU5UUy5wdWxzZSwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMubmVlZHNUcmFuc3BvcnRSZXN0YXJ0KSB7XG4gICAgICAgIHRoaXMubmVlZHNUcmFuc3BvcnRSZXN0YXJ0ID0gITEsIHRoaXMucmVsYXllci5ldmVudHMuZW1pdChndC5jb25uZWN0aW9uX3N0YWxsZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrUXVldWUoKTtcbiAgICB9KSwgdGhpcy5yZWxheWVyLm9uKGd0Lm1lc3NhZ2VfYWNrLCAoZSkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVSZXF1ZXN0RnJvbVF1ZXVlKGUuaWQudG9TdHJpbmcoKSk7XG4gICAgfSk7XG4gIH1cbn0sIE0xID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuc2V0ID0gKGUsIHQpID0+IHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmdldChlKTtcbiAgICAgIHRoaXMuZXhpc3RzKGUsIHQpIHx8IHRoaXMubWFwLnNldChlLCBbLi4ucywgdF0pO1xuICAgIH0sIHRoaXMuZ2V0ID0gKGUpID0+IHRoaXMubWFwLmdldChlKSB8fCBbXSwgdGhpcy5leGlzdHMgPSAoZSwgdCkgPT4gdGhpcy5nZXQoZSkuaW5jbHVkZXModCksIHRoaXMuZGVsZXRlID0gKGUsIHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdCA+IFwidVwiKSB7XG4gICAgICAgIHRoaXMubWFwLmRlbGV0ZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm1hcC5oYXMoZSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmdldChlKTtcbiAgICAgIGlmICghdGhpcy5leGlzdHMoZSwgdCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHIgPSBzLmZpbHRlcigobikgPT4gbiAhPT0gdCk7XG4gICAgICBpZiAoIXIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubWFwLmRlbGV0ZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXAuc2V0KGUsIHIpO1xuICAgIH0sIHRoaXMuY2xlYXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLm1hcC5jbGVhcigpO1xuICAgIH07XG4gIH1cbiAgZ2V0IHRvcGljcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm1hcC5rZXlzKCkpO1xuICB9XG59O1xudmFyIHExID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBqMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCB6MSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLCBpYSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIEsxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgVjEgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBzYSA9IChpLCBlLCB0KSA9PiBlIGluIGkgPyBxMShpLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaVtlXSA9IHQsIFppID0gKGksIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIEsxLmNhbGwoZSwgdCkgJiYgc2EoaSwgdCwgZVt0XSk7XG4gIGlmIChpYSlcbiAgICBmb3IgKHZhciB0IG9mIGlhKGUpKVxuICAgICAgVjEuY2FsbChlLCB0KSAmJiBzYShpLCB0LCBlW3RdKTtcbiAgcmV0dXJuIGk7XG59LCBQciA9IChpLCBlKSA9PiBqMShpLCB6MShlKSk7XG5sZXQgQjEgPSBjbGFzcyBleHRlbmRzIHdsIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLnJlbGF5ZXIgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMuc3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMudG9waWNNYXAgPSBuZXcgTTEoKSwgdGhpcy5ldmVudHMgPSBuZXcgV2UuRXZlbnRFbWl0dGVyKCksIHRoaXMubmFtZSA9IEQxLCB0aGlzLnZlcnNpb24gPSB4MSwgdGhpcy5wZW5kaW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25XYXRjaExhYmVsID0gXCJwZW5kaW5nX3N1Yl93YXRjaF9sYWJlbFwiLCB0aGlzLnBvbGxpbmdJbnRlcnZhbCA9IDIwLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSBoaSwgdGhpcy5zdWJzY3JpYmVUaW1lb3V0ID0gMWU0LCB0aGlzLnJlc3RhcnRJblByb2dyZXNzID0gITEsIHRoaXMuYmF0Y2hTdWJzY3JpYmVUb3BpY3NMaW1pdCA9IDUwMCwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAodGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKSwgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCksIHRoaXMuY2xpZW50SWQgPSBhd2FpdCB0aGlzLnJlbGF5ZXIuY29yZS5jcnlwdG8uZ2V0Q2xpZW50SWQoKSk7XG4gICAgfSwgdGhpcy5zdWJzY3JpYmUgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VG9Db21wbGV0ZSgpLCB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJTdWJzY3JpYmluZyBUb3BpY1wiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwic3Vic2NyaWJlXCIsIHBhcmFtczogeyB0b3BpYzogcywgb3B0czogciB9IH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbiA9IEdyKHIpLCBvID0geyB0b3BpYzogcywgcmVsYXk6IG4gfTtcbiAgICAgICAgdGhpcy5wZW5kaW5nLnNldChzLCBvKTtcbiAgICAgICAgY29uc3QgYyA9IGF3YWl0IHRoaXMucnBjU3Vic2NyaWJlKHMsIG4pO1xuICAgICAgICByZXR1cm4gdGhpcy5vblN1YnNjcmliZShjLCBvKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJTdWNjZXNzZnVsbHkgU3Vic2NyaWJlZCBUb3BpY1wiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwic3Vic2NyaWJlXCIsIHBhcmFtczogeyB0b3BpYzogcywgb3B0czogciB9IH0pLCBjO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkZhaWxlZCB0byBTdWJzY3JpYmUgVG9waWNcIiksIHRoaXMubG9nZ2VyLmVycm9yKG4pLCBuO1xuICAgICAgfVxuICAgIH0sIHRoaXMudW5zdWJzY3JpYmUgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VG9Db21wbGV0ZSgpLCB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdHlwZW9mIHI/LmlkIDwgXCJ1XCIgPyBhd2FpdCB0aGlzLnVuc3Vic2NyaWJlQnlJZChzLCByLmlkLCByKSA6IGF3YWl0IHRoaXMudW5zdWJzY3JpYmVCeVRvcGljKHMsIHIpO1xuICAgIH0sIHRoaXMuaXNTdWJzY3JpYmVkID0gYXN5bmMgKHMpID0+IHRoaXMudG9waWNzLmluY2x1ZGVzKHMpID8gITAgOiBhd2FpdCBuZXcgUHJvbWlzZSgociwgbikgPT4ge1xuICAgICAgY29uc3QgbyA9IG5ldyBWLldhdGNoKCk7XG4gICAgICBvLnN0YXJ0KHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbldhdGNoTGFiZWwpO1xuICAgICAgY29uc3QgYyA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgIXRoaXMucGVuZGluZy5oYXMocykgJiYgdGhpcy50b3BpY3MuaW5jbHVkZXMocykgJiYgKGNsZWFySW50ZXJ2YWwoYyksIG8uc3RvcCh0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25XYXRjaExhYmVsKSwgcighMCkpLCBvLmVsYXBzZWQodGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9uV2F0Y2hMYWJlbCkgPj0gTzEgJiYgKGNsZWFySW50ZXJ2YWwoYyksIG8uc3RvcCh0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25XYXRjaExhYmVsKSwgbihuZXcgRXJyb3IoXCJTdWJzY3JpcHRpb24gcmVzb2x1dGlvbiB0aW1lb3V0XCIpKSk7XG4gICAgICB9LCB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgfSkuY2F0Y2goKCkgPT4gITEpLCB0aGlzLm9uID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uKHMsIHIpO1xuICAgIH0sIHRoaXMub25jZSA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbmNlKHMsIHIpO1xuICAgIH0sIHRoaXMub2ZmID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9mZihzLCByKTtcbiAgICB9LCB0aGlzLnJlbW92ZUxpc3RlbmVyID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKHMsIHIpO1xuICAgIH0sIHRoaXMucmVzdGFydCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMucmVzdGFydEluUHJvZ3Jlc3MgPSAhMCwgYXdhaXQgdGhpcy5yZXN0b3JlKCksIGF3YWl0IHRoaXMucmVzZXQoKSwgdGhpcy5yZXN0YXJ0SW5Qcm9ncmVzcyA9ICExO1xuICAgIH0sIHRoaXMucmVsYXllciA9IGUsIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLmNsaWVudElkID0gXCJcIjtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHN0b3JhZ2VLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByZWZpeCArIHRoaXMudmVyc2lvbiArIFwiLy9cIiArIHRoaXMubmFtZTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbnMuc2l6ZTtcbiAgfVxuICBnZXQgaWRzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3Vic2NyaXB0aW9ucy5rZXlzKCkpO1xuICB9XG4gIGdldCB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdWJzY3JpcHRpb25zLnZhbHVlcygpKTtcbiAgfVxuICBnZXQgdG9waWNzKCkge1xuICAgIHJldHVybiB0aGlzLnRvcGljTWFwLnRvcGljcztcbiAgfVxuICBoYXNTdWJzY3JpcHRpb24oZSwgdCkge1xuICAgIGxldCBzID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIHMgPSB0aGlzLmdldFN1YnNjcmlwdGlvbihlKS50b3BpYyA9PT0gdDtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgb25FbmFibGUoKSB7XG4gICAgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICEwO1xuICB9XG4gIG9uRGlzYWJsZSgpIHtcbiAgICB0aGlzLmNhY2hlZCA9IHRoaXMudmFsdWVzLCB0aGlzLnN1YnNjcmlwdGlvbnMuY2xlYXIoKSwgdGhpcy50b3BpY01hcC5jbGVhcigpO1xuICB9XG4gIGFzeW5jIHVuc3Vic2NyaWJlQnlUb3BpYyhlLCB0KSB7XG4gICAgY29uc3QgcyA9IHRoaXMudG9waWNNYXAuZ2V0KGUpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHMubWFwKGFzeW5jIChyKSA9PiBhd2FpdCB0aGlzLnVuc3Vic2NyaWJlQnlJZChlLCByLCB0KSkpO1xuICB9XG4gIGFzeW5jIHVuc3Vic2NyaWJlQnlJZChlLCB0LCBzKSB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJVbnN1YnNjcmliaW5nIFRvcGljXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJ1bnN1YnNjcmliZVwiLCBwYXJhbXM6IHsgdG9waWM6IGUsIGlkOiB0LCBvcHRzOiBzIH0gfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHIgPSBHcihzKTtcbiAgICAgIGF3YWl0IHRoaXMucnBjVW5zdWJzY3JpYmUoZSwgdCwgcik7XG4gICAgICBjb25zdCBuID0gbnQoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiLCBgJHt0aGlzLm5hbWV9LCAke2V9YCk7XG4gICAgICBhd2FpdCB0aGlzLm9uVW5zdWJzY3JpYmUoZSwgdCwgbiksIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3VjY2Vzc2Z1bGx5IFVuc3Vic2NyaWJlZCBUb3BpY1wiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwidW5zdWJzY3JpYmVcIiwgcGFyYW1zOiB7IHRvcGljOiBlLCBpZDogdCwgb3B0czogcyB9IH0pO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIHRocm93IHRoaXMubG9nZ2VyLmRlYnVnKFwiRmFpbGVkIHRvIFVuc3Vic2NyaWJlIFRvcGljXCIpLCB0aGlzLmxvZ2dlci5lcnJvcihyKSwgcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcnBjU3Vic2NyaWJlKGUsIHQpIHtcbiAgICBjb25zdCBzID0geyBtZXRob2Q6IGpzKHQucHJvdG9jb2wpLnN1YnNjcmliZSwgcGFyYW1zOiB7IHRvcGljOiBlIH0gfTtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIk91dGdvaW5nIFJlbGF5IFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJwYXlsb2FkXCIsIGRpcmVjdGlvbjogXCJvdXRnb2luZ1wiLCByZXF1ZXN0OiBzIH0pO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhd2FpdCBkcyh0aGlzLnJlbGF5ZXIucmVxdWVzdChzKSwgdGhpcy5zdWJzY3JpYmVUaW1lb3V0KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiT3V0Z29pbmcgUmVsYXkgU3Vic2NyaWJlIFBheWxvYWQgc3RhbGxlZFwiKSwgdGhpcy5yZWxheWVyLmV2ZW50cy5lbWl0KGd0LmNvbm5lY3Rpb25fc3RhbGxlZCk7XG4gICAgfVxuICAgIHJldHVybiBGaShlICsgdGhpcy5jbGllbnRJZCk7XG4gIH1cbiAgYXN5bmMgcnBjQmF0Y2hTdWJzY3JpYmUoZSkge1xuICAgIGlmICghZS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGVbMF0ucmVsYXksIHMgPSB7IG1ldGhvZDoganModC5wcm90b2NvbCkuYmF0Y2hTdWJzY3JpYmUsIHBhcmFtczogeyB0b3BpY3M6IGUubWFwKChyKSA9PiByLnRvcGljKSB9IH07XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJPdXRnb2luZyBSZWxheSBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwicGF5bG9hZFwiLCBkaXJlY3Rpb246IFwib3V0Z29pbmdcIiwgcmVxdWVzdDogcyB9KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGF3YWl0IGRzKHRoaXMucmVsYXllci5yZXF1ZXN0KHMpLCB0aGlzLnN1YnNjcmliZVRpbWVvdXQpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJPdXRnb2luZyBSZWxheSBQYXlsb2FkIHN0YWxsZWRcIiksIHRoaXMucmVsYXllci5ldmVudHMuZW1pdChndC5jb25uZWN0aW9uX3N0YWxsZWQpO1xuICAgIH1cbiAgfVxuICBycGNVbnN1YnNjcmliZShlLCB0LCBzKSB7XG4gICAgY29uc3QgciA9IHsgbWV0aG9kOiBqcyhzLnByb3RvY29sKS51bnN1YnNjcmliZSwgcGFyYW1zOiB7IHRvcGljOiBlLCBpZDogdCB9IH07XG4gICAgcmV0dXJuIHRoaXMubG9nZ2VyLmRlYnVnKFwiT3V0Z29pbmcgUmVsYXkgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcInBheWxvYWRcIiwgZGlyZWN0aW9uOiBcIm91dGdvaW5nXCIsIHJlcXVlc3Q6IHIgfSksIHRoaXMucmVsYXllci5yZXF1ZXN0KHIpO1xuICB9XG4gIG9uU3Vic2NyaWJlKGUsIHQpIHtcbiAgICB0aGlzLnNldFN1YnNjcmlwdGlvbihlLCBQcihaaSh7fSwgdCksIHsgaWQ6IGUgfSkpLCB0aGlzLnBlbmRpbmcuZGVsZXRlKHQudG9waWMpO1xuICB9XG4gIG9uQmF0Y2hTdWJzY3JpYmUoZSkge1xuICAgIGUubGVuZ3RoICYmIGUuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdWJzY3JpcHRpb24odC5pZCwgWmkoe30sIHQpKSwgdGhpcy5wZW5kaW5nLmRlbGV0ZSh0LnRvcGljKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBvblVuc3Vic2NyaWJlKGUsIHQsIHMpIHtcbiAgICB0aGlzLmV2ZW50cy5yZW1vdmVBbGxMaXN0ZW5lcnModCksIHRoaXMuaGFzU3Vic2NyaXB0aW9uKHQsIGUpICYmIHRoaXMuZGVsZXRlU3Vic2NyaXB0aW9uKHQsIHMpLCBhd2FpdCB0aGlzLnJlbGF5ZXIubWVzc2FnZXMuZGVsKGUpO1xuICB9XG4gIGFzeW5jIHNldFJlbGF5ZXJTdWJzY3JpcHRpb25zKGUpIHtcbiAgICBhd2FpdCB0aGlzLnJlbGF5ZXIuY29yZS5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBlKTtcbiAgfVxuICBhc3luYyBnZXRSZWxheWVyU3Vic2NyaXB0aW9ucygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWxheWVyLmNvcmUuc3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gIH1cbiAgc2V0U3Vic2NyaXB0aW9uKGUsIHQpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuaGFzKGUpIHx8ICh0aGlzLmxvZ2dlci5kZWJ1ZyhcIlNldHRpbmcgc3Vic2NyaXB0aW9uXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJzZXRTdWJzY3JpcHRpb25cIiwgaWQ6IGUsIHN1YnNjcmlwdGlvbjogdCB9KSwgdGhpcy5hZGRTdWJzY3JpcHRpb24oZSwgdCkpO1xuICB9XG4gIGFkZFN1YnNjcmlwdGlvbihlLCB0KSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChlLCBaaSh7fSwgdCkpLCB0aGlzLnRvcGljTWFwLnNldCh0LnRvcGljLCBlKSwgdGhpcy5ldmVudHMuZW1pdChWdC5jcmVhdGVkLCB0KTtcbiAgfVxuICBnZXRTdWJzY3JpcHRpb24oZSkge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiR2V0dGluZyBzdWJzY3JpcHRpb25cIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcImdldFN1YnNjcmlwdGlvblwiLCBpZDogZSB9KTtcbiAgICBjb25zdCB0ID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChlKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogcyB9ID0gWShcIk5PX01BVENISU5HX0tFWVwiLCBgJHt0aGlzLm5hbWV9OiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iocyk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIGRlbGV0ZVN1YnNjcmlwdGlvbihlLCB0KSB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJEZWxldGluZyBzdWJzY3JpcHRpb25cIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcImRlbGV0ZVN1YnNjcmlwdGlvblwiLCBpZDogZSwgcmVhc29uOiB0IH0pO1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldFN1YnNjcmlwdGlvbihlKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKGUpLCB0aGlzLnRvcGljTWFwLmRlbGV0ZShzLnRvcGljLCBlKSwgdGhpcy5ldmVudHMuZW1pdChWdC5kZWxldGVkLCBQcihaaSh7fSwgcyksIHsgcmVhc29uOiB0IH0pKTtcbiAgfVxuICBhc3luYyBwZXJzaXN0KCkge1xuICAgIGF3YWl0IHRoaXMuc2V0UmVsYXllclN1YnNjcmlwdGlvbnModGhpcy52YWx1ZXMpLCB0aGlzLmV2ZW50cy5lbWl0KFZ0LnN5bmMpO1xuICB9XG4gIGFzeW5jIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLmNhY2hlZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGUgPSBNYXRoLmNlaWwodGhpcy5jYWNoZWQubGVuZ3RoIC8gdGhpcy5iYXRjaFN1YnNjcmliZVRvcGljc0xpbWl0KTtcbiAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZTsgdCsrKSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLmNhY2hlZC5zcGxpY2UoMCwgdGhpcy5iYXRjaFN1YnNjcmliZVRvcGljc0xpbWl0KTtcbiAgICAgICAgYXdhaXQgdGhpcy5iYXRjaFN1YnNjcmliZShzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ldmVudHMuZW1pdChWdC5yZXN1YnNjcmliZWQpO1xuICB9XG4gIGFzeW5jIHJlc3RvcmUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmdldFJlbGF5ZXJTdWJzY3JpcHRpb25zKCk7XG4gICAgICBpZiAodHlwZW9mIGUgPiBcInVcIiB8fCAhZS5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMuc2l6ZSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IFkoXCJSRVNUT1JFX1dJTExfT1ZFUlJJREVcIiwgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3IodCksIHRoaXMubG9nZ2VyLmVycm9yKGAke3RoaXMubmFtZX06ICR7SlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZXMpfWApLCBuZXcgRXJyb3IodCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlZCA9IGUsIHRoaXMubG9nZ2VyLmRlYnVnKGBTdWNjZXNzZnVsbHkgUmVzdG9yZWQgc3Vic2NyaXB0aW9ucyBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInJlc3RvcmVcIiwgc3Vic2NyaXB0aW9uczogdGhpcy52YWx1ZXMgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBSZXN0b3JlIHN1YnNjcmlwdGlvbnMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci5lcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYmF0Y2hTdWJzY3JpYmUoZSkge1xuICAgIGlmICghZS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGF3YWl0IHRoaXMucnBjQmF0Y2hTdWJzY3JpYmUoZSk7XG4gICAgRXModCkgJiYgdGhpcy5vbkJhdGNoU3Vic2NyaWJlKHQubWFwKChzLCByKSA9PiBQcihaaSh7fSwgZVtyXSksIHsgaWQ6IHMgfSkpKTtcbiAgfVxuICBhc3luYyBvbkNvbm5lY3QoKSB7XG4gICAgdGhpcy5yZXN0YXJ0SW5Qcm9ncmVzcyB8fCAoYXdhaXQgdGhpcy5yZXN0YXJ0KCksIHRoaXMub25FbmFibGUoKSk7XG4gIH1cbiAgb25EaXNjb25uZWN0KCkge1xuICAgIHRoaXMub25EaXNhYmxlKCk7XG4gIH1cbiAgYXN5bmMgY2hlY2tQZW5kaW5nKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCB8fCB0aGlzLnJlbGF5ZXIudHJhbnNwb3J0RXhwbGljaXRseUNsb3NlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gW107XG4gICAgdGhpcy5wZW5kaW5nLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGUucHVzaCh0KTtcbiAgICB9KSwgYXdhaXQgdGhpcy5iYXRjaFN1YnNjcmliZShlKTtcbiAgfVxuICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMucmVsYXllci5jb3JlLmhlYXJ0YmVhdC5vbihXdC5IRUFSVEJFQVRfRVZFTlRTLnB1bHNlLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmNoZWNrUGVuZGluZygpO1xuICAgIH0pLCB0aGlzLnJlbGF5ZXIub24oZ3QuY29ubmVjdCwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5vbkNvbm5lY3QoKTtcbiAgICB9KSwgdGhpcy5yZWxheWVyLm9uKGd0LmRpc2Nvbm5lY3QsICgpID0+IHtcbiAgICAgIHRoaXMub25EaXNjb25uZWN0KCk7XG4gICAgfSksIHRoaXMuZXZlbnRzLm9uKFZ0LmNyZWF0ZWQsIGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gVnQuY3JlYXRlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCBkYXRhOiBlIH0pLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KSwgdGhpcy5ldmVudHMub24oVnQuZGVsZXRlZCwgYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBWdC5kZWxldGVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIGRhdGE6IGUgfSksIGF3YWl0IHRoaXMucGVyc2lzdCgpO1xuICAgIH0pO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IFkoXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVzdGFydFRvQ29tcGxldGUoKSB7XG4gICAgdGhpcy5yZXN0YXJ0SW5Qcm9ncmVzcyAmJiBhd2FpdCBuZXcgUHJvbWlzZSgoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0SW5Qcm9ncmVzcyB8fCAoY2xlYXJJbnRlcnZhbCh0KSwgZSgpKTtcbiAgICAgIH0sIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBrMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgcmEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBIMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIEcxID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgbmEgPSAoaSwgZSwgdCkgPT4gZSBpbiBpID8gazEoaSwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IGlbZV0gPSB0LCBXMSA9IChpLCBlKSA9PiB7XG4gIGZvciAodmFyIHQgaW4gZSB8fCAoZSA9IHt9KSlcbiAgICBIMS5jYWxsKGUsIHQpICYmIG5hKGksIHQsIGVbdF0pO1xuICBpZiAocmEpXG4gICAgZm9yICh2YXIgdCBvZiByYShlKSlcbiAgICAgIEcxLmNhbGwoZSwgdCkgJiYgbmEoaSwgdCwgZVt0XSk7XG4gIHJldHVybiBpO1xufTtcbmxldCBZMSA9IGNsYXNzIGV4dGVuZHMgbWwge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSksIHRoaXMucHJvdG9jb2wgPSBcIndjXCIsIHRoaXMudmVyc2lvbiA9IDIsIHRoaXMuZXZlbnRzID0gbmV3IFdlLkV2ZW50RW1pdHRlcigpLCB0aGlzLm5hbWUgPSBiMSwgdGhpcy50cmFuc3BvcnRFeHBsaWNpdGx5Q2xvc2VkID0gITEsIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5jb25uZWN0aW9uQXR0ZW1wdEluUHJvZ3Jlc3MgPSAhMSwgdGhpcy5jb25uZWN0aW9uU3RhdHVzUG9sbGluZ0ludGVydmFsID0gMjAsIHRoaXMuc3RhbGVDb25uZWN0aW9uRXJyb3JzID0gW1wic29ja2V0IGhhbmcgdXBcIiwgXCJzb2NrZXQgc3RhbGxlZFwiXSwgdGhpcy5oYXNFeHBlcmllbmNlZE5ldHdvcmtEaXNydXB0aW9uID0gITEsIHRoaXMucmVxdWVzdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlB1Ymxpc2hpbmcgUmVxdWVzdCBQYXlsb2FkXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudG9Fc3RhYmxpc2hDb25uZWN0aW9uKCksIGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh0KTtcbiAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZGVidWcoXCJGYWlsZWQgdG8gUHVibGlzaCBSZXF1ZXN0XCIpLCB0aGlzLmxvZ2dlci5lcnJvcihzKSwgcztcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uUGF5bG9hZEhhbmRsZXIgPSAodCkgPT4ge1xuICAgICAgdGhpcy5vblByb3ZpZGVyUGF5bG9hZCh0KTtcbiAgICB9LCB0aGlzLm9uQ29ubmVjdEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5lbWl0KGd0LmNvbm5lY3QpO1xuICAgIH0sIHRoaXMub25EaXNjb25uZWN0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHRoaXMub25Qcm92aWRlckRpc2Nvbm5lY3QoKTtcbiAgICB9LCB0aGlzLm9uUHJvdmlkZXJFcnJvckhhbmRsZXIgPSAodCkgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IodCksIHRoaXMuZXZlbnRzLmVtaXQoZ3QuZXJyb3IsIHQpLCB0aGlzLmxvZ2dlci5pbmZvKFwiRmF0YWwgc29ja2V0IGVycm9yIHJlY2VpdmVkLCBjbG9zaW5nIHRyYW5zcG9ydFwiKSwgdGhpcy50cmFuc3BvcnRDbG9zZSgpO1xuICAgIH0sIHRoaXMucmVnaXN0ZXJQcm92aWRlckxpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgIHRoaXMucHJvdmlkZXIub24oWnQucGF5bG9hZCwgdGhpcy5vblBheWxvYWRIYW5kbGVyKSwgdGhpcy5wcm92aWRlci5vbihadC5jb25uZWN0LCB0aGlzLm9uQ29ubmVjdEhhbmRsZXIpLCB0aGlzLnByb3ZpZGVyLm9uKFp0LmRpc2Nvbm5lY3QsIHRoaXMub25EaXNjb25uZWN0SGFuZGxlciksIHRoaXMucHJvdmlkZXIub24oWnQuZXJyb3IsIHRoaXMub25Qcm92aWRlckVycm9ySGFuZGxlcik7XG4gICAgfSwgdGhpcy5jb3JlID0gZS5jb3JlLCB0aGlzLmxvZ2dlciA9IHR5cGVvZiBlLmxvZ2dlciA8IFwidVwiICYmIHR5cGVvZiBlLmxvZ2dlciAhPSBcInN0cmluZ1wiID8gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcihlLmxvZ2dlciwgdGhpcy5uYW1lKSA6IGVlLnBpbm8oZWUuZ2V0RGVmYXVsdExvZ2dlck9wdGlvbnMoeyBsZXZlbDogZS5sb2dnZXIgfHwgbTEgfSkpLCB0aGlzLm1lc3NhZ2VzID0gbmV3IFUxKHRoaXMubG9nZ2VyLCBlLmNvcmUpLCB0aGlzLnN1YnNjcmliZXIgPSBuZXcgQjEodGhpcywgdGhpcy5sb2dnZXIpLCB0aGlzLnB1Ymxpc2hlciA9IG5ldyBMMSh0aGlzLCB0aGlzLmxvZ2dlciksIHRoaXMucmVsYXlVcmwgPSBlPy5yZWxheVVybCB8fCBoaCwgdGhpcy5wcm9qZWN0SWQgPSBlLnByb2plY3RJZCwgdGhpcy5wcm92aWRlciA9IHt9O1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKSwgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCksIGF3YWl0IHRoaXMuY3JlYXRlUHJvdmlkZXIoKSwgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMubWVzc2FnZXMuaW5pdCgpLCB0aGlzLnN1YnNjcmliZXIuaW5pdCgpXSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0T3BlbigpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgQ29ubmVjdGlvbiB2aWEgJHt0aGlzLnJlbGF5VXJsfSBmYWlsZWQsIGF0dGVtcHRpbmcgdG8gY29ubmVjdCB2aWEgZmFpbG92ZXIgZG9tYWluICR7ZWF9Li4uYCksIGF3YWl0IHRoaXMucmVzdGFydFRyYW5zcG9ydChlYSk7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCwgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmliZXIudG9waWNzLmxlbmd0aCA9PT0gMCAmJiAodGhpcy5sb2dnZXIuaW5mbyhcIk5vIHRvcGljcyBzdWJzY3JpYmVkIHRvIGFmdGVyIGluaXQsIGNsb3NpbmcgdHJhbnNwb3J0XCIpLCBhd2FpdCB0aGlzLnRyYW5zcG9ydENsb3NlKCksIHRoaXMudHJhbnNwb3J0RXhwbGljaXRseUNsb3NlZCA9ICExKTtcbiAgICB9LCBFMSk7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuY29ubmVjdGlvbi5jb25uZWN0ZWQ7XG4gIH1cbiAgZ2V0IGNvbm5lY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuY29ubmVjdGlvbi5jb25uZWN0aW5nO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goZSwgdCwgcykge1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoKGUsIHQsIHMpLCBhd2FpdCB0aGlzLnJlY29yZE1lc3NhZ2VFdmVudCh7IHRvcGljOiBlLCBtZXNzYWdlOiB0LCBwdWJsaXNoZWRBdDogRGF0ZS5ub3coKSB9KTtcbiAgfVxuICBhc3luYyBzdWJzY3JpYmUoZSwgdCkge1xuICAgIHZhciBzO1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgIGxldCByID0gKChzID0gdGhpcy5zdWJzY3JpYmVyLnRvcGljTWFwLmdldChlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHNbMF0pIHx8IFwiXCI7XG4gICAgcmV0dXJuIHIgfHwgKGF3YWl0IFByb21pc2UuYWxsKFtuZXcgUHJvbWlzZSgobikgPT4ge1xuICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uY2UoVnQuY3JlYXRlZCwgKG8pID0+IHtcbiAgICAgICAgby50b3BpYyA9PT0gZSAmJiBuKCk7XG4gICAgICB9KTtcbiAgICB9KSwgbmV3IFByb21pc2UoYXN5bmMgKG4pID0+IHtcbiAgICAgIHIgPSBhd2FpdCB0aGlzLnN1YnNjcmliZXIuc3Vic2NyaWJlKGUsIHQpLCBuKCk7XG4gICAgfSldKSwgcik7XG4gIH1cbiAgYXN5bmMgdW5zdWJzY3JpYmUoZSwgdCkge1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLnN1YnNjcmliZXIudW5zdWJzY3JpYmUoZSwgdCk7XG4gIH1cbiAgb24oZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uKGUsIHQpO1xuICB9XG4gIG9uY2UoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uY2UoZSwgdCk7XG4gIH1cbiAgb2ZmKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vZmYoZSwgdCk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGUsIHQpO1xuICB9XG4gIGFzeW5jIHRyYW5zcG9ydENsb3NlKCkge1xuICAgIHRoaXMudHJhbnNwb3J0RXhwbGljaXRseUNsb3NlZCA9ICEwLCB0aGlzLmhhc0V4cGVyaWVuY2VkTmV0d29ya0Rpc3J1cHRpb24gJiYgdGhpcy5jb25uZWN0ZWQgPyBhd2FpdCBkcyh0aGlzLnByb3ZpZGVyLmRpc2Nvbm5lY3QoKSwgMWUzLCBcInByb3ZpZGVyLmRpc2Nvbm5lY3QoKVwiKS5jYXRjaCgoKSA9PiB0aGlzLm9uUHJvdmlkZXJEaXNjb25uZWN0KCkpIDogdGhpcy5jb25uZWN0ZWQgJiYgYXdhaXQgdGhpcy5wcm92aWRlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgYXN5bmMgdHJhbnNwb3J0T3BlbihlKSB7XG4gICAgaWYgKHRoaXMudHJhbnNwb3J0RXhwbGljaXRseUNsb3NlZCA9ICExLCBhd2FpdCB0aGlzLmNvbmZpcm1PbmxpbmVTdGF0ZU9yVGhyb3coKSwgIXRoaXMuY29ubmVjdGlvbkF0dGVtcHRJblByb2dyZXNzKSB7XG4gICAgICBlICYmIGUgIT09IHRoaXMucmVsYXlVcmwgJiYgKHRoaXMucmVsYXlVcmwgPSBlLCBhd2FpdCB0aGlzLnRyYW5zcG9ydENsb3NlKCksIGF3YWl0IHRoaXMuY3JlYXRlUHJvdmlkZXIoKSksIHRoaXMuY29ubmVjdGlvbkF0dGVtcHRJblByb2dyZXNzID0gITA7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbbmV3IFByb21pc2UoKHQpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpXG4gICAgICAgICAgICByZXR1cm4gdCgpO1xuICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5vbmNlKFZ0LnJlc3Vic2NyaWJlZCwgKCkgPT4ge1xuICAgICAgICAgICAgdCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgbmV3IFByb21pc2UoYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZHModGhpcy5wcm92aWRlci5jb25uZWN0KCksIDFlNCwgYFNvY2tldCBzdGFsbGVkIHdoZW4gdHJ5aW5nIHRvIGNvbm5lY3QgdG8gJHt0aGlzLnJlbGF5VXJsfWApO1xuICAgICAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgICAgIHMocik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHQoKTtcbiAgICAgICAgfSldKTtcbiAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IodCk7XG4gICAgICAgIGNvbnN0IHMgPSB0O1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0aW9uU3RhbGxlZChzLm1lc3NhZ2UpKVxuICAgICAgICAgIHRocm93IHQ7XG4gICAgICAgIHRoaXMucHJvdmlkZXIuZXZlbnRzLmVtaXQoWnQuZGlzY29ubmVjdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0SW5Qcm9ncmVzcyA9ICExLCB0aGlzLmhhc0V4cGVyaWVuY2VkTmV0d29ya0Rpc3J1cHRpb24gPSAhMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVzdGFydFRyYW5zcG9ydChlKSB7XG4gICAgYXdhaXQgdGhpcy5jb25maXJtT25saW5lU3RhdGVPclRocm93KCksICF0aGlzLmNvbm5lY3Rpb25BdHRlbXB0SW5Qcm9ncmVzcyAmJiAodGhpcy5yZWxheVVybCA9IGUgfHwgdGhpcy5yZWxheVVybCwgYXdhaXQgdGhpcy50cmFuc3BvcnRDbG9zZSgpLCBhd2FpdCB0aGlzLmNyZWF0ZVByb3ZpZGVyKCksIGF3YWl0IHRoaXMudHJhbnNwb3J0T3BlbigpKTtcbiAgfVxuICBhc3luYyBjb25maXJtT25saW5lU3RhdGVPclRocm93KCkge1xuICAgIGlmICghYXdhaXQgam8oKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGludGVybmV0IGNvbm5lY3Rpb24gZGV0ZWN0ZWQuIFBsZWFzZSByZXN0YXJ0IHlvdXIgbmV0d29yayBhbmQgdHJ5IGFnYWluLlwiKTtcbiAgfVxuICBpc0Nvbm5lY3Rpb25TdGFsbGVkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFsZUNvbm5lY3Rpb25FcnJvcnMuc29tZSgodCkgPT4gZS5pbmNsdWRlcyh0KSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlUHJvdmlkZXIoKSB7XG4gICAgdGhpcy5wcm92aWRlci5jb25uZWN0aW9uICYmIHRoaXMudW5yZWdpc3RlclByb3ZpZGVyTGlzdGVuZXJzKCk7XG4gICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uc2lnbkpXVCh0aGlzLnJlbGF5VXJsKTtcbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IF9uKG5ldyBXYyh3cCh7IHNka1ZlcnNpb246IF8xLCBwcm90b2NvbDogdGhpcy5wcm90b2NvbCwgdmVyc2lvbjogdGhpcy52ZXJzaW9uLCByZWxheVVybDogdGhpcy5yZWxheVVybCwgcHJvamVjdElkOiB0aGlzLnByb2plY3RJZCwgYXV0aDogZSwgdXNlT25DbG9zZUV2ZW50OiAhMCB9KSkpLCB0aGlzLnJlZ2lzdGVyUHJvdmlkZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBhc3luYyByZWNvcmRNZXNzYWdlRXZlbnQoZSkge1xuICAgIGNvbnN0IHsgdG9waWM6IHQsIG1lc3NhZ2U6IHMgfSA9IGU7XG4gICAgYXdhaXQgdGhpcy5tZXNzYWdlcy5zZXQodCwgcyk7XG4gIH1cbiAgYXN5bmMgc2hvdWxkSWdub3JlTWVzc2FnZUV2ZW50KGUpIHtcbiAgICBjb25zdCB7IHRvcGljOiB0LCBtZXNzYWdlOiBzIH0gPSBlO1xuICAgIGlmICghcyB8fCBzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxvZ2dlci5kZWJ1ZyhgSWdub3JpbmcgaW52YWxpZC9lbXB0eSBtZXNzYWdlOiAke3N9YCksICEwO1xuICAgIGlmICghYXdhaXQgdGhpcy5zdWJzY3JpYmVyLmlzU3Vic2NyaWJlZCh0KSlcbiAgICAgIHJldHVybiB0aGlzLmxvZ2dlci5kZWJ1ZyhgSWdub3JpbmcgbWVzc2FnZSBmb3Igbm9uLXN1YnNjcmliZWQgdG9waWMgJHt0fWApLCAhMDtcbiAgICBjb25zdCByID0gdGhpcy5tZXNzYWdlcy5oYXModCwgcyk7XG4gICAgcmV0dXJuIHIgJiYgdGhpcy5sb2dnZXIuZGVidWcoYElnbm9yaW5nIGR1cGxpY2F0ZSBtZXNzYWdlOiAke3N9YCksIHI7XG4gIH1cbiAgYXN5bmMgb25Qcm92aWRlclBheWxvYWQoZSkge1xuICAgIGlmICh0aGlzLmxvZ2dlci5kZWJ1ZyhcIkluY29taW5nIFJlbGF5IFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJwYXlsb2FkXCIsIGRpcmVjdGlvbjogXCJpbmNvbWluZ1wiLCBwYXlsb2FkOiBlIH0pLCBqaShlKSkge1xuICAgICAgaWYgKCFlLm1ldGhvZC5lbmRzV2l0aCh3MSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHQgPSBlLnBhcmFtcywgeyB0b3BpYzogcywgbWVzc2FnZTogciwgcHVibGlzaGVkQXQ6IG4gfSA9IHQuZGF0YSwgbyA9IHsgdG9waWM6IHMsIG1lc3NhZ2U6IHIsIHB1Ymxpc2hlZEF0OiBuIH07XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkVtaXR0aW5nIFJlbGF5ZXIgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoVzEoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LmlkIH0sIG8pKSwgdGhpcy5ldmVudHMuZW1pdCh0LmlkLCBvKSwgYXdhaXQgdGhpcy5hY2tub3dsZWRnZVBheWxvYWQoZSksIGF3YWl0IHRoaXMub25NZXNzYWdlRXZlbnQobyk7XG4gICAgfSBlbHNlXG4gICAgICBPaShlKSAmJiB0aGlzLmV2ZW50cy5lbWl0KGd0Lm1lc3NhZ2VfYWNrLCBlKTtcbiAgfVxuICBhc3luYyBvbk1lc3NhZ2VFdmVudChlKSB7XG4gICAgYXdhaXQgdGhpcy5zaG91bGRJZ25vcmVNZXNzYWdlRXZlbnQoZSkgfHwgKHRoaXMuZXZlbnRzLmVtaXQoZ3QubWVzc2FnZSwgZSksIGF3YWl0IHRoaXMucmVjb3JkTWVzc2FnZUV2ZW50KGUpKTtcbiAgfVxuICBhc3luYyBhY2tub3dsZWRnZVBheWxvYWQoZSkge1xuICAgIGNvbnN0IHQgPSB4aShlLmlkLCAhMCk7XG4gICAgYXdhaXQgdGhpcy5wcm92aWRlci5jb25uZWN0aW9uLnNlbmQodCk7XG4gIH1cbiAgdW5yZWdpc3RlclByb3ZpZGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMucHJvdmlkZXIub2ZmKFp0LnBheWxvYWQsIHRoaXMub25QYXlsb2FkSGFuZGxlciksIHRoaXMucHJvdmlkZXIub2ZmKFp0LmNvbm5lY3QsIHRoaXMub25Db25uZWN0SGFuZGxlciksIHRoaXMucHJvdmlkZXIub2ZmKFp0LmRpc2Nvbm5lY3QsIHRoaXMub25EaXNjb25uZWN0SGFuZGxlciksIHRoaXMucHJvdmlkZXIub2ZmKFp0LmVycm9yLCB0aGlzLm9uUHJvdmlkZXJFcnJvckhhbmRsZXIpO1xuICB9XG4gIGFzeW5jIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5ldmVudHMub24oZ3QuY29ubmVjdGlvbl9zdGFsbGVkLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlc3RhcnRUcmFuc3BvcnQoKS5jYXRjaCgodCkgPT4gdGhpcy5sb2dnZXIuZXJyb3IodCkpO1xuICAgIH0pO1xuICAgIGxldCBlID0gYXdhaXQgam8oKTtcbiAgICBsZyhhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCAmJiBlICE9PSB0ICYmIChlID0gdCwgdCA/IGF3YWl0IHRoaXMucmVzdGFydFRyYW5zcG9ydCgpLmNhdGNoKChzKSA9PiB0aGlzLmxvZ2dlci5lcnJvcihzKSkgOiAodGhpcy5oYXNFeHBlcmllbmNlZE5ldHdvcmtEaXNydXB0aW9uID0gITAsIGF3YWl0IHRoaXMudHJhbnNwb3J0Q2xvc2UoKS5jYXRjaCgocykgPT4gdGhpcy5sb2dnZXIuZXJyb3IocykpKSk7XG4gICAgfSk7XG4gIH1cbiAgb25Qcm92aWRlckRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5ldmVudHMuZW1pdChndC5kaXNjb25uZWN0KSwgdGhpcy5hdHRlbXB0VG9SZWNvbm5lY3QoKTtcbiAgfVxuICBhdHRlbXB0VG9SZWNvbm5lY3QoKSB7XG4gICAgdGhpcy50cmFuc3BvcnRFeHBsaWNpdGx5Q2xvc2VkIHx8ICh0aGlzLmxvZ2dlci5pbmZvKFwiYXR0ZW1wdFRvUmVjb25uZWN0IGNhbGxlZC4gQ29ubmVjdGluZy4uLlwiKSwgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLnJlc3RhcnRUcmFuc3BvcnQoKS5jYXRjaCgoZSkgPT4gdGhpcy5sb2dnZXIuZXJyb3IoZSkpO1xuICAgIH0sIFYudG9NaWxpc2Vjb25kcyh2MSkpKTtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBZKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHRvRXN0YWJsaXNoQ29ubmVjdGlvbigpIHtcbiAgICBpZiAoYXdhaXQgdGhpcy5jb25maXJtT25saW5lU3RhdGVPclRocm93KCksICF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbkF0dGVtcHRJblByb2dyZXNzKVxuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKGUpID0+IHtcbiAgICAgICAgICBjb25zdCB0ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgJiYgKGNsZWFySW50ZXJ2YWwodCksIGUoKSk7XG4gICAgICAgICAgfSwgdGhpcy5jb25uZWN0aW9uU3RhdHVzUG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgfSk7XG4gICAgICBhd2FpdCB0aGlzLnJlc3RhcnRUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgSjEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIG9hID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgUTEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBYMSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIGFhID0gKGksIGUsIHQpID0+IGUgaW4gaSA/IEoxKGksIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBpW2VdID0gdCwgY2EgPSAoaSwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgUTEuY2FsbChlLCB0KSAmJiBhYShpLCB0LCBlW3RdKTtcbiAgaWYgKG9hKVxuICAgIGZvciAodmFyIHQgb2Ygb2EoZSkpXG4gICAgICBYMS5jYWxsKGUsIHQpICYmIGFhKGksIHQsIGVbdF0pO1xuICByZXR1cm4gaTtcbn07XG5sZXQgZHIgPSBjbGFzcyBleHRlbmRzIGJsIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcywgciA9IGhpLCBuID0gdm9pZCAwKSB7XG4gICAgc3VwZXIoZSwgdCwgcywgciksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5uYW1lID0gcywgdGhpcy5tYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnZlcnNpb24gPSBTMSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSBoaSwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAodGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKSwgYXdhaXQgdGhpcy5yZXN0b3JlKCksIHRoaXMuY2FjaGVkLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgdGhpcy5nZXRLZXkgJiYgbyAhPT0gbnVsbCAmJiAhYnQobykgPyB0aGlzLm1hcC5zZXQodGhpcy5nZXRLZXkobyksIG8pIDogS3AobykgPyB0aGlzLm1hcC5zZXQoby5pZCwgbykgOiBWcChvKSAmJiB0aGlzLm1hcC5zZXQoby50b3BpYywgbyk7XG4gICAgICB9KSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICEwKTtcbiAgICB9LCB0aGlzLnNldCA9IGFzeW5jIChvLCBjKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5tYXAuaGFzKG8pID8gYXdhaXQgdGhpcy51cGRhdGUobywgYykgOiAodGhpcy5sb2dnZXIuZGVidWcoXCJTZXR0aW5nIHZhbHVlXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJzZXRcIiwga2V5OiBvLCB2YWx1ZTogYyB9KSwgdGhpcy5tYXAuc2V0KG8sIGMpLCBhd2FpdCB0aGlzLnBlcnNpc3QoKSk7XG4gICAgfSwgdGhpcy5nZXQgPSAobykgPT4gKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkdldHRpbmcgdmFsdWVcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcImdldFwiLCBrZXk6IG8gfSksIHRoaXMuZ2V0RGF0YShvKSksIHRoaXMuZ2V0QWxsID0gKG8pID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgbyA/IHRoaXMudmFsdWVzLmZpbHRlcigoYykgPT4gT2JqZWN0LmtleXMobykuZXZlcnkoKHUpID0+IFljKGNbdV0sIG9bdV0pKSkgOiB0aGlzLnZhbHVlcyksIHRoaXMudXBkYXRlID0gYXN5bmMgKG8sIGMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlVwZGF0aW5nIHZhbHVlXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJ1cGRhdGVcIiwga2V5OiBvLCB1cGRhdGU6IGMgfSk7XG4gICAgICBjb25zdCB1ID0gY2EoY2Eoe30sIHRoaXMuZ2V0RGF0YShvKSksIGMpO1xuICAgICAgdGhpcy5tYXAuc2V0KG8sIHUpLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9LCB0aGlzLmRlbGV0ZSA9IGFzeW5jIChvLCBjKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5tYXAuaGFzKG8pICYmICh0aGlzLmxvZ2dlci5kZWJ1ZyhcIkRlbGV0aW5nIHZhbHVlXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJkZWxldGVcIiwga2V5OiBvLCByZWFzb246IGMgfSksIHRoaXMubWFwLmRlbGV0ZShvKSwgYXdhaXQgdGhpcy5wZXJzaXN0KCkpO1xuICAgIH0sIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSByLCB0aGlzLmdldEtleSA9IG47XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBzdG9yYWdlS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQcmVmaXggKyB0aGlzLnZlcnNpb24gKyBcIi8vXCIgKyB0aGlzLm5hbWU7XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuc2l6ZTtcbiAgfVxuICBnZXQga2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm1hcC5rZXlzKCkpO1xuICB9XG4gIGdldCB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tYXAudmFsdWVzKCkpO1xuICB9XG4gIGFzeW5jIHNldERhdGFTdG9yZShlKSB7XG4gICAgYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIGUpO1xuICB9XG4gIGFzeW5jIGdldERhdGFTdG9yZSgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICB9XG4gIGdldERhdGEoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm1hcC5nZXQoZSk7XG4gICAgaWYgKCF0KSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHMgfSA9IFkoXCJOT19NQVRDSElOR19LRVlcIiwgYCR7dGhpcy5uYW1lfTogJHtlfWApO1xuICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3IocyksIG5ldyBFcnJvcihzKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldERhdGFTdG9yZSh0aGlzLnZhbHVlcyk7XG4gIH1cbiAgYXN5bmMgcmVzdG9yZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuZ2V0RGF0YVN0b3JlKCk7XG4gICAgICBpZiAodHlwZW9mIGUgPiBcInVcIiB8fCAhZS5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzLm1hcC5zaXplKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gWShcIlJFU1RPUkVfV0lMTF9PVkVSUklERVwiLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcih0KSwgbmV3IEVycm9yKHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZWQgPSBlLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIHZhbHVlIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicmVzdG9yZVwiLCB2YWx1ZTogdGhpcy52YWx1ZXMgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBSZXN0b3JlIHZhbHVlIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IFkoXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbn0sIFoxID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLm5hbWUgPSBOMSwgdGhpcy52ZXJzaW9uID0gUDEsIHRoaXMuZXZlbnRzID0gbmV3IGlyKCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5zdG9yYWdlUHJlZml4ID0gaGksIHRoaXMuaWdub3JlZFBheWxvYWRUeXBlcyA9IFtEaV0sIHRoaXMucmVnaXN0ZXJlZE1ldGhvZHMgPSBbXSwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAoYXdhaXQgdGhpcy5wYWlyaW5ncy5pbml0KCksIGF3YWl0IHRoaXMuY2xlYW51cCgpLCB0aGlzLnJlZ2lzdGVyUmVsYXllckV2ZW50cygpLCB0aGlzLnJlZ2lzdGVyRXhwaXJlckV2ZW50cygpLCB0aGlzLmluaXRpYWxpemVkID0gITAsIHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIikpO1xuICAgIH0sIHRoaXMucmVnaXN0ZXIgPSAoeyBtZXRob2RzOiBzIH0pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLnJlZ2lzdGVyZWRNZXRob2RzID0gWy4uLi8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi50aGlzLnJlZ2lzdGVyZWRNZXRob2RzLCAuLi5zXSldO1xuICAgIH0sIHRoaXMuY3JlYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBzID0gSHIoKSwgciA9IGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uc2V0U3ltS2V5KHMpLCBuID0gTXQoVi5GSVZFX01JTlVURVMpLCBvID0geyBwcm90b2NvbDogY2ggfSwgYyA9IHsgdG9waWM6IHIsIGV4cGlyeTogbiwgcmVsYXk6IG8sIGFjdGl2ZTogITEgfSwgdSA9IEFwKHsgcHJvdG9jb2w6IHRoaXMuY29yZS5wcm90b2NvbCwgdmVyc2lvbjogdGhpcy5jb3JlLnZlcnNpb24sIHRvcGljOiByLCBzeW1LZXk6IHMsIHJlbGF5OiBvIH0pO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucGFpcmluZ3Muc2V0KHIsIGMpLCBhd2FpdCB0aGlzLmNvcmUucmVsYXllci5zdWJzY3JpYmUociksIHRoaXMuY29yZS5leHBpcmVyLnNldChyLCBuKSwgeyB0b3BpYzogciwgdXJpOiB1IH07XG4gICAgfSwgdGhpcy5wYWlyID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmlzVmFsaWRQYWlyKHMpO1xuICAgICAgY29uc3QgeyB0b3BpYzogciwgc3ltS2V5OiBuLCByZWxheTogbyB9ID0gUHAocy51cmkpO1xuICAgICAgbGV0IGM7XG4gICAgICBpZiAodGhpcy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHIpICYmIChjID0gdGhpcy5wYWlyaW5ncy5nZXQociksIGMuYWN0aXZlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYWlyaW5nIGFscmVhZHkgZXhpc3RzOiAke3J9LiBQbGVhc2UgdHJ5IGFnYWluIHdpdGggYSBuZXcgY29ubmVjdGlvbiBVUkkuYCk7XG4gICAgICB0aGlzLmNvcmUuY3J5cHRvLmtleWNoYWluLmhhcyhyKSB8fCAoYXdhaXQgdGhpcy5jb3JlLmNyeXB0by5zZXRTeW1LZXkobiwgciksIGF3YWl0IHRoaXMuY29yZS5yZWxheWVyLnN1YnNjcmliZShyLCB7IHJlbGF5OiBvIH0pKTtcbiAgICAgIGNvbnN0IHUgPSBNdChWLkZJVkVfTUlOVVRFUyksIGQgPSB7IHRvcGljOiByLCByZWxheTogbywgZXhwaXJ5OiB1LCBhY3RpdmU6ICExIH07XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5wYWlyaW5ncy5zZXQociwgZCksIHRoaXMuY29yZS5leHBpcmVyLnNldChyLCB1KSwgcy5hY3RpdmF0ZVBhaXJpbmcgJiYgYXdhaXQgdGhpcy5hY3RpdmF0ZSh7IHRvcGljOiByIH0pLCB0aGlzLmV2ZW50cy5lbWl0KG9zLmNyZWF0ZSwgZCksIGQ7XG4gICAgfSwgdGhpcy5hY3RpdmF0ZSA9IGFzeW5jICh7IHRvcGljOiBzIH0pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgciA9IE10KFYuVEhJUlRZX0RBWVMpO1xuICAgICAgYXdhaXQgdGhpcy5wYWlyaW5ncy51cGRhdGUocywgeyBhY3RpdmU6ICEwLCBleHBpcnk6IHIgfSksIHRoaXMuY29yZS5leHBpcmVyLnNldChzLCByKTtcbiAgICB9LCB0aGlzLnBpbmcgPSBhc3luYyAocykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZFBpbmcocyk7XG4gICAgICBjb25zdCB7IHRvcGljOiByIH0gPSBzO1xuICAgICAgaWYgKHRoaXMucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhyKSkge1xuICAgICAgICBjb25zdCBuID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChyLCBcIndjX3BhaXJpbmdQaW5nXCIsIHt9KSwgeyBkb25lOiBvLCByZXNvbHZlOiBjLCByZWplY3Q6IHUgfSA9IEFpKCk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uY2UoQmUoXCJwYWlyaW5nX3BpbmdcIiwgbiksICh7IGVycm9yOiBkIH0pID0+IHtcbiAgICAgICAgICBkID8gdShkKSA6IGMoKTtcbiAgICAgICAgfSksIGF3YWl0IG8oKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnVwZGF0ZUV4cGlyeSA9IGFzeW5jICh7IHRvcGljOiBzLCBleHBpcnk6IHIgfSkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMucGFpcmluZ3MudXBkYXRlKHMsIHsgZXhwaXJ5OiByIH0pO1xuICAgIH0sIHRoaXMudXBkYXRlTWV0YWRhdGEgPSBhc3luYyAoeyB0b3BpYzogcywgbWV0YWRhdGE6IHIgfSkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMucGFpcmluZ3MudXBkYXRlKHMsIHsgcGVlck1ldGFkYXRhOiByIH0pO1xuICAgIH0sIHRoaXMuZ2V0UGFpcmluZ3MgPSAoKSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMucGFpcmluZ3MudmFsdWVzKSwgdGhpcy5kaXNjb25uZWN0ID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWREaXNjb25uZWN0KHMpO1xuICAgICAgY29uc3QgeyB0b3BpYzogciB9ID0gcztcbiAgICAgIHRoaXMucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyhyKSAmJiAoYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChyLCBcIndjX3BhaXJpbmdEZWxldGVcIiwgbnQoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSksIGF3YWl0IHRoaXMuZGVsZXRlUGFpcmluZyhyKSk7XG4gICAgfSwgdGhpcy5zZW5kUmVxdWVzdCA9IGFzeW5jIChzLCByLCBuKSA9PiB7XG4gICAgICBjb25zdCBvID0gdGkociwgbiksIGMgPSBhd2FpdCB0aGlzLmNvcmUuY3J5cHRvLmVuY29kZShzLCBvKSwgdSA9IFhpW3JdLnJlcTtcbiAgICAgIHJldHVybiB0aGlzLmNvcmUuaGlzdG9yeS5zZXQocywgbyksIHRoaXMuY29yZS5yZWxheWVyLnB1Ymxpc2gocywgYywgdSksIG8uaWQ7XG4gICAgfSwgdGhpcy5zZW5kUmVzdWx0ID0gYXN5bmMgKHMsIHIsIG4pID0+IHtcbiAgICAgIGNvbnN0IG8gPSB4aShzLCBuKSwgYyA9IGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uZW5jb2RlKHIsIG8pLCB1ID0gYXdhaXQgdGhpcy5jb3JlLmhpc3RvcnkuZ2V0KHIsIHMpLCBkID0gWGlbdS5yZXF1ZXN0Lm1ldGhvZF0ucmVzO1xuICAgICAgYXdhaXQgdGhpcy5jb3JlLnJlbGF5ZXIucHVibGlzaChyLCBjLCBkKSwgYXdhaXQgdGhpcy5jb3JlLmhpc3RvcnkucmVzb2x2ZShvKTtcbiAgICB9LCB0aGlzLnNlbmRFcnJvciA9IGFzeW5jIChzLCByLCBuKSA9PiB7XG4gICAgICBjb25zdCBvID0gcWkocywgbiksIGMgPSBhd2FpdCB0aGlzLmNvcmUuY3J5cHRvLmVuY29kZShyLCBvKSwgdSA9IGF3YWl0IHRoaXMuY29yZS5oaXN0b3J5LmdldChyLCBzKSwgZCA9IFhpW3UucmVxdWVzdC5tZXRob2RdID8gWGlbdS5yZXF1ZXN0Lm1ldGhvZF0ucmVzIDogWGkudW5yZWdpc3RlcmVkX21ldGhvZC5yZXM7XG4gICAgICBhd2FpdCB0aGlzLmNvcmUucmVsYXllci5wdWJsaXNoKHIsIGMsIGQpLCBhd2FpdCB0aGlzLmNvcmUuaGlzdG9yeS5yZXNvbHZlKG8pO1xuICAgIH0sIHRoaXMuZGVsZXRlUGFpcmluZyA9IGFzeW5jIChzLCByKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmNvcmUucmVsYXllci51bnN1YnNjcmliZShzKSwgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucGFpcmluZ3MuZGVsZXRlKHMsIG50KFwiVVNFUl9ESVNDT05ORUNURURcIikpLCB0aGlzLmNvcmUuY3J5cHRvLmRlbGV0ZVN5bUtleShzKSwgciA/IFByb21pc2UucmVzb2x2ZSgpIDogdGhpcy5jb3JlLmV4cGlyZXIuZGVsKHMpXSk7XG4gICAgfSwgdGhpcy5jbGVhbnVwID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcyA9IHRoaXMucGFpcmluZ3MuZ2V0QWxsKCkuZmlsdGVyKChyKSA9PiBhaShyLmV4cGlyeSkpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocy5tYXAoKHIpID0+IHRoaXMuZGVsZXRlUGFpcmluZyhyLnRvcGljKSkpO1xuICAgIH0sIHRoaXMub25SZWxheUV2ZW50UmVxdWVzdCA9IChzKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiByLCBwYXlsb2FkOiBuIH0gPSBzO1xuICAgICAgc3dpdGNoIChuLm1ldGhvZCkge1xuICAgICAgICBjYXNlIFwid2NfcGFpcmluZ1BpbmdcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblBhaXJpbmdQaW5nUmVxdWVzdChyLCBuKTtcbiAgICAgICAgY2FzZSBcIndjX3BhaXJpbmdEZWxldGVcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblBhaXJpbmdEZWxldGVSZXF1ZXN0KHIsIG4pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uVW5rbm93blJwY01ldGhvZFJlcXVlc3Qociwgbik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblJlbGF5RXZlbnRSZXNwb25zZSA9IGFzeW5jIChzKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiByLCBwYXlsb2FkOiBuIH0gPSBzLCBvID0gKGF3YWl0IHRoaXMuY29yZS5oaXN0b3J5LmdldChyLCBuLmlkKSkucmVxdWVzdC5tZXRob2Q7XG4gICAgICBzd2l0Y2ggKG8pIHtcbiAgICAgICAgY2FzZSBcIndjX3BhaXJpbmdQaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25QYWlyaW5nUGluZ1Jlc3BvbnNlKHIsIG4pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uVW5rbm93blJwY01ldGhvZFJlc3BvbnNlKG8pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25QYWlyaW5nUGluZ1JlcXVlc3QgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgY29uc3QgeyBpZDogbiB9ID0gcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZFBpbmcoeyB0b3BpYzogcyB9KSwgYXdhaXQgdGhpcy5zZW5kUmVzdWx0KG4sIHMsICEwKSwgdGhpcy5ldmVudHMuZW1pdChvcy5waW5nLCB7IGlkOiBuLCB0b3BpYzogcyB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IobiwgcywgbyksIHRoaXMubG9nZ2VyLmVycm9yKG8pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25QYWlyaW5nUGluZ1Jlc3BvbnNlID0gKHMsIHIpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IG4gfSA9IHI7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaHQocikgPyB0aGlzLmV2ZW50cy5lbWl0KEJlKFwicGFpcmluZ19waW5nXCIsIG4pLCB7fSkgOiBHZShyKSAmJiB0aGlzLmV2ZW50cy5lbWl0KEJlKFwicGFpcmluZ19waW5nXCIsIG4pLCB7IGVycm9yOiByLmVycm9yIH0pO1xuICAgICAgfSwgNTAwKTtcbiAgICB9LCB0aGlzLm9uUGFpcmluZ0RlbGV0ZVJlcXVlc3QgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgY29uc3QgeyBpZDogbiB9ID0gcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZERpc2Nvbm5lY3QoeyB0b3BpYzogcyB9KSwgYXdhaXQgdGhpcy5kZWxldGVQYWlyaW5nKHMpLCB0aGlzLmV2ZW50cy5lbWl0KG9zLmRlbGV0ZSwgeyBpZDogbiwgdG9waWM6IHMgfSk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKG4sIHMsIG8pLCB0aGlzLmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uVW5rbm93blJwY01ldGhvZFJlcXVlc3QgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgY29uc3QgeyBpZDogbiwgbWV0aG9kOiBvIH0gPSByO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlZE1ldGhvZHMuaW5jbHVkZXMobykpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjID0gbnQoXCJXQ19NRVRIT0RfVU5TVVBQT1JURURcIiwgbyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKG4sIHMsIGMpLCB0aGlzLmxvZ2dlci5lcnJvcihjKTtcbiAgICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IobiwgcywgYyksIHRoaXMubG9nZ2VyLmVycm9yKGMpO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25Vbmtub3duUnBjTWV0aG9kUmVzcG9uc2UgPSAocykgPT4ge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkTWV0aG9kcy5pbmNsdWRlcyhzKSB8fCB0aGlzLmxvZ2dlci5lcnJvcihudChcIldDX01FVEhPRF9VTlNVUFBPUlRFRFwiLCBzKSk7XG4gICAgfSwgdGhpcy5pc1ZhbGlkUGFpciA9IChzKSA9PiB7XG4gICAgICBpZiAoIVN0KHMpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogciB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcGFpcigpIHBhcmFtczogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgICBpZiAoIXpwKHMudXJpKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHIgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHBhaXIoKSB1cmk6ICR7cy51cml9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzVmFsaWRQaW5nID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIGlmICghU3QocykpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwaW5nKCkgcGFyYW1zOiAke3N9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IHIgfSA9IHM7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRQYWlyaW5nVG9waWMocik7XG4gICAgfSwgdGhpcy5pc1ZhbGlkRGlzY29ubmVjdCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICBpZiAoIVN0KHMpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZGlzY29ubmVjdCgpIHBhcmFtczogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiByIH0gPSBzO1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkUGFpcmluZ1RvcGljKHIpO1xuICAgIH0sIHRoaXMuaXNWYWxpZFBhaXJpbmdUb3BpYyA9IGFzeW5jIChzKSA9PiB7XG4gICAgICBpZiAoIW90KHMsICExKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHIgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHBhaXJpbmcgdG9waWMgc2hvdWxkIGJlIGEgc3RyaW5nOiAke3N9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHMpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogciB9ID0gWShcIk5PX01BVENISU5HX0tFWVwiLCBgcGFpcmluZyB0b3BpYyBkb2Vzbid0IGV4aXN0OiAke3N9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgICAgIH1cbiAgICAgIGlmIChhaSh0aGlzLnBhaXJpbmdzLmdldChzKS5leHBpcnkpKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZGVsZXRlUGFpcmluZyhzKTtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiByIH0gPSBZKFwiRVhQSVJFRFwiLCBgcGFpcmluZyB0b3BpYzogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSBlZS5nZW5lcmF0ZUNoaWxkTG9nZ2VyKHQsIHRoaXMubmFtZSksIHRoaXMucGFpcmluZ3MgPSBuZXcgZHIodGhpcy5jb3JlLCB0aGlzLmxvZ2dlciwgdGhpcy5uYW1lLCB0aGlzLnN0b3JhZ2VQcmVmaXgpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBZKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyUmVsYXllckV2ZW50cygpIHtcbiAgICB0aGlzLmNvcmUucmVsYXllci5vbihndC5tZXNzYWdlLCBhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogdCwgbWVzc2FnZTogcyB9ID0gZTtcbiAgICAgIGlmICghdGhpcy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHQpIHx8IHRoaXMuaWdub3JlZFBheWxvYWRUeXBlcy5pbmNsdWRlcyh0aGlzLmNvcmUuY3J5cHRvLmdldFBheWxvYWRUeXBlKHMpKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uZGVjb2RlKHQsIHMpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgamkocikgPyAodGhpcy5jb3JlLmhpc3Rvcnkuc2V0KHQsIHIpLCB0aGlzLm9uUmVsYXlFdmVudFJlcXVlc3QoeyB0b3BpYzogdCwgcGF5bG9hZDogciB9KSkgOiBPaShyKSAmJiAoYXdhaXQgdGhpcy5jb3JlLmhpc3RvcnkucmVzb2x2ZShyKSwgYXdhaXQgdGhpcy5vblJlbGF5RXZlbnRSZXNwb25zZSh7IHRvcGljOiB0LCBwYXlsb2FkOiByIH0pLCB0aGlzLmNvcmUuaGlzdG9yeS5kZWxldGUodCwgci5pZCkpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZWdpc3RlckV4cGlyZXJFdmVudHMoKSB7XG4gICAgdGhpcy5jb3JlLmV4cGlyZXIub24oVHQuZXhwaXJlZCwgYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHQgfSA9IGpjKGUudGFyZ2V0KTtcbiAgICAgIHQgJiYgdGhpcy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHQpICYmIChhd2FpdCB0aGlzLmRlbGV0ZVBhaXJpbmcodCwgITApLCB0aGlzLmV2ZW50cy5lbWl0KG9zLmV4cGlyZSwgeyB0b3BpYzogdCB9KSk7XG4gICAgfSk7XG4gIH1cbn0sIGVtID0gY2xhc3MgZXh0ZW5kcyBwbCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLnJlY29yZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5uYW1lID0gUjEsIHRoaXMudmVyc2lvbiA9IEMxLCB0aGlzLmNhY2hlZCA9IFtdLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuc3RvcmFnZVByZWZpeCA9IGhpLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkIHx8ICh0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpLCBhd2FpdCB0aGlzLnJlc3RvcmUoKSwgdGhpcy5jYWNoZWQuZm9yRWFjaCgocykgPT4gdGhpcy5yZWNvcmRzLnNldChzLmlkLCBzKSksIHRoaXMuY2FjaGVkID0gW10sIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLmluaXRpYWxpemVkID0gITApO1xuICAgIH0sIHRoaXMuc2V0ID0gKHMsIHIsIG4pID0+IHtcbiAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJTZXR0aW5nIEpTT04tUlBDIHJlcXVlc3QgaGlzdG9yeSByZWNvcmRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInNldFwiLCB0b3BpYzogcywgcmVxdWVzdDogciwgY2hhaW5JZDogbiB9KSwgdGhpcy5yZWNvcmRzLmhhcyhyLmlkKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbyA9IHsgaWQ6IHIuaWQsIHRvcGljOiBzLCByZXF1ZXN0OiB7IG1ldGhvZDogci5tZXRob2QsIHBhcmFtczogci5wYXJhbXMgfHwgbnVsbCB9LCBjaGFpbklkOiBuLCBleHBpcnk6IE10KFYuVEhJUlRZX0RBWVMpIH07XG4gICAgICB0aGlzLnJlY29yZHMuc2V0KG8uaWQsIG8pLCB0aGlzLmV2ZW50cy5lbWl0KHp0LmNyZWF0ZWQsIG8pO1xuICAgIH0sIHRoaXMucmVzb2x2ZSA9IGFzeW5jIChzKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubG9nZ2VyLmRlYnVnKFwiVXBkYXRpbmcgSlNPTi1SUEMgcmVzcG9uc2UgaGlzdG9yeSByZWNvcmRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInVwZGF0ZVwiLCByZXNwb25zZTogcyB9KSwgIXRoaXMucmVjb3Jkcy5oYXMocy5pZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLmdldFJlY29yZChzLmlkKTtcbiAgICAgIHR5cGVvZiByLnJlc3BvbnNlID4gXCJ1XCIgJiYgKHIucmVzcG9uc2UgPSBHZShzKSA/IHsgZXJyb3I6IHMuZXJyb3IgfSA6IHsgcmVzdWx0OiBzLnJlc3VsdCB9LCB0aGlzLnJlY29yZHMuc2V0KHIuaWQsIHIpLCB0aGlzLmV2ZW50cy5lbWl0KHp0LnVwZGF0ZWQsIHIpKTtcbiAgICB9LCB0aGlzLmdldCA9IGFzeW5jIChzLCByKSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubG9nZ2VyLmRlYnVnKFwiR2V0dGluZyByZWNvcmRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcImdldFwiLCB0b3BpYzogcywgaWQ6IHIgfSksIGF3YWl0IHRoaXMuZ2V0UmVjb3JkKHIpKSwgdGhpcy5kZWxldGUgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMubG9nZ2VyLmRlYnVnKFwiRGVsZXRpbmcgcmVjb3JkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJkZWxldGVcIiwgaWQ6IHIgfSksIHRoaXMudmFsdWVzLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgaWYgKG4udG9waWMgPT09IHMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHIgPCBcInVcIiAmJiBuLmlkICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHRoaXMucmVjb3Jkcy5kZWxldGUobi5pZCksIHRoaXMuZXZlbnRzLmVtaXQoenQuZGVsZXRlZCwgbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHRoaXMuZXhpc3RzID0gYXN5bmMgKHMsIHIpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5yZWNvcmRzLmhhcyhyKSA/IChhd2FpdCB0aGlzLmdldFJlY29yZChyKSkudG9waWMgPT09IHMgOiAhMSksIHRoaXMub24gPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub24ocywgcik7XG4gICAgfSwgdGhpcy5vbmNlID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uY2Uocywgcik7XG4gICAgfSwgdGhpcy5vZmYgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub2ZmKHMsIHIpO1xuICAgIH0sIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIocywgcik7XG4gICAgfSwgdGhpcy5sb2dnZXIgPSBlZS5nZW5lcmF0ZUNoaWxkTG9nZ2VyKHQsIHRoaXMubmFtZSk7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBzdG9yYWdlS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQcmVmaXggKyB0aGlzLnZlcnNpb24gKyBcIi8vXCIgKyB0aGlzLm5hbWU7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb3Jkcy5zaXplO1xuICB9XG4gIGdldCBrZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVjb3Jkcy5rZXlzKCkpO1xuICB9XG4gIGdldCB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWNvcmRzLnZhbHVlcygpKTtcbiAgfVxuICBnZXQgcGVuZGluZygpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdC5yZXNwb25zZSA8IFwidVwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBzID0geyB0b3BpYzogdC50b3BpYywgcmVxdWVzdDogdGkodC5yZXF1ZXN0Lm1ldGhvZCwgdC5yZXF1ZXN0LnBhcmFtcywgdC5pZCksIGNoYWluSWQ6IHQuY2hhaW5JZCB9O1xuICAgICAgcmV0dXJuIGUucHVzaChzKTtcbiAgICB9KSwgZTtcbiAgfVxuICBhc3luYyBzZXRKc29uUnBjUmVjb3JkcyhlKSB7XG4gICAgYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIGUpO1xuICB9XG4gIGFzeW5jIGdldEpzb25ScGNSZWNvcmRzKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gIH1cbiAgZ2V0UmVjb3JkKGUpIHtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5yZWNvcmRzLmdldChlKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogcyB9ID0gWShcIk5PX01BVENISU5HX0tFWVwiLCBgJHt0aGlzLm5hbWV9OiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iocyk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIGFzeW5jIHBlcnNpc3QoKSB7XG4gICAgYXdhaXQgdGhpcy5zZXRKc29uUnBjUmVjb3Jkcyh0aGlzLnZhbHVlcyksIHRoaXMuZXZlbnRzLmVtaXQoenQuc3luYyk7XG4gIH1cbiAgYXN5bmMgcmVzdG9yZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuZ2V0SnNvblJwY1JlY29yZHMoKTtcbiAgICAgIGlmICh0eXBlb2YgZSA+IFwidVwiIHx8ICFlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMucmVjb3Jkcy5zaXplKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gWShcIlJFU1RPUkVfV0lMTF9PVkVSUklERVwiLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcih0KSwgbmV3IEVycm9yKHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZWQgPSBlLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIHJlY29yZHMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJyZXN0b3JlXCIsIHJlY29yZHM6IHRoaXMudmFsdWVzIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGYWlsZWQgdG8gUmVzdG9yZSByZWNvcmRzIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5ldmVudHMub24oenQuY3JlYXRlZCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB6dC5jcmVhdGVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIHJlY29yZDogZSB9KSwgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSksIHRoaXMuZXZlbnRzLm9uKHp0LnVwZGF0ZWQsIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0genQudXBkYXRlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCByZWNvcmQ6IGUgfSksIHRoaXMucGVyc2lzdCgpO1xuICAgIH0pLCB0aGlzLmV2ZW50cy5vbih6dC5kZWxldGVkLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IHp0LmRlbGV0ZWQ7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFbWl0dGluZyAke3R9YCksIHRoaXMubG9nZ2VyLmRlYnVnKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdCwgcmVjb3JkOiBlIH0pLCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KSwgdGhpcy5jb3JlLmhlYXJ0YmVhdC5vbihXdC5IRUFSVEJFQVRfRVZFTlRTLnB1bHNlLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9KTtcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlY29yZHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICBWLnRvTWlsaXNlY29uZHMoZS5leHBpcnkgfHwgMCkgLSBEYXRlLm5vdygpIDw9IDAgJiYgKHRoaXMubG9nZ2VyLmluZm8oYERlbGV0aW5nIGV4cGlyZWQgaGlzdG9yeSBsb2c6ICR7ZS5pZH1gKSwgdGhpcy5kZWxldGUoZS50b3BpYywgZS5pZCkpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihlKTtcbiAgICB9XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gWShcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxufSwgdG0gPSBjbGFzcyBleHRlbmRzIHZsIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMuZXhwaXJhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5uYW1lID0gQTEsIHRoaXMudmVyc2lvbiA9IFQxLCB0aGlzLmNhY2hlZCA9IFtdLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuc3RvcmFnZVByZWZpeCA9IGhpLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkIHx8ICh0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpLCBhd2FpdCB0aGlzLnJlc3RvcmUoKSwgdGhpcy5jYWNoZWQuZm9yRWFjaCgocykgPT4gdGhpcy5leHBpcmF0aW9ucy5zZXQocy50YXJnZXQsIHMpKSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCk7XG4gICAgfSwgdGhpcy5oYXMgPSAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuZm9ybWF0VGFyZ2V0KHMpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuZ2V0RXhwaXJhdGlvbihyKSA8IFwidVwiO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnNldCA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmZvcm1hdFRhcmdldChzKSwgbyA9IHsgdGFyZ2V0OiBuLCBleHBpcnk6IHIgfTtcbiAgICAgIHRoaXMuZXhwaXJhdGlvbnMuc2V0KG4sIG8pLCB0aGlzLmNoZWNrRXhwaXJ5KG4sIG8pLCB0aGlzLmV2ZW50cy5lbWl0KFR0LmNyZWF0ZWQsIHsgdGFyZ2V0OiBuLCBleHBpcmF0aW9uOiBvIH0pO1xuICAgIH0sIHRoaXMuZ2V0ID0gKHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgciA9IHRoaXMuZm9ybWF0VGFyZ2V0KHMpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RXhwaXJhdGlvbihyKTtcbiAgICB9LCB0aGlzLmRlbCA9IChzKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMuaGFzKHMpKSB7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLmZvcm1hdFRhcmdldChzKSwgbiA9IHRoaXMuZ2V0RXhwaXJhdGlvbihyKTtcbiAgICAgICAgdGhpcy5leHBpcmF0aW9ucy5kZWxldGUociksIHRoaXMuZXZlbnRzLmVtaXQoVHQuZGVsZXRlZCwgeyB0YXJnZXQ6IHIsIGV4cGlyYXRpb246IG4gfSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vbiA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbihzLCByKTtcbiAgICB9LCB0aGlzLm9uY2UgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub25jZShzLCByKTtcbiAgICB9LCB0aGlzLm9mZiA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vZmYocywgcik7XG4gICAgfSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihzLCByKTtcbiAgICB9LCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHN0b3JhZ2VLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByZWZpeCArIHRoaXMudmVyc2lvbiArIFwiLy9cIiArIHRoaXMubmFtZTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmV4cGlyYXRpb25zLnNpemU7XG4gIH1cbiAgZ2V0IGtleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5leHBpcmF0aW9ucy5rZXlzKCkpO1xuICB9XG4gIGdldCB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5leHBpcmF0aW9ucy52YWx1ZXMoKSk7XG4gIH1cbiAgZm9ybWF0VGFyZ2V0KGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB2cChlKTtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBfcChlKTtcbiAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IFkoXCJVTktOT1dOX1RZUEVcIiwgYFRhcmdldCB0eXBlOiAke3R5cGVvZiBlfWApO1xuICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgfVxuICBhc3luYyBzZXRFeHBpcmF0aW9ucyhlKSB7XG4gICAgYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIGUpO1xuICB9XG4gIGFzeW5jIGdldEV4cGlyYXRpb25zKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldEV4cGlyYXRpb25zKHRoaXMudmFsdWVzKSwgdGhpcy5ldmVudHMuZW1pdChUdC5zeW5jKTtcbiAgfVxuICBhc3luYyByZXN0b3JlKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5nZXRFeHBpcmF0aW9ucygpO1xuICAgICAgaWYgKHR5cGVvZiBlID4gXCJ1XCIgfHwgIWUubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5leHBpcmF0aW9ucy5zaXplKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gWShcIlJFU1RPUkVfV0lMTF9PVkVSUklERVwiLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcih0KSwgbmV3IEVycm9yKHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZWQgPSBlLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIGV4cGlyYXRpb25zIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicmVzdG9yZVwiLCBleHBpcmF0aW9uczogdGhpcy52YWx1ZXMgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBSZXN0b3JlIGV4cGlyYXRpb25zIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGdldEV4cGlyYXRpb24oZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmV4cGlyYXRpb25zLmdldChlKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogcyB9ID0gWShcIk5PX01BVENISU5HX0tFWVwiLCBgJHt0aGlzLm5hbWV9OiAke2V9YCk7XG4gICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihzKSwgbmV3IEVycm9yKHMpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBjaGVja0V4cGlyeShlLCB0KSB7XG4gICAgY29uc3QgeyBleHBpcnk6IHMgfSA9IHQ7XG4gICAgVi50b01pbGlzZWNvbmRzKHMpIC0gRGF0ZS5ub3coKSA8PSAwICYmIHRoaXMuZXhwaXJlKGUsIHQpO1xuICB9XG4gIGV4cGlyZShlLCB0KSB7XG4gICAgdGhpcy5leHBpcmF0aW9ucy5kZWxldGUoZSksIHRoaXMuZXZlbnRzLmVtaXQoVHQuZXhwaXJlZCwgeyB0YXJnZXQ6IGUsIGV4cGlyYXRpb246IHQgfSk7XG4gIH1cbiAgY2hlY2tFeHBpcmF0aW9ucygpIHtcbiAgICB0aGlzLmNvcmUucmVsYXllci5jb25uZWN0ZWQgJiYgdGhpcy5leHBpcmF0aW9ucy5mb3JFYWNoKChlLCB0KSA9PiB0aGlzLmNoZWNrRXhwaXJ5KHQsIGUpKTtcbiAgfVxuICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuY29yZS5oZWFydGJlYXQub24oV3QuSEVBUlRCRUFUX0VWRU5UUy5wdWxzZSwgKCkgPT4gdGhpcy5jaGVja0V4cGlyYXRpb25zKCkpLCB0aGlzLmV2ZW50cy5vbihUdC5jcmVhdGVkLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IFR0LmNyZWF0ZWQ7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFbWl0dGluZyAke3R9YCksIHRoaXMubG9nZ2VyLmRlYnVnKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdCwgZGF0YTogZSB9KSwgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSksIHRoaXMuZXZlbnRzLm9uKFR0LmV4cGlyZWQsIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gVHQuZXhwaXJlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCBkYXRhOiBlIH0pLCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KSwgdGhpcy5ldmVudHMub24oVHQuZGVsZXRlZCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBUdC5kZWxldGVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIGRhdGE6IGUgfSksIHRoaXMucGVyc2lzdCgpO1xuICAgIH0pO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IFkoXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbn0sIGltID0gY2xhc3MgZXh0ZW5kcyBfbCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5wcm9qZWN0SWQgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMubmFtZSA9IE5yLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMucXVldWUgPSBbXSwgdGhpcy52ZXJpZnlEaXNhYmxlZCA9ICExLCB0aGlzLmluaXQgPSBhc3luYyAocykgPT4ge1xuICAgICAgaWYgKHRoaXMudmVyaWZ5RGlzYWJsZWQgfHwgdXIoKSB8fCAhdnMoKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IHM/LnZlcmlmeVVybCB8fCBLcztcbiAgICAgIHRoaXMudmVyaWZ5VXJsICE9PSByICYmIHRoaXMucmVtb3ZlSWZyYW1lKCksIHRoaXMudmVyaWZ5VXJsID0gcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlSWZyYW1lKCk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFZlcmlmeSBpZnJhbWUgZmFpbGVkIHRvIGxvYWQ6ICR7dGhpcy52ZXJpZnlVcmx9YCksIHRoaXMubG9nZ2VyLmluZm8obik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVJZnJhbWUoKSwgdGhpcy52ZXJpZnlVcmwgPSB0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUlmcmFtZSgpO1xuICAgICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgVmVyaWZ5IGlmcmFtZSBmYWlsZWQgdG8gbG9hZDogJHt0aGlzLnZlcmlmeVVybH1gKSwgdGhpcy5sb2dnZXIuaW5mbyhuKSwgdGhpcy52ZXJpZnlEaXNhYmxlZCA9ICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcy5yZWdpc3RlciA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID8gdGhpcy5zZW5kUG9zdChzLmF0dGVzdGF0aW9uSWQpIDogKHRoaXMuYWRkVG9RdWV1ZShzLmF0dGVzdGF0aW9uSWQpLCBhd2FpdCB0aGlzLmluaXQoKSk7XG4gICAgfSwgdGhpcy5yZXNvbHZlID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzRGV2RW52KVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGNvbnN0IHIgPSBzPy52ZXJpZnlVcmwgfHwgS3M7XG4gICAgICBsZXQgbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIG4gPSBhd2FpdCB0aGlzLmZldGNoQXR0ZXN0YXRpb24ocy5hdHRlc3RhdGlvbklkLCByKTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgZmFpbGVkIHRvIHJlc29sdmUgYXR0ZXN0YXRpb246ICR7cy5hdHRlc3RhdGlvbklkfSBmcm9tIHVybDogJHtyfWApLCB0aGlzLmxvZ2dlci5pbmZvKG8pLCBuID0gYXdhaXQgdGhpcy5mZXRjaEF0dGVzdGF0aW9uKHMuYXR0ZXN0YXRpb25JZCwgdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSwgdGhpcy5mZXRjaEF0dGVzdGF0aW9uID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYHJlc29sdmluZyBhdHRlc3RhdGlvbjogJHtzfSBmcm9tIHVybDogJHtyfWApO1xuICAgICAgY29uc3QgbiA9IHRoaXMuc3RhcnRBYm9ydFRpbWVyKFYuT05FX1NFQ09ORCAqIDIpLCBvID0gYXdhaXQgZmV0Y2goYCR7cn0vYXR0ZXN0YXRpb24vJHtzfWAsIHsgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwgfSk7XG4gICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG4pLCBvLnN0YXR1cyA9PT0gMjAwID8gYXdhaXQgby5qc29uKCkgOiB2b2lkIDA7XG4gICAgfSwgdGhpcy5hZGRUb1F1ZXVlID0gKHMpID0+IHtcbiAgICAgIHRoaXMucXVldWUucHVzaChzKTtcbiAgICB9LCB0aGlzLnByb2Nlc3NRdWV1ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMucXVldWUubGVuZ3RoICE9PSAwICYmICh0aGlzLnF1ZXVlLmZvckVhY2goKHMpID0+IHRoaXMuc2VuZFBvc3QocykpLCB0aGlzLnF1ZXVlID0gW10pO1xuICAgIH0sIHRoaXMuc2VuZFBvc3QgPSAocykgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMuaWZyYW1lKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgKHIgPSB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93KSA9PSBudWxsIHx8IHIucG9zdE1lc3NhZ2UocywgXCIqXCIpLCB0aGlzLmxvZ2dlci5pbmZvKGBwb3N0TWVzc2FnZSBzZW50OiAke3N9ICR7dGhpcy52ZXJpZnlVcmx9YCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmNyZWF0ZUlmcmFtZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBzO1xuICAgICAgY29uc3QgciA9IChuKSA9PiB7XG4gICAgICAgIG4uZGF0YSA9PT0gXCJ2ZXJpZnlfcmVhZHlcIiAmJiAodGhpcy5pbml0aWFsaXplZCA9ICEwLCB0aGlzLnByb2Nlc3NRdWV1ZSgpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgciksIHMoKSk7XG4gICAgICB9O1xuICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtuZXcgUHJvbWlzZSgobikgPT4ge1xuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoTnIpKVxuICAgICAgICAgIHJldHVybiBuKCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCByKTtcbiAgICAgICAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgIG8uaWQgPSBOciwgby5zcmMgPSBgJHt0aGlzLnZlcmlmeVVybH0vJHt0aGlzLnByb2plY3RJZH1gLCBvLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgZG9jdW1lbnQuYm9keS5hcHBlbmQobyksIHRoaXMuaWZyYW1lID0gbywgcyA9IG47XG4gICAgICB9KSwgbmV3IFByb21pc2UoKG4sIG8pID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgciksIG8oXCJ2ZXJpZnkgaWZyYW1lIGxvYWQgdGltZW91dFwiKTtcbiAgICAgIH0sIFYudG9NaWxpc2Vjb25kcyhWLkZJVkVfU0VDT05EUykpKV0pO1xuICAgIH0sIHRoaXMucmVtb3ZlSWZyYW1lID0gKCkgPT4ge1xuICAgICAgdGhpcy5pZnJhbWUgJiYgKHRoaXMuaWZyYW1lLnJlbW92ZSgpLCB0aGlzLmlmcmFtZSA9IHZvaWQgMCwgdGhpcy5pbml0aWFsaXplZCA9ICExKTtcbiAgICB9LCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKSwgdGhpcy52ZXJpZnlVcmwgPSBLcywgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCksIHRoaXMuaXNEZXZFbnYgPSB5bigpICYmIHByb2Nlc3MuZW52LklTX1ZJVEVTVDtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgc3RhcnRBYm9ydFRpbWVyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCksIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKSwgVi50b01pbGlzZWNvbmRzKGUpKTtcbiAgfVxufTtcbnZhciBzbSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgaGEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBybSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIG5tID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgdWEgPSAoaSwgZSwgdCkgPT4gZSBpbiBpID8gc20oaSwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IGlbZV0gPSB0LCBsYSA9IChpLCBlKSA9PiB7XG4gIGZvciAodmFyIHQgaW4gZSB8fCAoZSA9IHt9KSlcbiAgICBybS5jYWxsKGUsIHQpICYmIHVhKGksIHQsIGVbdF0pO1xuICBpZiAoaGEpXG4gICAgZm9yICh2YXIgdCBvZiBoYShlKSlcbiAgICAgIG5tLmNhbGwoZSwgdCkgJiYgdWEoaSwgdCwgZVt0XSk7XG4gIHJldHVybiBpO1xufTtcbmxldCBvbSA9IGNsYXNzIHVoIGV4dGVuZHMgZmwge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSksIHRoaXMucHJvdG9jb2wgPSBhaCwgdGhpcy52ZXJzaW9uID0gbzEsIHRoaXMubmFtZSA9IEVuLCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLm9uID0gKHMsIHIpID0+IHRoaXMuZXZlbnRzLm9uKHMsIHIpLCB0aGlzLm9uY2UgPSAocywgcikgPT4gdGhpcy5ldmVudHMub25jZShzLCByKSwgdGhpcy5vZmYgPSAocywgcikgPT4gdGhpcy5ldmVudHMub2ZmKHMsIHIpLCB0aGlzLnJlbW92ZUxpc3RlbmVyID0gKHMsIHIpID0+IHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKHMsIHIpLCB0aGlzLnByb2plY3RJZCA9IGU/LnByb2plY3RJZCwgdGhpcy5yZWxheVVybCA9IGU/LnJlbGF5VXJsIHx8IGhoO1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZT8ubG9nZ2VyIDwgXCJ1XCIgJiYgdHlwZW9mIGU/LmxvZ2dlciAhPSBcInN0cmluZ1wiID8gZS5sb2dnZXIgOiBlZS5waW5vKGVlLmdldERlZmF1bHRMb2dnZXJPcHRpb25zKHsgbGV2ZWw6IGU/LmxvZ2dlciB8fCBhMS5sb2dnZXIgfSkpO1xuICAgIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLmhlYXJ0YmVhdCA9IG5ldyBXdC5IZWFydEJlYXQoKSwgdGhpcy5jcnlwdG8gPSBuZXcgRjEodGhpcywgdGhpcy5sb2dnZXIsIGU/LmtleWNoYWluKSwgdGhpcy5oaXN0b3J5ID0gbmV3IGVtKHRoaXMsIHRoaXMubG9nZ2VyKSwgdGhpcy5leHBpcmVyID0gbmV3IHRtKHRoaXMsIHRoaXMubG9nZ2VyKSwgdGhpcy5zdG9yYWdlID0gZSAhPSBudWxsICYmIGUuc3RvcmFnZSA/IGUuc3RvcmFnZSA6IG5ldyBuYyhsYShsYSh7fSwgYzEpLCBlPy5zdG9yYWdlT3B0aW9ucykpLCB0aGlzLnJlbGF5ZXIgPSBuZXcgWTEoeyBjb3JlOiB0aGlzLCBsb2dnZXI6IHRoaXMubG9nZ2VyLCByZWxheVVybDogdGhpcy5yZWxheVVybCwgcHJvamVjdElkOiB0aGlzLnByb2plY3RJZCB9KSwgdGhpcy5wYWlyaW5nID0gbmV3IFoxKHRoaXMsIHRoaXMubG9nZ2VyKSwgdGhpcy52ZXJpZnkgPSBuZXcgaW0odGhpcy5wcm9qZWN0SWQgfHwgXCJcIiwgdGhpcy5sb2dnZXIpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBpbml0KGUpIHtcbiAgICBjb25zdCB0ID0gbmV3IHVoKGUpO1xuICAgIGF3YWl0IHQuaW5pdGlhbGl6ZSgpO1xuICAgIGNvbnN0IHMgPSBhd2FpdCB0LmNyeXB0by5nZXRDbGllbnRJZCgpO1xuICAgIHJldHVybiBhd2FpdCB0LnN0b3JhZ2Uuc2V0SXRlbShJMSwgcyksIHQ7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmNyeXB0by5pbml0KCksIGF3YWl0IHRoaXMuaGlzdG9yeS5pbml0KCksIGF3YWl0IHRoaXMuZXhwaXJlci5pbml0KCksIGF3YWl0IHRoaXMucmVsYXllci5pbml0KCksIGF3YWl0IHRoaXMuaGVhcnRiZWF0LmluaXQoKSwgYXdhaXQgdGhpcy5wYWlyaW5nLmluaXQoKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwLCB0aGlzLmxvZ2dlci5pbmZvKFwiQ29yZSBJbml0aWFsaXphdGlvbiBTdWNjZXNzXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IHRoaXMubG9nZ2VyLndhcm4oYENvcmUgSW5pdGlhbGl6YXRpb24gRmFpbHVyZSBhdCBlcG9jaCAke0RhdGUubm93KCl9YCwgZSksIHRoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSksIGU7XG4gICAgfVxuICB9XG59O1xuY29uc3QgYW0gPSBvbSwgbGggPSBcIndjXCIsIGRoID0gMiwgZmggPSBcImNsaWVudFwiLCBTbiA9IGAke2xofUAke2RofToke2ZofTpgLCBSciA9IHsgbmFtZTogZmgsIGxvZ2dlcjogXCJlcnJvclwiLCBjb250cm9sbGVyOiAhMSwgcmVsYXlVcmw6IFwid3NzOi8vcmVsYXkud2FsbGV0Y29ubmVjdC5jb21cIiB9LCBkYSA9IFwiV0FMTEVUQ09OTkVDVF9ERUVQTElOS19DSE9JQ0VcIiwgY20gPSBcInByb3Bvc2FsXCIsIGhtID0gXCJQcm9wb3NhbCBleHBpcmVkXCIsIHVtID0gXCJzZXNzaW9uXCIsIEZzID0gVi5TRVZFTl9EQVlTLCBsbSA9IFwiZW5naW5lXCIsIGVzID0geyB3Y19zZXNzaW9uUHJvcG9zZTogeyByZXE6IHsgdHRsOiBWLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMCwgdGFnOiAxMTAwIH0sIHJlczogeyB0dGw6IFYuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICExLCB0YWc6IDExMDEgfSB9LCB3Y19zZXNzaW9uU2V0dGxlOiB7IHJlcTogeyB0dGw6IFYuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICExLCB0YWc6IDExMDIgfSwgcmVzOiB7IHR0bDogVi5GSVZFX01JTlVURVMsIHByb21wdDogITEsIHRhZzogMTEwMyB9IH0sIHdjX3Nlc3Npb25VcGRhdGU6IHsgcmVxOiB7IHR0bDogVi5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDExMDQgfSwgcmVzOiB7IHR0bDogVi5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDExMDUgfSB9LCB3Y19zZXNzaW9uRXh0ZW5kOiB7IHJlcTogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMTA2IH0sIHJlczogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMTA3IH0gfSwgd2Nfc2Vzc2lvblJlcXVlc3Q6IHsgcmVxOiB7IHR0bDogVi5GSVZFX01JTlVURVMsIHByb21wdDogITAsIHRhZzogMTEwOCB9LCByZXM6IHsgdHRsOiBWLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMSwgdGFnOiAxMTA5IH0gfSwgd2Nfc2Vzc2lvbkV2ZW50OiB7IHJlcTogeyB0dGw6IFYuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICEwLCB0YWc6IDExMTAgfSwgcmVzOiB7IHR0bDogVi5GSVZFX01JTlVURVMsIHByb21wdDogITEsIHRhZzogMTExMSB9IH0sIHdjX3Nlc3Npb25EZWxldGU6IHsgcmVxOiB7IHR0bDogVi5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDExMTIgfSwgcmVzOiB7IHR0bDogVi5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDExMTMgfSB9LCB3Y19zZXNzaW9uUGluZzogeyByZXE6IHsgdHRsOiBWLlRISVJUWV9TRUNPTkRTLCBwcm9tcHQ6ICExLCB0YWc6IDExMTQgfSwgcmVzOiB7IHR0bDogVi5USElSVFlfU0VDT05EUywgcHJvbXB0OiAhMSwgdGFnOiAxMTE1IH0gfSB9LCBDciA9IHsgbWluOiBWLkZJVkVfTUlOVVRFUywgbWF4OiBWLlNFVkVOX0RBWVMgfSwgZWkgPSB7IGlkbGU6IFwiSURMRVwiLCBhY3RpdmU6IFwiQUNUSVZFXCIgfSwgZG0gPSBcInJlcXVlc3RcIiwgZm0gPSBbXCJ3Y19zZXNzaW9uUHJvcG9zZVwiLCBcIndjX3Nlc3Npb25SZXF1ZXN0XCIsIFwid2NfYXV0aFJlcXVlc3RcIl07XG52YXIgcG0gPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGdtID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsIHltID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMsIGZhID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgbW0gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBibSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIHBhID0gKGksIGUsIHQpID0+IGUgaW4gaSA/IHBtKGksIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBpW2VdID0gdCwgRXQgPSAoaSwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgbW0uY2FsbChlLCB0KSAmJiBwYShpLCB0LCBlW3RdKTtcbiAgaWYgKGZhKVxuICAgIGZvciAodmFyIHQgb2YgZmEoZSkpXG4gICAgICBibS5jYWxsKGUsIHQpICYmIHBhKGksIHQsIGVbdF0pO1xuICByZXR1cm4gaTtcbn0sIHRzID0gKGksIGUpID0+IGdtKGksIHltKGUpKTtcbmxldCB3bSA9IGNsYXNzIGV4dGVuZHMgU2wge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSksIHRoaXMubmFtZSA9IGxtLCB0aGlzLmV2ZW50cyA9IG5ldyBpcigpLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuaWdub3JlZFBheWxvYWRUeXBlcyA9IFtEaV0sIHRoaXMucmVxdWVzdFF1ZXVlID0geyBzdGF0ZTogZWkuaWRsZSwgcXVldWU6IFtdIH0sIHRoaXMuc2Vzc2lvblJlcXVlc3RRdWV1ZSA9IHsgc3RhdGU6IGVpLmlkbGUsIHF1ZXVlOiBbXSB9LCB0aGlzLnJlcXVlc3RRdWV1ZURlbGF5ID0gVi5PTkVfU0VDT05ELCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkIHx8IChhd2FpdCB0aGlzLmNsZWFudXAoKSwgdGhpcy5yZWdpc3RlclJlbGF5ZXJFdmVudHMoKSwgdGhpcy5yZWdpc3RlckV4cGlyZXJFdmVudHMoKSwgdGhpcy5yZWdpc3RlclBhaXJpbmdFdmVudHMoKSwgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnJlZ2lzdGVyKHsgbWV0aG9kczogT2JqZWN0LmtleXMoZXMpIH0pLCB0aGlzLmluaXRpYWxpemVkID0gITAsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUucXVldWUgPSB0aGlzLmdldFBlbmRpbmdTZXNzaW9uUmVxdWVzdHMoKSwgdGhpcy5wcm9jZXNzU2Vzc2lvblJlcXVlc3RRdWV1ZSgpO1xuICAgICAgfSwgVi50b01pbGlzZWNvbmRzKHRoaXMucmVxdWVzdFF1ZXVlRGVsYXkpKSk7XG4gICAgfSwgdGhpcy5jb25uZWN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgcyA9IHRzKEV0KHt9LCB0KSwgeyByZXF1aXJlZE5hbWVzcGFjZXM6IHQucmVxdWlyZWROYW1lc3BhY2VzIHx8IHt9LCBvcHRpb25hbE5hbWVzcGFjZXM6IHQub3B0aW9uYWxOYW1lc3BhY2VzIHx8IHt9IH0pO1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkQ29ubmVjdChzKTtcbiAgICAgIGNvbnN0IHsgcGFpcmluZ1RvcGljOiByLCByZXF1aXJlZE5hbWVzcGFjZXM6IG4sIG9wdGlvbmFsTmFtZXNwYWNlczogbywgc2Vzc2lvblByb3BlcnRpZXM6IGMsIHJlbGF5czogdSB9ID0gcztcbiAgICAgIGxldCBkID0gciwgcCwgYiA9ICExO1xuICAgICAgaWYgKGQgJiYgKGIgPSB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcmluZ3MuZ2V0KGQpLmFjdGl2ZSksICFkIHx8ICFiKSB7XG4gICAgICAgIGNvbnN0IHsgdG9waWM6IEQsIHVyaTogeSB9ID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLmNyZWF0ZSgpO1xuICAgICAgICBkID0gRCwgcCA9IHk7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZ2VuZXJhdGVLZXlQYWlyKCksIE8gPSBFdCh7IHJlcXVpcmVkTmFtZXNwYWNlczogbiwgb3B0aW9uYWxOYW1lc3BhY2VzOiBvLCByZWxheXM6IHUgPz8gW3sgcHJvdG9jb2w6IGNoIH1dLCBwcm9wb3NlcjogeyBwdWJsaWNLZXk6IHgsIG1ldGFkYXRhOiB0aGlzLmNsaWVudC5tZXRhZGF0YSB9IH0sIGMgJiYgeyBzZXNzaW9uUHJvcGVydGllczogYyB9KSwgeyByZWplY3Q6IF8sIHJlc29sdmU6IEMsIGRvbmU6IEYgfSA9IEFpKFYuRklWRV9NSU5VVEVTLCBobSk7XG4gICAgICBpZiAodGhpcy5ldmVudHMub25jZShCZShcInNlc3Npb25fY29ubmVjdFwiKSwgYXN5bmMgKHsgZXJyb3I6IEQsIHNlc3Npb246IHkgfSkgPT4ge1xuICAgICAgICBpZiAoRClcbiAgICAgICAgICBfKEQpO1xuICAgICAgICBlbHNlIGlmICh5KSB7XG4gICAgICAgICAgeS5zZWxmLnB1YmxpY0tleSA9IHg7XG4gICAgICAgICAgY29uc3QgdyA9IHRzKEV0KHt9LCB5KSwgeyByZXF1aXJlZE5hbWVzcGFjZXM6IHkucmVxdWlyZWROYW1lc3BhY2VzLCBvcHRpb25hbE5hbWVzcGFjZXM6IHkub3B0aW9uYWxOYW1lc3BhY2VzIH0pO1xuICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24uc2V0KHkudG9waWMsIHcpLCBhd2FpdCB0aGlzLnNldEV4cGlyeSh5LnRvcGljLCB5LmV4cGlyeSksIGQgJiYgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnVwZGF0ZU1ldGFkYXRhKHsgdG9waWM6IGQsIG1ldGFkYXRhOiB5LnBlZXIubWV0YWRhdGEgfSksIEModyk7XG4gICAgICAgIH1cbiAgICAgIH0pLCAhZCkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IEQgfSA9IFkoXCJOT19NQVRDSElOR19LRVlcIiwgYGNvbm5lY3QoKSBwYWlyaW5nIHRvcGljOiAke2R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihEKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IEsgPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHsgdG9waWM6IGQsIG1ldGhvZDogXCJ3Y19zZXNzaW9uUHJvcG9zZVwiLCBwYXJhbXM6IE8gfSksIEkgPSBNdChWLkZJVkVfTUlOVVRFUyk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXRQcm9wb3NhbChLLCBFdCh7IGlkOiBLLCBleHBpcnk6IEkgfSwgTykpLCB7IHVyaTogcCwgYXBwcm92YWw6IEYgfTtcbiAgICB9LCB0aGlzLnBhaXIgPSBhc3luYyAodCkgPT4gKGF3YWl0IHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcih0KSksIHRoaXMuYXBwcm92ZSA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkQXBwcm92ZSh0KTtcbiAgICAgIGNvbnN0IHsgaWQ6IHMsIHJlbGF5UHJvdG9jb2w6IHIsIG5hbWVzcGFjZXM6IG4sIHNlc3Npb25Qcm9wZXJ0aWVzOiBvIH0gPSB0LCBjID0gdGhpcy5jbGllbnQucHJvcG9zYWwuZ2V0KHMpO1xuICAgICAgbGV0IHsgcGFpcmluZ1RvcGljOiB1LCBwcm9wb3NlcjogZCwgcmVxdWlyZWROYW1lc3BhY2VzOiBwLCBvcHRpb25hbE5hbWVzcGFjZXM6IGIgfSA9IGM7XG4gICAgICB1ID0gdSB8fCBcIlwiLCBjcyhwKSB8fCAocCA9IFVwKG4sIFwiYXBwcm92ZSgpXCIpKTtcbiAgICAgIGNvbnN0IHggPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5nZW5lcmF0ZUtleVBhaXIoKSwgTyA9IGQucHVibGljS2V5LCBfID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZ2VuZXJhdGVTaGFyZWRLZXkoeCwgTyk7XG4gICAgICB1ICYmIHMgJiYgKGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy51cGRhdGVNZXRhZGF0YSh7IHRvcGljOiB1LCBtZXRhZGF0YTogZC5tZXRhZGF0YSB9KSwgYXdhaXQgdGhpcy5zZW5kUmVzdWx0KHsgaWQ6IHMsIHRvcGljOiB1LCByZXN1bHQ6IHsgcmVsYXk6IHsgcHJvdG9jb2w6IHIgPz8gXCJpcm5cIiB9LCByZXNwb25kZXJQdWJsaWNLZXk6IHggfSB9KSwgYXdhaXQgdGhpcy5jbGllbnQucHJvcG9zYWwuZGVsZXRlKHMsIG50KFwiVVNFUl9ESVNDT05ORUNURURcIikpLCBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcuYWN0aXZhdGUoeyB0b3BpYzogdSB9KSk7XG4gICAgICBjb25zdCBDID0gRXQoeyByZWxheTogeyBwcm90b2NvbDogciA/PyBcImlyblwiIH0sIG5hbWVzcGFjZXM6IG4sIHJlcXVpcmVkTmFtZXNwYWNlczogcCwgb3B0aW9uYWxOYW1lc3BhY2VzOiBiLCBwYWlyaW5nVG9waWM6IHUsIGNvbnRyb2xsZXI6IHsgcHVibGljS2V5OiB4LCBtZXRhZGF0YTogdGhpcy5jbGllbnQubWV0YWRhdGEgfSwgZXhwaXJ5OiBNdChGcykgfSwgbyAmJiB7IHNlc3Npb25Qcm9wZXJ0aWVzOiBvIH0pO1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnN1YnNjcmliZShfKSwgYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCh7IHRvcGljOiBfLCBtZXRob2Q6IFwid2Nfc2Vzc2lvblNldHRsZVwiLCBwYXJhbXM6IEMsIHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCB9KTtcbiAgICAgIGNvbnN0IEYgPSB0cyhFdCh7fSwgQyksIHsgdG9waWM6IF8sIHBhaXJpbmdUb3BpYzogdSwgYWNrbm93bGVkZ2VkOiAhMSwgc2VsZjogQy5jb250cm9sbGVyLCBwZWVyOiB7IHB1YmxpY0tleTogZC5wdWJsaWNLZXksIG1ldGFkYXRhOiBkLm1ldGFkYXRhIH0sIGNvbnRyb2xsZXI6IHggfSk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi5zZXQoXywgRiksIGF3YWl0IHRoaXMuc2V0RXhwaXJ5KF8sIE10KEZzKSksIHsgdG9waWM6IF8sIGFja25vd2xlZGdlZDogKCkgPT4gbmV3IFByb21pc2UoKEspID0+IHNldFRpbWVvdXQoKCkgPT4gSyh0aGlzLmNsaWVudC5zZXNzaW9uLmdldChfKSksIDUwMCkpIH07XG4gICAgfSwgdGhpcy5yZWplY3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZFJlamVjdCh0KTtcbiAgICAgIGNvbnN0IHsgaWQ6IHMsIHJlYXNvbjogciB9ID0gdCwgeyBwYWlyaW5nVG9waWM6IG4gfSA9IHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldChzKTtcbiAgICAgIG4gJiYgKGF3YWl0IHRoaXMuc2VuZEVycm9yKHMsIG4sIHIpLCBhd2FpdCB0aGlzLmNsaWVudC5wcm9wb3NhbC5kZWxldGUocywgbnQoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSkpO1xuICAgIH0sIHRoaXMudXBkYXRlID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRVcGRhdGUodCk7XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCBuYW1lc3BhY2VzOiByIH0gPSB0LCBuID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCh7IHRvcGljOiBzLCBtZXRob2Q6IFwid2Nfc2Vzc2lvblVwZGF0ZVwiLCBwYXJhbXM6IHsgbmFtZXNwYWNlczogciB9IH0pLCB7IGRvbmU6IG8sIHJlc29sdmU6IGMsIHJlamVjdDogdSB9ID0gQWkoKTtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50cy5vbmNlKEJlKFwic2Vzc2lvbl91cGRhdGVcIiwgbiksICh7IGVycm9yOiBkIH0pID0+IHtcbiAgICAgICAgZCA/IHUoZCkgOiBjKCk7XG4gICAgICB9KSwgYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi51cGRhdGUocywgeyBuYW1lc3BhY2VzOiByIH0pLCB7IGFja25vd2xlZGdlZDogbyB9O1xuICAgIH0sIHRoaXMuZXh0ZW5kID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRFeHRlbmQodCk7XG4gICAgICBjb25zdCB7IHRvcGljOiBzIH0gPSB0LCByID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCh7IHRvcGljOiBzLCBtZXRob2Q6IFwid2Nfc2Vzc2lvbkV4dGVuZFwiLCBwYXJhbXM6IHt9IH0pLCB7IGRvbmU6IG4sIHJlc29sdmU6IG8sIHJlamVjdDogYyB9ID0gQWkoKTtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50cy5vbmNlKEJlKFwic2Vzc2lvbl9leHRlbmRcIiwgciksICh7IGVycm9yOiB1IH0pID0+IHtcbiAgICAgICAgdSA/IGModSkgOiBvKCk7XG4gICAgICB9KSwgYXdhaXQgdGhpcy5zZXRFeHBpcnkocywgTXQoRnMpKSwgeyBhY2tub3dsZWRnZWQ6IG4gfTtcbiAgICB9LCB0aGlzLnJlcXVlc3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZFJlcXVlc3QodCk7XG4gICAgICBjb25zdCB7IGNoYWluSWQ6IHMsIHJlcXVlc3Q6IHIsIHRvcGljOiBuLCBleHBpcnk6IG8gfSA9IHQsIGMgPSB3bigpLCB7IGRvbmU6IHUsIHJlc29sdmU6IGQsIHJlamVjdDogcCB9ID0gQWkobyk7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudHMub25jZShCZShcInNlc3Npb25fcmVxdWVzdFwiLCBjKSwgKHsgZXJyb3I6IGIsIHJlc3VsdDogeCB9KSA9PiB7XG4gICAgICAgIGIgPyBwKGIpIDogZCh4KTtcbiAgICAgIH0pLCBhd2FpdCBQcm9taXNlLmFsbChbbmV3IFByb21pc2UoYXN5bmMgKGIpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCh7IGNsaWVudFJwY0lkOiBjLCB0b3BpYzogbiwgbWV0aG9kOiBcIndjX3Nlc3Npb25SZXF1ZXN0XCIsIHBhcmFtczogeyByZXF1ZXN0OiByLCBjaGFpbklkOiBzIH0sIGV4cGlyeTogbywgdGhyb3dPbkZhaWxlZFB1Ymxpc2g6ICEwIH0pLmNhdGNoKCh4KSA9PiBwKHgpKSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX3JlcXVlc3Rfc2VudFwiLCB7IHRvcGljOiBuLCByZXF1ZXN0OiByLCBjaGFpbklkOiBzLCBpZDogYyB9KSwgYigpO1xuICAgICAgfSksIG5ldyBQcm9taXNlKGFzeW5jIChiKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnN0b3JhZ2UuZ2V0SXRlbShkYSk7XG4gICAgICAgIEVwKHsgaWQ6IGMsIHRvcGljOiBuLCB3Y0RlZXBMaW5rOiB4IH0pLCBiKCk7XG4gICAgICB9KSwgdSgpXSkudGhlbigoYikgPT4gYlsyXSk7XG4gICAgfSwgdGhpcy5yZXNwb25kID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRSZXNwb25kKHQpO1xuICAgICAgY29uc3QgeyB0b3BpYzogcywgcmVzcG9uc2U6IHIgfSA9IHQsIHsgaWQ6IG4gfSA9IHI7XG4gICAgICBodChyKSA/IGF3YWl0IHRoaXMuc2VuZFJlc3VsdCh7IGlkOiBuLCB0b3BpYzogcywgcmVzdWx0OiByLnJlc3VsdCwgdGhyb3dPbkZhaWxlZFB1Ymxpc2g6ICEwIH0pIDogR2UocikgJiYgYXdhaXQgdGhpcy5zZW5kRXJyb3Iobiwgcywgci5lcnJvciksIHRoaXMuY2xlYW51cEFmdGVyUmVzcG9uc2UodCk7XG4gICAgfSwgdGhpcy5waW5nID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRQaW5nKHQpO1xuICAgICAgY29uc3QgeyB0b3BpYzogcyB9ID0gdDtcbiAgICAgIGlmICh0aGlzLmNsaWVudC5zZXNzaW9uLmtleXMuaW5jbHVkZXMocykpIHtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoeyB0b3BpYzogcywgbWV0aG9kOiBcIndjX3Nlc3Npb25QaW5nXCIsIHBhcmFtczoge30gfSksIHsgZG9uZTogbiwgcmVzb2x2ZTogbywgcmVqZWN0OiBjIH0gPSBBaSgpO1xuICAgICAgICB0aGlzLmV2ZW50cy5vbmNlKEJlKFwic2Vzc2lvbl9waW5nXCIsIHIpLCAoeyBlcnJvcjogdSB9KSA9PiB7XG4gICAgICAgICAgdSA/IGModSkgOiBvKCk7XG4gICAgICAgIH0pLCBhd2FpdCBuKCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXJpbmdzLmtleXMuaW5jbHVkZXMocykgJiYgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBpbmcoeyB0b3BpYzogcyB9KTtcbiAgICB9LCB0aGlzLmVtaXQgPSBhc3luYyAodCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZEVtaXQodCk7XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCBldmVudDogciwgY2hhaW5JZDogbiB9ID0gdDtcbiAgICAgIGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoeyB0b3BpYzogcywgbWV0aG9kOiBcIndjX3Nlc3Npb25FdmVudFwiLCBwYXJhbXM6IHsgZXZlbnQ6IHIsIGNoYWluSWQ6IG4gfSB9KTtcbiAgICB9LCB0aGlzLmRpc2Nvbm5lY3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZERpc2Nvbm5lY3QodCk7XG4gICAgICBjb25zdCB7IHRvcGljOiBzIH0gPSB0O1xuICAgICAgdGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKHMpID8gKGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoeyB0b3BpYzogcywgbWV0aG9kOiBcIndjX3Nlc3Npb25EZWxldGVcIiwgcGFyYW1zOiBudChcIlVTRVJfRElTQ09OTkVDVEVEXCIpLCB0aHJvd09uRmFpbGVkUHVibGlzaDogITAgfSksIGF3YWl0IHRoaXMuZGVsZXRlU2Vzc2lvbihzKSkgOiBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcuZGlzY29ubmVjdCh7IHRvcGljOiBzIH0pO1xuICAgIH0sIHRoaXMuZmluZCA9ICh0KSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0QWxsKCkuZmlsdGVyKChzKSA9PiBxcChzLCB0KSkpLCB0aGlzLmdldFBlbmRpbmdTZXNzaW9uUmVxdWVzdHMgPSAoKSA9PiAodGhpcy5pc0luaXRpYWxpemVkKCksIHRoaXMuY2xpZW50LnBlbmRpbmdSZXF1ZXN0LmdldEFsbCgpKSwgdGhpcy5jbGVhbnVwRHVwbGljYXRlUGFpcmluZ3MgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKHQucGFpcmluZ1RvcGljKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcmluZ3MuZ2V0KHQucGFpcmluZ1RvcGljKSwgciA9IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyaW5ncy5nZXRBbGwoKS5maWx0ZXIoKG4pID0+IHtcbiAgICAgICAgICAgIHZhciBvLCBjO1xuICAgICAgICAgICAgcmV0dXJuICgobyA9IG4ucGVlck1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogby51cmwpICYmICgoYyA9IG4ucGVlck1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogYy51cmwpID09PSB0LnBlZXIubWV0YWRhdGEudXJsICYmIG4udG9waWMgJiYgbi50b3BpYyAhPT0gcy50b3BpYztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoci5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oYENsZWFuaW5nIHVwICR7ci5sZW5ndGh9IGR1cGxpY2F0ZSBwYWlyaW5nKHMpYCksIGF3YWl0IFByb21pc2UuYWxsKHIubWFwKChuKSA9PiB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcuZGlzY29ubmVjdCh7IHRvcGljOiBuLnRvcGljIH0pKSksIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKFwiRHVwbGljYXRlIHBhaXJpbmdzIGNsZWFuIHVwIGZpbmlzaGVkXCIpO1xuICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKHMpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcy5kZWxldGVTZXNzaW9uID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgc2VsZjogciB9ID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQodCk7XG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIudW5zdWJzY3JpYmUodCksIHRoaXMuY2xpZW50LnNlc3Npb24uZGVsZXRlKHQsIG50KFwiVVNFUl9ESVNDT05ORUNURURcIikpLCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5rZXljaGFpbi5oYXMoci5wdWJsaWNLZXkpICYmIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmRlbGV0ZUtleVBhaXIoci5wdWJsaWNLZXkpLCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5rZXljaGFpbi5oYXModCkgJiYgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZGVsZXRlU3ltS2V5KHQpLCBzIHx8IHRoaXMuY2xpZW50LmNvcmUuZXhwaXJlci5kZWwodCksIHRoaXMuY2xpZW50LmNvcmUuc3RvcmFnZS5yZW1vdmVJdGVtKGRhKS5jYXRjaCgobikgPT4gdGhpcy5jbGllbnQubG9nZ2VyLndhcm4obikpO1xuICAgIH0sIHRoaXMuZGVsZXRlUHJvcG9zYWwgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuY2xpZW50LnByb3Bvc2FsLmRlbGV0ZSh0LCBudChcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgcyA/IFByb21pc2UucmVzb2x2ZSgpIDogdGhpcy5jbGllbnQuY29yZS5leHBpcmVyLmRlbCh0KV0pO1xuICAgIH0sIHRoaXMuZGVsZXRlUGVuZGluZ1Nlc3Npb25SZXF1ZXN0ID0gYXN5bmMgKHQsIHMsIHIgPSAhMSkgPT4ge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuY2xpZW50LnBlbmRpbmdSZXF1ZXN0LmRlbGV0ZSh0LCBzKSwgciA/IFByb21pc2UucmVzb2x2ZSgpIDogdGhpcy5jbGllbnQuY29yZS5leHBpcmVyLmRlbCh0KV0pLCB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUucXVldWUgPSB0aGlzLnNlc3Npb25SZXF1ZXN0UXVldWUucXVldWUuZmlsdGVyKChuKSA9PiBuLmlkICE9PSB0KSwgciAmJiAodGhpcy5zZXNzaW9uUmVxdWVzdFF1ZXVlLnN0YXRlID0gZWkuaWRsZSk7XG4gICAgfSwgdGhpcy5zZXRFeHBpcnkgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgdGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKHQpICYmIGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24udXBkYXRlKHQsIHsgZXhwaXJ5OiBzIH0pLCB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuc2V0KHQsIHMpO1xuICAgIH0sIHRoaXMuc2V0UHJvcG9zYWwgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQucHJvcG9zYWwuc2V0KHQsIHMpLCB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuc2V0KHQsIHMuZXhwaXJ5KTtcbiAgICB9LCB0aGlzLnNldFBlbmRpbmdTZXNzaW9uUmVxdWVzdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBjb25zdCBzID0gZXMud2Nfc2Vzc2lvblJlcXVlc3QucmVxLnR0bCwgeyBpZDogciwgdG9waWM6IG4sIHBhcmFtczogbywgdmVyaWZ5Q29udGV4dDogYyB9ID0gdDtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnBlbmRpbmdSZXF1ZXN0LnNldChyLCB7IGlkOiByLCB0b3BpYzogbiwgcGFyYW1zOiBvLCB2ZXJpZnlDb250ZXh0OiBjIH0pLCBzICYmIHRoaXMuY2xpZW50LmNvcmUuZXhwaXJlci5zZXQociwgTXQocykpO1xuICAgIH0sIHRoaXMuc2VuZFJlcXVlc3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogcywgbWV0aG9kOiByLCBwYXJhbXM6IG4sIGV4cGlyeTogbywgcmVsYXlScGNJZDogYywgY2xpZW50UnBjSWQ6IHUsIHRocm93T25GYWlsZWRQdWJsaXNoOiBkIH0gPSB0LCBwID0gdGkociwgbiwgdSk7XG4gICAgICBpZiAodnMoKSAmJiBmbS5pbmNsdWRlcyhyKSkge1xuICAgICAgICBjb25zdCBPID0gRmkoSlNPTi5zdHJpbmdpZnkocCkpO1xuICAgICAgICB0aGlzLmNsaWVudC5jb3JlLnZlcmlmeS5yZWdpc3Rlcih7IGF0dGVzdGF0aW9uSWQ6IE8gfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBiID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZW5jb2RlKHMsIHApLCB4ID0gZXNbcl0ucmVxO1xuICAgICAgcmV0dXJuIG8gJiYgKHgudHRsID0gbyksIGMgJiYgKHguaWQgPSBjKSwgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LnNldChzLCBwKSwgZCA/ICh4LmludGVybmFsID0gdHMoRXQoe30sIHguaW50ZXJuYWwpLCB7IHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCB9KSwgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnB1Ymxpc2gocywgYiwgeCkpIDogdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnB1Ymxpc2gocywgYiwgeCkuY2F0Y2goKE8pID0+IHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihPKSksIHAuaWQ7XG4gICAgfSwgdGhpcy5zZW5kUmVzdWx0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHMsIHRvcGljOiByLCByZXN1bHQ6IG4sIHRocm93T25GYWlsZWRQdWJsaXNoOiBvIH0gPSB0LCBjID0geGkocywgbiksIHUgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5lbmNvZGUociwgYyksIGQgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkuZ2V0KHIsIHMpLCBwID0gZXNbZC5yZXF1ZXN0Lm1ldGhvZF0ucmVzO1xuICAgICAgbyA/IChwLmludGVybmFsID0gdHMoRXQoe30sIHAuaW50ZXJuYWwpLCB7IHRocm93T25GYWlsZWRQdWJsaXNoOiAhMCB9KSwgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnB1Ymxpc2gociwgdSwgcCkpIDogdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnB1Ymxpc2gociwgdSwgcCkuY2F0Y2goKGIpID0+IHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihiKSksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuaGlzdG9yeS5yZXNvbHZlKGMpO1xuICAgIH0sIHRoaXMuc2VuZEVycm9yID0gYXN5bmMgKHQsIHMsIHIpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBxaSh0LCByKSwgbyA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmVuY29kZShzLCBuKSwgYyA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuaGlzdG9yeS5nZXQocywgdCksIHUgPSBlc1tjLnJlcXVlc3QubWV0aG9kXS5yZXM7XG4gICAgICB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIucHVibGlzaChzLCBvLCB1KSwgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LnJlc29sdmUobik7XG4gICAgfSwgdGhpcy5jbGVhbnVwID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IFtdLCBzID0gW107XG4gICAgICB0aGlzLmNsaWVudC5zZXNzaW9uLmdldEFsbCgpLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgYWkoci5leHBpcnkpICYmIHQucHVzaChyLnRvcGljKTtcbiAgICAgIH0pLCB0aGlzLmNsaWVudC5wcm9wb3NhbC5nZXRBbGwoKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIGFpKHIuZXhwaXJ5KSAmJiBzLnB1c2goci5pZCk7XG4gICAgICB9KSwgYXdhaXQgUHJvbWlzZS5hbGwoWy4uLnQubWFwKChyKSA9PiB0aGlzLmRlbGV0ZVNlc3Npb24ocikpLCAuLi5zLm1hcCgocikgPT4gdGhpcy5kZWxldGVQcm9wb3NhbChyKSldKTtcbiAgICB9LCB0aGlzLm9uUmVsYXlFdmVudFJlcXVlc3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5yZXF1ZXN0UXVldWUucXVldWUucHVzaCh0KSwgYXdhaXQgdGhpcy5wcm9jZXNzUmVxdWVzdHNRdWV1ZSgpO1xuICAgIH0sIHRoaXMucHJvY2Vzc1JlcXVlc3RzUXVldWUgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5yZXF1ZXN0UXVldWUuc3RhdGUgPT09IGVpLmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhcIlJlcXVlc3QgcXVldWUgYWxyZWFkeSBhY3RpdmUsIHNraXBwaW5nLi4uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKGBSZXF1ZXN0IHF1ZXVlIHN0YXJ0aW5nIHdpdGggJHt0aGlzLnJlcXVlc3RRdWV1ZS5xdWV1ZS5sZW5ndGh9IHJlcXVlc3RzYCk7IHRoaXMucmVxdWVzdFF1ZXVlLnF1ZXVlLmxlbmd0aCA+IDA7ICkge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5zdGF0ZSA9IGVpLmFjdGl2ZTtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMucmVxdWVzdFF1ZXVlLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0KVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NSZXF1ZXN0KHQpLCBhd2FpdCBuZXcgUHJvbWlzZSgocykgPT4gc2V0VGltZW91dChzLCAzMDApKTtcbiAgICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIud2FybihzKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5zdGF0ZSA9IGVpLmlkbGU7XG4gICAgfSwgdGhpcy5wcm9jZXNzUmVxdWVzdCA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCBwYXlsb2FkOiByIH0gPSB0LCBuID0gci5tZXRob2Q7XG4gICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25Qcm9wb3NlXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uUHJvcG9zZVJlcXVlc3Qocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uU2V0dGxlXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uU2V0dGxlUmVxdWVzdChzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25VcGRhdGVcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25VcGRhdGVSZXF1ZXN0KHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvbkV4dGVuZFwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvbkV4dGVuZFJlcXVlc3Qocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uUGluZ1wiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblBpbmdSZXF1ZXN0KHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvbkRlbGV0ZVwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvbkRlbGV0ZVJlcXVlc3Qocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uUmVxdWVzdFwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblJlcXVlc3Qocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uRXZlbnRcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25FdmVudFJlcXVlc3Qocywgcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKGBVbnN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZCAke259YCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblJlbGF5RXZlbnRSZXNwb25zZSA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCBwYXlsb2FkOiByIH0gPSB0LCBuID0gKGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuaGlzdG9yeS5nZXQocywgci5pZCkpLnJlcXVlc3QubWV0aG9kO1xuICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uUHJvcG9zZVwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZShzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25TZXR0bGVcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25TZXR0bGVSZXNwb25zZShzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25VcGRhdGVcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25VcGRhdGVSZXNwb25zZShzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25FeHRlbmRcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25FeHRlbmRSZXNwb25zZShzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25QaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uUGluZ1Jlc3BvbnNlKHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblJlcXVlc3RcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25SZXF1ZXN0UmVzcG9uc2Uocywgcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKGBVbnN1cHBvcnRlZCByZXNwb25zZSBtZXRob2QgJHtufWApO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25SZWxheUV2ZW50VW5rbm93blBheWxvYWQgPSAodCkgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogcyB9ID0gdCwgeyBtZXNzYWdlOiByIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBEZWNvZGVkIHBheWxvYWQgb24gdG9waWMgJHtzfSBpcyBub3QgaWRlbnRpZmlhYmxlIGFzIGEgSlNPTi1SUEMgcmVxdWVzdCBvciBhIHJlc3BvbnNlLmApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHIpO1xuICAgIH0sIHRoaXMub25TZXNzaW9uUHJvcG9zZVJlcXVlc3QgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBwYXJhbXM6IHIsIGlkOiBuIH0gPSBzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkQ29ubmVjdChFdCh7fSwgcy5wYXJhbXMpKTtcbiAgICAgICAgY29uc3QgbyA9IE10KFYuRklWRV9NSU5VVEVTKSwgYyA9IEV0KHsgaWQ6IG4sIHBhaXJpbmdUb3BpYzogdCwgZXhwaXJ5OiBvIH0sIHIpO1xuICAgICAgICBhd2FpdCB0aGlzLnNldFByb3Bvc2FsKG4sIGMpO1xuICAgICAgICBjb25zdCB1ID0gRmkoSlNPTi5zdHJpbmdpZnkocykpLCBkID0gYXdhaXQgdGhpcy5nZXRWZXJpZnlDb250ZXh0KHUsIGMucHJvcG9zZXIubWV0YWRhdGEpO1xuICAgICAgICB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fcHJvcG9zYWxcIiwgeyBpZDogbiwgcGFyYW1zOiBjLCB2ZXJpZnlDb250ZXh0OiBkIH0pO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihuLCB0LCBvKSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG8pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIgfSA9IHM7XG4gICAgICBpZiAoaHQocykpIHtcbiAgICAgICAgY29uc3QgeyByZXN1bHQ6IG4gfSA9IHM7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJvblNlc3Npb25Qcm9wb3NlUmVzcG9uc2VcIiwgcmVzdWx0OiBuIH0pO1xuICAgICAgICBjb25zdCBvID0gdGhpcy5jbGllbnQucHJvcG9zYWwuZ2V0KHIpO1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwib25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlXCIsIHByb3Bvc2FsOiBvIH0pO1xuICAgICAgICBjb25zdCBjID0gby5wcm9wb3Nlci5wdWJsaWNLZXk7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJvblNlc3Npb25Qcm9wb3NlUmVzcG9uc2VcIiwgc2VsZlB1YmxpY0tleTogYyB9KTtcbiAgICAgICAgY29uc3QgdSA9IG4ucmVzcG9uZGVyUHVibGljS2V5O1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwib25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlXCIsIHBlZXJQdWJsaWNLZXk6IHUgfSk7XG4gICAgICAgIGNvbnN0IGQgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5nZW5lcmF0ZVNoYXJlZEtleShjLCB1KTtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcIm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZVwiLCBzZXNzaW9uVG9waWM6IGQgfSk7XG4gICAgICAgIGNvbnN0IHAgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIuc3Vic2NyaWJlKGQpO1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwib25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlXCIsIHN1YnNjcmlwdGlvbklkOiBwIH0pLCBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcuYWN0aXZhdGUoeyB0b3BpYzogdCB9KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBHZShzKSAmJiAoYXdhaXQgdGhpcy5jbGllbnQucHJvcG9zYWwuZGVsZXRlKHIsIG50KFwiVVNFUl9ESVNDT05ORUNURURcIikpLCB0aGlzLmV2ZW50cy5lbWl0KEJlKFwic2Vzc2lvbl9jb25uZWN0XCIpLCB7IGVycm9yOiBzLmVycm9yIH0pKTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvblNldHRsZVJlcXVlc3QgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciwgcGFyYW1zOiBuIH0gPSBzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkU2Vzc2lvblNldHRsZVJlcXVlc3Qobik7XG4gICAgICAgIGNvbnN0IHsgcmVsYXk6IG8sIGNvbnRyb2xsZXI6IGMsIGV4cGlyeTogdSwgbmFtZXNwYWNlczogZCwgcmVxdWlyZWROYW1lc3BhY2VzOiBwLCBvcHRpb25hbE5hbWVzcGFjZXM6IGIsIHNlc3Npb25Qcm9wZXJ0aWVzOiB4LCBwYWlyaW5nVG9waWM6IE8gfSA9IHMucGFyYW1zLCBfID0gRXQoeyB0b3BpYzogdCwgcmVsYXk6IG8sIGV4cGlyeTogdSwgbmFtZXNwYWNlczogZCwgYWNrbm93bGVkZ2VkOiAhMCwgcGFpcmluZ1RvcGljOiBPLCByZXF1aXJlZE5hbWVzcGFjZXM6IHAsIG9wdGlvbmFsTmFtZXNwYWNlczogYiwgY29udHJvbGxlcjogYy5wdWJsaWNLZXksIHNlbGY6IHsgcHVibGljS2V5OiBcIlwiLCBtZXRhZGF0YTogdGhpcy5jbGllbnQubWV0YWRhdGEgfSwgcGVlcjogeyBwdWJsaWNLZXk6IGMucHVibGljS2V5LCBtZXRhZGF0YTogYy5tZXRhZGF0YSB9IH0sIHggJiYgeyBzZXNzaW9uUHJvcGVydGllczogeCB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUmVzdWx0KHsgaWQ6IHMuaWQsIHRvcGljOiB0LCByZXN1bHQ6ICEwIH0pLCB0aGlzLmV2ZW50cy5lbWl0KEJlKFwic2Vzc2lvbl9jb25uZWN0XCIpLCB7IHNlc3Npb246IF8gfSksIHRoaXMuY2xlYW51cER1cGxpY2F0ZVBhaXJpbmdzKF8pO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihyLCB0LCBvKSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG8pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uU2V0dGxlUmVzcG9uc2UgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIGh0KHMpID8gKGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24udXBkYXRlKHQsIHsgYWNrbm93bGVkZ2VkOiAhMCB9KSwgdGhpcy5ldmVudHMuZW1pdChCZShcInNlc3Npb25fYXBwcm92ZVwiLCByKSwge30pKSA6IEdlKHMpICYmIChhd2FpdCB0aGlzLmNsaWVudC5zZXNzaW9uLmRlbGV0ZSh0LCBudChcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgdGhpcy5ldmVudHMuZW1pdChCZShcInNlc3Npb25fYXBwcm92ZVwiLCByKSwgeyBlcnJvcjogcy5lcnJvciB9KSk7XG4gICAgfSwgdGhpcy5vblNlc3Npb25VcGRhdGVSZXF1ZXN0ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zOiByLCBpZDogbiB9ID0gcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG8gPSBgJHt0fV9zZXNzaW9uX3VwZGF0ZWAsIGMgPSAkcy5nZXQobyk7XG4gICAgICAgIGlmIChjICYmIHRoaXMuaXNSZXF1ZXN0T3V0T2ZTeW5jKGMsIG4pKSB7XG4gICAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oYERpc2NhcmRpbmcgb3V0IG9mIHN5bmMgcmVxdWVzdCAtICR7bn1gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1ZhbGlkVXBkYXRlKEV0KHsgdG9waWM6IHQgfSwgcikpLCBhd2FpdCB0aGlzLmNsaWVudC5zZXNzaW9uLnVwZGF0ZSh0LCB7IG5hbWVzcGFjZXM6IHIubmFtZXNwYWNlcyB9KSwgYXdhaXQgdGhpcy5zZW5kUmVzdWx0KHsgaWQ6IG4sIHRvcGljOiB0LCByZXN1bHQ6ICEwIH0pLCB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fdXBkYXRlXCIsIHsgaWQ6IG4sIHRvcGljOiB0LCBwYXJhbXM6IHIgfSksICRzLnNldChvLCBuKTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IobiwgdCwgbyksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzUmVxdWVzdE91dE9mU3luYyA9ICh0LCBzKSA9PiBwYXJzZUludChzLnRvU3RyaW5nKCkuc2xpY2UoMCwgLTMpKSA8PSBwYXJzZUludCh0LnRvU3RyaW5nKCkuc2xpY2UoMCwgLTMpKSwgdGhpcy5vblNlc3Npb25VcGRhdGVSZXNwb25zZSA9ICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByIH0gPSBzO1xuICAgICAgaHQocykgPyB0aGlzLmV2ZW50cy5lbWl0KEJlKFwic2Vzc2lvbl91cGRhdGVcIiwgciksIHt9KSA6IEdlKHMpICYmIHRoaXMuZXZlbnRzLmVtaXQoQmUoXCJzZXNzaW9uX3VwZGF0ZVwiLCByKSwgeyBlcnJvcjogcy5lcnJvciB9KTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvbkV4dGVuZFJlcXVlc3QgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZEV4dGVuZCh7IHRvcGljOiB0IH0pLCBhd2FpdCB0aGlzLnNldEV4cGlyeSh0LCBNdChGcykpLCBhd2FpdCB0aGlzLnNlbmRSZXN1bHQoeyBpZDogciwgdG9waWM6IHQsIHJlc3VsdDogITAgfSksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9leHRlbmRcIiwgeyBpZDogciwgdG9waWM6IHQgfSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKHIsIHQsIG4pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iobik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblNlc3Npb25FeHRlbmRSZXNwb25zZSA9ICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByIH0gPSBzO1xuICAgICAgaHQocykgPyB0aGlzLmV2ZW50cy5lbWl0KEJlKFwic2Vzc2lvbl9leHRlbmRcIiwgciksIHt9KSA6IEdlKHMpICYmIHRoaXMuZXZlbnRzLmVtaXQoQmUoXCJzZXNzaW9uX2V4dGVuZFwiLCByKSwgeyBlcnJvcjogcy5lcnJvciB9KTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvblBpbmdSZXF1ZXN0ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIgfSA9IHM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWRQaW5nKHsgdG9waWM6IHQgfSksIGF3YWl0IHRoaXMuc2VuZFJlc3VsdCh7IGlkOiByLCB0b3BpYzogdCwgcmVzdWx0OiAhMCB9KSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX3BpbmdcIiwgeyBpZDogciwgdG9waWM6IHQgfSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKHIsIHQsIG4pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iobik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblNlc3Npb25QaW5nUmVzcG9uc2UgPSAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBodChzKSA/IHRoaXMuZXZlbnRzLmVtaXQoQmUoXCJzZXNzaW9uX3BpbmdcIiwgciksIHt9KSA6IEdlKHMpICYmIHRoaXMuZXZlbnRzLmVtaXQoQmUoXCJzZXNzaW9uX3BpbmdcIiwgciksIHsgZXJyb3I6IHMuZXJyb3IgfSk7XG4gICAgICB9LCA1MDApO1xuICAgIH0sIHRoaXMub25TZXNzaW9uRGVsZXRlUmVxdWVzdCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByIH0gPSBzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkRGlzY29ubmVjdCh7IHRvcGljOiB0LCByZWFzb246IHMucGFyYW1zIH0pLCBhd2FpdCBQcm9taXNlLmFsbChbbmV3IFByb21pc2UoKG4pID0+IHtcbiAgICAgICAgICB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIub25jZShndC5wdWJsaXNoLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBuKGF3YWl0IHRoaXMuZGVsZXRlU2Vzc2lvbih0KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLCB0aGlzLnNlbmRSZXN1bHQoeyBpZDogciwgdG9waWM6IHQsIHJlc3VsdDogITAgfSldKSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX2RlbGV0ZVwiLCB7IGlkOiByLCB0b3BpYzogdCB9KTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG4pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uUmVxdWVzdCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByLCBwYXJhbXM6IG4gfSA9IHM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWRSZXF1ZXN0KEV0KHsgdG9waWM6IHQgfSwgbikpO1xuICAgICAgICBjb25zdCBvID0gRmkoSlNPTi5zdHJpbmdpZnkodGkoXCJ3Y19zZXNzaW9uUmVxdWVzdFwiLCBuLCByKSkpLCBjID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQodCksIHUgPSBhd2FpdCB0aGlzLmdldFZlcmlmeUNvbnRleHQobywgYy5wZWVyLm1ldGFkYXRhKSwgZCA9IHsgaWQ6IHIsIHRvcGljOiB0LCBwYXJhbXM6IG4sIHZlcmlmeUNvbnRleHQ6IHUgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRQZW5kaW5nU2Vzc2lvblJlcXVlc3QoZCksIHRoaXMuYWRkU2Vzc2lvblJlcXVlc3RUb1Nlc3Npb25SZXF1ZXN0UXVldWUoZCksIHRoaXMucHJvY2Vzc1Nlc3Npb25SZXF1ZXN0UXVldWUoKTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IociwgdCwgbyksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uU2Vzc2lvblJlcXVlc3RSZXNwb25zZSA9ICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByIH0gPSBzO1xuICAgICAgaHQocykgPyB0aGlzLmV2ZW50cy5lbWl0KEJlKFwic2Vzc2lvbl9yZXF1ZXN0XCIsIHIpLCB7IHJlc3VsdDogcy5yZXN1bHQgfSkgOiBHZShzKSAmJiB0aGlzLmV2ZW50cy5lbWl0KEJlKFwic2Vzc2lvbl9yZXF1ZXN0XCIsIHIpLCB7IGVycm9yOiBzLmVycm9yIH0pO1xuICAgIH0sIHRoaXMub25TZXNzaW9uRXZlbnRSZXF1ZXN0ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIsIHBhcmFtczogbiB9ID0gcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG8gPSBgJHt0fV9zZXNzaW9uX2V2ZW50XyR7bi5ldmVudC5uYW1lfWAsIGMgPSAkcy5nZXQobyk7XG4gICAgICAgIGlmIChjICYmIHRoaXMuaXNSZXF1ZXN0T3V0T2ZTeW5jKGMsIHIpKSB7XG4gICAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oYERpc2NhcmRpbmcgb3V0IG9mIHN5bmMgcmVxdWVzdCAtICR7cn1gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1ZhbGlkRW1pdChFdCh7IHRvcGljOiB0IH0sIG4pKSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX2V2ZW50XCIsIHsgaWQ6IHIsIHRvcGljOiB0LCBwYXJhbXM6IG4gfSksICRzLnNldChvLCByKTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IociwgdCwgbyksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmFkZFNlc3Npb25SZXF1ZXN0VG9TZXNzaW9uUmVxdWVzdFF1ZXVlID0gKHQpID0+IHtcbiAgICAgIHRoaXMuc2Vzc2lvblJlcXVlc3RRdWV1ZS5xdWV1ZS5wdXNoKHQpO1xuICAgIH0sIHRoaXMuY2xlYW51cEFmdGVyUmVzcG9uc2UgPSAodCkgPT4ge1xuICAgICAgdGhpcy5kZWxldGVQZW5kaW5nU2Vzc2lvblJlcXVlc3QodC5yZXNwb25zZS5pZCwgeyBtZXNzYWdlOiBcImZ1bGZpbGxlZFwiLCBjb2RlOiAwIH0pLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXNzaW9uUmVxdWVzdFF1ZXVlLnN0YXRlID0gZWkuaWRsZSwgdGhpcy5wcm9jZXNzU2Vzc2lvblJlcXVlc3RRdWV1ZSgpO1xuICAgICAgfSwgVi50b01pbGlzZWNvbmRzKHRoaXMucmVxdWVzdFF1ZXVlRGVsYXkpKTtcbiAgICB9LCB0aGlzLnByb2Nlc3NTZXNzaW9uUmVxdWVzdFF1ZXVlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2Vzc2lvblJlcXVlc3RRdWV1ZS5zdGF0ZSA9PT0gZWkuYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci5pbmZvKFwic2Vzc2lvbiByZXF1ZXN0IHF1ZXVlIGlzIGFscmVhZHkgYWN0aXZlLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IHRoaXMuc2Vzc2lvblJlcXVlc3RRdWV1ZS5xdWV1ZVswXTtcbiAgICAgIGlmICghdCkge1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhcInNlc3Npb24gcmVxdWVzdCBxdWV1ZSBpcyBlbXB0eS5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvblJlcXVlc3RRdWV1ZS5zdGF0ZSA9IGVpLmFjdGl2ZSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX3JlcXVlc3RcIiwgdCk7XG4gICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihzKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uUGFpcmluZ0NyZWF0ZWQgPSAodCkgPT4ge1xuICAgICAgaWYgKHQuYWN0aXZlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBzID0gdGhpcy5jbGllbnQucHJvcG9zYWwuZ2V0QWxsKCkuZmluZCgocikgPT4gci5wYWlyaW5nVG9waWMgPT09IHQudG9waWMpO1xuICAgICAgcyAmJiB0aGlzLm9uU2Vzc2lvblByb3Bvc2VSZXF1ZXN0KHQudG9waWMsIHRpKFwid2Nfc2Vzc2lvblByb3Bvc2VcIiwgeyByZXF1aXJlZE5hbWVzcGFjZXM6IHMucmVxdWlyZWROYW1lc3BhY2VzLCBvcHRpb25hbE5hbWVzcGFjZXM6IHMub3B0aW9uYWxOYW1lc3BhY2VzLCByZWxheXM6IHMucmVsYXlzLCBwcm9wb3Nlcjogcy5wcm9wb3NlciB9LCBzLmlkKSk7XG4gICAgfSwgdGhpcy5pc1ZhbGlkQ29ubmVjdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIVN0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdSB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgY29ubmVjdCgpIHBhcmFtczogJHtKU09OLnN0cmluZ2lmeSh0KX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBwYWlyaW5nVG9waWM6IHMsIHJlcXVpcmVkTmFtZXNwYWNlczogciwgb3B0aW9uYWxOYW1lc3BhY2VzOiBuLCBzZXNzaW9uUHJvcGVydGllczogbywgcmVsYXlzOiBjIH0gPSB0O1xuICAgICAgaWYgKGJ0KHMpIHx8IGF3YWl0IHRoaXMuaXNWYWxpZFBhaXJpbmdUb3BpYyhzKSwgIVFwKGMsICEwKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHUgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGNvbm5lY3QoKSByZWxheXM6ICR7Y31gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUpO1xuICAgICAgfVxuICAgICAgIWJ0KHIpICYmIGNzKHIpICE9PSAwICYmIHRoaXMudmFsaWRhdGVOYW1lc3BhY2VzKHIsIFwicmVxdWlyZWROYW1lc3BhY2VzXCIpLCAhYnQobikgJiYgY3MobikgIT09IDAgJiYgdGhpcy52YWxpZGF0ZU5hbWVzcGFjZXMobiwgXCJvcHRpb25hbE5hbWVzcGFjZXNcIiksIGJ0KG8pIHx8IHRoaXMudmFsaWRhdGVTZXNzaW9uUHJvcHMobywgXCJzZXNzaW9uUHJvcGVydGllc1wiKTtcbiAgICB9LCB0aGlzLnZhbGlkYXRlTmFtZXNwYWNlcyA9ICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCByID0gSnAodCwgXCJjb25uZWN0KClcIiwgcyk7XG4gICAgICBpZiAocilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHIubWVzc2FnZSk7XG4gICAgfSwgdGhpcy5pc1ZhbGlkQXBwcm92ZSA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIVN0KHQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgYXBwcm92ZSgpIHBhcmFtczogJHt0fWApLm1lc3NhZ2UpO1xuICAgICAgY29uc3QgeyBpZDogcywgbmFtZXNwYWNlczogciwgcmVsYXlQcm90b2NvbDogbiwgc2Vzc2lvblByb3BlcnRpZXM6IG8gfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRQcm9wb3NhbElkKHMpO1xuICAgICAgY29uc3QgYyA9IHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldChzKSwgdSA9IHpzKHIsIFwiYXBwcm92ZSgpXCIpO1xuICAgICAgaWYgKHUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1Lm1lc3NhZ2UpO1xuICAgICAgY29uc3QgZCA9IE1vKGMucmVxdWlyZWROYW1lc3BhY2VzLCByLCBcImFwcHJvdmUoKVwiKTtcbiAgICAgIGlmIChkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZC5tZXNzYWdlKTtcbiAgICAgIGlmICghb3QobiwgITApKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogcCB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgYXBwcm92ZSgpIHJlbGF5UHJvdG9jb2w6ICR7bn1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHApO1xuICAgICAgfVxuICAgICAgYnQobykgfHwgdGhpcy52YWxpZGF0ZVNlc3Npb25Qcm9wcyhvLCBcInNlc3Npb25Qcm9wZXJ0aWVzXCIpO1xuICAgIH0sIHRoaXMuaXNWYWxpZFJlamVjdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIVN0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVqZWN0KCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaWQ6IHMsIHJlYXNvbjogciB9ID0gdDtcbiAgICAgIGlmIChhd2FpdCB0aGlzLmlzVmFsaWRQcm9wb3NhbElkKHMpLCAhWnAocikpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZWplY3QoKSByZWFzb246ICR7SlNPTi5zdHJpbmdpZnkocil9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzVmFsaWRTZXNzaW9uU2V0dGxlUmVxdWVzdCA9ICh0KSA9PiB7XG4gICAgICBpZiAoIVN0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogZCB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgb25TZXNzaW9uU2V0dGxlUmVxdWVzdCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHJlbGF5OiBzLCBjb250cm9sbGVyOiByLCBuYW1lc3BhY2VzOiBuLCBleHBpcnk6IG8gfSA9IHQ7XG4gICAgICBpZiAoIUtjKHMpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogZCB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBcIm9uU2Vzc2lvblNldHRsZVJlcXVlc3QoKSByZWxheSBwcm90b2NvbCBzaG91bGQgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGMgPSBCcChyLCBcIm9uU2Vzc2lvblNldHRsZVJlcXVlc3QoKVwiKTtcbiAgICAgIGlmIChjKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYy5tZXNzYWdlKTtcbiAgICAgIGNvbnN0IHUgPSB6cyhuLCBcIm9uU2Vzc2lvblNldHRsZVJlcXVlc3QoKVwiKTtcbiAgICAgIGlmICh1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodS5tZXNzYWdlKTtcbiAgICAgIGlmIChhaShvKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGQgfSA9IFkoXCJFWFBJUkVEXCIsIFwib25TZXNzaW9uU2V0dGxlUmVxdWVzdCgpXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1ZhbGlkVXBkYXRlID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghU3QodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB1IH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGB1cGRhdGUoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogcywgbmFtZXNwYWNlczogciB9ID0gdDtcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFNlc3Npb25Ub3BpYyhzKTtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmNsaWVudC5zZXNzaW9uLmdldChzKSwgbyA9IHpzKHIsIFwidXBkYXRlKClcIik7XG4gICAgICBpZiAobylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG8ubWVzc2FnZSk7XG4gICAgICBjb25zdCBjID0gTW8obi5yZXF1aXJlZE5hbWVzcGFjZXMsIHIsIFwidXBkYXRlKClcIik7XG4gICAgICBpZiAoYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMubWVzc2FnZSk7XG4gICAgfSwgdGhpcy5pc1ZhbGlkRXh0ZW5kID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghU3QodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiByIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBleHRlbmQoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHIpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogcyB9ID0gdDtcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFNlc3Npb25Ub3BpYyhzKTtcbiAgICB9LCB0aGlzLmlzVmFsaWRSZXF1ZXN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghU3QodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB1IH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZXF1ZXN0KCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IHMsIHJlcXVlc3Q6IHIsIGNoYWluSWQ6IG4sIGV4cGlyeTogbyB9ID0gdDtcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFNlc3Npb25Ub3BpYyhzKTtcbiAgICAgIGNvbnN0IHsgbmFtZXNwYWNlczogYyB9ID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQocyk7XG4gICAgICBpZiAoIUxvKGMsIG4pKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdSB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVxdWVzdCgpIGNoYWluSWQ6ICR7bn1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUpO1xuICAgICAgfVxuICAgICAgaWYgKCFlZyhyKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHUgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlcXVlc3QoKSAke0pTT04uc3RyaW5naWZ5KHIpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodSk7XG4gICAgICB9XG4gICAgICBpZiAoIXNnKGMsIG4sIHIubWV0aG9kKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHUgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlcXVlc3QoKSBtZXRob2Q6ICR7ci5tZXRob2R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1KTtcbiAgICAgIH1cbiAgICAgIGlmIChvICYmICFhZyhvLCBDcikpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB1IH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZXF1ZXN0KCkgZXhwaXJ5OiAke299LiBFeHBpcnkgbXVzdCBiZSBhIG51bWJlciAoaW4gc2Vjb25kcykgYmV0d2VlbiAke0NyLm1pbn0gYW5kICR7Q3IubWF4fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1ZhbGlkUmVzcG9uZCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIVN0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVzcG9uZCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCByZXNwb25zZTogciB9ID0gdDtcbiAgICAgIGlmIChhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uVG9waWMocyksICF0ZyhyKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlc3BvbmQoKSByZXNwb25zZTogJHtKU09OLnN0cmluZ2lmeShyKX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG4pO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaXNWYWxpZFBpbmcgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFTdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHIgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHBpbmcoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHIpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogcyB9ID0gdDtcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFNlc3Npb25PclBhaXJpbmdUb3BpYyhzKTtcbiAgICB9LCB0aGlzLmlzVmFsaWRFbWl0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghU3QodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBjIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBlbWl0KCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IHMsIGV2ZW50OiByLCBjaGFpbklkOiBuIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvblRvcGljKHMpO1xuICAgICAgY29uc3QgeyBuYW1lc3BhY2VzOiBvIH0gPSB0aGlzLmNsaWVudC5zZXNzaW9uLmdldChzKTtcbiAgICAgIGlmICghTG8obywgbikpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBjIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBlbWl0KCkgY2hhaW5JZDogJHtufWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlnKHIpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogYyB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZW1pdCgpIGV2ZW50OiAke0pTT04uc3RyaW5naWZ5KHIpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYyk7XG4gICAgICB9XG4gICAgICBpZiAoIXJnKG8sIG4sIHIubmFtZSkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBjIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBlbWl0KCkgZXZlbnQ6ICR7SlNPTi5zdHJpbmdpZnkocil9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzVmFsaWREaXNjb25uZWN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghU3QodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiByIH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBkaXNjb25uZWN0KCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IHMgfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uT3JQYWlyaW5nVG9waWMocyk7XG4gICAgfSwgdGhpcy5nZXRWZXJpZnlDb250ZXh0ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHIgPSB7IHZlcmlmaWVkOiB7IHZlcmlmeVVybDogcy52ZXJpZnlVcmwgfHwgS3MsIHZhbGlkYXRpb246IFwiVU5LTk9XTlwiLCBvcmlnaW46IHMudXJsIHx8IFwiXCIgfSB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbiA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUudmVyaWZ5LnJlc29sdmUoeyBhdHRlc3RhdGlvbklkOiB0LCB2ZXJpZnlVcmw6IHMudmVyaWZ5VXJsIH0pO1xuICAgICAgICBuICYmIChyLnZlcmlmaWVkLm9yaWdpbiA9IG4ub3JpZ2luLCByLnZlcmlmaWVkLmlzU2NhbSA9IG4uaXNTY2FtLCByLnZlcmlmaWVkLnZhbGlkYXRpb24gPSBuLm9yaWdpbiA9PT0gbmV3IFVSTChzLnVybCkub3JpZ2luID8gXCJWQUxJRFwiIDogXCJJTlZBTElEXCIpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhgVmVyaWZ5IGNvbnRleHQ6ICR7SlNPTi5zdHJpbmdpZnkocil9YCksIHI7XG4gICAgfSwgdGhpcy52YWxpZGF0ZVNlc3Npb25Qcm9wcyA9ICh0LCBzKSA9PiB7XG4gICAgICBPYmplY3QudmFsdWVzKHQpLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgaWYgKCFvdChyLCAhMSkpIHtcbiAgICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYCR7c30gbXVzdCBiZSBpbiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IGZvcm1hdC4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkocil9YCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGFzeW5jIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IFkoXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLmNvbmZpcm1PbmxpbmVTdGF0ZU9yVGhyb3coKTtcbiAgfVxuICByZWdpc3RlclJlbGF5ZXJFdmVudHMoKSB7XG4gICAgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLm9uKGd0Lm1lc3NhZ2UsIGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiB0LCBtZXNzYWdlOiBzIH0gPSBlO1xuICAgICAgaWYgKHRoaXMuaWdub3JlZFBheWxvYWRUeXBlcy5pbmNsdWRlcyh0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5nZXRQYXlsb2FkVHlwZShzKSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5kZWNvZGUodCwgcyk7XG4gICAgICB0cnkge1xuICAgICAgICBqaShyKSA/ICh0aGlzLmNsaWVudC5jb3JlLmhpc3Rvcnkuc2V0KHQsIHIpLCB0aGlzLm9uUmVsYXlFdmVudFJlcXVlc3QoeyB0b3BpYzogdCwgcGF5bG9hZDogciB9KSkgOiBPaShyKSA/IChhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkucmVzb2x2ZShyKSwgYXdhaXQgdGhpcy5vblJlbGF5RXZlbnRSZXNwb25zZSh7IHRvcGljOiB0LCBwYXlsb2FkOiByIH0pLCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkuZGVsZXRlKHQsIHIuaWQpKSA6IHRoaXMub25SZWxheUV2ZW50VW5rbm93blBheWxvYWQoeyB0b3BpYzogdCwgcGF5bG9hZDogciB9KTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlZ2lzdGVyRXhwaXJlckV2ZW50cygpIHtcbiAgICB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIub24oVHQuZXhwaXJlZCwgYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHQsIGlkOiBzIH0gPSBqYyhlLnRhcmdldCk7XG4gICAgICBpZiAocyAmJiB0aGlzLmNsaWVudC5wZW5kaW5nUmVxdWVzdC5rZXlzLmluY2x1ZGVzKHMpKVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kZWxldGVQZW5kaW5nU2Vzc2lvblJlcXVlc3QocywgWShcIkVYUElSRURcIiksICEwKTtcbiAgICAgIHQgPyB0aGlzLmNsaWVudC5zZXNzaW9uLmtleXMuaW5jbHVkZXModCkgJiYgKGF3YWl0IHRoaXMuZGVsZXRlU2Vzc2lvbih0LCAhMCksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9leHBpcmVcIiwgeyB0b3BpYzogdCB9KSkgOiBzICYmIChhd2FpdCB0aGlzLmRlbGV0ZVByb3Bvc2FsKHMsICEwKSwgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJwcm9wb3NhbF9leHBpcmVcIiwgeyBpZDogcyB9KSk7XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJQYWlyaW5nRXZlbnRzKCkge1xuICAgIHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5ldmVudHMub24ob3MuY3JlYXRlLCAoZSkgPT4gdGhpcy5vblBhaXJpbmdDcmVhdGVkKGUpKTtcbiAgfVxuICBpc1ZhbGlkUGFpcmluZ1RvcGljKGUpIHtcbiAgICBpZiAoIW90KGUsICExKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBZKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwYWlyaW5nIHRvcGljIHNob3VsZCBiZSBhIHN0cmluZzogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKGUpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IFkoXCJOT19NQVRDSElOR19LRVlcIiwgYHBhaXJpbmcgdG9waWMgZG9lc24ndCBleGlzdDogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgICBpZiAoYWkodGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXJpbmdzLmdldChlKS5leHBpcnkpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IFkoXCJFWFBJUkVEXCIsIGBwYWlyaW5nIHRvcGljOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGlzVmFsaWRTZXNzaW9uVG9waWMoZSkge1xuICAgIGlmICghb3QoZSwgITEpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHNlc3Npb24gdG9waWMgc2hvdWxkIGJlIGEgc3RyaW5nOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKGUpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IFkoXCJOT19NQVRDSElOR19LRVlcIiwgYHNlc3Npb24gdG9waWMgZG9lc24ndCBleGlzdDogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgICBpZiAoYWkodGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQoZSkuZXhwaXJ5KSkge1xuICAgICAgYXdhaXQgdGhpcy5kZWxldGVTZXNzaW9uKGUpO1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBZKFwiRVhQSVJFRFwiLCBgc2Vzc2lvbiB0b3BpYzogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBpc1ZhbGlkU2Vzc2lvbk9yUGFpcmluZ1RvcGljKGUpIHtcbiAgICBpZiAodGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKGUpKVxuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvblRvcGljKGUpO1xuICAgIGVsc2UgaWYgKHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKGUpKVxuICAgICAgdGhpcy5pc1ZhbGlkUGFpcmluZ1RvcGljKGUpO1xuICAgIGVsc2UgaWYgKG90KGUsICExKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBZKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGBzZXNzaW9uIG9yIHBhaXJpbmcgdG9waWMgZG9lc24ndCBleGlzdDogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IFkoXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHNlc3Npb24gb3IgcGFpcmluZyB0b3BpYyBzaG91bGQgYmUgYSBzdHJpbmc6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaXNWYWxpZFByb3Bvc2FsSWQoZSkge1xuICAgIGlmICghWHAoZSkpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gWShcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcHJvcG9zYWwgaWQgc2hvdWxkIGJlIGEgbnVtYmVyOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jbGllbnQucHJvcG9zYWwua2V5cy5pbmNsdWRlcyhlKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBZKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGBwcm9wb3NhbCBpZCBkb2Vzbid0IGV4aXN0OiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmIChhaSh0aGlzLmNsaWVudC5wcm9wb3NhbC5nZXQoZSkuZXhwaXJ5KSkge1xuICAgICAgYXdhaXQgdGhpcy5kZWxldGVQcm9wb3NhbChlKTtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gWShcIkVYUElSRURcIiwgYHByb3Bvc2FsIGlkOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICB9XG59LCB2bSA9IGNsYXNzIGV4dGVuZHMgZHIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCwgY20sIFNuKSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59LCBfbSA9IGNsYXNzIGV4dGVuZHMgZHIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCwgdW0sIFNuKSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59LCBFbSA9IGNsYXNzIGV4dGVuZHMgZHIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCwgZG0sIFNuLCAocykgPT4gcy5pZCksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdDtcbiAgfVxufSwgU20gPSBjbGFzcyBwaCBleHRlbmRzIEVsIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLnByb3RvY29sID0gbGgsIHRoaXMudmVyc2lvbiA9IGRoLCB0aGlzLm5hbWUgPSBSci5uYW1lLCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5vbiA9IChzLCByKSA9PiB0aGlzLmV2ZW50cy5vbihzLCByKSwgdGhpcy5vbmNlID0gKHMsIHIpID0+IHRoaXMuZXZlbnRzLm9uY2UocywgciksIHRoaXMub2ZmID0gKHMsIHIpID0+IHRoaXMuZXZlbnRzLm9mZihzLCByKSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChzLCByKSA9PiB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihzLCByKSwgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSAocykgPT4gdGhpcy5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKHMpLCB0aGlzLmNvbm5lY3QgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLmNvbm5lY3Qocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5wYWlyID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5wYWlyKHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMuYXBwcm92ZSA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUuYXBwcm92ZShzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnJlamVjdCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUucmVqZWN0KHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMudXBkYXRlID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS51cGRhdGUocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5leHRlbmQgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLmV4dGVuZChzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnJlcXVlc3QgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLnJlcXVlc3Qocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5yZXNwb25kID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5yZXNwb25kKHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMucGluZyA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUucGluZyhzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmVtaXQgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLmVtaXQocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5kaXNjb25uZWN0ID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5kaXNjb25uZWN0KHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMuZmluZCA9IChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUuZmluZChzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmdldFBlbmRpbmdTZXNzaW9uUmVxdWVzdHMgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUuZ2V0UGVuZGluZ1Nlc3Npb25SZXF1ZXN0cygpO1xuICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihzLm1lc3NhZ2UpLCBzO1xuICAgICAgfVxuICAgIH0sIHRoaXMubmFtZSA9IGU/Lm5hbWUgfHwgUnIubmFtZSwgdGhpcy5tZXRhZGF0YSA9IGU/Lm1ldGFkYXRhIHx8IGdwKCk7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBlPy5sb2dnZXIgPCBcInVcIiAmJiB0eXBlb2YgZT8ubG9nZ2VyICE9IFwic3RyaW5nXCIgPyBlLmxvZ2dlciA6IGVlLnBpbm8oZWUuZ2V0RGVmYXVsdExvZ2dlck9wdGlvbnMoeyBsZXZlbDogZT8ubG9nZ2VyIHx8IFJyLmxvZ2dlciB9KSk7XG4gICAgdGhpcy5jb3JlID0gZT8uY29yZSB8fCBuZXcgYW0oZSksIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLnNlc3Npb24gPSBuZXcgX20odGhpcy5jb3JlLCB0aGlzLmxvZ2dlciksIHRoaXMucHJvcG9zYWwgPSBuZXcgdm0odGhpcy5jb3JlLCB0aGlzLmxvZ2dlciksIHRoaXMucGVuZGluZ1JlcXVlc3QgPSBuZXcgRW0odGhpcy5jb3JlLCB0aGlzLmxvZ2dlciksIHRoaXMuZW5naW5lID0gbmV3IHdtKHRoaXMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBpbml0KGUpIHtcbiAgICBjb25zdCB0ID0gbmV3IHBoKGUpO1xuICAgIHJldHVybiBhd2FpdCB0LmluaXRpYWxpemUoKSwgdDtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHBhaXJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29yZS5wYWlyaW5nLnBhaXJpbmdzO1xuICB9XG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jb3JlLnN0YXJ0KCksIGF3YWl0IHRoaXMuc2Vzc2lvbi5pbml0KCksIGF3YWl0IHRoaXMucHJvcG9zYWwuaW5pdCgpLCBhd2FpdCB0aGlzLnBlbmRpbmdSZXF1ZXN0LmluaXQoKSwgYXdhaXQgdGhpcy5lbmdpbmUuaW5pdCgpLCB0aGlzLmNvcmUudmVyaWZ5LmluaXQoeyB2ZXJpZnlVcmw6IHRoaXMubWV0YWRhdGEudmVyaWZ5VXJsIH0pLCB0aGlzLmxvZ2dlci5pbmZvKFwiU2lnbkNsaWVudCBJbml0aWFsaXphdGlvbiBTdWNjZXNzXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IHRoaXMubG9nZ2VyLmluZm8oXCJTaWduQ2xpZW50IEluaXRpYWxpemF0aW9uIEZhaWx1cmVcIiksIHRoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSksIGU7XG4gICAgfVxuICB9XG59O1xuY29uc3QgSW0gPSAoKSA9PiB7XG4gIGNvbnN0IGUgPSBobigpPy5vcz8udG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGU/LmluY2x1ZGVzKFwiYW5kcm9pZFwiKSA/IFwiYW5kcm9pZFwiIDogZT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImlvc1wiKSB8fCBlPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwibWFjXCIpICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEgPyBcImlvc1wiIDogXCJkZXNrdG9wXCI7XG59LCBVcyA9IEltKCksIERtID0ge1xuICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICB0b3A6IFwiMFwiLFxuICBsZWZ0OiBcIjBcIixcbiAgcmlnaHQ6IFwiMFwiLFxuICBib3R0b206IFwiMFwiLFxuICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgwLDAsMCwwLjgpXCIsXG4gIGJhY2tkcm9wRmlsdGVyOiBcImJsdXIoMTBweClcIixcbiAgekluZGV4OiBcIjk5OTlcIixcbiAgZGlzcGxheTogXCJmbGV4XCIsXG4gIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICBjb2xvcjogXCJ3aGl0ZVwiLFxuICBmb250V2VpZ2h0OiBcIjUwMFwiLFxuICBmb250RmFtaWx5OiBcIidCYXJsb3cnLCBzYW5zLXNlcmlmXCJcbn0sIHhtID0ge1xuICB3aWR0aDogXCI4NDBweFwiLFxuICBoZWlnaHQ6IFwiNTQwcHhcIixcbiAgekluZGV4OiBcIjk5OTk5XCIsXG4gIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiLFxuICBib3JkZXI6IFwibm9uZVwiLFxuICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgYm9yZGVyUmFkaXVzOiBcIjQwcHhcIixcbiAgYm94U2hhZG93OiBcIjBweCA0cHggNDBweCAwcHggcmdiKDAgMCAwKSwgMHB4IDRweCA4cHggMHB4IHJnYigwIDAgMCAvIDI1JSlcIixcbiAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgdG9wOiBcIjUwJVwiLFxuICBsZWZ0OiBcIjUwJVwiLFxuICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUsLTUwJSlcIlxufSwgT20gPSBgXG4gIDxkaXYgaWQ9XCJhcmdlbnQtbW9iaWxlLW1vZGFsLWNvbnRhaW5lclwiIHN0eWxlPVwicG9zaXRpb246IHJlbGF0aXZlXCI+XG4gICAgPGlmcmFtZSBjbGFzcz1cImFyZ2VudC1pZnJhbWVcIiBhbGxvdz1cImNsaXBib2FyZC13cml0ZVwiPjwvaWZyYW1lPlxuICAgIDxkaXYgY2xhc3M9XCJhcmdlbnQtY2xvc2UtYnV0dG9uXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMjRweDsgcmlnaHQ6IDI0cHg7IGN1cnNvcjogcG9pbnRlcjtcIj5cbiAgICAgIDxzdmcgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgICA8Y2lyY2xlIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjE2XCIgZmlsbD1cIiNGNUYzRjBcIi8+XG4gICAgICAgIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgZD1cIk0yMi4yNDYyIDkuNzUzODJDMjIuNzAxOCAxMC4yMDk0IDIyLjcwMTggMTAuOTQ4MSAyMi4yNDYyIDExLjQwMzdMMTcuNjQ5OSAxNkwyMi4yNDYyIDIwLjU5NjNDMjIuNzAxOCAyMS4wNTE5IDIyLjcwMTggMjEuNzkwNiAyMi4yNDYyIDIyLjI0NjJDMjEuNzkwNSAyMi43MDE4IDIxLjA1MTkgMjIuNzAxOCAyMC41OTYyIDIyLjI0NjJMMTYgMTcuNjQ5OUwxMS40MDM5IDIyLjI0NkMxMC45NDgyIDIyLjcwMTcgMTAuMjA5NiAyMi43MDE3IDkuNzUzOTQgMjIuMjQ2QzkuMjk4MzMgMjEuNzkwNCA5LjI5ODMzIDIxLjA1MTcgOS43NTM5NCAyMC41OTYxTDE0LjM1MDEgMTZMOS43NTM5NCAxMS40MDM5QzkuMjk4MzMgMTAuOTQ4MyA5LjI5ODMzIDEwLjIwOTYgOS43NTM5NCA5Ljc1Mzk2QzEwLjIwOTYgOS4yOTgzNSAxMC45NDgyIDkuMjk4MzUgMTEuNDAzOSA5Ljc1Mzk2TDE2IDE0LjM1MDFMMjAuNTk2MiA5Ljc1MzgyQzIxLjA1MTkgOS4yOTgyMSAyMS43OTA1IDkuMjk4MjEgMjIuMjQ2MiA5Ljc1MzgyWlwiIGZpbGw9XCIjMzMzMzMyXCIvPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuYDtcbmNsYXNzIE5tIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgd2UodGhpcywgXCJicmlkZ2VVcmxcIiwgXCJodHRwczovL2xvZ2luLmFyZ2VudC54eXpcIik7XG4gICAgd2UodGhpcywgXCJtb2JpbGVVcmxcIiwgXCJhcmdlbnQ6Ly9cIik7XG4gICAgd2UodGhpcywgXCJ0eXBlXCIsIFwib3ZlcmxheVwiKTtcbiAgICB3ZSh0aGlzLCBcIndjVXJpXCIpO1xuICAgIHdlKHRoaXMsIFwib3ZlcmxheVwiKTtcbiAgICB3ZSh0aGlzLCBcInBvcHVwV2luZG93XCIpO1xuICAgIHdlKHRoaXMsIFwiY2xvc2luZ1RpbWVvdXRcIik7XG4gICAgd2UodGhpcywgXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLm92ZXJsYXk/LnJlbW92ZSgpLCB0aGlzLnBvcHVwV2luZG93Py5jbG9zZSgpLCB0aGlzLm92ZXJsYXkgPSB2b2lkIDAsIHRoaXMucG9wdXBXaW5kb3cgPSB2b2lkIDA7XG4gICAgfSk7XG4gIH1cbiAgc2hvd0Nvbm5lY3Rpb25Nb2RhbChlKSB7XG4gICAgY29uc3QgdCA9IGVuY29kZVVSSUNvbXBvbmVudChlKSwgcyA9IGVuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgdGhpcy5zaG93TW9kYWwoe1xuICAgICAgZGVza3RvcDogYCR7dGhpcy5icmlkZ2VVcmx9P3djPSR7dH0mZGV2aWNlPWRlc2t0b3BgLFxuICAgICAgaW9zOiBgJHt0aGlzLm1vYmlsZVVybH1hcHAvd2M/dXJpPSR7dH0maHJlZj0ke3N9JmRldmljZT1tb2JpbGVgLFxuICAgICAgYW5kcm9pZDogYCR7dGhpcy5tb2JpbGVVcmx9YXBwL3djP3VyaT0ke3R9JmhyZWY9JHtzfSZkZXZpY2U9bW9iaWxlYFxuICAgIH0pO1xuICB9XG4gIHNob3dBcHByb3ZhbE1vZGFsKGUpIHtcbiAgICBpZiAoVXMgPT09IFwiZGVza3RvcFwiKSB7XG4gICAgICB0aGlzLnNob3dNb2RhbCh7XG4gICAgICAgIGRlc2t0b3A6IGAke3RoaXMuYnJpZGdlVXJsfT9hY3Rpb249c2lnbmAsXG4gICAgICAgIGlvczogXCJcIixcbiAgICAgICAgYW5kcm9pZDogXCJcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHQgPSBlbmNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIHRoaXMuc2hvd01vZGFsKHtcbiAgICAgIGRlc2t0b3A6IGAke3RoaXMuYnJpZGdlVXJsfT9hY3Rpb249c2lnbiZkZXZpY2U9ZGVza3RvcGAsXG4gICAgICBpb3M6IGAke3RoaXMubW9iaWxlVXJsfWFwcC93Yy9yZXF1ZXN0P2hyZWY9JHt0fSZkZXZpY2U9bW9iaWxlYCxcbiAgICAgIGFuZHJvaWQ6IGAke3RoaXMubW9iaWxlVXJsfWFwcC93Yy9yZXF1ZXN0P2hyZWY9JHt0fSZkZXZpY2U9bW9iaWxlYFxuICAgIH0pO1xuICB9XG4gIGNsb3NlTW9kYWwoZSkge1xuICAgIGUgPyAodGhpcy5vdmVybGF5Py5xdWVyeVNlbGVjdG9yKFwiaWZyYW1lXCIpPy5jb250ZW50V2luZG93Py5wb3N0TWVzc2FnZShcImFyZ2VudC1sb2dpbi5zdWNjZXNzXCIsIFwiKlwiKSwgdGhpcy5wb3B1cFdpbmRvdz8ucG9zdE1lc3NhZ2UoXCJhcmdlbnQtbG9naW4uc3VjY2Vzc1wiLCBcIipcIiksIHRoaXMuY2xvc2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuY2xvc2UsIDM0MDApKSA6IHRoaXMuY2xvc2UoKTtcbiAgfVxuICBzaG93TW9kYWwoZSkge1xuICAgIGlmIChjbGVhclRpbWVvdXQodGhpcy5jbG9zaW5nVGltZW91dCksICh0aGlzLm92ZXJsYXkgfHwgdGhpcy5wb3B1cFdpbmRvdykgJiYgdGhpcy5jbG9zZSgpLCBVcyA9PT0gXCJhbmRyb2lkXCIgfHwgVXMgPT09IFwiaW9zXCIpIHtcbiAgICAgIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBlW1VzXTtcbiAgICAgIH0pLCBuLmNsaWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnR5cGUgPT09IFwid2luZG93XCIpIHtcbiAgICAgIGNvbnN0IG4gPSBcIm1lbnViYXI9bm8sbG9jYXRpb249bm8scmVzaXphYmxlPW5vLHNjcm9sbGJhcnM9bm8sc3RhdHVzPW5vLHdpZHRoPTg0MCxoZWlnaHQ9NTQwXCI7XG4gICAgICB0aGlzLnBvcHVwV2luZG93ID0gd2luZG93Lm9wZW4oZS5kZXNrdG9wLCBcIl9ibGFua1wiLCBuKSB8fCB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHQuaW5uZXJIVE1MID0gT20sIHQuaWQgPSBcImFyZ2VudC1tb2JpbGUtbW9kYWwtb3ZlcmxheVwiO1xuICAgIGZvciAoY29uc3QgW24sIG9dIG9mIE9iamVjdC5lbnRyaWVzKERtKSlcbiAgICAgIHQuc3R5bGVbbl0gPSBvO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodCksIHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuY2xvc2VNb2RhbCgpKSwgdGhpcy5vdmVybGF5ID0gdDtcbiAgICBjb25zdCBzID0gdC5xdWVyeVNlbGVjdG9yKFwiaWZyYW1lXCIpO1xuICAgIHMuc2V0QXR0cmlidXRlKFwic3JjXCIsIGUuZGVza3RvcCk7XG4gICAgZm9yIChjb25zdCBbbiwgb10gb2YgT2JqZWN0LmVudHJpZXMoeG0pKVxuICAgICAgcy5zdHlsZVtuXSA9IG87XG4gICAgdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgXCIuYXJnZW50LWNsb3NlLWJ1dHRvblwiXG4gICAgKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5jbG9zZU1vZGFsKCkpO1xuICB9XG59XG5jb25zdCBrdCA9IG5ldyBObSgpLCBYcyA9IE1zLk5ldHdvcmtOYW1lLCBQbSA9IGFzeW5jICh7XG4gIHByb2plY3RJZDogaSxcbiAgY2hhaW5JZDogZSxcbiAgbmFtZTogdCxcbiAgZGVzY3JpcHRpb246IHMsXG4gIHJwY1VybDogcixcbiAgYnJpZGdlVXJsOiBuID0gUm0oZSksXG4gIG1vYmlsZVVybDogbyA9IENtKGUpLFxuICBtb2RhbFR5cGU6IGMgPSBcIm92ZXJsYXlcIixcbiAgdXJsOiB1LFxuICBpY29uczogZCxcbiAgd2FsbGV0Q29ubmVjdDogcCxcbiAgcHJvdmlkZXI6IGJcbn0sIHgpID0+IHtcbiAgaWYgKCFuKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJyaWRnZVVybCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKCFvKVxuICAgIHRocm93IG5ldyBFcnJvcihcIm1vYmlsZVVybCBpcyByZXF1aXJlZFwiKTtcbiAga3QuYnJpZGdlVXJsID0gbiwga3QubW9iaWxlVXJsID0gbywga3QudHlwZSA9IGM7XG4gIGNvbnN0IE8gPSB7XG4gICAgcHJvamVjdElkOiBpLFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICBuYW1lOiB0ID8/IFwiVW5rbm93biBkYXBwXCIsXG4gICAgICBkZXNjcmlwdGlvbjogcyA/PyBcIlVua25vd24gZGFwcCBkZXNjcmlwdGlvblwiLFxuICAgICAgdXJsOiB1ID8/IFwiI1wiLFxuICAgICAgaWNvbnM6IGQgPz8gW10sXG4gICAgICAuLi5wPy5tZXRhZGF0YVxuICAgIH1cbiAgfSwgXyA9IGF3YWl0IFNtLmluaXQoTyksIEMgPSBuZXcgeCh7IGNsaWVudDogXywgY2hhaW5JZDogZSwgcnBjVXJsOiByLCBwcm92aWRlcjogYiB9KTtcbiAgXy5vbihcInNlc3Npb25fZXZlbnRcIiwgKEYpID0+IHtcbiAgfSksIF8ub24oXCJzZXNzaW9uX3VwZGF0ZVwiLCAoeyB0b3BpYzogRiwgcGFyYW1zOiBLIH0pID0+IHtcbiAgICBjb25zdCB7IG5hbWVzcGFjZXM6IEkgfSA9IEssIEQgPSBfLnNlc3Npb24uZ2V0KEYpO1xuICAgIEMudXBkYXRlU2Vzc2lvbih7IC4uLkQsIG5hbWVzcGFjZXM6IEkgfSk7XG4gIH0pLCBfLm9uKFwic2Vzc2lvbl9kZWxldGVcIiwgKCkgPT4ge1xuICB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCBGID0gXy5zZXNzaW9uLmdldEFsbCgpLmZpbmQoQy5pc1ZhbGlkU2Vzc2lvbik7XG4gICAgaWYgKEYpXG4gICAgICByZXR1cm4gQy51cGRhdGVTZXNzaW9uKEYpLCBDO1xuICAgIGNvbnN0IEsgPSB7IHJlcXVpcmVkTmFtZXNwYWNlczogQy5nZXRSZXF1aXJlZE5hbWVzcGFjZXMoKSB9O1xuICAgIFV1KCksIGF3YWl0IG5ldyBQcm9taXNlKCh5KSA9PiBzZXRUaW1lb3V0KHksIDIwMCkpO1xuICAgIGNvbnN0IHsgdXJpOiBJLCBhcHByb3ZhbDogRCB9ID0gYXdhaXQgXy5jb25uZWN0KEspO1xuICAgIGlmIChJKSB7XG4gICAgICBrdC5zaG93Q29ubmVjdGlvbk1vZGFsKEkpLCBrdC53Y1VyaSA9IEk7XG4gICAgICBjb25zdCB5ID0gYXdhaXQgRCgpO1xuICAgICAgQy51cGRhdGVTZXNzaW9uKHkpLCBrdC5jbG9zZU1vZGFsKFwiYW5pbWF0ZVN1Y2Nlc3NcIik7XG4gICAgfVxuICAgIHJldHVybiBDO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkBhcmdlbnQvbG9naW46OmVycm9yXCIpLCBrdC5jbG9zZU1vZGFsKCksIG51bGw7XG4gIH1cbn0sIFJtID0gKGkpID0+IHtcbiAgaWYgKCFpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVbmtub3duIG9yIHVuc3VwcG9ydGVkIGNoYWluSWQgKCR7aX0pLCBlaXRoZXIgc3BlY2lmeSBhIHN1cHBvcnRlZCBjaGFpbiBvciBzZXQgYnJpZGdlVXJsLmBcbiAgICApO1xuICBjb25zdCBlID0gcGFyc2VJbnQoYCR7aX1gKTtcbiAgaWYgKFN0cmluZyhpKS5zdGFydHNXaXRoKFhzLlNOX1NFUE9MSUEpIHx8IGUgPT09IDExMTU1MTExKVxuICAgIHJldHVybiBcImh0dHBzOi8vbG9naW4uaHlkcm9nZW4uYXJnZW50NDcubmV0XCI7XG4gIGlmIChTdHJpbmcoaSkuc3RhcnRzV2l0aChYcy5TTl9NQUlOKSB8fCBlID09PSAxKVxuICAgIHJldHVybiBcImh0dHBzOi8vbG9naW4uYXJnZW50Lnh5elwiO1xufSwgQ20gPSAoaSkgPT4ge1xuICBpZiAoIWkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFVua25vd24gb3IgdW5zdXBwb3J0ZWQgY2hhaW5JZCAoJHtpfSksIGVpdGhlciBzcGVjaWZ5IGEgc3VwcG9ydGVkIGNoYWluIG9yIHNldCBtb2JpbGVVcmwuYFxuICAgICk7XG4gIGNvbnN0IGUgPSBwYXJzZUludChgJHtpfWApO1xuICBpZiAoU3RyaW5nKGkpLnN0YXJ0c1dpdGgoWHMuU05fU0VQT0xJQSkgfHwgZSA9PT0gMTExNTUxMTEpXG4gICAgcmV0dXJuIFwiYXJnZW50LWRldjovL1wiO1xuICBpZiAoU3RyaW5nKGkpLnN0YXJ0c1dpdGgoWHMuU05fTUFJTikgfHwgZSA9PT0gMSlcbiAgICByZXR1cm4gXCJhcmdlbnQ6Ly9cIjtcbn07XG5jbGFzcyBBbSBleHRlbmRzIE50IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMub3B0cyA9IGUsIHRoaXMucHJvdG9jb2wgPSBcIndjXCIsIHRoaXMudmVyc2lvbiA9IDI7XG4gIH1cbn1cbmNsYXNzIFRtIGV4dGVuZHMgTnQge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLnJlY29yZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG59XG5jbGFzcyAkbSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLmxvZ2dlciA9IGUsIHRoaXMuY29yZSA9IHQ7XG4gIH1cbn1cbmNsYXNzIEZtIGV4dGVuZHMgTnQge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5yZWxheWVyID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59XG5sZXQgVW0gPSBjbGFzcyBleHRlbmRzIE50IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCk7XG4gIH1cbn0sIExtID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzLCByKSB7XG4gICAgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLm5hbWUgPSBzO1xuICB9XG59O1xuY2xhc3MgTW0gZXh0ZW5kcyBOdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLnJlbGF5ZXIgPSBlLCB0aGlzLmxvZ2dlciA9IHQ7XG4gIH1cbn1cbmNsYXNzIHFtIGV4dGVuZHMgTnQge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59XG5jbGFzcyBqbSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLnByb2plY3RJZCA9IGUsIHRoaXMubG9nZ2VyID0gdDtcbiAgfVxufVxubGV0IHptID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5vcHRzID0gZSwgdGhpcy5wcm90b2NvbCA9IFwid2NcIiwgdGhpcy52ZXJzaW9uID0gMjtcbiAgfVxufSwgS20gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmNsaWVudCA9IGU7XG4gIH1cbn07XG5jb25zdCBnaCA9IFwiOlwiO1xuZnVuY3Rpb24gVm0oaSkge1xuICBjb25zdCB7IG5hbWVzcGFjZTogZSwgcmVmZXJlbmNlOiB0IH0gPSBpO1xuICByZXR1cm4gW2UsIHRdLmpvaW4oZ2gpO1xufVxuZnVuY3Rpb24gQm0oaSkge1xuICBjb25zdCBbZSwgdCwgc10gPSBpLnNwbGl0KGdoKTtcbiAgcmV0dXJuIHsgbmFtZXNwYWNlOiBlLCByZWZlcmVuY2U6IHQsIGFkZHJlc3M6IHMgfTtcbn1cbmZ1bmN0aW9uIGttKGksIGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gaS5mb3JFYWNoKChzKSA9PiB7XG4gICAgY29uc3QgciA9IGUocyk7XG4gICAgdC5pbmNsdWRlcyhyKSB8fCB0LnB1c2gocik7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gSG0oaSkge1xuICBjb25zdCB7IG5hbWVzcGFjZTogZSwgcmVmZXJlbmNlOiB0IH0gPSBCbShpKTtcbiAgcmV0dXJuIFZtKHsgbmFtZXNwYWNlOiBlLCByZWZlcmVuY2U6IHQgfSk7XG59XG5mdW5jdGlvbiBHbShpKSB7XG4gIHJldHVybiBrbShpLCBIbSk7XG59XG5mdW5jdGlvbiBXbShpLCBlID0gW10pIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gT2JqZWN0LmtleXMoaSkuZm9yRWFjaCgocykgPT4ge1xuICAgIGlmIChlLmxlbmd0aCAmJiAhZS5pbmNsdWRlcyhzKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gaVtzXTtcbiAgICB0LnB1c2goLi4uci5hY2NvdW50cyk7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gWW0oaSwgZSA9IFtdKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGkpLmZvckVhY2goKHMpID0+IHtcbiAgICBpZiAoZS5sZW5ndGggJiYgIWUuaW5jbHVkZXMocykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IGlbc107XG4gICAgdC5wdXNoKC4uLkdtKHIuYWNjb3VudHMpKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBKbShpLCBlID0gW10pIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gT2JqZWN0LmtleXMoaSkuZm9yRWFjaCgocykgPT4ge1xuICAgIGlmIChlLmxlbmd0aCAmJiAhZS5pbmNsdWRlcyhzKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gaVtzXTtcbiAgICB0LnB1c2goLi4uSW4ocywgcikpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIEluKGksIGUpIHtcbiAgcmV0dXJuIGkuaW5jbHVkZXMoXCI6XCIpID8gW2ldIDogZS5jaGFpbnMgfHwgW107XG59XG5jb25zdCB5aCA9IFwiYmFzZTEwXCIsIF90ID0gXCJiYXNlMTZcIiwgSnIgPSBcImJhc2U2NHBhZFwiLCBEbiA9IFwidXRmOFwiLCBtaCA9IDAsIE5pID0gMSwgUW0gPSAwLCBnYSA9IDEsIFFyID0gMTIsIHhuID0gMzI7XG5mdW5jdGlvbiBYbSgpIHtcbiAgY29uc3QgaSA9IG1zLmdlbmVyYXRlS2V5UGFpcigpO1xuICByZXR1cm4geyBwcml2YXRlS2V5OiBOZShpLnNlY3JldEtleSwgX3QpLCBwdWJsaWNLZXk6IE5lKGkucHVibGljS2V5LCBfdCkgfTtcbn1cbmZ1bmN0aW9uIFhyKCkge1xuICBjb25zdCBpID0gbGkucmFuZG9tQnl0ZXMoeG4pO1xuICByZXR1cm4gTmUoaSwgX3QpO1xufVxuZnVuY3Rpb24gWm0oaSwgZSkge1xuICBjb25zdCB0ID0gbXMuc2hhcmVkS2V5KENlKGksIF90KSwgQ2UoZSwgX3QpKSwgcyA9IG5ldyBSYyhTaS5TSEEyNTYsIHQpLmV4cGFuZCh4bik7XG4gIHJldHVybiBOZShzLCBfdCk7XG59XG5mdW5jdGlvbiBlYihpKSB7XG4gIGNvbnN0IGUgPSBTaS5oYXNoKENlKGksIF90KSk7XG4gIHJldHVybiBOZShlLCBfdCk7XG59XG5mdW5jdGlvbiBVaShpKSB7XG4gIGNvbnN0IGUgPSBTaS5oYXNoKENlKGksIERuKSk7XG4gIHJldHVybiBOZShlLCBfdCk7XG59XG5mdW5jdGlvbiB0YihpKSB7XG4gIHJldHVybiBDZShgJHtpfWAsIHloKTtcbn1cbmZ1bmN0aW9uIElzKGkpIHtcbiAgcmV0dXJuIE51bWJlcihOZShpLCB5aCkpO1xufVxuZnVuY3Rpb24gaWIoaSkge1xuICBjb25zdCBlID0gdGIodHlwZW9mIGkudHlwZSA8IFwidVwiID8gaS50eXBlIDogbWgpO1xuICBpZiAoSXMoZSkgPT09IE5pICYmIHR5cGVvZiBpLnNlbmRlclB1YmxpY0tleSA+IFwidVwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc2VuZGVyIHB1YmxpYyBrZXkgZm9yIHR5cGUgMSBlbnZlbG9wZVwiKTtcbiAgY29uc3QgdCA9IHR5cGVvZiBpLnNlbmRlclB1YmxpY0tleSA8IFwidVwiID8gQ2UoaS5zZW5kZXJQdWJsaWNLZXksIF90KSA6IHZvaWQgMCwgcyA9IHR5cGVvZiBpLml2IDwgXCJ1XCIgPyBDZShpLml2LCBfdCkgOiBsaS5yYW5kb21CeXRlcyhRciksIHIgPSBuZXcgZ3MuQ2hhQ2hhMjBQb2x5MTMwNShDZShpLnN5bUtleSwgX3QpKS5zZWFsKHMsIENlKGkubWVzc2FnZSwgRG4pKTtcbiAgcmV0dXJuIHJiKHsgdHlwZTogZSwgc2VhbGVkOiByLCBpdjogcywgc2VuZGVyUHVibGljS2V5OiB0IH0pO1xufVxuZnVuY3Rpb24gc2IoaSkge1xuICBjb25zdCBlID0gbmV3IGdzLkNoYUNoYTIwUG9seTEzMDUoQ2UoaS5zeW1LZXksIF90KSksIHsgc2VhbGVkOiB0LCBpdjogcyB9ID0gWnMoaS5lbmNvZGVkKSwgciA9IGUub3BlbihzLCB0KTtcbiAgaWYgKHIgPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHRcIik7XG4gIHJldHVybiBOZShyLCBEbik7XG59XG5mdW5jdGlvbiByYihpKSB7XG4gIGlmIChJcyhpLnR5cGUpID09PSBOaSkge1xuICAgIGlmICh0eXBlb2YgaS5zZW5kZXJQdWJsaWNLZXkgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc2VuZGVyIHB1YmxpYyBrZXkgZm9yIHR5cGUgMSBlbnZlbG9wZVwiKTtcbiAgICByZXR1cm4gTmUobHMoW2kudHlwZSwgaS5zZW5kZXJQdWJsaWNLZXksIGkuaXYsIGkuc2VhbGVkXSksIEpyKTtcbiAgfVxuICByZXR1cm4gTmUobHMoW2kudHlwZSwgaS5pdiwgaS5zZWFsZWRdKSwgSnIpO1xufVxuZnVuY3Rpb24gWnMoaSkge1xuICBjb25zdCBlID0gQ2UoaSwgSnIpLCB0ID0gZS5zbGljZShRbSwgZ2EpLCBzID0gZ2E7XG4gIGlmIChJcyh0KSA9PT0gTmkpIHtcbiAgICBjb25zdCBjID0gcyArIHhuLCB1ID0gYyArIFFyLCBkID0gZS5zbGljZShzLCBjKSwgcCA9IGUuc2xpY2UoYywgdSksIGIgPSBlLnNsaWNlKHUpO1xuICAgIHJldHVybiB7IHR5cGU6IHQsIHNlYWxlZDogYiwgaXY6IHAsIHNlbmRlclB1YmxpY0tleTogZCB9O1xuICB9XG4gIGNvbnN0IHIgPSBzICsgUXIsIG4gPSBlLnNsaWNlKHMsIHIpLCBvID0gZS5zbGljZShyKTtcbiAgcmV0dXJuIHsgdHlwZTogdCwgc2VhbGVkOiBvLCBpdjogbiB9O1xufVxuZnVuY3Rpb24gbmIoaSwgZSkge1xuICBjb25zdCB0ID0gWnMoaSk7XG4gIHJldHVybiBiaCh7IHR5cGU6IElzKHQudHlwZSksIHNlbmRlclB1YmxpY0tleTogdHlwZW9mIHQuc2VuZGVyUHVibGljS2V5IDwgXCJ1XCIgPyBOZSh0LnNlbmRlclB1YmxpY0tleSwgX3QpIDogdm9pZCAwLCByZWNlaXZlclB1YmxpY0tleTogZT8ucmVjZWl2ZXJQdWJsaWNLZXkgfSk7XG59XG5mdW5jdGlvbiBiaChpKSB7XG4gIGNvbnN0IGUgPSBpPy50eXBlIHx8IG1oO1xuICBpZiAoZSA9PT0gTmkpIHtcbiAgICBpZiAodHlwZW9mIGk/LnNlbmRlclB1YmxpY0tleSA+IFwidVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzZW5kZXIgcHVibGljIGtleVwiKTtcbiAgICBpZiAodHlwZW9mIGk/LnJlY2VpdmVyUHVibGljS2V5ID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHJlY2VpdmVyIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogZSwgc2VuZGVyUHVibGljS2V5OiBpPy5zZW5kZXJQdWJsaWNLZXksIHJlY2VpdmVyUHVibGljS2V5OiBpPy5yZWNlaXZlclB1YmxpY0tleSB9O1xufVxuZnVuY3Rpb24geWEoaSkge1xuICByZXR1cm4gaS50eXBlID09PSBOaSAmJiB0eXBlb2YgaS5zZW5kZXJQdWJsaWNLZXkgPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaS5yZWNlaXZlclB1YmxpY0tleSA9PSBcInN0cmluZ1wiO1xufVxudmFyIG9iID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBtYSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIGFiID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgY2IgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBiYSA9IChpLCBlLCB0KSA9PiBlIGluIGkgPyBvYihpLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaVtlXSA9IHQsIHdhID0gKGksIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIGFiLmNhbGwoZSwgdCkgJiYgYmEoaSwgdCwgZVt0XSk7XG4gIGlmIChtYSlcbiAgICBmb3IgKHZhciB0IG9mIG1hKGUpKVxuICAgICAgY2IuY2FsbChlLCB0KSAmJiBiYShpLCB0LCBlW3RdKTtcbiAgcmV0dXJuIGk7XG59O1xuY29uc3QgaGIgPSBcIlJlYWN0TmF0aXZlXCIsIGFzID0geyByZWFjdE5hdGl2ZTogXCJyZWFjdC1uYXRpdmVcIiwgbm9kZTogXCJub2RlXCIsIGJyb3dzZXI6IFwiYnJvd3NlclwiLCB1bmtub3duOiBcInVua25vd25cIiB9LCB1YiA9IFwianNcIjtcbmZ1bmN0aW9uIE9uKCkge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgPCBcInVcIiAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA8IFwidVwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgPCBcInVcIjtcbn1cbmZ1bmN0aW9uIHdoKCkge1xuICByZXR1cm4gIXVuKCkgJiYgISFicygpICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBoYjtcbn1cbmZ1bmN0aW9uIE5uKCkge1xuICByZXR1cm4gIU9uKCkgJiYgISFicygpO1xufVxuZnVuY3Rpb24gbGIoKSB7XG4gIHJldHVybiB3aCgpID8gYXMucmVhY3ROYXRpdmUgOiBPbigpID8gYXMubm9kZSA6IE5uKCkgPyBhcy5icm93c2VyIDogYXMudW5rbm93bjtcbn1cbmZ1bmN0aW9uIGRiKGksIGUpIHtcbiAgbGV0IHQgPSBpaS5wYXJzZShpKTtcbiAgcmV0dXJuIHQgPSB3YSh3YSh7fSwgdCksIGUpLCBpID0gaWkuc3RyaW5naWZ5KHQpLCBpO1xufVxuZnVuY3Rpb24gZmIoKSB7XG4gIHJldHVybiBmbigpIHx8IHsgbmFtZTogXCJcIiwgZGVzY3JpcHRpb246IFwiXCIsIHVybDogXCJcIiwgaWNvbnM6IFtcIlwiXSB9O1xufVxuZnVuY3Rpb24gcGIoKSB7XG4gIGNvbnN0IGkgPSBobigpO1xuICBpZiAoaSA9PT0gbnVsbClcbiAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gIGNvbnN0IGUgPSBpLm9zID8gaS5vcy5yZXBsYWNlKFwiIFwiLCBcIlwiKS50b0xvd2VyQ2FzZSgpIDogXCJ1bmtub3duXCI7XG4gIHJldHVybiBpLnR5cGUgPT09IFwiYnJvd3NlclwiID8gW2UsIGkubmFtZSwgaS52ZXJzaW9uXS5qb2luKFwiLVwiKSA6IFtlLCBpLnZlcnNpb25dLmpvaW4oXCItXCIpO1xufVxuZnVuY3Rpb24gZ2IoKSB7XG4gIHZhciBpO1xuICBjb25zdCBlID0gbGIoKTtcbiAgcmV0dXJuIGUgPT09IGFzLmJyb3dzZXIgPyBbZSwgKChpID0gbG4oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuaG9zdCkgfHwgXCJ1bmtub3duXCJdLmpvaW4oXCI6XCIpIDogZTtcbn1cbmZ1bmN0aW9uIHliKGksIGUsIHQpIHtcbiAgY29uc3QgcyA9IHBiKCksIHIgPSBnYigpO1xuICByZXR1cm4gW1tpLCBlXS5qb2luKFwiLVwiKSwgW3ViLCB0XS5qb2luKFwiLVwiKSwgcywgcl0uam9pbihcIi9cIik7XG59XG5mdW5jdGlvbiBtYih7IHByb3RvY29sOiBpLCB2ZXJzaW9uOiBlLCByZWxheVVybDogdCwgc2RrVmVyc2lvbjogcywgYXV0aDogciwgcHJvamVjdElkOiBuLCB1c2VPbkNsb3NlRXZlbnQ6IG8gfSkge1xuICBjb25zdCBjID0gdC5zcGxpdChcIj9cIiksIHUgPSB5YihpLCBlLCBzKSwgZCA9IHsgYXV0aDogciwgdWE6IHUsIHByb2plY3RJZDogbiwgdXNlT25DbG9zZUV2ZW50OiBvIHx8IHZvaWQgMCB9LCBwID0gZGIoY1sxXSB8fCBcIlwiLCBkKTtcbiAgcmV0dXJuIGNbMF0gKyBcIj9cIiArIHA7XG59XG5mdW5jdGlvbiBFaShpLCBlKSB7XG4gIHJldHVybiBpLmZpbHRlcigodCkgPT4gZS5pbmNsdWRlcyh0KSkubGVuZ3RoID09PSBpLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHZoKGkpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhpLmVudHJpZXMoKSk7XG59XG5mdW5jdGlvbiBfaChpKSB7XG4gIHJldHVybiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGkpKTtcbn1cbmZ1bmN0aW9uIFRpKGkgPSBWLkZJVkVfTUlOVVRFUywgZSkge1xuICBjb25zdCB0ID0gVi50b01pbGlzZWNvbmRzKGkgfHwgVi5GSVZFX01JTlVURVMpO1xuICBsZXQgcywgciwgbjtcbiAgcmV0dXJuIHsgcmVzb2x2ZTogKG8pID0+IHtcbiAgICBuICYmIHMgJiYgKGNsZWFyVGltZW91dChuKSwgcyhvKSk7XG4gIH0sIHJlamVjdDogKG8pID0+IHtcbiAgICBuICYmIHIgJiYgKGNsZWFyVGltZW91dChuKSwgcihvKSk7XG4gIH0sIGRvbmU6ICgpID0+IG5ldyBQcm9taXNlKChvLCBjKSA9PiB7XG4gICAgbiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYyhuZXcgRXJyb3IoZSkpO1xuICAgIH0sIHQpLCBzID0gbywgciA9IGM7XG4gIH0pIH07XG59XG5mdW5jdGlvbiBlcihpLCBlLCB0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocywgcikgPT4ge1xuICAgIGNvbnN0IG4gPSBzZXRUaW1lb3V0KCgpID0+IHIobmV3IEVycm9yKHQpKSwgZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG8gPSBhd2FpdCBpO1xuICAgICAgcyhvKTtcbiAgICB9IGNhdGNoIChvKSB7XG4gICAgICByKG8pO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQobik7XG4gIH0pO1xufVxuZnVuY3Rpb24gRWgoaSwgZSkge1xuICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiBlLnN0YXJ0c1dpdGgoYCR7aX06YCkpXG4gICAgcmV0dXJuIGU7XG4gIGlmIChpLnRvTG93ZXJDYXNlKCkgPT09IFwidG9waWNcIikge1xuICAgIGlmICh0eXBlb2YgZSAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBtdXN0IGJlIFwic3RyaW5nXCIgZm9yIGV4cGlyZXIgdGFyZ2V0IHR5cGU6IHRvcGljJyk7XG4gICAgcmV0dXJuIGB0b3BpYzoke2V9YDtcbiAgfSBlbHNlIGlmIChpLnRvTG93ZXJDYXNlKCkgPT09IFwiaWRcIikge1xuICAgIGlmICh0eXBlb2YgZSAhPSBcIm51bWJlclwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBtdXN0IGJlIFwibnVtYmVyXCIgZm9yIGV4cGlyZXIgdGFyZ2V0IHR5cGU6IGlkJyk7XG4gICAgcmV0dXJuIGBpZDoke2V9YDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZXhwaXJlciB0YXJnZXQgdHlwZTogJHtpfWApO1xufVxuZnVuY3Rpb24gYmIoaSkge1xuICByZXR1cm4gRWgoXCJ0b3BpY1wiLCBpKTtcbn1cbmZ1bmN0aW9uIHdiKGkpIHtcbiAgcmV0dXJuIEVoKFwiaWRcIiwgaSk7XG59XG5mdW5jdGlvbiBTaChpKSB7XG4gIGNvbnN0IFtlLCB0XSA9IGkuc3BsaXQoXCI6XCIpLCBzID0geyBpZDogdm9pZCAwLCB0b3BpYzogdm9pZCAwIH07XG4gIGlmIChlID09PSBcInRvcGljXCIgJiYgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIilcbiAgICBzLnRvcGljID0gdDtcbiAgZWxzZSBpZiAoZSA9PT0gXCJpZFwiICYmIE51bWJlci5pc0ludGVnZXIoTnVtYmVyKHQpKSlcbiAgICBzLmlkID0gTnVtYmVyKHQpO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhcmdldCwgZXhwZWN0ZWQgaWQ6bnVtYmVyIG9yIHRvcGljOnN0cmluZywgZ290ICR7ZX06JHt0fWApO1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIEh0KGksIGUpIHtcbiAgcmV0dXJuIFYuZnJvbU1pbGlzZWNvbmRzKChlIHx8IERhdGUubm93KCkpICsgVi50b01pbGlzZWNvbmRzKGkpKTtcbn1cbmZ1bmN0aW9uIGNpKGkpIHtcbiAgcmV0dXJuIERhdGUubm93KCkgPj0gVi50b01pbGlzZWNvbmRzKGkpO1xufVxuZnVuY3Rpb24ga2UoaSwgZSkge1xuICByZXR1cm4gYCR7aX0ke2UgPyBgOiR7ZX1gIDogXCJcIn1gO1xufVxuY29uc3QgdmIgPSBcImlyblwiO1xuZnVuY3Rpb24gWnIoaSkge1xuICByZXR1cm4gaT8ucmVsYXkgfHwgeyBwcm90b2NvbDogdmIgfTtcbn1cbmZ1bmN0aW9uIFZzKGkpIHtcbiAgY29uc3QgZSA9IEFjW2ldO1xuICBpZiAodHlwZW9mIGUgPiBcInVcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJlbGF5IFByb3RvY29sIG5vdCBzdXBwb3J0ZWQ6ICR7aX1gKTtcbiAgcmV0dXJuIGU7XG59XG52YXIgX2IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIHZhID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgRWIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBTYiA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIF9hID0gKGksIGUsIHQpID0+IGUgaW4gaSA/IF9iKGksIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBpW2VdID0gdCwgSWIgPSAoaSwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgRWIuY2FsbChlLCB0KSAmJiBfYShpLCB0LCBlW3RdKTtcbiAgaWYgKHZhKVxuICAgIGZvciAodmFyIHQgb2YgdmEoZSkpXG4gICAgICBTYi5jYWxsKGUsIHQpICYmIF9hKGksIHQsIGVbdF0pO1xuICByZXR1cm4gaTtcbn07XG5mdW5jdGlvbiBEYihpLCBlID0gXCItXCIpIHtcbiAgY29uc3QgdCA9IHt9LCBzID0gXCJyZWxheVwiICsgZTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGkpLmZvckVhY2goKHIpID0+IHtcbiAgICBpZiAoci5zdGFydHNXaXRoKHMpKSB7XG4gICAgICBjb25zdCBuID0gci5yZXBsYWNlKHMsIFwiXCIpLCBvID0gaVtyXTtcbiAgICAgIHRbbl0gPSBvO1xuICAgIH1cbiAgfSksIHQ7XG59XG5mdW5jdGlvbiB4YihpKSB7XG4gIGNvbnN0IGUgPSBpLmluZGV4T2YoXCI6XCIpLCB0ID0gaS5pbmRleE9mKFwiP1wiKSAhPT0gLTEgPyBpLmluZGV4T2YoXCI/XCIpIDogdm9pZCAwLCBzID0gaS5zdWJzdHJpbmcoMCwgZSksIHIgPSBpLnN1YnN0cmluZyhlICsgMSwgdCkuc3BsaXQoXCJAXCIpLCBuID0gdHlwZW9mIHQgPCBcInVcIiA/IGkuc3Vic3RyaW5nKHQpIDogXCJcIiwgbyA9IGlpLnBhcnNlKG4pO1xuICByZXR1cm4geyBwcm90b2NvbDogcywgdG9waWM6IE9iKHJbMF0pLCB2ZXJzaW9uOiBwYXJzZUludChyWzFdLCAxMCksIHN5bUtleTogby5zeW1LZXksIHJlbGF5OiBEYihvKSB9O1xufVxuZnVuY3Rpb24gT2IoaSkge1xuICByZXR1cm4gaS5zdGFydHNXaXRoKFwiLy9cIikgPyBpLnN1YnN0cmluZygyKSA6IGk7XG59XG5mdW5jdGlvbiBOYihpLCBlID0gXCItXCIpIHtcbiAgY29uc3QgdCA9IFwicmVsYXlcIiwgcyA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMoaSkuZm9yRWFjaCgocikgPT4ge1xuICAgIGNvbnN0IG4gPSB0ICsgZSArIHI7XG4gICAgaVtyXSAmJiAoc1tuXSA9IGlbcl0pO1xuICB9KSwgcztcbn1cbmZ1bmN0aW9uIFBiKGkpIHtcbiAgcmV0dXJuIGAke2kucHJvdG9jb2x9OiR7aS50b3BpY31AJHtpLnZlcnNpb259P2AgKyBpaS5zdHJpbmdpZnkoSWIoeyBzeW1LZXk6IGkuc3ltS2V5IH0sIE5iKGkucmVsYXkpKSk7XG59XG5mdW5jdGlvbiB6aShpKSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgcmV0dXJuIGkuZm9yRWFjaCgodCkgPT4ge1xuICAgIGNvbnN0IFtzLCByXSA9IHQuc3BsaXQoXCI6XCIpO1xuICAgIGUucHVzaChgJHtzfToke3J9YCk7XG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gUmIoaSkge1xuICBjb25zdCBlID0gW107XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGkpLmZvckVhY2goKHQpID0+IHtcbiAgICBlLnB1c2goLi4uemkodC5hY2NvdW50cykpO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIENiKGksIGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgemkocy5hY2NvdW50cykuaW5jbHVkZXMoZSkgJiYgdC5wdXNoKC4uLnMubWV0aG9kcyk7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gQWIoaSwgZSkge1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGkpLmZvckVhY2goKHMpID0+IHtcbiAgICB6aShzLmFjY291bnRzKS5pbmNsdWRlcyhlKSAmJiB0LnB1c2goLi4ucy5ldmVudHMpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIFRiKGksIGUpIHtcbiAgY29uc3QgdCA9IEJzKGksIGUpO1xuICBpZiAodClcbiAgICB0aHJvdyBuZXcgRXJyb3IodC5tZXNzYWdlKTtcbiAgY29uc3QgcyA9IHt9O1xuICBmb3IgKGNvbnN0IFtyLCBuXSBvZiBPYmplY3QuZW50cmllcyhpKSlcbiAgICBzW3JdID0geyBtZXRob2RzOiBuLm1ldGhvZHMsIGV2ZW50czogbi5ldmVudHMsIGNoYWluczogbi5hY2NvdW50cy5tYXAoKG8pID0+IGAke28uc3BsaXQoXCI6XCIpWzBdfToke28uc3BsaXQoXCI6XCIpWzFdfWApIH07XG4gIHJldHVybiBzO1xufVxuY29uc3QgJGIgPSB7IElOVkFMSURfTUVUSE9EOiB7IG1lc3NhZ2U6IFwiSW52YWxpZCBtZXRob2QuXCIsIGNvZGU6IDEwMDEgfSwgSU5WQUxJRF9FVkVOVDogeyBtZXNzYWdlOiBcIkludmFsaWQgZXZlbnQuXCIsIGNvZGU6IDEwMDIgfSwgSU5WQUxJRF9VUERBVEVfUkVRVUVTVDogeyBtZXNzYWdlOiBcIkludmFsaWQgdXBkYXRlIHJlcXVlc3QuXCIsIGNvZGU6IDEwMDMgfSwgSU5WQUxJRF9FWFRFTkRfUkVRVUVTVDogeyBtZXNzYWdlOiBcIkludmFsaWQgZXh0ZW5kIHJlcXVlc3QuXCIsIGNvZGU6IDEwMDQgfSwgSU5WQUxJRF9TRVNTSU9OX1NFVFRMRV9SRVFVRVNUOiB7IG1lc3NhZ2U6IFwiSW52YWxpZCBzZXNzaW9uIHNldHRsZSByZXF1ZXN0LlwiLCBjb2RlOiAxMDA1IH0sIFVOQVVUSE9SSVpFRF9NRVRIT0Q6IHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWQgbWV0aG9kLlwiLCBjb2RlOiAzMDAxIH0sIFVOQVVUSE9SSVpFRF9FVkVOVDogeyBtZXNzYWdlOiBcIlVuYXV0aG9yaXplZCBldmVudC5cIiwgY29kZTogMzAwMiB9LCBVTkFVVEhPUklaRURfVVBEQVRFX1JFUVVFU1Q6IHsgbWVzc2FnZTogXCJVbmF1dGhvcml6ZWQgdXBkYXRlIHJlcXVlc3QuXCIsIGNvZGU6IDMwMDMgfSwgVU5BVVRIT1JJWkVEX0VYVEVORF9SRVFVRVNUOiB7IG1lc3NhZ2U6IFwiVW5hdXRob3JpemVkIGV4dGVuZCByZXF1ZXN0LlwiLCBjb2RlOiAzMDA0IH0sIFVTRVJfUkVKRUNURUQ6IHsgbWVzc2FnZTogXCJVc2VyIHJlamVjdGVkLlwiLCBjb2RlOiA1ZTMgfSwgVVNFUl9SRUpFQ1RFRF9DSEFJTlM6IHsgbWVzc2FnZTogXCJVc2VyIHJlamVjdGVkIGNoYWlucy5cIiwgY29kZTogNTAwMSB9LCBVU0VSX1JFSkVDVEVEX01FVEhPRFM6IHsgbWVzc2FnZTogXCJVc2VyIHJlamVjdGVkIG1ldGhvZHMuXCIsIGNvZGU6IDUwMDIgfSwgVVNFUl9SRUpFQ1RFRF9FVkVOVFM6IHsgbWVzc2FnZTogXCJVc2VyIHJlamVjdGVkIGV2ZW50cy5cIiwgY29kZTogNTAwMyB9LCBVTlNVUFBPUlRFRF9DSEFJTlM6IHsgbWVzc2FnZTogXCJVbnN1cHBvcnRlZCBjaGFpbnMuXCIsIGNvZGU6IDUxMDAgfSwgVU5TVVBQT1JURURfTUVUSE9EUzogeyBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIG1ldGhvZHMuXCIsIGNvZGU6IDUxMDEgfSwgVU5TVVBQT1JURURfRVZFTlRTOiB7IG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgZXZlbnRzLlwiLCBjb2RlOiA1MTAyIH0sIFVOU1VQUE9SVEVEX0FDQ09VTlRTOiB7IG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgYWNjb3VudHMuXCIsIGNvZGU6IDUxMDMgfSwgVU5TVVBQT1JURURfTkFNRVNQQUNFX0tFWTogeyBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIG5hbWVzcGFjZSBrZXkuXCIsIGNvZGU6IDUxMDQgfSwgVVNFUl9ESVNDT05ORUNURUQ6IHsgbWVzc2FnZTogXCJVc2VyIGRpc2Nvbm5lY3RlZC5cIiwgY29kZTogNmUzIH0sIFNFU1NJT05fU0VUVExFTUVOVF9GQUlMRUQ6IHsgbWVzc2FnZTogXCJTZXNzaW9uIHNldHRsZW1lbnQgZmFpbGVkLlwiLCBjb2RlOiA3ZTMgfSwgV0NfTUVUSE9EX1VOU1VQUE9SVEVEOiB7IG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgd2NfIG1ldGhvZC5cIiwgY29kZTogMTAwMDEgfSB9LCBGYiA9IHsgTk9UX0lOSVRJQUxJWkVEOiB7IG1lc3NhZ2U6IFwiTm90IGluaXRpYWxpemVkLlwiLCBjb2RlOiAxIH0sIE5PX01BVENISU5HX0tFWTogeyBtZXNzYWdlOiBcIk5vIG1hdGNoaW5nIGtleS5cIiwgY29kZTogMiB9LCBSRVNUT1JFX1dJTExfT1ZFUlJJREU6IHsgbWVzc2FnZTogXCJSZXN0b3JlIHdpbGwgb3ZlcnJpZGUuXCIsIGNvZGU6IDMgfSwgUkVTVUJTQ1JJQkVEOiB7IG1lc3NhZ2U6IFwiUmVzdWJzY3JpYmVkLlwiLCBjb2RlOiA0IH0sIE1JU1NJTkdfT1JfSU5WQUxJRDogeyBtZXNzYWdlOiBcIk1pc3Npbmcgb3IgaW52YWxpZC5cIiwgY29kZTogNSB9LCBFWFBJUkVEOiB7IG1lc3NhZ2U6IFwiRXhwaXJlZC5cIiwgY29kZTogNiB9LCBVTktOT1dOX1RZUEU6IHsgbWVzc2FnZTogXCJVbmtub3duIHR5cGUuXCIsIGNvZGU6IDcgfSwgTUlTTUFUQ0hFRF9UT1BJQzogeyBtZXNzYWdlOiBcIk1pc21hdGNoZWQgdG9waWMuXCIsIGNvZGU6IDggfSwgTk9OX0NPTkZPUk1JTkdfTkFNRVNQQUNFUzogeyBtZXNzYWdlOiBcIk5vbiBjb25mb3JtaW5nIG5hbWVzcGFjZXMuXCIsIGNvZGU6IDkgfSB9O1xuZnVuY3Rpb24gSihpLCBlKSB7XG4gIGNvbnN0IHsgbWVzc2FnZTogdCwgY29kZTogcyB9ID0gRmJbaV07XG4gIHJldHVybiB7IG1lc3NhZ2U6IGUgPyBgJHt0fSAke2V9YCA6IHQsIGNvZGU6IHMgfTtcbn1cbmZ1bmN0aW9uIEplKGksIGUpIHtcbiAgY29uc3QgeyBtZXNzYWdlOiB0LCBjb2RlOiBzIH0gPSAkYltpXTtcbiAgcmV0dXJuIHsgbWVzc2FnZTogZSA/IGAke3R9ICR7ZX1gIDogdCwgY29kZTogcyB9O1xufVxuZnVuY3Rpb24gRHMoaSwgZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpKSA/IHR5cGVvZiBlIDwgXCJ1XCIgJiYgaS5sZW5ndGggPyBpLmV2ZXJ5KGUpIDogITAgOiAhMTtcbn1cbmZ1bmN0aW9uIHVzKGkpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihpKSA9PT0gT2JqZWN0LnByb3RvdHlwZSAmJiBPYmplY3Qua2V5cyhpKS5sZW5ndGg7XG59XG5mdW5jdGlvbiB3dChpKSB7XG4gIHJldHVybiB0eXBlb2YgaSA+IFwidVwiO1xufVxuZnVuY3Rpb24gYXQoaSwgZSkge1xuICByZXR1cm4gZSAmJiB3dChpKSA/ICEwIDogdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiAmJiAhIWkudHJpbSgpLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIFBuKGksIGUpIHtcbiAgcmV0dXJuIGUgJiYgd3QoaSkgPyAhMCA6IHR5cGVvZiBpID09IFwibnVtYmVyXCIgJiYgIWlzTmFOKGkpO1xufVxuZnVuY3Rpb24gVWIoaSwgZSkge1xuICBjb25zdCB7IHJlcXVpcmVkTmFtZXNwYWNlczogdCB9ID0gZSwgcyA9IE9iamVjdC5rZXlzKGkubmFtZXNwYWNlcyksIHIgPSBPYmplY3Qua2V5cyh0KTtcbiAgbGV0IG4gPSAhMDtcbiAgcmV0dXJuIEVpKHIsIHMpID8gKHMuZm9yRWFjaCgobykgPT4ge1xuICAgIGNvbnN0IHsgYWNjb3VudHM6IGMsIG1ldGhvZHM6IHUsIGV2ZW50czogZCB9ID0gaS5uYW1lc3BhY2VzW29dLCBwID0gemkoYyksIGIgPSB0W29dO1xuICAgICghRWkoSW4obywgYiksIHApIHx8ICFFaShiLm1ldGhvZHMsIHUpIHx8ICFFaShiLmV2ZW50cywgZCkpICYmIChuID0gITEpO1xuICB9KSwgbikgOiAhMTtcbn1cbmZ1bmN0aW9uIFJuKGkpIHtcbiAgcmV0dXJuIGF0KGksICExKSAmJiBpLmluY2x1ZGVzKFwiOlwiKSA/IGkuc3BsaXQoXCI6XCIpLmxlbmd0aCA9PT0gMiA6ICExO1xufVxuZnVuY3Rpb24gTGIoaSkge1xuICBpZiAoYXQoaSwgITEpICYmIGkuaW5jbHVkZXMoXCI6XCIpKSB7XG4gICAgY29uc3QgZSA9IGkuc3BsaXQoXCI6XCIpO1xuICAgIGlmIChlLmxlbmd0aCA9PT0gMykge1xuICAgICAgY29uc3QgdCA9IGVbMF0gKyBcIjpcIiArIGVbMV07XG4gICAgICByZXR1cm4gISFlWzJdICYmIFJuKHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBNYihpKSB7XG4gIGlmIChhdChpLCAhMSkpXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0eXBlb2YgbmV3IFVSTChpKSA8IFwidVwiO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gcWIoaSkge1xuICB2YXIgZTtcbiAgcmV0dXJuIChlID0gaT8ucHJvcG9zZXIpID09IG51bGwgPyB2b2lkIDAgOiBlLnB1YmxpY0tleTtcbn1cbmZ1bmN0aW9uIGpiKGkpIHtcbiAgcmV0dXJuIGk/LnRvcGljO1xufVxuZnVuY3Rpb24gemIoaSwgZSkge1xuICBsZXQgdCA9IG51bGw7XG4gIHJldHVybiBhdChpPy5wdWJsaWNLZXksICExKSB8fCAodCA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYCR7ZX0gY29udHJvbGxlciBwdWJsaWMga2V5IHNob3VsZCBiZSBhIHN0cmluZ2ApKSwgdDtcbn1cbmZ1bmN0aW9uIEVhKGkpIHtcbiAgbGV0IGUgPSAhMDtcbiAgcmV0dXJuIERzKGkpID8gaS5sZW5ndGggJiYgKGUgPSBpLmV2ZXJ5KCh0KSA9PiBhdCh0LCAhMSkpKSA6IGUgPSAhMSwgZTtcbn1cbmZ1bmN0aW9uIEtiKGksIGUsIHQpIHtcbiAgbGV0IHMgPSBudWxsO1xuICByZXR1cm4gRHMoZSkgPyBlLmZvckVhY2goKHIpID0+IHtcbiAgICBzIHx8ICghUm4ocikgfHwgIXIuaW5jbHVkZXMoaSkpICYmIChzID0gSmUoXCJVTlNVUFBPUlRFRF9DSEFJTlNcIiwgYCR7dH0sIGNoYWluICR7cn0gc2hvdWxkIGJlIGEgc3RyaW5nIGFuZCBjb25mb3JtIHRvIFwibmFtZXNwYWNlOmNoYWluSWRcIiBmb3JtYXRgKSk7XG4gIH0pIDogcyA9IEplKFwiVU5TVVBQT1JURURfQ0hBSU5TXCIsIGAke3R9LCBjaGFpbnMgJHtlfSBzaG91bGQgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncyBjb25mb3JtaW5nIHRvIFwibmFtZXNwYWNlOmNoYWluSWRcIiBmb3JtYXRgKSwgcztcbn1cbmZ1bmN0aW9uIFZiKGksIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoaSkuZm9yRWFjaCgoW3MsIHJdKSA9PiB7XG4gICAgaWYgKHQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IEtiKHMsIEluKHMsIHIpLCBgJHtlfSByZXF1aXJlZE5hbWVzcGFjZWApO1xuICAgIG4gJiYgKHQgPSBuKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBCYihpLCBlKSB7XG4gIGxldCB0ID0gbnVsbDtcbiAgcmV0dXJuIERzKGkpID8gaS5mb3JFYWNoKChzKSA9PiB7XG4gICAgdCB8fCBMYihzKSB8fCAodCA9IEplKFwiVU5TVVBQT1JURURfQUNDT1VOVFNcIiwgYCR7ZX0sIGFjY291bnQgJHtzfSBzaG91bGQgYmUgYSBzdHJpbmcgYW5kIGNvbmZvcm0gdG8gXCJuYW1lc3BhY2U6Y2hhaW5JZDphZGRyZXNzXCIgZm9ybWF0YCkpO1xuICB9KSA6IHQgPSBKZShcIlVOU1VQUE9SVEVEX0FDQ09VTlRTXCIsIGAke2V9LCBhY2NvdW50cyBzaG91bGQgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncyBjb25mb3JtaW5nIHRvIFwibmFtZXNwYWNlOmNoYWluSWQ6YWRkcmVzc1wiIGZvcm1hdGApLCB0O1xufVxuZnVuY3Rpb24ga2IoaSwgZSkge1xuICBsZXQgdCA9IG51bGw7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGkpLmZvckVhY2goKHMpID0+IHtcbiAgICBpZiAodClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gQmIocz8uYWNjb3VudHMsIGAke2V9IG5hbWVzcGFjZWApO1xuICAgIHIgJiYgKHQgPSByKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBIYihpLCBlKSB7XG4gIGxldCB0ID0gbnVsbDtcbiAgcmV0dXJuIEVhKGk/Lm1ldGhvZHMpID8gRWEoaT8uZXZlbnRzKSB8fCAodCA9IEplKFwiVU5TVVBQT1JURURfRVZFTlRTXCIsIGAke2V9LCBldmVudHMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgZW1wdHkgYXJyYXkgZm9yIG5vIGV2ZW50c2ApKSA6IHQgPSBKZShcIlVOU1VQUE9SVEVEX01FVEhPRFNcIiwgYCR7ZX0sIG1ldGhvZHMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgZW1wdHkgYXJyYXkgZm9yIG5vIG1ldGhvZHNgKSwgdDtcbn1cbmZ1bmN0aW9uIEloKGksIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgaWYgKHQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IEhiKHMsIGAke2V9LCBuYW1lc3BhY2VgKTtcbiAgICByICYmICh0ID0gcik7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gR2IoaSwgZSwgdCkge1xuICBsZXQgcyA9IG51bGw7XG4gIGlmIChpICYmIHVzKGkpKSB7XG4gICAgY29uc3QgciA9IEloKGksIGUpO1xuICAgIHIgJiYgKHMgPSByKTtcbiAgICBjb25zdCBuID0gVmIoaSwgZSk7XG4gICAgbiAmJiAocyA9IG4pO1xuICB9IGVsc2VcbiAgICBzID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgJHtlfSwgJHt0fSBzaG91bGQgYmUgYW4gb2JqZWN0IHdpdGggZGF0YWApO1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIEJzKGksIGUpIHtcbiAgbGV0IHQgPSBudWxsO1xuICBpZiAoaSAmJiB1cyhpKSkge1xuICAgIGNvbnN0IHMgPSBJaChpLCBlKTtcbiAgICBzICYmICh0ID0gcyk7XG4gICAgY29uc3QgciA9IGtiKGksIGUpO1xuICAgIHIgJiYgKHQgPSByKTtcbiAgfSBlbHNlXG4gICAgdCA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYCR7ZX0sIG5hbWVzcGFjZXMgc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGRhdGFgKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBEaChpKSB7XG4gIHJldHVybiBhdChpLnByb3RvY29sLCAhMCk7XG59XG5mdW5jdGlvbiBXYihpLCBlKSB7XG4gIGxldCB0ID0gITE7XG4gIHJldHVybiBlICYmICFpID8gdCA9ICEwIDogaSAmJiBEcyhpKSAmJiBpLmxlbmd0aCAmJiBpLmZvckVhY2goKHMpID0+IHtcbiAgICB0ID0gRGgocyk7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gWWIoaSkge1xuICByZXR1cm4gdHlwZW9mIGkgPT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIEl0KGkpIHtcbiAgcmV0dXJuIHR5cGVvZiBpIDwgXCJ1XCIgJiYgdHlwZW9mIGkgIT09IG51bGw7XG59XG5mdW5jdGlvbiBKYihpKSB7XG4gIHJldHVybiAhKCFpIHx8IHR5cGVvZiBpICE9IFwib2JqZWN0XCIgfHwgIWkuY29kZSB8fCAhUG4oaS5jb2RlLCAhMSkgfHwgIWkubWVzc2FnZSB8fCAhYXQoaS5tZXNzYWdlLCAhMSkpO1xufVxuZnVuY3Rpb24gUWIoaSkge1xuICByZXR1cm4gISh3dChpKSB8fCAhYXQoaS5tZXRob2QsICExKSk7XG59XG5mdW5jdGlvbiBYYihpKSB7XG4gIHJldHVybiAhKHd0KGkpIHx8IHd0KGkucmVzdWx0KSAmJiB3dChpLmVycm9yKSB8fCAhUG4oaS5pZCwgITEpIHx8ICFhdChpLmpzb25ycGMsICExKSk7XG59XG5mdW5jdGlvbiBaYihpKSB7XG4gIHJldHVybiAhKHd0KGkpIHx8ICFhdChpLm5hbWUsICExKSk7XG59XG5mdW5jdGlvbiBTYShpLCBlKSB7XG4gIHJldHVybiAhKCFSbihlKSB8fCAhUmIoaSkuaW5jbHVkZXMoZSkpO1xufVxuZnVuY3Rpb24gZXcoaSwgZSwgdCkge1xuICByZXR1cm4gYXQodCwgITEpID8gQ2IoaSwgZSkuaW5jbHVkZXModCkgOiAhMTtcbn1cbmZ1bmN0aW9uIHR3KGksIGUsIHQpIHtcbiAgcmV0dXJuIGF0KHQsICExKSA/IEFiKGksIGUpLmluY2x1ZGVzKHQpIDogITE7XG59XG5mdW5jdGlvbiBJYShpLCBlLCB0KSB7XG4gIGxldCBzID0gbnVsbDtcbiAgY29uc3QgciA9IGl3KGkpLCBuID0gc3coZSksIG8gPSBPYmplY3Qua2V5cyhyKSwgYyA9IE9iamVjdC5rZXlzKG4pLCB1ID0gRGEoT2JqZWN0LmtleXMoaSkpLCBkID0gRGEoT2JqZWN0LmtleXMoZSkpLCBwID0gdS5maWx0ZXIoKGIpID0+ICFkLmluY2x1ZGVzKGIpKTtcbiAgcmV0dXJuIHAubGVuZ3RoICYmIChzID0gSihcIk5PTl9DT05GT1JNSU5HX05BTUVTUEFDRVNcIiwgYCR7dH0gbmFtZXNwYWNlcyBrZXlzIGRvbid0IHNhdGlzZnkgcmVxdWlyZWROYW1lc3BhY2VzLlxuICAgICAgUmVxdWlyZWQ6ICR7cC50b1N0cmluZygpfVxuICAgICAgUmVjZWl2ZWQ6ICR7T2JqZWN0LmtleXMoZSkudG9TdHJpbmcoKX1gKSksIEVpKG8sIGMpIHx8IChzID0gSihcIk5PTl9DT05GT1JNSU5HX05BTUVTUEFDRVNcIiwgYCR7dH0gbmFtZXNwYWNlcyBjaGFpbnMgZG9uJ3Qgc2F0aXNmeSByZXF1aXJlZCBuYW1lc3BhY2VzLlxuICAgICAgUmVxdWlyZWQ6ICR7by50b1N0cmluZygpfVxuICAgICAgQXBwcm92ZWQ6ICR7Yy50b1N0cmluZygpfWApKSwgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoYikgPT4ge1xuICAgIGlmICghYi5pbmNsdWRlcyhcIjpcIikgfHwgcylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4ID0gemkoZVtiXS5hY2NvdW50cyk7XG4gICAgeC5pbmNsdWRlcyhiKSB8fCAocyA9IEooXCJOT05fQ09ORk9STUlOR19OQU1FU1BBQ0VTXCIsIGAke3R9IG5hbWVzcGFjZXMgYWNjb3VudHMgZG9uJ3Qgc2F0aXNmeSBuYW1lc3BhY2UgYWNjb3VudHMgZm9yICR7Yn1cbiAgICAgICAgUmVxdWlyZWQ6ICR7Yn1cbiAgICAgICAgQXBwcm92ZWQ6ICR7eC50b1N0cmluZygpfWApKTtcbiAgfSksIG8uZm9yRWFjaCgoYikgPT4ge1xuICAgIHMgfHwgKEVpKHJbYl0ubWV0aG9kcywgbltiXS5tZXRob2RzKSA/IEVpKHJbYl0uZXZlbnRzLCBuW2JdLmV2ZW50cykgfHwgKHMgPSBKKFwiTk9OX0NPTkZPUk1JTkdfTkFNRVNQQUNFU1wiLCBgJHt0fSBuYW1lc3BhY2VzIGV2ZW50cyBkb24ndCBzYXRpc2Z5IG5hbWVzcGFjZSBldmVudHMgZm9yICR7Yn1gKSkgOiBzID0gSihcIk5PTl9DT05GT1JNSU5HX05BTUVTUEFDRVNcIiwgYCR7dH0gbmFtZXNwYWNlcyBtZXRob2RzIGRvbid0IHNhdGlzZnkgbmFtZXNwYWNlIG1ldGhvZHMgZm9yICR7Yn1gKSk7XG4gIH0pLCBzO1xufVxuZnVuY3Rpb24gaXcoaSkge1xuICBjb25zdCBlID0ge307XG4gIHJldHVybiBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgdmFyIHM7XG4gICAgdC5pbmNsdWRlcyhcIjpcIikgPyBlW3RdID0gaVt0XSA6IChzID0gaVt0XS5jaGFpbnMpID09IG51bGwgfHwgcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICBlW3JdID0geyBtZXRob2RzOiBpW3RdLm1ldGhvZHMsIGV2ZW50czogaVt0XS5ldmVudHMgfTtcbiAgICB9KTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBEYShpKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChpLm1hcCgoZSkgPT4gZS5pbmNsdWRlcyhcIjpcIikgPyBlLnNwbGl0KFwiOlwiKVswXSA6IGUpKV07XG59XG5mdW5jdGlvbiBzdyhpKSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGkpLmZvckVhY2goKHQpID0+IHtcbiAgICB0LmluY2x1ZGVzKFwiOlwiKSA/IGVbdF0gPSBpW3RdIDogemkoaVt0XS5hY2NvdW50cyk/LmZvckVhY2goKHIpID0+IHtcbiAgICAgIGVbcl0gPSB7IGFjY291bnRzOiBpW3RdLmFjY291bnRzLmZpbHRlcigobikgPT4gbi5pbmNsdWRlcyhgJHtyfTpgKSksIG1ldGhvZHM6IGlbdF0ubWV0aG9kcywgZXZlbnRzOiBpW3RdLmV2ZW50cyB9O1xuICAgIH0pO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIHJ3KGksIGUpIHtcbiAgcmV0dXJuIFBuKGksICExKSAmJiBpIDw9IGUubWF4ICYmIGkgPj0gZS5taW47XG59XG5mdW5jdGlvbiBudyhpLCBlKSB7XG4gIGlmIChpLmxlbmd0aCA+PSAyNTUpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFscGhhYmV0IHRvbyBsb25nXCIpO1xuICBmb3IgKHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KSwgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcysrKVxuICAgIHRbc10gPSAyNTU7XG4gIGZvciAodmFyIHIgPSAwOyByIDwgaS5sZW5ndGg7IHIrKykge1xuICAgIHZhciBuID0gaS5jaGFyQXQociksIG8gPSBuLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKHRbb10gIT09IDI1NSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobiArIFwiIGlzIGFtYmlndW91c1wiKTtcbiAgICB0W29dID0gcjtcbiAgfVxuICB2YXIgYyA9IGkubGVuZ3RoLCB1ID0gaS5jaGFyQXQoMCksIGQgPSBNYXRoLmxvZyhjKSAvIE1hdGgubG9nKDI1NiksIHAgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coYyk7XG4gIGZ1bmN0aW9uIGIoXykge1xuICAgIGlmIChfIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KF8pID8gXyA9IG5ldyBVaW50OEFycmF5KF8uYnVmZmVyLCBfLmJ5dGVPZmZzZXQsIF8uYnl0ZUxlbmd0aCkgOiBBcnJheS5pc0FycmF5KF8pICYmIChfID0gVWludDhBcnJheS5mcm9tKF8pKSksICEoXyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFVpbnQ4QXJyYXlcIik7XG4gICAgaWYgKF8ubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgZm9yICh2YXIgQyA9IDAsIEYgPSAwLCBLID0gMCwgSSA9IF8ubGVuZ3RoOyBLICE9PSBJICYmIF9bS10gPT09IDA7IClcbiAgICAgIEsrKywgQysrO1xuICAgIGZvciAodmFyIEQgPSAoSSAtIEspICogcCArIDEgPj4+IDAsIHkgPSBuZXcgVWludDhBcnJheShEKTsgSyAhPT0gSTsgKSB7XG4gICAgICBmb3IgKHZhciB3ID0gX1tLXSwgZiA9IDAsIGEgPSBEIC0gMTsgKHcgIT09IDAgfHwgZiA8IEYpICYmIGEgIT09IC0xOyBhLS0sIGYrKylcbiAgICAgICAgdyArPSAyNTYgKiB5W2FdID4+PiAwLCB5W2FdID0gdyAlIGMgPj4+IDAsIHcgPSB3IC8gYyA+Pj4gMDtcbiAgICAgIGlmICh3ICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24temVybyBjYXJyeVwiKTtcbiAgICAgIEYgPSBmLCBLKys7XG4gICAgfVxuICAgIGZvciAodmFyIGwgPSBEIC0gRjsgbCAhPT0gRCAmJiB5W2xdID09PSAwOyApXG4gICAgICBsKys7XG4gICAgZm9yICh2YXIgTCA9IHUucmVwZWF0KEMpOyBsIDwgRDsgKytsKVxuICAgICAgTCArPSBpLmNoYXJBdCh5W2xdKTtcbiAgICByZXR1cm4gTDtcbiAgfVxuICBmdW5jdGlvbiB4KF8pIHtcbiAgICBpZiAodHlwZW9mIF8gIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBTdHJpbmdcIik7XG4gICAgaWYgKF8ubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgdmFyIEMgPSAwO1xuICAgIGlmIChfW0NdICE9PSBcIiBcIikge1xuICAgICAgZm9yICh2YXIgRiA9IDAsIEsgPSAwOyBfW0NdID09PSB1OyApXG4gICAgICAgIEYrKywgQysrO1xuICAgICAgZm9yICh2YXIgSSA9IChfLmxlbmd0aCAtIEMpICogZCArIDEgPj4+IDAsIEQgPSBuZXcgVWludDhBcnJheShJKTsgX1tDXTsgKSB7XG4gICAgICAgIHZhciB5ID0gdFtfLmNoYXJDb2RlQXQoQyldO1xuICAgICAgICBpZiAoeSA9PT0gMjU1KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgdyA9IDAsIGYgPSBJIC0gMTsgKHkgIT09IDAgfHwgdyA8IEspICYmIGYgIT09IC0xOyBmLS0sIHcrKylcbiAgICAgICAgICB5ICs9IGMgKiBEW2ZdID4+PiAwLCBEW2ZdID0geSAlIDI1NiA+Pj4gMCwgeSA9IHkgLyAyNTYgPj4+IDA7XG4gICAgICAgIGlmICh5ICE9PSAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi16ZXJvIGNhcnJ5XCIpO1xuICAgICAgICBLID0gdywgQysrO1xuICAgICAgfVxuICAgICAgaWYgKF9bQ10gIT09IFwiIFwiKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBJIC0gSzsgYSAhPT0gSSAmJiBEW2FdID09PSAwOyApXG4gICAgICAgICAgYSsrO1xuICAgICAgICBmb3IgKHZhciBsID0gbmV3IFVpbnQ4QXJyYXkoRiArIChJIC0gYSkpLCBMID0gRjsgYSAhPT0gSTsgKVxuICAgICAgICAgIGxbTCsrXSA9IERbYSsrXTtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIE8oXykge1xuICAgIHZhciBDID0geChfKTtcbiAgICBpZiAoQylcbiAgICAgIHJldHVybiBDO1xuICAgIHRocm93IG5ldyBFcnJvcihgTm9uLSR7ZX0gY2hhcmFjdGVyYCk7XG4gIH1cbiAgcmV0dXJuIHsgZW5jb2RlOiBiLCBkZWNvZGVVbnNhZmU6IHgsIGRlY29kZTogTyB9O1xufVxudmFyIG93ID0gbncsIGF3ID0gb3c7XG5jb25zdCB4aCA9IChpKSA9PiB7XG4gIGlmIChpIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBpLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiVWludDhBcnJheVwiKVxuICAgIHJldHVybiBpO1xuICBpZiAoaSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShpKTtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhpKSlcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaS5idWZmZXIsIGkuYnl0ZU9mZnNldCwgaS5ieXRlTGVuZ3RoKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlXCIpO1xufSwgY3cgPSAoaSkgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGkpLCBodyA9IChpKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoaSk7XG5jbGFzcyB1dyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMpIHtcbiAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLnByZWZpeCA9IHQsIHRoaXMuYmFzZUVuY29kZSA9IHM7XG4gIH1cbiAgZW5jb2RlKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICByZXR1cm4gYCR7dGhpcy5wcmVmaXh9JHt0aGlzLmJhc2VFbmNvZGUoZSl9YDtcbiAgICB0aHJvdyBFcnJvcihcIlVua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZVwiKTtcbiAgfVxufVxuY2xhc3MgbHcge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzKSB7XG4gICAgaWYgKHRoaXMubmFtZSA9IGUsIHRoaXMucHJlZml4ID0gdCwgdC5jb2RlUG9pbnRBdCgwKSA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcmVmaXggY2hhcmFjdGVyXCIpO1xuICAgIHRoaXMucHJlZml4Q29kZVBvaW50ID0gdC5jb2RlUG9pbnRBdCgwKSwgdGhpcy5iYXNlRGVjb2RlID0gcztcbiAgfVxuICBkZWNvZGUoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoZS5jb2RlUG9pbnRBdCgwKSAhPT0gdGhpcy5wcmVmaXhDb2RlUG9pbnQpXG4gICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShlKX0sICR7dGhpcy5uYW1lfSBkZWNvZGVyIG9ubHkgc3VwcG9ydHMgaW5wdXRzIHByZWZpeGVkIHdpdGggJHt0aGlzLnByZWZpeH1gKTtcbiAgICAgIHJldHVybiB0aGlzLmJhc2VEZWNvZGUoZS5zbGljZSh0aGlzLnByZWZpeC5sZW5ndGgpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IEVycm9yKFwiQ2FuIG9ubHkgbXVsdGliYXNlIGRlY29kZSBzdHJpbmdzXCIpO1xuICB9XG4gIG9yKGUpIHtcbiAgICByZXR1cm4gT2godGhpcywgZSk7XG4gIH1cbn1cbmNsYXNzIGR3IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuZGVjb2RlcnMgPSBlO1xuICB9XG4gIG9yKGUpIHtcbiAgICByZXR1cm4gT2godGhpcywgZSk7XG4gIH1cbiAgZGVjb2RlKGUpIHtcbiAgICBjb25zdCB0ID0gZVswXSwgcyA9IHRoaXMuZGVjb2RlcnNbdF07XG4gICAgaWYgKHMpXG4gICAgICByZXR1cm4gcy5kZWNvZGUoZSk7XG4gICAgdGhyb3cgUmFuZ2VFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkoZSl9LCBvbmx5IGlucHV0cyBwcmVmaXhlZCB3aXRoICR7T2JqZWN0LmtleXModGhpcy5kZWNvZGVycyl9IGFyZSBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuY29uc3QgT2ggPSAoaSwgZSkgPT4gbmV3IGR3KHsgLi4uaS5kZWNvZGVycyB8fCB7IFtpLnByZWZpeF06IGkgfSwgLi4uZS5kZWNvZGVycyB8fCB7IFtlLnByZWZpeF06IGUgfSB9KTtcbmNsYXNzIGZ3IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcywgcikge1xuICAgIHRoaXMubmFtZSA9IGUsIHRoaXMucHJlZml4ID0gdCwgdGhpcy5iYXNlRW5jb2RlID0gcywgdGhpcy5iYXNlRGVjb2RlID0gciwgdGhpcy5lbmNvZGVyID0gbmV3IHV3KGUsIHQsIHMpLCB0aGlzLmRlY29kZXIgPSBuZXcgbHcoZSwgdCwgcik7XG4gIH1cbiAgZW5jb2RlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGVyLmVuY29kZShlKTtcbiAgfVxuICBkZWNvZGUoZSkge1xuICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlKGUpO1xuICB9XG59XG5jb25zdCBmciA9ICh7IG5hbWU6IGksIHByZWZpeDogZSwgZW5jb2RlOiB0LCBkZWNvZGU6IHMgfSkgPT4gbmV3IGZ3KGksIGUsIHQsIHMpLCB4cyA9ICh7IHByZWZpeDogaSwgbmFtZTogZSwgYWxwaGFiZXQ6IHQgfSkgPT4ge1xuICBjb25zdCB7IGVuY29kZTogcywgZGVjb2RlOiByIH0gPSBhdyh0LCBlKTtcbiAgcmV0dXJuIGZyKHsgcHJlZml4OiBpLCBuYW1lOiBlLCBlbmNvZGU6IHMsIGRlY29kZTogKG4pID0+IHhoKHIobikpIH0pO1xufSwgcHcgPSAoaSwgZSwgdCwgcykgPT4ge1xuICBjb25zdCByID0ge307XG4gIGZvciAobGV0IHAgPSAwOyBwIDwgZS5sZW5ndGg7ICsrcClcbiAgICByW2VbcF1dID0gcDtcbiAgbGV0IG4gPSBpLmxlbmd0aDtcbiAgZm9yICg7IGlbbiAtIDFdID09PSBcIj1cIjsgKVxuICAgIC0tbjtcbiAgY29uc3QgbyA9IG5ldyBVaW50OEFycmF5KG4gKiB0IC8gOCB8IDApO1xuICBsZXQgYyA9IDAsIHUgPSAwLCBkID0gMDtcbiAgZm9yIChsZXQgcCA9IDA7IHAgPCBuOyArK3ApIHtcbiAgICBjb25zdCBiID0gcltpW3BdXTtcbiAgICBpZiAoYiA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb24tJHtzfSBjaGFyYWN0ZXJgKTtcbiAgICB1ID0gdSA8PCB0IHwgYiwgYyArPSB0LCBjID49IDggJiYgKGMgLT0gOCwgb1tkKytdID0gMjU1ICYgdSA+PiBjKTtcbiAgfVxuICBpZiAoYyA+PSB0IHx8IDI1NSAmIHUgPDwgOCAtIGMpXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgZGF0YVwiKTtcbiAgcmV0dXJuIG87XG59LCBndyA9IChpLCBlLCB0KSA9PiB7XG4gIGNvbnN0IHMgPSBlW2UubGVuZ3RoIC0gMV0gPT09IFwiPVwiLCByID0gKDEgPDwgdCkgLSAxO1xuICBsZXQgbiA9IFwiXCIsIG8gPSAwLCBjID0gMDtcbiAgZm9yIChsZXQgdSA9IDA7IHUgPCBpLmxlbmd0aDsgKyt1KVxuICAgIGZvciAoYyA9IGMgPDwgOCB8IGlbdV0sIG8gKz0gODsgbyA+IHQ7IClcbiAgICAgIG8gLT0gdCwgbiArPSBlW3IgJiBjID4+IG9dO1xuICBpZiAobyAmJiAobiArPSBlW3IgJiBjIDw8IHQgLSBvXSksIHMpXG4gICAgZm9yICg7IG4ubGVuZ3RoICogdCAmIDc7IClcbiAgICAgIG4gKz0gXCI9XCI7XG4gIHJldHVybiBuO1xufSwgZHQgPSAoeyBuYW1lOiBpLCBwcmVmaXg6IGUsIGJpdHNQZXJDaGFyOiB0LCBhbHBoYWJldDogcyB9KSA9PiBmcih7IHByZWZpeDogZSwgbmFtZTogaSwgZW5jb2RlKHIpIHtcbiAgcmV0dXJuIGd3KHIsIHMsIHQpO1xufSwgZGVjb2RlKHIpIHtcbiAgcmV0dXJuIHB3KHIsIHMsIHQsIGkpO1xufSB9KSwgeXcgPSBmcih7IHByZWZpeDogXCJcXDBcIiwgbmFtZTogXCJpZGVudGl0eVwiLCBlbmNvZGU6IChpKSA9PiBodyhpKSwgZGVjb2RlOiAoaSkgPT4gY3coaSkgfSk7XG52YXIgbXcgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBpZGVudGl0eTogeXcgfSk7XG5jb25zdCBidyA9IGR0KHsgcHJlZml4OiBcIjBcIiwgbmFtZTogXCJiYXNlMlwiLCBhbHBoYWJldDogXCIwMVwiLCBiaXRzUGVyQ2hhcjogMSB9KTtcbnZhciB3dyA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2UyOiBidyB9KTtcbmNvbnN0IHZ3ID0gZHQoeyBwcmVmaXg6IFwiN1wiLCBuYW1lOiBcImJhc2U4XCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3XCIsIGJpdHNQZXJDaGFyOiAzIH0pO1xudmFyIF93ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTg6IHZ3IH0pO1xuY29uc3QgRXcgPSB4cyh7IHByZWZpeDogXCI5XCIsIG5hbWU6IFwiYmFzZTEwXCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlcIiB9KTtcbnZhciBTdyA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2UxMDogRXcgfSk7XG5jb25zdCBJdyA9IGR0KHsgcHJlZml4OiBcImZcIiwgbmFtZTogXCJiYXNlMTZcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OWFiY2RlZlwiLCBiaXRzUGVyQ2hhcjogNCB9KSwgRHcgPSBkdCh7IHByZWZpeDogXCJGXCIsIG5hbWU6IFwiYmFzZTE2dXBwZXJcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiLCBiaXRzUGVyQ2hhcjogNCB9KTtcbnZhciB4dyA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2UxNjogSXcsIGJhc2UxNnVwcGVyOiBEdyB9KTtcbmNvbnN0IE93ID0gZHQoeyBwcmVmaXg6IFwiYlwiLCBuYW1lOiBcImJhc2UzMlwiLCBhbHBoYWJldDogXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2N1wiLCBiaXRzUGVyQ2hhcjogNSB9KSwgTncgPSBkdCh7IHByZWZpeDogXCJCXCIsIG5hbWU6IFwiYmFzZTMydXBwZXJcIiwgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjdcIiwgYml0c1BlckNoYXI6IDUgfSksIFB3ID0gZHQoeyBwcmVmaXg6IFwiY1wiLCBuYW1lOiBcImJhc2UzMnBhZFwiLCBhbHBoYWJldDogXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nz1cIiwgYml0c1BlckNoYXI6IDUgfSksIFJ3ID0gZHQoeyBwcmVmaXg6IFwiQ1wiLCBuYW1lOiBcImJhc2UzMnBhZHVwcGVyXCIsIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3PVwiLCBiaXRzUGVyQ2hhcjogNSB9KSwgQ3cgPSBkdCh7IHByZWZpeDogXCJ2XCIsIG5hbWU6IFwiYmFzZTMyaGV4XCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2XCIsIGJpdHNQZXJDaGFyOiA1IH0pLCBBdyA9IGR0KHsgcHJlZml4OiBcIlZcIiwgbmFtZTogXCJiYXNlMzJoZXh1cHBlclwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVlwiLCBiaXRzUGVyQ2hhcjogNSB9KSwgVHcgPSBkdCh7IHByZWZpeDogXCJ0XCIsIG5hbWU6IFwiYmFzZTMyaGV4cGFkXCIsIGFscGhhYmV0OiBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PVwiLCBiaXRzUGVyQ2hhcjogNSB9KSwgJHcgPSBkdCh7IHByZWZpeDogXCJUXCIsIG5hbWU6IFwiYmFzZTMyaGV4cGFkdXBwZXJcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9XCIsIGJpdHNQZXJDaGFyOiA1IH0pLCBGdyA9IGR0KHsgcHJlZml4OiBcImhcIiwgbmFtZTogXCJiYXNlMzJ6XCIsIGFscGhhYmV0OiBcInlibmRyZmc4ZWprbWNwcXhvdDF1d2lzemEzNDVoNzY5XCIsIGJpdHNQZXJDaGFyOiA1IH0pO1xudmFyIFV3ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTMyOiBPdywgYmFzZTMydXBwZXI6IE53LCBiYXNlMzJwYWQ6IFB3LCBiYXNlMzJwYWR1cHBlcjogUncsIGJhc2UzMmhleDogQ3csIGJhc2UzMmhleHVwcGVyOiBBdywgYmFzZTMyaGV4cGFkOiBUdywgYmFzZTMyaGV4cGFkdXBwZXI6ICR3LCBiYXNlMzJ6OiBGdyB9KTtcbmNvbnN0IEx3ID0geHMoeyBwcmVmaXg6IFwia1wiLCBuYW1lOiBcImJhc2UzNlwiLCBhbHBoYWJldDogXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIiB9KSwgTXcgPSB4cyh7IHByZWZpeDogXCJLXCIsIG5hbWU6IFwiYmFzZTM2dXBwZXJcIiwgYWxwaGFiZXQ6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIgfSk7XG52YXIgcXcgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlMzY6IEx3LCBiYXNlMzZ1cHBlcjogTXcgfSk7XG5jb25zdCBqdyA9IHhzKHsgbmFtZTogXCJiYXNlNThidGNcIiwgcHJlZml4OiBcInpcIiwgYWxwaGFiZXQ6IFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiIH0pLCB6dyA9IHhzKHsgbmFtZTogXCJiYXNlNThmbGlja3JcIiwgcHJlZml4OiBcIlpcIiwgYWxwaGFiZXQ6IFwiMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWlwiIH0pO1xudmFyIEt3ID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgYmFzZTU4YnRjOiBqdywgYmFzZTU4ZmxpY2tyOiB6dyB9KTtcbmNvbnN0IFZ3ID0gZHQoeyBwcmVmaXg6IFwibVwiLCBuYW1lOiBcImJhc2U2NFwiLCBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIsIGJpdHNQZXJDaGFyOiA2IH0pLCBCdyA9IGR0KHsgcHJlZml4OiBcIk1cIiwgbmFtZTogXCJiYXNlNjRwYWRcIiwgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIiwgYml0c1BlckNoYXI6IDYgfSksIGt3ID0gZHQoeyBwcmVmaXg6IFwidVwiLCBuYW1lOiBcImJhc2U2NHVybFwiLCBhbHBoYWJldDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fXCIsIGJpdHNQZXJDaGFyOiA2IH0pLCBIdyA9IGR0KHsgcHJlZml4OiBcIlVcIiwgbmFtZTogXCJiYXNlNjR1cmxwYWRcIiwgYWxwaGFiZXQ6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz1cIiwgYml0c1BlckNoYXI6IDYgfSk7XG52YXIgR3cgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBiYXNlNjQ6IFZ3LCBiYXNlNjRwYWQ6IEJ3LCBiYXNlNjR1cmw6IGt3LCBiYXNlNjR1cmxwYWQ6IEh3IH0pO1xuY29uc3QgTmggPSBBcnJheS5mcm9tKFwi8J+agPCfqpDimITwn5uw8J+MjPCfjJHwn4yS8J+Mk/CfjJTwn4yV8J+MlvCfjJfwn4yY8J+MjfCfjI/wn4yO8J+QieKYgPCfkrvwn5al8J+SvvCfkr/wn5iC4p2k8J+YjfCfpKPwn5iK8J+Zj/CfkpXwn5it8J+YmPCfkY3wn5iF8J+Rj/CfmIHwn5Sl8J+lsPCfkpTwn5KW8J+SmfCfmKLwn6SU8J+YhvCfmYTwn5Kq8J+YieKYuvCfkYzwn6SX8J+SnPCfmJTwn5iO8J+Yh/CfjLnwn6Sm8J+OifCfkp7inIzinKjwn6S38J+YsfCfmIzwn4y48J+ZjPCfmIvwn5KX8J+SmvCfmI/wn5Kb8J+ZgvCfkpPwn6Sp8J+YhPCfmIDwn5ak8J+Yg/Cfkq/wn5mI8J+Rh/Cfjrbwn5iS8J+kreKdo/CfmJzwn5KL8J+RgPCfmKrwn5iR8J+SpfCfmYvwn5ie8J+YqfCfmKHwn6Sq8J+RivCfpbPwn5il8J+kpPCfkYnwn5KD8J+Ys+Kci/CfmJrwn5id8J+YtPCfjJ/wn5is8J+Zg/CfjYDwn4y38J+Yu/CfmJPirZDinIXwn6W68J+MiPCfmIjwn6SY8J+SpuKclPCfmKPwn4+D8J+SkOKYufCfjorwn5KY8J+YoOKYnfCfmJXwn4y68J+OgvCfjLvwn5iQ8J+WlfCfkp3wn5mK8J+YufCfl6Pwn5Kr8J+SgPCfkZHwn4618J+knvCfmJvwn5S08J+YpPCfjLzwn5ir4pq98J+kmeKYlfCfj4bwn6Sr8J+RiPCfmK7wn5mG8J+Nu/CfjYPwn5C28J+SgfCfmLLwn4y/8J+nofCfjoHimqHwn4ye8J+OiOKdjOKcivCfkYvwn5iw8J+kqPCfmLbwn6Sd8J+atvCfkrDwn42T8J+SovCfpJ/wn5mB8J+aqPCfkqjwn6Ss4pyI8J+OgPCfjbrwn6ST8J+YmfCfkp/wn4yx8J+YlvCfkbbwn6W04pa24p6h4p2T8J+SjvCfkrjirIfwn5io8J+MmvCfpovwn5i38J+VuuKaoPCfmYXwn5if8J+YtfCfkY7wn6Sy8J+koPCfpKfwn5OM8J+UtfCfkoXwn6eQ8J+QvvCfjZLwn5iX8J+kkfCfjIrwn6Sv8J+Qt+KYjvCfkqfwn5iv8J+ShvCfkYbwn46k8J+Zh/CfjZHinYTwn4y08J+So/CfkLjwn5KM8J+TjfCfpYDwn6Si8J+RhfCfkqHwn5Kp8J+RkPCfk7jwn5G78J+kkPCfpK7wn4688J+ltfCfmqnwn42O8J+NivCfkbzwn5KN8J+To/CfpYJcIiksIFd3ID0gTmgucmVkdWNlKChpLCBlLCB0KSA9PiAoaVt0XSA9IGUsIGkpLCBbXSksIFl3ID0gTmgucmVkdWNlKChpLCBlLCB0KSA9PiAoaVtlLmNvZGVQb2ludEF0KDApXSA9IHQsIGkpLCBbXSk7XG5mdW5jdGlvbiBKdyhpKSB7XG4gIHJldHVybiBpLnJlZHVjZSgoZSwgdCkgPT4gKGUgKz0gV3dbdF0sIGUpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIFF3KGkpIHtcbiAgY29uc3QgZSA9IFtdO1xuICBmb3IgKGNvbnN0IHQgb2YgaSkge1xuICAgIGNvbnN0IHMgPSBZd1t0LmNvZGVQb2ludEF0KDApXTtcbiAgICBpZiAocyA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24tYmFzZTI1NmVtb2ppIGNoYXJhY3RlcjogJHt0fWApO1xuICAgIGUucHVzaChzKTtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZSk7XG59XG5jb25zdCBYdyA9IGZyKHsgcHJlZml4OiBcIvCfmoBcIiwgbmFtZTogXCJiYXNlMjU2ZW1vamlcIiwgZW5jb2RlOiBKdywgZGVjb2RlOiBRdyB9KTtcbnZhciBadyA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGJhc2UyNTZlbW9qaTogWHcgfSksIGUwID0gUGgsIHhhID0gMTI4LCB0MCA9IDEyNywgaTAgPSB+dDAsIHMwID0gTWF0aC5wb3coMiwgMzEpO1xuZnVuY3Rpb24gUGgoaSwgZSwgdCkge1xuICBlID0gZSB8fCBbXSwgdCA9IHQgfHwgMDtcbiAgZm9yICh2YXIgcyA9IHQ7IGkgPj0gczA7IClcbiAgICBlW3QrK10gPSBpICYgMjU1IHwgeGEsIGkgLz0gMTI4O1xuICBmb3IgKDsgaSAmIGkwOyApXG4gICAgZVt0KytdID0gaSAmIDI1NSB8IHhhLCBpID4+Pj0gNztcbiAgcmV0dXJuIGVbdF0gPSBpIHwgMCwgUGguYnl0ZXMgPSB0IC0gcyArIDEsIGU7XG59XG52YXIgcjAgPSBlbiwgbjAgPSAxMjgsIE9hID0gMTI3O1xuZnVuY3Rpb24gZW4oaSwgcykge1xuICB2YXIgdCA9IDAsIHMgPSBzIHx8IDAsIHIgPSAwLCBuID0gcywgbywgYyA9IGkubGVuZ3RoO1xuICBkbyB7XG4gICAgaWYgKG4gPj0gYylcbiAgICAgIHRocm93IGVuLmJ5dGVzID0gMCwgbmV3IFJhbmdlRXJyb3IoXCJDb3VsZCBub3QgZGVjb2RlIHZhcmludFwiKTtcbiAgICBvID0gaVtuKytdLCB0ICs9IHIgPCAyOCA/IChvICYgT2EpIDw8IHIgOiAobyAmIE9hKSAqIE1hdGgucG93KDIsIHIpLCByICs9IDc7XG4gIH0gd2hpbGUgKG8gPj0gbjApO1xuICByZXR1cm4gZW4uYnl0ZXMgPSBuIC0gcywgdDtcbn1cbnZhciBvMCA9IE1hdGgucG93KDIsIDcpLCBhMCA9IE1hdGgucG93KDIsIDE0KSwgYzAgPSBNYXRoLnBvdygyLCAyMSksIGgwID0gTWF0aC5wb3coMiwgMjgpLCB1MCA9IE1hdGgucG93KDIsIDM1KSwgbDAgPSBNYXRoLnBvdygyLCA0MiksIGQwID0gTWF0aC5wb3coMiwgNDkpLCBmMCA9IE1hdGgucG93KDIsIDU2KSwgcDAgPSBNYXRoLnBvdygyLCA2MyksIGcwID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gaSA8IG8wID8gMSA6IGkgPCBhMCA/IDIgOiBpIDwgYzAgPyAzIDogaSA8IGgwID8gNCA6IGkgPCB1MCA/IDUgOiBpIDwgbDAgPyA2IDogaSA8IGQwID8gNyA6IGkgPCBmMCA/IDggOiBpIDwgcDAgPyA5IDogMTA7XG59LCB5MCA9IHsgZW5jb2RlOiBlMCwgZGVjb2RlOiByMCwgZW5jb2RpbmdMZW5ndGg6IGcwIH0sIFJoID0geTA7XG5jb25zdCBOYSA9IChpLCBlLCB0ID0gMCkgPT4gKFJoLmVuY29kZShpLCBlLCB0KSwgZSksIFBhID0gKGkpID0+IFJoLmVuY29kaW5nTGVuZ3RoKGkpLCB0biA9IChpLCBlKSA9PiB7XG4gIGNvbnN0IHQgPSBlLmJ5dGVMZW5ndGgsIHMgPSBQYShpKSwgciA9IHMgKyBQYSh0KSwgbiA9IG5ldyBVaW50OEFycmF5KHIgKyB0KTtcbiAgcmV0dXJuIE5hKGksIG4sIDApLCBOYSh0LCBuLCBzKSwgbi5zZXQoZSwgciksIG5ldyBtMChpLCB0LCBlLCBuKTtcbn07XG5jbGFzcyBtMCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMsIHIpIHtcbiAgICB0aGlzLmNvZGUgPSBlLCB0aGlzLnNpemUgPSB0LCB0aGlzLmRpZ2VzdCA9IHMsIHRoaXMuYnl0ZXMgPSByO1xuICB9XG59XG5jb25zdCBDaCA9ICh7IG5hbWU6IGksIGNvZGU6IGUsIGVuY29kZTogdCB9KSA9PiBuZXcgYjAoaSwgZSwgdCk7XG5jbGFzcyBiMCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHMpIHtcbiAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLmNvZGUgPSB0LCB0aGlzLmVuY29kZSA9IHM7XG4gIH1cbiAgZGlnZXN0KGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmVuY29kZShlKTtcbiAgICAgIHJldHVybiB0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IHRuKHRoaXMuY29kZSwgdCkgOiB0LnRoZW4oKHMpID0+IHRuKHRoaXMuY29kZSwgcykpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGVcIik7XG4gIH1cbn1cbmNvbnN0IEFoID0gKGkpID0+IGFzeW5jIChlKSA9PiBuZXcgVWludDhBcnJheShhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChpLCBlKSksIHcwID0gQ2goeyBuYW1lOiBcInNoYTItMjU2XCIsIGNvZGU6IDE4LCBlbmNvZGU6IEFoKFwiU0hBLTI1NlwiKSB9KSwgdjAgPSBDaCh7IG5hbWU6IFwic2hhMi01MTJcIiwgY29kZTogMTksIGVuY29kZTogQWgoXCJTSEEtNTEyXCIpIH0pO1xudmFyIF8wID0gT2JqZWN0LmZyZWV6ZSh7IF9fcHJvdG9fXzogbnVsbCwgc2hhMjU2OiB3MCwgc2hhNTEyOiB2MCB9KTtcbmNvbnN0IFRoID0gMCwgRTAgPSBcImlkZW50aXR5XCIsICRoID0geGgsIFMwID0gKGkpID0+IHRuKFRoLCAkaChpKSksIEkwID0geyBjb2RlOiBUaCwgbmFtZTogRTAsIGVuY29kZTogJGgsIGRpZ2VzdDogUzAgfTtcbnZhciBEMCA9IE9iamVjdC5mcmVlemUoeyBfX3Byb3RvX186IG51bGwsIGlkZW50aXR5OiBJMCB9KTtcbm5ldyBUZXh0RW5jb2RlcigpLCBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IFJhID0geyAuLi5tdywgLi4ud3csIC4uLl93LCAuLi5TdywgLi4ueHcsIC4uLlV3LCAuLi5xdywgLi4uS3csIC4uLkd3LCAuLi5adyB9O1xuKHsgLi4uXzAsIC4uLkQwIH0pO1xuZnVuY3Rpb24gRmgoaSkge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCA/IG5ldyBVaW50OEFycmF5KGkuYnVmZmVyLCBpLmJ5dGVPZmZzZXQsIGkuYnl0ZUxlbmd0aCkgOiBpO1xufVxuZnVuY3Rpb24geDAoaSA9IDApIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2NVbnNhZmUgIT0gbnVsbCA/IEZoKGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jVW5zYWZlKGkpKSA6IG5ldyBVaW50OEFycmF5KGkpO1xufVxuZnVuY3Rpb24gVWgoaSwgZSwgdCwgcykge1xuICByZXR1cm4geyBuYW1lOiBpLCBwcmVmaXg6IGUsIGVuY29kZXI6IHsgbmFtZTogaSwgcHJlZml4OiBlLCBlbmNvZGU6IHQgfSwgZGVjb2RlcjogeyBkZWNvZGU6IHMgfSB9O1xufVxuY29uc3QgQ2EgPSBVaChcInV0ZjhcIiwgXCJ1XCIsIChpKSA9PiBcInVcIiArIG5ldyBUZXh0RGVjb2RlcihcInV0ZjhcIikuZGVjb2RlKGkpLCAoaSkgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGkuc3Vic3RyaW5nKDEpKSksIEFyID0gVWgoXCJhc2NpaVwiLCBcImFcIiwgKGkpID0+IHtcbiAgbGV0IGUgPSBcImFcIjtcbiAgZm9yIChsZXQgdCA9IDA7IHQgPCBpLmxlbmd0aDsgdCsrKVxuICAgIGUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShpW3RdKTtcbiAgcmV0dXJuIGU7XG59LCAoaSkgPT4ge1xuICBpID0gaS5zdWJzdHJpbmcoMSk7XG4gIGNvbnN0IGUgPSB4MChpLmxlbmd0aCk7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgaS5sZW5ndGg7IHQrKylcbiAgICBlW3RdID0gaS5jaGFyQ29kZUF0KHQpO1xuICByZXR1cm4gZTtcbn0pLCBPMCA9IHsgdXRmODogQ2EsIFwidXRmLThcIjogQ2EsIGhleDogUmEuYmFzZTE2LCBsYXRpbjE6IEFyLCBhc2NpaTogQXIsIGJpbmFyeTogQXIsIC4uLlJhIH07XG5mdW5jdGlvbiBOMChpLCBlID0gXCJ1dGY4XCIpIHtcbiAgY29uc3QgdCA9IE8wW2VdO1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7ZX1cImApO1xuICByZXR1cm4gKGUgPT09IFwidXRmOFwiIHx8IGUgPT09IFwidXRmLThcIikgJiYgZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tICE9IG51bGwgPyBGaChnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGksIFwidXRmLThcIikpIDogdC5kZWNvZGVyLmRlY29kZShgJHt0LnByZWZpeH0ke2l9YCk7XG59XG5jb25zdCBMaCA9IFwid2NcIiwgUDAgPSAyLCBDbiA9IFwiY29yZVwiLCB1aSA9IGAke0xofUAyOiR7Q259OmAsIFIwID0geyBuYW1lOiBDbiwgbG9nZ2VyOiBcImVycm9yXCIgfSwgQzAgPSB7IGRhdGFiYXNlOiBcIjptZW1vcnk6XCIgfSwgQTAgPSBcImNyeXB0b1wiLCBBYSA9IFwiY2xpZW50X2VkMjU1MTlfc2VlZFwiLCBUMCA9IFYuT05FX0RBWSwgJDAgPSBcImtleWNoYWluXCIsIEYwID0gXCIwLjNcIiwgVTAgPSBcIm1lc3NhZ2VzXCIsIEwwID0gXCIwLjNcIiwgTTAgPSBWLlNJWF9IT1VSUywgcTAgPSBcInB1Ymxpc2hlclwiLCBNaCA9IFwiaXJuXCIsIGowID0gXCJlcnJvclwiLCBxaCA9IFwid3NzOi8vcmVsYXkud2FsbGV0Y29ubmVjdC5jb21cIiwgejAgPSBcInJlbGF5ZXJcIiwgSGUgPSB7IG1lc3NhZ2U6IFwicmVsYXllcl9tZXNzYWdlXCIsIG1lc3NhZ2VfYWNrOiBcInJlbGF5ZXJfbWVzc2FnZV9hY2tcIiwgY29ubmVjdDogXCJyZWxheWVyX2Nvbm5lY3RcIiwgZGlzY29ubmVjdDogXCJyZWxheWVyX2Rpc2Nvbm5lY3RcIiwgZXJyb3I6IFwicmVsYXllcl9lcnJvclwiLCBjb25uZWN0aW9uX3N0YWxsZWQ6IFwicmVsYXllcl9jb25uZWN0aW9uX3N0YWxsZWRcIiwgdHJhbnNwb3J0X2Nsb3NlZDogXCJyZWxheWVyX3RyYW5zcG9ydF9jbG9zZWRcIiwgcHVibGlzaDogXCJyZWxheWVyX3B1Ymxpc2hcIiB9LCBLMCA9IFwiX3N1YnNjcmlwdGlvblwiLCBpcyA9IHsgcGF5bG9hZDogXCJwYXlsb2FkXCIsIGNvbm5lY3Q6IFwiY29ubmVjdFwiLCBkaXNjb25uZWN0OiBcImRpc2Nvbm5lY3RcIiwgZXJyb3I6IFwiZXJyb3JcIiB9LCBWMCA9IFYuT05FX1NFQ09ORCAvIDIsIEIwID0gXCJ5XCIsIGswID0gMWU0LCBIMCA9IFwiMC4zXCIsIEJ0ID0geyBjcmVhdGVkOiBcInN1YnNjcmlwdGlvbl9jcmVhdGVkXCIsIGRlbGV0ZWQ6IFwic3Vic2NyaXB0aW9uX2RlbGV0ZWRcIiwgZXhwaXJlZDogXCJzdWJzY3JpcHRpb25fZXhwaXJlZFwiLCBkaXNhYmxlZDogXCJzdWJzY3JpcHRpb25fZGlzYWJsZWRcIiwgc3luYzogXCJzdWJzY3JpcHRpb25fc3luY1wiLCByZXN1YnNjcmliZWQ6IFwic3Vic2NyaXB0aW9uX3Jlc3Vic2NyaWJlZFwiIH0sIEcwID0gXCJzdWJzY3JpcHRpb25cIiwgVzAgPSBcIjAuM1wiLCBZMCA9IFYuRklWRV9TRUNPTkRTICogMWUzLCBKMCA9IFwicGFpcmluZ1wiLCBRMCA9IFwiMC4zXCIsIHNzID0geyB3Y19wYWlyaW5nRGVsZXRlOiB7IHJlcTogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxZTMgfSwgcmVzOiB7IHR0bDogVi5PTkVfREFZLCBwcm9tcHQ6ICExLCB0YWc6IDEwMDEgfSB9LCB3Y19wYWlyaW5nUGluZzogeyByZXE6IHsgdHRsOiBWLlRISVJUWV9TRUNPTkRTLCBwcm9tcHQ6ICExLCB0YWc6IDEwMDIgfSwgcmVzOiB7IHR0bDogVi5USElSVFlfU0VDT05EUywgcHJvbXB0OiAhMSwgdGFnOiAxMDAzIH0gfSwgdW5yZWdpc3RlcmVkX21ldGhvZDogeyByZXE6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMCB9LCByZXM6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMCB9IH0gfSwgS3QgPSB7IGNyZWF0ZWQ6IFwiaGlzdG9yeV9jcmVhdGVkXCIsIHVwZGF0ZWQ6IFwiaGlzdG9yeV91cGRhdGVkXCIsIGRlbGV0ZWQ6IFwiaGlzdG9yeV9kZWxldGVkXCIsIHN5bmM6IFwiaGlzdG9yeV9zeW5jXCIgfSwgWDAgPSBcImhpc3RvcnlcIiwgWjAgPSBcIjAuM1wiLCBldiA9IFwiZXhwaXJlclwiLCAkdCA9IHsgY3JlYXRlZDogXCJleHBpcmVyX2NyZWF0ZWRcIiwgZGVsZXRlZDogXCJleHBpcmVyX2RlbGV0ZWRcIiwgZXhwaXJlZDogXCJleHBpcmVyX2V4cGlyZWRcIiwgc3luYzogXCJleHBpcmVyX3N5bmNcIiB9LCB0diA9IFwiMC4zXCIsIFRyID0gXCJ2ZXJpZnktYXBpXCIsIFRhID0gXCJodHRwczovL3ZlcmlmeS53YWxsZXRjb25uZWN0LmNvbVwiO1xuY2xhc3MgaXYge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLmtleWNoYWluID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5uYW1lID0gJDAsIHRoaXMudmVyc2lvbiA9IEYwLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuc3RvcmFnZVByZWZpeCA9IHVpLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgcyA9IGF3YWl0IHRoaXMuZ2V0S2V5Q2hhaW4oKTtcbiAgICAgICAgdHlwZW9mIHMgPCBcInVcIiAmJiAodGhpcy5rZXljaGFpbiA9IHMpLCB0aGlzLmluaXRpYWxpemVkID0gITA7XG4gICAgICB9XG4gICAgfSwgdGhpcy5oYXMgPSAocykgPT4gKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmtleWNoYWluLmhhcyhzKSksIHRoaXMuc2V0ID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmtleWNoYWluLnNldChzLCByKSwgYXdhaXQgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSwgdGhpcy5nZXQgPSAocykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCByID0gdGhpcy5rZXljaGFpbi5nZXQocyk7XG4gICAgICBpZiAodHlwZW9mIHIgPiBcInVcIikge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IEooXCJOT19NQVRDSElOR19LRVlcIiwgYCR7dGhpcy5uYW1lfTogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9LCB0aGlzLmRlbCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5rZXljaGFpbi5kZWxldGUocyksIGF3YWl0IHRoaXMucGVyc2lzdCgpO1xuICAgIH0sIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgc3RvcmFnZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJlZml4ICsgdGhpcy52ZXJzaW9uICsgXCIvL1wiICsgdGhpcy5uYW1lO1xuICB9XG4gIGFzeW5jIHNldEtleUNoYWluKGUpIHtcbiAgICBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgdmgoZSkpO1xuICB9XG4gIGFzeW5jIGdldEtleUNoYWluKCkge1xuICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgcmV0dXJuIHR5cGVvZiBlIDwgXCJ1XCIgPyBfaChlKSA6IHZvaWQgMDtcbiAgfVxuICBhc3luYyBwZXJzaXN0KCkge1xuICAgIGF3YWl0IHRoaXMuc2V0S2V5Q2hhaW4odGhpcy5rZXljaGFpbik7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gSihcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxufVxuY2xhc3Mgc3Yge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzKSB7XG4gICAgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0LCB0aGlzLm5hbWUgPSBBMCwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkIHx8IChhd2FpdCB0aGlzLmtleWNoYWluLmluaXQoKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwKTtcbiAgICB9LCB0aGlzLmhhc0tleXMgPSAocikgPT4gKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmtleWNoYWluLmhhcyhyKSksIHRoaXMuZ2V0Q2xpZW50SWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLmdldENsaWVudFNlZWQoKSwgbiA9IFdzKHIpO1xuICAgICAgcmV0dXJuIGFuKG4ucHVibGljS2V5KTtcbiAgICB9LCB0aGlzLmdlbmVyYXRlS2V5UGFpciA9ICgpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgciA9IFhtKCk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRQcml2YXRlS2V5KHIucHVibGljS2V5LCByLnByaXZhdGVLZXkpO1xuICAgIH0sIHRoaXMuc2lnbkpXVCA9IGFzeW5jIChyKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IG4gPSBhd2FpdCB0aGlzLmdldENsaWVudFNlZWQoKSwgbyA9IFdzKG4pLCBjID0gWHIoKTtcbiAgICAgIHJldHVybiBhd2FpdCBJYyhjLCByLCBUMCwgbyk7XG4gICAgfSwgdGhpcy5nZW5lcmF0ZVNoYXJlZEtleSA9IChyLCBuLCBvKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmdldFByaXZhdGVLZXkociksIHUgPSBabShjLCBuKTtcbiAgICAgIHJldHVybiB0aGlzLnNldFN5bUtleSh1LCBvKTtcbiAgICB9LCB0aGlzLnNldFN5bUtleSA9IGFzeW5jIChyLCBuKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IG8gPSBuIHx8IGViKHIpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMua2V5Y2hhaW4uc2V0KG8sIHIpLCBvO1xuICAgIH0sIHRoaXMuZGVsZXRlS2V5UGFpciA9IGFzeW5jIChyKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5rZXljaGFpbi5kZWwocik7XG4gICAgfSwgdGhpcy5kZWxldGVTeW1LZXkgPSBhc3luYyAocikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMua2V5Y2hhaW4uZGVsKHIpO1xuICAgIH0sIHRoaXMuZW5jb2RlID0gYXN5bmMgKHIsIG4sIG8pID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgYyA9IGJoKG8pLCB1ID0gcnIobik7XG4gICAgICBpZiAoeWEoYykpIHtcbiAgICAgICAgY29uc3QgeCA9IGMuc2VuZGVyUHVibGljS2V5LCBPID0gYy5yZWNlaXZlclB1YmxpY0tleTtcbiAgICAgICAgciA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVTaGFyZWRLZXkoeCwgTyk7XG4gICAgICB9XG4gICAgICBjb25zdCBkID0gdGhpcy5nZXRTeW1LZXkociksIHsgdHlwZTogcCwgc2VuZGVyUHVibGljS2V5OiBiIH0gPSBjO1xuICAgICAgcmV0dXJuIGliKHsgdHlwZTogcCwgc3ltS2V5OiBkLCBtZXNzYWdlOiB1LCBzZW5kZXJQdWJsaWNLZXk6IGIgfSk7XG4gICAgfSwgdGhpcy5kZWNvZGUgPSBhc3luYyAociwgbiwgbykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBjID0gbmIobiwgbyk7XG4gICAgICBpZiAoeWEoYykpIHtcbiAgICAgICAgY29uc3QgcCA9IGMucmVjZWl2ZXJQdWJsaWNLZXksIGIgPSBjLnNlbmRlclB1YmxpY0tleTtcbiAgICAgICAgciA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVTaGFyZWRLZXkocCwgYik7XG4gICAgICB9XG4gICAgICBjb25zdCB1ID0gdGhpcy5nZXRTeW1LZXkociksIGQgPSBzYih7IHN5bUtleTogdSwgZW5jb2RlZDogbiB9KTtcbiAgICAgIHJldHVybiBybihkKTtcbiAgICB9LCB0aGlzLmdldFBheWxvYWRUeXBlID0gKHIpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBacyhyKTtcbiAgICAgIHJldHVybiBJcyhuLnR5cGUpO1xuICAgIH0sIHRoaXMuZ2V0UGF5bG9hZFNlbmRlclB1YmxpY0tleSA9IChyKSA9PiB7XG4gICAgICBjb25zdCBuID0gWnMocik7XG4gICAgICByZXR1cm4gbi5zZW5kZXJQdWJsaWNLZXkgPyBOZShuLnNlbmRlclB1YmxpY0tleSwgX3QpIDogdm9pZCAwO1xuICAgIH0sIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLmtleWNoYWluID0gcyB8fCBuZXcgaXYodGhpcy5jb3JlLCB0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGFzeW5jIHNldFByaXZhdGVLZXkoZSwgdCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmtleWNoYWluLnNldChlLCB0KSwgZTtcbiAgfVxuICBnZXRQcml2YXRlS2V5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5rZXljaGFpbi5nZXQoZSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xpZW50U2VlZCgpIHtcbiAgICBsZXQgZSA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIGUgPSB0aGlzLmtleWNoYWluLmdldChBYSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBlID0gWHIoKSwgYXdhaXQgdGhpcy5rZXljaGFpbi5zZXQoQWEsIGUpO1xuICAgIH1cbiAgICByZXR1cm4gTjAoZSwgXCJiYXNlMTZcIik7XG4gIH1cbiAgZ2V0U3ltS2V5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5rZXljaGFpbi5nZXQoZSk7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gSihcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgcnYgZXh0ZW5kcyAkbSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5sb2dnZXIgPSBlLCB0aGlzLmNvcmUgPSB0LCB0aGlzLm1lc3NhZ2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5uYW1lID0gVTAsIHRoaXMudmVyc2lvbiA9IEwwLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuc3RvcmFnZVByZWZpeCA9IHVpLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzID0gYXdhaXQgdGhpcy5nZXRSZWxheWVyTWVzc2FnZXMoKTtcbiAgICAgICAgICB0eXBlb2YgcyA8IFwidVwiICYmICh0aGlzLm1lc3NhZ2VzID0gcyksIHRoaXMubG9nZ2VyLmRlYnVnKGBTdWNjZXNzZnVsbHkgUmVzdG9yZWQgcmVjb3JkcyBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInJlc3RvcmVcIiwgc2l6ZTogdGhpcy5tZXNzYWdlcy5zaXplIH0pO1xuICAgICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBSZXN0b3JlIHJlY29yZHMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci5lcnJvcihzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gITA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzLnNldCA9IGFzeW5jIChzLCByKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IG4gPSBVaShyKTtcbiAgICAgIGxldCBvID0gdGhpcy5tZXNzYWdlcy5nZXQocyk7XG4gICAgICByZXR1cm4gdHlwZW9mIG8gPiBcInVcIiAmJiAobyA9IHt9KSwgdHlwZW9mIG9bbl0gPCBcInVcIiB8fCAob1tuXSA9IHIsIHRoaXMubWVzc2FnZXMuc2V0KHMsIG8pLCBhd2FpdCB0aGlzLnBlcnNpc3QoKSksIG47XG4gICAgfSwgdGhpcy5nZXQgPSAocykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBsZXQgciA9IHRoaXMubWVzc2FnZXMuZ2V0KHMpO1xuICAgICAgcmV0dXJuIHR5cGVvZiByID4gXCJ1XCIgJiYgKHIgPSB7fSksIHI7XG4gICAgfSwgdGhpcy5oYXMgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCBuID0gdGhpcy5nZXQocyksIG8gPSBVaShyKTtcbiAgICAgIHJldHVybiB0eXBlb2YgbltvXSA8IFwidVwiO1xuICAgIH0sIHRoaXMuZGVsID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLm1lc3NhZ2VzLmRlbGV0ZShzKSwgYXdhaXQgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSwgdGhpcy5sb2dnZXIgPSBlZS5nZW5lcmF0ZUNoaWxkTG9nZ2VyKGUsIHRoaXMubmFtZSksIHRoaXMuY29yZSA9IHQ7XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBzdG9yYWdlS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQcmVmaXggKyB0aGlzLnZlcnNpb24gKyBcIi8vXCIgKyB0aGlzLm5hbWU7XG4gIH1cbiAgYXN5bmMgc2V0UmVsYXllck1lc3NhZ2VzKGUpIHtcbiAgICBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgdmgoZSkpO1xuICB9XG4gIGFzeW5jIGdldFJlbGF5ZXJNZXNzYWdlcygpIHtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgIHJldHVybiB0eXBlb2YgZSA8IFwidVwiID8gX2goZSkgOiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldFJlbGF5ZXJNZXNzYWdlcyh0aGlzLm1lc3NhZ2VzKTtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBKKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBudiBleHRlbmRzIEZtIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLnJlbGF5ZXIgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMuZXZlbnRzID0gbmV3IFdlLkV2ZW50RW1pdHRlcigpLCB0aGlzLm5hbWUgPSBxMCwgdGhpcy5xdWV1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMucHVibGlzaFRpbWVvdXQgPSAxZTQsIHRoaXMucHVibGlzaCA9IGFzeW5jIChzLCByLCBuKSA9PiB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlB1Ymxpc2hpbmcgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicHVibGlzaFwiLCBwYXJhbXM6IHsgdG9waWM6IHMsIG1lc3NhZ2U6IHIsIG9wdHM6IG4gfSB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG8gPSBuPy50dGwgfHwgTTAsIGMgPSBacihuKSwgdSA9IG4/LnByb21wdCB8fCAhMSwgZCA9IG4/LnRhZyB8fCAwLCBwID0gbj8uaWQgfHwgdm4oKS50b1N0cmluZygpLCBiID0geyB0b3BpYzogcywgbWVzc2FnZTogciwgb3B0czogeyB0dGw6IG8sIHJlbGF5OiBjLCBwcm9tcHQ6IHUsIHRhZzogZCwgaWQ6IHAgfSB9O1xuICAgICAgICB0aGlzLnF1ZXVlLnNldChwLCBiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBhd2FpdCBlcih0aGlzLnJwY1B1Ymxpc2gocywgciwgbywgYywgdSwgZCwgcCksIHRoaXMucHVibGlzaFRpbWVvdXQpLCB0aGlzLnJlbGF5ZXIuZXZlbnRzLmVtaXQoSGUucHVibGlzaCwgYik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiUHVibGlzaGluZyBQYXlsb2FkIHN0YWxsZWRcIiksIHRoaXMucmVsYXllci5ldmVudHMuZW1pdChIZS5jb25uZWN0aW9uX3N0YWxsZWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN1Y2Nlc3NmdWxseSBQdWJsaXNoZWQgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicHVibGlzaFwiLCBwYXJhbXM6IHsgdG9waWM6IHMsIG1lc3NhZ2U6IHIsIG9wdHM6IG4gfSB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZGVidWcoXCJGYWlsZWQgdG8gUHVibGlzaCBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci5lcnJvcihvKSwgbztcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uKHMsIHIpO1xuICAgIH0sIHRoaXMub25jZSA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbmNlKHMsIHIpO1xuICAgIH0sIHRoaXMub2ZmID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9mZihzLCByKTtcbiAgICB9LCB0aGlzLnJlbW92ZUxpc3RlbmVyID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKHMsIHIpO1xuICAgIH0sIHRoaXMucmVsYXllciA9IGUsIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgcnBjUHVibGlzaChlLCB0LCBzLCByLCBuLCBvLCBjKSB7XG4gICAgdmFyIHUsIGQsIHAsIGI7XG4gICAgY29uc3QgeCA9IHsgbWV0aG9kOiBWcyhyLnByb3RvY29sKS5wdWJsaXNoLCBwYXJhbXM6IHsgdG9waWM6IGUsIG1lc3NhZ2U6IHQsIHR0bDogcywgcHJvbXB0OiBuLCB0YWc6IG8gfSwgaWQ6IGMgfTtcbiAgICByZXR1cm4gd3QoKHUgPSB4LnBhcmFtcykgPT0gbnVsbCA/IHZvaWQgMCA6IHUucHJvbXB0KSAmJiAoKGQgPSB4LnBhcmFtcykgPT0gbnVsbCB8fCBkZWxldGUgZC5wcm9tcHQpLCB3dCgocCA9IHgucGFyYW1zKSA9PSBudWxsID8gdm9pZCAwIDogcC50YWcpICYmICgoYiA9IHgucGFyYW1zKSA9PSBudWxsIHx8IGRlbGV0ZSBiLnRhZyksIHRoaXMubG9nZ2VyLmRlYnVnKFwiT3V0Z29pbmcgUmVsYXkgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1lc3NhZ2VcIiwgZGlyZWN0aW9uOiBcIm91dGdvaW5nXCIsIHJlcXVlc3Q6IHggfSksIHRoaXMucmVsYXllci5yZXF1ZXN0KHgpO1xuICB9XG4gIG9uUHVibGlzaChlKSB7XG4gICAgdGhpcy5xdWV1ZS5kZWxldGUoZSk7XG4gIH1cbiAgY2hlY2tRdWV1ZSgpIHtcbiAgICB0aGlzLnF1ZXVlLmZvckVhY2goYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHQsIG1lc3NhZ2U6IHMsIG9wdHM6IHIgfSA9IGU7XG4gICAgICBhd2FpdCB0aGlzLnB1Ymxpc2godCwgcywgcik7XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLnJlbGF5ZXIuY29yZS5oZWFydGJlYXQub24oV3QuSEVBUlRCRUFUX0VWRU5UUy5wdWxzZSwgKCkgPT4ge1xuICAgICAgdGhpcy5jaGVja1F1ZXVlKCk7XG4gICAgfSksIHRoaXMucmVsYXllci5vbihIZS5tZXNzYWdlX2FjaywgKGUpID0+IHtcbiAgICAgIHRoaXMub25QdWJsaXNoKGUuaWQudG9TdHJpbmcoKSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIG92IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnNldCA9IChlLCB0KSA9PiB7XG4gICAgICBjb25zdCBzID0gdGhpcy5nZXQoZSk7XG4gICAgICB0aGlzLmV4aXN0cyhlLCB0KSB8fCB0aGlzLm1hcC5zZXQoZSwgWy4uLnMsIHRdKTtcbiAgICB9LCB0aGlzLmdldCA9IChlKSA9PiB0aGlzLm1hcC5nZXQoZSkgfHwgW10sIHRoaXMuZXhpc3RzID0gKGUsIHQpID0+IHRoaXMuZ2V0KGUpLmluY2x1ZGVzKHQpLCB0aGlzLmRlbGV0ZSA9IChlLCB0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHQgPiBcInVcIikge1xuICAgICAgICB0aGlzLm1hcC5kZWxldGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5tYXAuaGFzKGUpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBzID0gdGhpcy5nZXQoZSk7XG4gICAgICBpZiAoIXRoaXMuZXhpc3RzKGUsIHQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByID0gcy5maWx0ZXIoKG4pID0+IG4gIT09IHQpO1xuICAgICAgaWYgKCFyLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm1hcC5kZWxldGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwLnNldChlLCByKTtcbiAgICB9LCB0aGlzLmNsZWFyID0gKCkgPT4ge1xuICAgICAgdGhpcy5tYXAuY2xlYXIoKTtcbiAgICB9O1xuICB9XG4gIGdldCB0b3BpY3MoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tYXAua2V5cygpKTtcbiAgfVxufVxudmFyIGF2ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBjdiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBodiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLCAkYSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIHV2ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgbHYgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBGYSA9IChpLCBlLCB0KSA9PiBlIGluIGkgPyBhdihpLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaVtlXSA9IHQsIHJzID0gKGksIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIHV2LmNhbGwoZSwgdCkgJiYgRmEoaSwgdCwgZVt0XSk7XG4gIGlmICgkYSlcbiAgICBmb3IgKHZhciB0IG9mICRhKGUpKVxuICAgICAgbHYuY2FsbChlLCB0KSAmJiBGYShpLCB0LCBlW3RdKTtcbiAgcmV0dXJuIGk7XG59LCAkciA9IChpLCBlKSA9PiBjdihpLCBodihlKSk7XG5jbGFzcyBkdiBleHRlbmRzIE1tIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLnJlbGF5ZXIgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMuc3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMudG9waWNNYXAgPSBuZXcgb3YoKSwgdGhpcy5ldmVudHMgPSBuZXcgV2UuRXZlbnRFbWl0dGVyKCksIHRoaXMubmFtZSA9IEcwLCB0aGlzLnZlcnNpb24gPSBXMCwgdGhpcy5wZW5kaW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25XYXRjaExhYmVsID0gXCJwZW5kaW5nX3N1Yl93YXRjaF9sYWJlbFwiLCB0aGlzLnBvbGxpbmdJbnRlcnZhbCA9IDIwLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSB1aSwgdGhpcy5zdWJzY3JpYmVUaW1lb3V0ID0gMWU0LCB0aGlzLnJlc3RhcnRJblByb2dyZXNzID0gITEsIHRoaXMuYmF0Y2hTdWJzY3JpYmVUb3BpY3NMaW1pdCA9IDUwMCwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAodGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKSwgYXdhaXQgdGhpcy5yZXN0YXJ0KCksIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLm9uRW5hYmxlKCksIHRoaXMuY2xpZW50SWQgPSBhd2FpdCB0aGlzLnJlbGF5ZXIuY29yZS5jcnlwdG8uZ2V0Q2xpZW50SWQoKSk7XG4gICAgfSwgdGhpcy5zdWJzY3JpYmUgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VG9Db21wbGV0ZSgpLCB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJTdWJzY3JpYmluZyBUb3BpY1wiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwic3Vic2NyaWJlXCIsIHBhcmFtczogeyB0b3BpYzogcywgb3B0czogciB9IH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbiA9IFpyKHIpLCBvID0geyB0b3BpYzogcywgcmVsYXk6IG4gfTtcbiAgICAgICAgdGhpcy5wZW5kaW5nLnNldChzLCBvKTtcbiAgICAgICAgY29uc3QgYyA9IGF3YWl0IHRoaXMucnBjU3Vic2NyaWJlKHMsIG4pO1xuICAgICAgICByZXR1cm4gdGhpcy5vblN1YnNjcmliZShjLCBvKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJTdWNjZXNzZnVsbHkgU3Vic2NyaWJlZCBUb3BpY1wiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwic3Vic2NyaWJlXCIsIHBhcmFtczogeyB0b3BpYzogcywgb3B0czogciB9IH0pLCBjO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkZhaWxlZCB0byBTdWJzY3JpYmUgVG9waWNcIiksIHRoaXMubG9nZ2VyLmVycm9yKG4pLCBuO1xuICAgICAgfVxuICAgIH0sIHRoaXMudW5zdWJzY3JpYmUgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VG9Db21wbGV0ZSgpLCB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdHlwZW9mIHI/LmlkIDwgXCJ1XCIgPyBhd2FpdCB0aGlzLnVuc3Vic2NyaWJlQnlJZChzLCByLmlkLCByKSA6IGF3YWl0IHRoaXMudW5zdWJzY3JpYmVCeVRvcGljKHMsIHIpO1xuICAgIH0sIHRoaXMuaXNTdWJzY3JpYmVkID0gYXN5bmMgKHMpID0+IHRoaXMudG9waWNzLmluY2x1ZGVzKHMpID8gITAgOiBhd2FpdCBuZXcgUHJvbWlzZSgociwgbikgPT4ge1xuICAgICAgY29uc3QgbyA9IG5ldyBWLldhdGNoKCk7XG4gICAgICBvLnN0YXJ0KHRoaXMucGVuZGluZ1N1YnNjcmlwdGlvbldhdGNoTGFiZWwpO1xuICAgICAgY29uc3QgYyA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgIXRoaXMucGVuZGluZy5oYXMocykgJiYgdGhpcy50b3BpY3MuaW5jbHVkZXMocykgJiYgKGNsZWFySW50ZXJ2YWwoYyksIG8uc3RvcCh0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25XYXRjaExhYmVsKSwgcighMCkpLCBvLmVsYXBzZWQodGhpcy5wZW5kaW5nU3Vic2NyaXB0aW9uV2F0Y2hMYWJlbCkgPj0gWTAgJiYgKGNsZWFySW50ZXJ2YWwoYyksIG8uc3RvcCh0aGlzLnBlbmRpbmdTdWJzY3JpcHRpb25XYXRjaExhYmVsKSwgbihuZXcgRXJyb3IoXCJTdWJzY3JpcHRpb24gcmVzb2x1dGlvbiB0aW1lb3V0XCIpKSk7XG4gICAgICB9LCB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgfSkuY2F0Y2goKCkgPT4gITEpLCB0aGlzLm9uID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uKHMsIHIpO1xuICAgIH0sIHRoaXMub25jZSA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbmNlKHMsIHIpO1xuICAgIH0sIHRoaXMub2ZmID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9mZihzLCByKTtcbiAgICB9LCB0aGlzLnJlbW92ZUxpc3RlbmVyID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKHMsIHIpO1xuICAgIH0sIHRoaXMucmVzdGFydCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMucmVzdGFydEluUHJvZ3Jlc3MgPSAhMCwgYXdhaXQgdGhpcy5yZXN0b3JlKCksIGF3YWl0IHRoaXMucmVzZXQoKSwgdGhpcy5yZXN0YXJ0SW5Qcm9ncmVzcyA9ICExO1xuICAgIH0sIHRoaXMucmVsYXllciA9IGUsIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLmNsaWVudElkID0gXCJcIjtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHN0b3JhZ2VLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByZWZpeCArIHRoaXMudmVyc2lvbiArIFwiLy9cIiArIHRoaXMubmFtZTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbnMuc2l6ZTtcbiAgfVxuICBnZXQgaWRzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3Vic2NyaXB0aW9ucy5rZXlzKCkpO1xuICB9XG4gIGdldCB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdWJzY3JpcHRpb25zLnZhbHVlcygpKTtcbiAgfVxuICBnZXQgdG9waWNzKCkge1xuICAgIHJldHVybiB0aGlzLnRvcGljTWFwLnRvcGljcztcbiAgfVxuICBoYXNTdWJzY3JpcHRpb24oZSwgdCkge1xuICAgIGxldCBzID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIHMgPSB0aGlzLmdldFN1YnNjcmlwdGlvbihlKS50b3BpYyA9PT0gdDtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgb25FbmFibGUoKSB7XG4gICAgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICEwO1xuICB9XG4gIG9uRGlzYWJsZSgpIHtcbiAgICB0aGlzLmNhY2hlZCA9IHRoaXMudmFsdWVzLCB0aGlzLnN1YnNjcmlwdGlvbnMuY2xlYXIoKSwgdGhpcy50b3BpY01hcC5jbGVhcigpO1xuICB9XG4gIGFzeW5jIHVuc3Vic2NyaWJlQnlUb3BpYyhlLCB0KSB7XG4gICAgY29uc3QgcyA9IHRoaXMudG9waWNNYXAuZ2V0KGUpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHMubWFwKGFzeW5jIChyKSA9PiBhd2FpdCB0aGlzLnVuc3Vic2NyaWJlQnlJZChlLCByLCB0KSkpO1xuICB9XG4gIGFzeW5jIHVuc3Vic2NyaWJlQnlJZChlLCB0LCBzKSB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJVbnN1YnNjcmliaW5nIFRvcGljXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJ1bnN1YnNjcmliZVwiLCBwYXJhbXM6IHsgdG9waWM6IGUsIGlkOiB0LCBvcHRzOiBzIH0gfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHIgPSBacihzKTtcbiAgICAgIGF3YWl0IHRoaXMucnBjVW5zdWJzY3JpYmUoZSwgdCwgcik7XG4gICAgICBjb25zdCBuID0gSmUoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiLCBgJHt0aGlzLm5hbWV9LCAke2V9YCk7XG4gICAgICBhd2FpdCB0aGlzLm9uVW5zdWJzY3JpYmUoZSwgdCwgbiksIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3VjY2Vzc2Z1bGx5IFVuc3Vic2NyaWJlZCBUb3BpY1wiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwidW5zdWJzY3JpYmVcIiwgcGFyYW1zOiB7IHRvcGljOiBlLCBpZDogdCwgb3B0czogcyB9IH0pO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIHRocm93IHRoaXMubG9nZ2VyLmRlYnVnKFwiRmFpbGVkIHRvIFVuc3Vic2NyaWJlIFRvcGljXCIpLCB0aGlzLmxvZ2dlci5lcnJvcihyKSwgcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcnBjU3Vic2NyaWJlKGUsIHQpIHtcbiAgICBjb25zdCBzID0geyBtZXRob2Q6IFZzKHQucHJvdG9jb2wpLnN1YnNjcmliZSwgcGFyYW1zOiB7IHRvcGljOiBlIH0gfTtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIk91dGdvaW5nIFJlbGF5IFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJwYXlsb2FkXCIsIGRpcmVjdGlvbjogXCJvdXRnb2luZ1wiLCByZXF1ZXN0OiBzIH0pO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhd2FpdCBlcih0aGlzLnJlbGF5ZXIucmVxdWVzdChzKSwgdGhpcy5zdWJzY3JpYmVUaW1lb3V0KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiT3V0Z29pbmcgUmVsYXkgU3Vic2NyaWJlIFBheWxvYWQgc3RhbGxlZFwiKSwgdGhpcy5yZWxheWVyLmV2ZW50cy5lbWl0KEhlLmNvbm5lY3Rpb25fc3RhbGxlZCk7XG4gICAgfVxuICAgIHJldHVybiBVaShlICsgdGhpcy5jbGllbnRJZCk7XG4gIH1cbiAgYXN5bmMgcnBjQmF0Y2hTdWJzY3JpYmUoZSkge1xuICAgIGlmICghZS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGVbMF0ucmVsYXksIHMgPSB7IG1ldGhvZDogVnModC5wcm90b2NvbCkuYmF0Y2hTdWJzY3JpYmUsIHBhcmFtczogeyB0b3BpY3M6IGUubWFwKChyKSA9PiByLnRvcGljKSB9IH07XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJPdXRnb2luZyBSZWxheSBQYXlsb2FkXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwicGF5bG9hZFwiLCBkaXJlY3Rpb246IFwib3V0Z29pbmdcIiwgcmVxdWVzdDogcyB9KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGF3YWl0IGVyKHRoaXMucmVsYXllci5yZXF1ZXN0KHMpLCB0aGlzLnN1YnNjcmliZVRpbWVvdXQpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJPdXRnb2luZyBSZWxheSBQYXlsb2FkIHN0YWxsZWRcIiksIHRoaXMucmVsYXllci5ldmVudHMuZW1pdChIZS5jb25uZWN0aW9uX3N0YWxsZWQpO1xuICAgIH1cbiAgfVxuICBycGNVbnN1YnNjcmliZShlLCB0LCBzKSB7XG4gICAgY29uc3QgciA9IHsgbWV0aG9kOiBWcyhzLnByb3RvY29sKS51bnN1YnNjcmliZSwgcGFyYW1zOiB7IHRvcGljOiBlLCBpZDogdCB9IH07XG4gICAgcmV0dXJuIHRoaXMubG9nZ2VyLmRlYnVnKFwiT3V0Z29pbmcgUmVsYXkgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcInBheWxvYWRcIiwgZGlyZWN0aW9uOiBcIm91dGdvaW5nXCIsIHJlcXVlc3Q6IHIgfSksIHRoaXMucmVsYXllci5yZXF1ZXN0KHIpO1xuICB9XG4gIG9uU3Vic2NyaWJlKGUsIHQpIHtcbiAgICB0aGlzLnNldFN1YnNjcmlwdGlvbihlLCAkcihycyh7fSwgdCksIHsgaWQ6IGUgfSkpLCB0aGlzLnBlbmRpbmcuZGVsZXRlKHQudG9waWMpO1xuICB9XG4gIG9uQmF0Y2hTdWJzY3JpYmUoZSkge1xuICAgIGUubGVuZ3RoICYmIGUuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdWJzY3JpcHRpb24odC5pZCwgcnMoe30sIHQpKSwgdGhpcy5wZW5kaW5nLmRlbGV0ZSh0LnRvcGljKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBvblVuc3Vic2NyaWJlKGUsIHQsIHMpIHtcbiAgICB0aGlzLmV2ZW50cy5yZW1vdmVBbGxMaXN0ZW5lcnModCksIHRoaXMuaGFzU3Vic2NyaXB0aW9uKHQsIGUpICYmIHRoaXMuZGVsZXRlU3Vic2NyaXB0aW9uKHQsIHMpLCBhd2FpdCB0aGlzLnJlbGF5ZXIubWVzc2FnZXMuZGVsKGUpO1xuICB9XG4gIGFzeW5jIHNldFJlbGF5ZXJTdWJzY3JpcHRpb25zKGUpIHtcbiAgICBhd2FpdCB0aGlzLnJlbGF5ZXIuY29yZS5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBlKTtcbiAgfVxuICBhc3luYyBnZXRSZWxheWVyU3Vic2NyaXB0aW9ucygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWxheWVyLmNvcmUuc3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gIH1cbiAgc2V0U3Vic2NyaXB0aW9uKGUsIHQpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuaGFzKGUpIHx8ICh0aGlzLmxvZ2dlci5kZWJ1ZyhcIlNldHRpbmcgc3Vic2NyaXB0aW9uXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJzZXRTdWJzY3JpcHRpb25cIiwgaWQ6IGUsIHN1YnNjcmlwdGlvbjogdCB9KSwgdGhpcy5hZGRTdWJzY3JpcHRpb24oZSwgdCkpO1xuICB9XG4gIGFkZFN1YnNjcmlwdGlvbihlLCB0KSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChlLCBycyh7fSwgdCkpLCB0aGlzLnRvcGljTWFwLnNldCh0LnRvcGljLCBlKSwgdGhpcy5ldmVudHMuZW1pdChCdC5jcmVhdGVkLCB0KTtcbiAgfVxuICBnZXRTdWJzY3JpcHRpb24oZSkge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiR2V0dGluZyBzdWJzY3JpcHRpb25cIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcImdldFN1YnNjcmlwdGlvblwiLCBpZDogZSB9KTtcbiAgICBjb25zdCB0ID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChlKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogcyB9ID0gSihcIk5PX01BVENISU5HX0tFWVwiLCBgJHt0aGlzLm5hbWV9OiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iocyk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIGRlbGV0ZVN1YnNjcmlwdGlvbihlLCB0KSB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXCJEZWxldGluZyBzdWJzY3JpcHRpb25cIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcImRlbGV0ZVN1YnNjcmlwdGlvblwiLCBpZDogZSwgcmVhc29uOiB0IH0pO1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldFN1YnNjcmlwdGlvbihlKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKGUpLCB0aGlzLnRvcGljTWFwLmRlbGV0ZShzLnRvcGljLCBlKSwgdGhpcy5ldmVudHMuZW1pdChCdC5kZWxldGVkLCAkcihycyh7fSwgcyksIHsgcmVhc29uOiB0IH0pKTtcbiAgfVxuICBhc3luYyBwZXJzaXN0KCkge1xuICAgIGF3YWl0IHRoaXMuc2V0UmVsYXllclN1YnNjcmlwdGlvbnModGhpcy52YWx1ZXMpLCB0aGlzLmV2ZW50cy5lbWl0KEJ0LnN5bmMpO1xuICB9XG4gIGFzeW5jIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLmNhY2hlZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGUgPSBNYXRoLmNlaWwodGhpcy5jYWNoZWQubGVuZ3RoIC8gdGhpcy5iYXRjaFN1YnNjcmliZVRvcGljc0xpbWl0KTtcbiAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZTsgdCsrKSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLmNhY2hlZC5zcGxpY2UoMCwgdGhpcy5iYXRjaFN1YnNjcmliZVRvcGljc0xpbWl0KTtcbiAgICAgICAgYXdhaXQgdGhpcy5iYXRjaFN1YnNjcmliZShzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ldmVudHMuZW1pdChCdC5yZXN1YnNjcmliZWQpO1xuICB9XG4gIGFzeW5jIHJlc3RvcmUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmdldFJlbGF5ZXJTdWJzY3JpcHRpb25zKCk7XG4gICAgICBpZiAodHlwZW9mIGUgPiBcInVcIiB8fCAhZS5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMuc2l6ZSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IEooXCJSRVNUT1JFX1dJTExfT1ZFUlJJREVcIiwgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3IodCksIHRoaXMubG9nZ2VyLmVycm9yKGAke3RoaXMubmFtZX06ICR7SlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZXMpfWApLCBuZXcgRXJyb3IodCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlZCA9IGUsIHRoaXMubG9nZ2VyLmRlYnVnKGBTdWNjZXNzZnVsbHkgUmVzdG9yZWQgc3Vic2NyaXB0aW9ucyBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInJlc3RvcmVcIiwgc3Vic2NyaXB0aW9uczogdGhpcy52YWx1ZXMgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBSZXN0b3JlIHN1YnNjcmlwdGlvbnMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci5lcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYmF0Y2hTdWJzY3JpYmUoZSkge1xuICAgIGlmICghZS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGF3YWl0IHRoaXMucnBjQmF0Y2hTdWJzY3JpYmUoZSk7XG4gICAgRHModCkgJiYgdGhpcy5vbkJhdGNoU3Vic2NyaWJlKHQubWFwKChzLCByKSA9PiAkcihycyh7fSwgZVtyXSksIHsgaWQ6IHMgfSkpKTtcbiAgfVxuICBhc3luYyBvbkNvbm5lY3QoKSB7XG4gICAgdGhpcy5yZXN0YXJ0SW5Qcm9ncmVzcyB8fCAoYXdhaXQgdGhpcy5yZXN0YXJ0KCksIHRoaXMub25FbmFibGUoKSk7XG4gIH1cbiAgb25EaXNjb25uZWN0KCkge1xuICAgIHRoaXMub25EaXNhYmxlKCk7XG4gIH1cbiAgYXN5bmMgY2hlY2tQZW5kaW5nKCkge1xuICAgIGlmICh0aGlzLnJlbGF5ZXIudHJhbnNwb3J0RXhwbGljaXRseUNsb3NlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gW107XG4gICAgdGhpcy5wZW5kaW5nLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGUucHVzaCh0KTtcbiAgICB9KSwgYXdhaXQgdGhpcy5iYXRjaFN1YnNjcmliZShlKTtcbiAgfVxuICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMucmVsYXllci5jb3JlLmhlYXJ0YmVhdC5vbihXdC5IRUFSVEJFQVRfRVZFTlRTLnB1bHNlLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLmNoZWNrUGVuZGluZygpO1xuICAgIH0pLCB0aGlzLnJlbGF5ZXIub24oSGUuY29ubmVjdCwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5vbkNvbm5lY3QoKTtcbiAgICB9KSwgdGhpcy5yZWxheWVyLm9uKEhlLmRpc2Nvbm5lY3QsICgpID0+IHtcbiAgICAgIHRoaXMub25EaXNjb25uZWN0KCk7XG4gICAgfSksIHRoaXMuZXZlbnRzLm9uKEJ0LmNyZWF0ZWQsIGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gQnQuY3JlYXRlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCBkYXRhOiBlIH0pLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KSwgdGhpcy5ldmVudHMub24oQnQuZGVsZXRlZCwgYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBCdC5kZWxldGVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIGRhdGE6IGUgfSksIGF3YWl0IHRoaXMucGVyc2lzdCgpO1xuICAgIH0pO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IEooXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVzdGFydFRvQ29tcGxldGUoKSB7XG4gICAgdGhpcy5yZXN0YXJ0SW5Qcm9ncmVzcyAmJiBhd2FpdCBuZXcgUHJvbWlzZSgoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0SW5Qcm9ncmVzcyB8fCAoY2xlYXJJbnRlcnZhbCh0KSwgZSgpKTtcbiAgICAgIH0sIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICB9KTtcbiAgfVxufVxudmFyIGZ2ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBVYSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIHB2ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgZ3YgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBMYSA9IChpLCBlLCB0KSA9PiBlIGluIGkgPyBmdihpLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaVtlXSA9IHQsIHl2ID0gKGksIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIHB2LmNhbGwoZSwgdCkgJiYgTGEoaSwgdCwgZVt0XSk7XG4gIGlmIChVYSlcbiAgICBmb3IgKHZhciB0IG9mIFVhKGUpKVxuICAgICAgZ3YuY2FsbChlLCB0KSAmJiBMYShpLCB0LCBlW3RdKTtcbiAgcmV0dXJuIGk7XG59O1xuY2xhc3MgbXYgZXh0ZW5kcyBVbSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKSwgdGhpcy5wcm90b2NvbCA9IFwid2NcIiwgdGhpcy52ZXJzaW9uID0gMiwgdGhpcy5ldmVudHMgPSBuZXcgV2UuRXZlbnRFbWl0dGVyKCksIHRoaXMubmFtZSA9IHowLCB0aGlzLnRyYW5zcG9ydEV4cGxpY2l0bHlDbG9zZWQgPSAhMSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnJlY29ubmVjdGluZyA9ICExLCB0aGlzLmNvbm5lY3Rpb25TdGF0dXNQb2xsaW5nSW50ZXJ2YWwgPSAyMCwgdGhpcy5zdGFsZUNvbm5lY3Rpb25FcnJvcnMgPSBbXCJzb2NrZXQgaGFuZyB1cFwiLCBcInNvY2tldCBzdGFsbGVkXCJdLCB0aGlzLnJlcXVlc3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJQdWJsaXNoaW5nIFJlcXVlc3QgUGF5bG9hZFwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRvRXN0YWJsaXNoQ29ubmVjdGlvbigpLCBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3QodCk7XG4gICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmRlYnVnKFwiRmFpbGVkIHRvIFB1Ymxpc2ggUmVxdWVzdFwiKSwgdGhpcy5sb2dnZXIuZXJyb3IocyksIHM7XG4gICAgICB9XG4gICAgfSwgdGhpcy5jb3JlID0gZS5jb3JlLCB0aGlzLmxvZ2dlciA9IHR5cGVvZiBlLmxvZ2dlciA8IFwidVwiICYmIHR5cGVvZiBlLmxvZ2dlciAhPSBcInN0cmluZ1wiID8gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcihlLmxvZ2dlciwgdGhpcy5uYW1lKSA6IGVlLnBpbm8oZWUuZ2V0RGVmYXVsdExvZ2dlck9wdGlvbnMoeyBsZXZlbDogZS5sb2dnZXIgfHwgajAgfSkpLCB0aGlzLm1lc3NhZ2VzID0gbmV3IHJ2KHRoaXMubG9nZ2VyLCBlLmNvcmUpLCB0aGlzLnN1YnNjcmliZXIgPSBuZXcgZHYodGhpcywgdGhpcy5sb2dnZXIpLCB0aGlzLnB1Ymxpc2hlciA9IG5ldyBudih0aGlzLCB0aGlzLmxvZ2dlciksIHRoaXMucmVsYXlVcmwgPSBlPy5yZWxheVVybCB8fCBxaCwgdGhpcy5wcm9qZWN0SWQgPSBlLnByb2plY3RJZCwgdGhpcy5wcm92aWRlciA9IHt9O1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKSwgYXdhaXQgdGhpcy5jcmVhdGVQcm92aWRlcigpLCBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5tZXNzYWdlcy5pbml0KCksIHRoaXMudHJhbnNwb3J0T3BlbigpLCB0aGlzLnN1YnNjcmliZXIuaW5pdCgpXSksIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLmluaXRpYWxpemVkID0gITAsIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5zdWJzY3JpYmVyLnRvcGljcy5sZW5ndGggPT09IDAgJiYgKHRoaXMubG9nZ2VyLmluZm8oXCJObyB0b3BpY3Mgc3Vic2NyaWJ0ZWQgdG8gYWZ0ZXIgaW5pdCwgY2xvc2luZyB0cmFuc3BvcnRcIiksIGF3YWl0IHRoaXMudHJhbnNwb3J0Q2xvc2UoKSwgdGhpcy50cmFuc3BvcnRFeHBsaWNpdGx5Q2xvc2VkID0gITEpO1xuICAgIH0sIGswKTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5jb25uZWN0aW9uLmNvbm5lY3RlZDtcbiAgfVxuICBnZXQgY29ubmVjdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5jb25uZWN0aW9uLmNvbm5lY3Rpbmc7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChlLCB0LCBzKSB7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMucHVibGlzaGVyLnB1Ymxpc2goZSwgdCwgcyksIGF3YWl0IHRoaXMucmVjb3JkTWVzc2FnZUV2ZW50KHsgdG9waWM6IGUsIG1lc3NhZ2U6IHQsIHB1Ymxpc2hlZEF0OiBEYXRlLm5vdygpIH0pO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZShlLCB0KSB7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgbGV0IHMgPSBcIlwiO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChbbmV3IFByb21pc2UoKHIpID0+IHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlci5vbmNlKEJ0LmNyZWF0ZWQsIChuKSA9PiB7XG4gICAgICAgIG4udG9waWMgPT09IGUgJiYgcigpO1xuICAgICAgfSk7XG4gICAgfSksIG5ldyBQcm9taXNlKGFzeW5jIChyKSA9PiB7XG4gICAgICBzID0gYXdhaXQgdGhpcy5zdWJzY3JpYmVyLnN1YnNjcmliZShlLCB0KSwgcigpO1xuICAgIH0pXSksIHM7XG4gIH1cbiAgYXN5bmMgdW5zdWJzY3JpYmUoZSwgdCkge1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLnN1YnNjcmliZXIudW5zdWJzY3JpYmUoZSwgdCk7XG4gIH1cbiAgb24oZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uKGUsIHQpO1xuICB9XG4gIG9uY2UoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9uY2UoZSwgdCk7XG4gIH1cbiAgb2ZmKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50cy5vZmYoZSwgdCk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGUsIHQpO1xuICB9XG4gIGFzeW5jIHRyYW5zcG9ydENsb3NlKCkge1xuICAgIHRoaXMudHJhbnNwb3J0RXhwbGljaXRseUNsb3NlZCA9ICEwLCB0aGlzLmNvbm5lY3RlZCAmJiAoYXdhaXQgdGhpcy5wcm92aWRlci5kaXNjb25uZWN0KCksIHRoaXMuZXZlbnRzLmVtaXQoSGUudHJhbnNwb3J0X2Nsb3NlZCkpO1xuICB9XG4gIGFzeW5jIHRyYW5zcG9ydE9wZW4oZSkge1xuICAgIGlmICh0aGlzLnRyYW5zcG9ydEV4cGxpY2l0bHlDbG9zZWQgPSAhMSwgIXRoaXMucmVjb25uZWN0aW5nKSB7XG4gICAgICB0aGlzLnJlbGF5VXJsID0gZSB8fCB0aGlzLnJlbGF5VXJsLCB0aGlzLnJlY29ubmVjdGluZyA9ICEwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW25ldyBQcm9taXNlKCh0KSA9PiB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCB0KCksIHRoaXMuc3Vic2NyaWJlci5vbmNlKEJ0LnJlc3Vic2NyaWJlZCwgKCkgPT4ge1xuICAgICAgICAgICAgdCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgYXdhaXQgUHJvbWlzZS5yYWNlKFtuZXcgUHJvbWlzZShhc3luYyAodCwgcykgPT4ge1xuICAgICAgICAgIGF3YWl0IGVyKHRoaXMucHJvdmlkZXIuY29ubmVjdCgpLCA1ZTMsIFwic29ja2V0IHN0YWxsZWRcIikuY2F0Y2goKHIpID0+IHMocikpLnRoZW4oKCkgPT4gdCgpKS5maW5hbGx5KCgpID0+IHRoaXMucmVtb3ZlTGlzdGVuZXIoSGUudHJhbnNwb3J0X2Nsb3NlZCwgdGhpcy5yZWplY3RUcmFuc3BvcnRPcGVuKSk7XG4gICAgICAgIH0pLCBuZXcgUHJvbWlzZSgodCkgPT4gdGhpcy5vbmNlKEhlLnRyYW5zcG9ydF9jbG9zZWQsIHRoaXMucmVqZWN0VHJhbnNwb3J0T3BlbikpXSldKTtcbiAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IodCk7XG4gICAgICAgIGNvbnN0IHMgPSB0O1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0aW9uU3RhbGxlZChzLm1lc3NhZ2UpKVxuICAgICAgICAgIHRocm93IHQ7XG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoSGUudHJhbnNwb3J0X2Nsb3NlZCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdGluZyA9ICExO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyByZXN0YXJ0VHJhbnNwb3J0KGUpIHtcbiAgICB0aGlzLnRyYW5zcG9ydEV4cGxpY2l0bHlDbG9zZWQgfHwgKHRoaXMucmVsYXlVcmwgPSBlIHx8IHRoaXMucmVsYXlVcmwsIHRoaXMuY29ubmVjdGVkICYmIGF3YWl0IFByb21pc2UuYWxsKFtuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgdGhpcy5wcm92aWRlci5vbmNlKGlzLmRpc2Nvbm5lY3QsICgpID0+IHtcbiAgICAgICAgdCgpO1xuICAgICAgfSk7XG4gICAgfSksIHRoaXMudHJhbnNwb3J0Q2xvc2UoKV0pLCBhd2FpdCB0aGlzLmNyZWF0ZVByb3ZpZGVyKCksIGF3YWl0IHRoaXMudHJhbnNwb3J0T3BlbigpKTtcbiAgfVxuICBpc0Nvbm5lY3Rpb25TdGFsbGVkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFsZUNvbm5lY3Rpb25FcnJvcnMuc29tZSgodCkgPT4gZS5pbmNsdWRlcyh0KSk7XG4gIH1cbiAgcmVqZWN0VHJhbnNwb3J0T3BlbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbG9zZVRyYW5zcG9ydCBjYWxsZWQgYmVmb3JlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkXCIpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVByb3ZpZGVyKCkge1xuICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmNvcmUuY3J5cHRvLnNpZ25KV1QodGhpcy5yZWxheVVybCk7XG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBfbihuZXcgV2MobWIoeyBzZGtWZXJzaW9uOiBCMCwgcHJvdG9jb2w6IHRoaXMucHJvdG9jb2wsIHZlcnNpb246IHRoaXMudmVyc2lvbiwgcmVsYXlVcmw6IHRoaXMucmVsYXlVcmwsIHByb2plY3RJZDogdGhpcy5wcm9qZWN0SWQsIGF1dGg6IGUsIHVzZU9uQ2xvc2VFdmVudDogITAgfSkpKSwgdGhpcy5yZWdpc3RlclByb3ZpZGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgYXN5bmMgcmVjb3JkTWVzc2FnZUV2ZW50KGUpIHtcbiAgICBjb25zdCB7IHRvcGljOiB0LCBtZXNzYWdlOiBzIH0gPSBlO1xuICAgIGF3YWl0IHRoaXMubWVzc2FnZXMuc2V0KHQsIHMpO1xuICB9XG4gIGFzeW5jIHNob3VsZElnbm9yZU1lc3NhZ2VFdmVudChlKSB7XG4gICAgY29uc3QgeyB0b3BpYzogdCwgbWVzc2FnZTogcyB9ID0gZTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zdWJzY3JpYmVyLmlzU3Vic2NyaWJlZCh0KSA/IHRoaXMubWVzc2FnZXMuaGFzKHQsIHMpIDogITA7XG4gIH1cbiAgYXN5bmMgb25Qcm92aWRlclBheWxvYWQoZSkge1xuICAgIGlmICh0aGlzLmxvZ2dlci5kZWJ1ZyhcIkluY29taW5nIFJlbGF5IFBheWxvYWRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJwYXlsb2FkXCIsIGRpcmVjdGlvbjogXCJpbmNvbWluZ1wiLCBwYXlsb2FkOiBlIH0pLCBqaShlKSkge1xuICAgICAgaWYgKCFlLm1ldGhvZC5lbmRzV2l0aChLMCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHQgPSBlLnBhcmFtcywgeyB0b3BpYzogcywgbWVzc2FnZTogciwgcHVibGlzaGVkQXQ6IG4gfSA9IHQuZGF0YSwgbyA9IHsgdG9waWM6IHMsIG1lc3NhZ2U6IHIsIHB1Ymxpc2hlZEF0OiBuIH07XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkVtaXR0aW5nIFJlbGF5ZXIgUGF5bG9hZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeXYoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LmlkIH0sIG8pKSwgdGhpcy5ldmVudHMuZW1pdCh0LmlkLCBvKSwgYXdhaXQgdGhpcy5hY2tub3dsZWRnZVBheWxvYWQoZSksIGF3YWl0IHRoaXMub25NZXNzYWdlRXZlbnQobyk7XG4gICAgfSBlbHNlXG4gICAgICBPaShlKSAmJiB0aGlzLmV2ZW50cy5lbWl0KEhlLm1lc3NhZ2VfYWNrLCBlKTtcbiAgfVxuICBhc3luYyBvbk1lc3NhZ2VFdmVudChlKSB7XG4gICAgYXdhaXQgdGhpcy5zaG91bGRJZ25vcmVNZXNzYWdlRXZlbnQoZSkgfHwgKHRoaXMuZXZlbnRzLmVtaXQoSGUubWVzc2FnZSwgZSksIGF3YWl0IHRoaXMucmVjb3JkTWVzc2FnZUV2ZW50KGUpKTtcbiAgfVxuICBhc3luYyBhY2tub3dsZWRnZVBheWxvYWQoZSkge1xuICAgIGNvbnN0IHQgPSB4aShlLmlkLCAhMCk7XG4gICAgYXdhaXQgdGhpcy5wcm92aWRlci5jb25uZWN0aW9uLnNlbmQodCk7XG4gIH1cbiAgcmVnaXN0ZXJQcm92aWRlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLnByb3ZpZGVyLm9uKGlzLnBheWxvYWQsIChlKSA9PiB0aGlzLm9uUHJvdmlkZXJQYXlsb2FkKGUpKSwgdGhpcy5wcm92aWRlci5vbihpcy5jb25uZWN0LCAoKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5lbWl0KEhlLmNvbm5lY3QpO1xuICAgIH0pLCB0aGlzLnByb3ZpZGVyLm9uKGlzLmRpc2Nvbm5lY3QsICgpID0+IHtcbiAgICAgIHRoaXMub25Qcm92aWRlckRpc2Nvbm5lY3QoKTtcbiAgICB9KSwgdGhpcy5wcm92aWRlci5vbihpcy5lcnJvciwgKGUpID0+IHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUpLCB0aGlzLmV2ZW50cy5lbWl0KEhlLmVycm9yLCBlKTtcbiAgICB9KTtcbiAgfVxuICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZXZlbnRzLm9uKEhlLmNvbm5lY3Rpb25fc3RhbGxlZCwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VHJhbnNwb3J0KCk7XG4gICAgfSk7XG4gIH1cbiAgb25Qcm92aWRlckRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5ldmVudHMuZW1pdChIZS5kaXNjb25uZWN0KSwgdGhpcy5hdHRlbXB0VG9SZWNvbm5lY3QoKTtcbiAgfVxuICBhdHRlbXB0VG9SZWNvbm5lY3QoKSB7XG4gICAgdGhpcy50cmFuc3BvcnRFeHBsaWNpdGx5Q2xvc2VkIHx8IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VHJhbnNwb3J0KCk7XG4gICAgfSwgVi50b01pbGlzZWNvbmRzKFYwKSk7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gSihcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBhc3luYyB0b0VzdGFibGlzaENvbm5lY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGluZylcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkICYmIChjbGVhckludGVydmFsKHQpLCBlKCkpO1xuICAgICAgICAgIH0sIHRoaXMuY29ubmVjdGlvblN0YXR1c1BvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VHJhbnNwb3J0KCk7XG4gICAgfVxuICB9XG59XG52YXIgYnYgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIE1hID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgd3YgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCB2diA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIHFhID0gKGksIGUsIHQpID0+IGUgaW4gaSA/IGJ2KGksIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBpW2VdID0gdCwgamEgPSAoaSwgZSkgPT4ge1xuICBmb3IgKHZhciB0IGluIGUgfHwgKGUgPSB7fSkpXG4gICAgd3YuY2FsbChlLCB0KSAmJiBxYShpLCB0LCBlW3RdKTtcbiAgaWYgKE1hKVxuICAgIGZvciAodmFyIHQgb2YgTWEoZSkpXG4gICAgICB2di5jYWxsKGUsIHQpICYmIHFhKGksIHQsIGVbdF0pO1xuICByZXR1cm4gaTtcbn07XG5jbGFzcyBwciBleHRlbmRzIExtIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcywgciA9IHVpLCBuID0gdm9pZCAwKSB7XG4gICAgc3VwZXIoZSwgdCwgcywgciksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5uYW1lID0gcywgdGhpcy5tYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnZlcnNpb24gPSBIMCwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSB1aSwgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAodGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKSwgYXdhaXQgdGhpcy5yZXN0b3JlKCksIHRoaXMuY2FjaGVkLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgdGhpcy5nZXRLZXkgJiYgbyAhPT0gbnVsbCAmJiAhd3QobykgPyB0aGlzLm1hcC5zZXQodGhpcy5nZXRLZXkobyksIG8pIDogcWIobykgPyB0aGlzLm1hcC5zZXQoby5pZCwgbykgOiBqYihvKSAmJiB0aGlzLm1hcC5zZXQoby50b3BpYywgbyk7XG4gICAgICB9KSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5pbml0aWFsaXplZCA9ICEwKTtcbiAgICB9LCB0aGlzLnNldCA9IGFzeW5jIChvLCBjKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5tYXAuaGFzKG8pID8gYXdhaXQgdGhpcy51cGRhdGUobywgYykgOiAodGhpcy5sb2dnZXIuZGVidWcoXCJTZXR0aW5nIHZhbHVlXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJzZXRcIiwga2V5OiBvLCB2YWx1ZTogYyB9KSwgdGhpcy5tYXAuc2V0KG8sIGMpLCBhd2FpdCB0aGlzLnBlcnNpc3QoKSk7XG4gICAgfSwgdGhpcy5nZXQgPSAobykgPT4gKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkdldHRpbmcgdmFsdWVcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcImdldFwiLCBrZXk6IG8gfSksIHRoaXMuZ2V0RGF0YShvKSksIHRoaXMuZ2V0QWxsID0gKG8pID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgbyA/IHRoaXMudmFsdWVzLmZpbHRlcigoYykgPT4gT2JqZWN0LmtleXMobykuZXZlcnkoKHUpID0+IFljKGNbdV0sIG9bdV0pKSkgOiB0aGlzLnZhbHVlcyksIHRoaXMudXBkYXRlID0gYXN5bmMgKG8sIGMpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlVwZGF0aW5nIHZhbHVlXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJ1cGRhdGVcIiwga2V5OiBvLCB1cGRhdGU6IGMgfSk7XG4gICAgICBjb25zdCB1ID0gamEoamEoe30sIHRoaXMuZ2V0RGF0YShvKSksIGMpO1xuICAgICAgdGhpcy5tYXAuc2V0KG8sIHUpLCBhd2FpdCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9LCB0aGlzLmRlbGV0ZSA9IGFzeW5jIChvLCBjKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5tYXAuaGFzKG8pICYmICh0aGlzLmxvZ2dlci5kZWJ1ZyhcIkRlbGV0aW5nIHZhbHVlXCIpLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJkZWxldGVcIiwga2V5OiBvLCByZWFzb246IGMgfSksIHRoaXMubWFwLmRlbGV0ZShvKSwgYXdhaXQgdGhpcy5wZXJzaXN0KCkpO1xuICAgIH0sIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLnN0b3JhZ2VQcmVmaXggPSByLCB0aGlzLmdldEtleSA9IG47XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGVlLmdldExvZ2dlckNvbnRleHQodGhpcy5sb2dnZXIpO1xuICB9XG4gIGdldCBzdG9yYWdlS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQcmVmaXggKyB0aGlzLnZlcnNpb24gKyBcIi8vXCIgKyB0aGlzLm5hbWU7XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuc2l6ZTtcbiAgfVxuICBnZXQga2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm1hcC5rZXlzKCkpO1xuICB9XG4gIGdldCB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tYXAudmFsdWVzKCkpO1xuICB9XG4gIGFzeW5jIHNldERhdGFTdG9yZShlKSB7XG4gICAgYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIGUpO1xuICB9XG4gIGFzeW5jIGdldERhdGFTdG9yZSgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb3JlLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICB9XG4gIGdldERhdGEoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm1hcC5nZXQoZSk7XG4gICAgaWYgKCF0KSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHMgfSA9IEooXCJOT19NQVRDSElOR19LRVlcIiwgYCR7dGhpcy5uYW1lfTogJHtlfWApO1xuICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3IocyksIG5ldyBFcnJvcihzKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldERhdGFTdG9yZSh0aGlzLnZhbHVlcyk7XG4gIH1cbiAgYXN5bmMgcmVzdG9yZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuZ2V0RGF0YVN0b3JlKCk7XG4gICAgICBpZiAodHlwZW9mIGUgPiBcInVcIiB8fCAhZS5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzLm1hcC5zaXplKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gSihcIlJFU1RPUkVfV0lMTF9PVkVSUklERVwiLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcih0KSwgbmV3IEVycm9yKHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZWQgPSBlLCB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IFJlc3RvcmVkIHZhbHVlIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwicmVzdG9yZVwiLCB2YWx1ZTogdGhpcy52YWx1ZXMgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBSZXN0b3JlIHZhbHVlIGZvciAke3RoaXMubmFtZX1gKSwgdGhpcy5sb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IEooXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIF92IHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5uYW1lID0gSjAsIHRoaXMudmVyc2lvbiA9IFEwLCB0aGlzLmV2ZW50cyA9IG5ldyBpcigpLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuc3RvcmFnZVByZWZpeCA9IHVpLCB0aGlzLmlnbm9yZWRQYXlsb2FkVHlwZXMgPSBbTmldLCB0aGlzLnJlZ2lzdGVyZWRNZXRob2RzID0gW10sIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgKGF3YWl0IHRoaXMucGFpcmluZ3MuaW5pdCgpLCBhd2FpdCB0aGlzLmNsZWFudXAoKSwgdGhpcy5yZWdpc3RlclJlbGF5ZXJFdmVudHMoKSwgdGhpcy5yZWdpc3RlckV4cGlyZXJFdmVudHMoKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwLCB0aGlzLmxvZ2dlci50cmFjZShcIkluaXRpYWxpemVkXCIpKTtcbiAgICB9LCB0aGlzLnJlZ2lzdGVyID0gKHsgbWV0aG9kczogcyB9KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5yZWdpc3RlcmVkTWV0aG9kcyA9IFsuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4udGhpcy5yZWdpc3RlcmVkTWV0aG9kcywgLi4uc10pXTtcbiAgICB9LCB0aGlzLmNyZWF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgcyA9IFhyKCksIHIgPSBhd2FpdCB0aGlzLmNvcmUuY3J5cHRvLnNldFN5bUtleShzKSwgbiA9IEh0KFYuRklWRV9NSU5VVEVTKSwgbyA9IHsgcHJvdG9jb2w6IE1oIH0sIGMgPSB7IHRvcGljOiByLCBleHBpcnk6IG4sIHJlbGF5OiBvLCBhY3RpdmU6ICExIH0sIHUgPSBQYih7IHByb3RvY29sOiB0aGlzLmNvcmUucHJvdG9jb2wsIHZlcnNpb246IHRoaXMuY29yZS52ZXJzaW9uLCB0b3BpYzogciwgc3ltS2V5OiBzLCByZWxheTogbyB9KTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBhaXJpbmdzLnNldChyLCBjKSwgYXdhaXQgdGhpcy5jb3JlLnJlbGF5ZXIuc3Vic2NyaWJlKHIpLCB0aGlzLmNvcmUuZXhwaXJlci5zZXQociwgbiksIHsgdG9waWM6IHIsIHVyaTogdSB9O1xuICAgIH0sIHRoaXMucGFpciA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5pc1ZhbGlkUGFpcihzKTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHIsIHN5bUtleTogbiwgcmVsYXk6IG8gfSA9IHhiKHMudXJpKTtcbiAgICAgIGlmICh0aGlzLnBhaXJpbmdzLmtleXMuaW5jbHVkZXMocikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFpcmluZyBhbHJlYWR5IGV4aXN0czogJHtyfWApO1xuICAgICAgaWYgKHRoaXMuY29yZS5jcnlwdG8uaGFzS2V5cyhyKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXljaGFpbiBhbHJlYWR5IGV4aXN0czogJHtyfWApO1xuICAgICAgY29uc3QgYyA9IEh0KFYuRklWRV9NSU5VVEVTKSwgdSA9IHsgdG9waWM6IHIsIHJlbGF5OiBvLCBleHBpcnk6IGMsIGFjdGl2ZTogITEgfTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBhaXJpbmdzLnNldChyLCB1KSwgYXdhaXQgdGhpcy5jb3JlLmNyeXB0by5zZXRTeW1LZXkobiwgciksIGF3YWl0IHRoaXMuY29yZS5yZWxheWVyLnN1YnNjcmliZShyLCB7IHJlbGF5OiBvIH0pLCB0aGlzLmNvcmUuZXhwaXJlci5zZXQociwgYyksIHMuYWN0aXZhdGVQYWlyaW5nICYmIGF3YWl0IHRoaXMuYWN0aXZhdGUoeyB0b3BpYzogciB9KSwgdTtcbiAgICB9LCB0aGlzLmFjdGl2YXRlID0gYXN5bmMgKHsgdG9waWM6IHMgfSkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCByID0gSHQoVi5USElSVFlfREFZUyk7XG4gICAgICBhd2FpdCB0aGlzLnBhaXJpbmdzLnVwZGF0ZShzLCB7IGFjdGl2ZTogITAsIGV4cGlyeTogciB9KSwgdGhpcy5jb3JlLmV4cGlyZXIuc2V0KHMsIHIpO1xuICAgIH0sIHRoaXMucGluZyA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkUGluZyhzKTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHIgfSA9IHM7XG4gICAgICBpZiAodGhpcy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHIpKSB7XG4gICAgICAgIGNvbnN0IG4gPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHIsIFwid2NfcGFpcmluZ1BpbmdcIiwge30pLCB7IGRvbmU6IG8sIHJlc29sdmU6IGMsIHJlamVjdDogdSB9ID0gVGkoKTtcbiAgICAgICAgdGhpcy5ldmVudHMub25jZShrZShcInBhaXJpbmdfcGluZ1wiLCBuKSwgKHsgZXJyb3I6IGQgfSkgPT4ge1xuICAgICAgICAgIGQgPyB1KGQpIDogYygpO1xuICAgICAgICB9KSwgYXdhaXQgbygpO1xuICAgICAgfVxuICAgIH0sIHRoaXMudXBkYXRlRXhwaXJ5ID0gYXN5bmMgKHsgdG9waWM6IHMsIGV4cGlyeTogciB9KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5wYWlyaW5ncy51cGRhdGUocywgeyBleHBpcnk6IHIgfSk7XG4gICAgfSwgdGhpcy51cGRhdGVNZXRhZGF0YSA9IGFzeW5jICh7IHRvcGljOiBzLCBtZXRhZGF0YTogciB9KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5wYWlyaW5ncy51cGRhdGUocywgeyBwZWVyTWV0YWRhdGE6IHIgfSk7XG4gICAgfSwgdGhpcy5nZXRQYWlyaW5ncyA9ICgpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5wYWlyaW5ncy52YWx1ZXMpLCB0aGlzLmRpc2Nvbm5lY3QgPSBhc3luYyAocykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZERpc2Nvbm5lY3Qocyk7XG4gICAgICBjb25zdCB7IHRvcGljOiByIH0gPSBzO1xuICAgICAgdGhpcy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHIpICYmIChhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHIsIFwid2NfcGFpcmluZ0RlbGV0ZVwiLCBKZShcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgYXdhaXQgdGhpcy5kZWxldGVQYWlyaW5nKHIpKTtcbiAgICB9LCB0aGlzLnNlbmRSZXF1ZXN0ID0gYXN5bmMgKHMsIHIsIG4pID0+IHtcbiAgICAgIGNvbnN0IG8gPSB0aShyLCBuKSwgYyA9IGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uZW5jb2RlKHMsIG8pLCB1ID0gc3Nbcl0ucmVxO1xuICAgICAgcmV0dXJuIHRoaXMuY29yZS5oaXN0b3J5LnNldChzLCBvKSwgdGhpcy5jb3JlLnJlbGF5ZXIucHVibGlzaChzLCBjLCB1KSwgby5pZDtcbiAgICB9LCB0aGlzLnNlbmRSZXN1bHQgPSBhc3luYyAocywgciwgbikgPT4ge1xuICAgICAgY29uc3QgbyA9IHhpKHMsIG4pLCBjID0gYXdhaXQgdGhpcy5jb3JlLmNyeXB0by5lbmNvZGUociwgbyksIHUgPSBhd2FpdCB0aGlzLmNvcmUuaGlzdG9yeS5nZXQociwgcyksIGQgPSBzc1t1LnJlcXVlc3QubWV0aG9kXS5yZXM7XG4gICAgICBhd2FpdCB0aGlzLmNvcmUucmVsYXllci5wdWJsaXNoKHIsIGMsIGQpLCBhd2FpdCB0aGlzLmNvcmUuaGlzdG9yeS5yZXNvbHZlKG8pO1xuICAgIH0sIHRoaXMuc2VuZEVycm9yID0gYXN5bmMgKHMsIHIsIG4pID0+IHtcbiAgICAgIGNvbnN0IG8gPSBxaShzLCBuKSwgYyA9IGF3YWl0IHRoaXMuY29yZS5jcnlwdG8uZW5jb2RlKHIsIG8pLCB1ID0gYXdhaXQgdGhpcy5jb3JlLmhpc3RvcnkuZ2V0KHIsIHMpLCBkID0gc3NbdS5yZXF1ZXN0Lm1ldGhvZF0gPyBzc1t1LnJlcXVlc3QubWV0aG9kXS5yZXMgOiBzcy51bnJlZ2lzdGVyZWRfbWV0aG9kLnJlcztcbiAgICAgIGF3YWl0IHRoaXMuY29yZS5yZWxheWVyLnB1Ymxpc2gociwgYywgZCksIGF3YWl0IHRoaXMuY29yZS5oaXN0b3J5LnJlc29sdmUobyk7XG4gICAgfSwgdGhpcy5kZWxldGVQYWlyaW5nID0gYXN5bmMgKHMsIHIpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuY29yZS5yZWxheWVyLnVuc3Vic2NyaWJlKHMpLCBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5wYWlyaW5ncy5kZWxldGUocywgSmUoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSksIHRoaXMuY29yZS5jcnlwdG8uZGVsZXRlU3ltS2V5KHMpLCByID8gUHJvbWlzZS5yZXNvbHZlKCkgOiB0aGlzLmNvcmUuZXhwaXJlci5kZWwocyldKTtcbiAgICB9LCB0aGlzLmNsZWFudXAgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzID0gdGhpcy5wYWlyaW5ncy5nZXRBbGwoKS5maWx0ZXIoKHIpID0+IGNpKHIuZXhwaXJ5KSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChzLm1hcCgocikgPT4gdGhpcy5kZWxldGVQYWlyaW5nKHIudG9waWMpKSk7XG4gICAgfSwgdGhpcy5vblJlbGF5RXZlbnRSZXF1ZXN0ID0gKHMpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHIsIHBheWxvYWQ6IG4gfSA9IHMsIG8gPSBuLm1ldGhvZDtcbiAgICAgIGlmICh0aGlzLnBhaXJpbmdzLmtleXMuaW5jbHVkZXMocikpXG4gICAgICAgIHN3aXRjaCAobykge1xuICAgICAgICAgIGNhc2UgXCJ3Y19wYWlyaW5nUGluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25QYWlyaW5nUGluZ1JlcXVlc3Qociwgbik7XG4gICAgICAgICAgY2FzZSBcIndjX3BhaXJpbmdEZWxldGVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uUGFpcmluZ0RlbGV0ZVJlcXVlc3Qociwgbik7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uVW5rbm93blJwY01ldGhvZFJlcXVlc3Qociwgbik7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzLm9uUmVsYXlFdmVudFJlc3BvbnNlID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHIsIHBheWxvYWQ6IG4gfSA9IHMsIG8gPSAoYXdhaXQgdGhpcy5jb3JlLmhpc3RvcnkuZ2V0KHIsIG4uaWQpKS5yZXF1ZXN0Lm1ldGhvZDtcbiAgICAgIGlmICh0aGlzLnBhaXJpbmdzLmtleXMuaW5jbHVkZXMocikpXG4gICAgICAgIHN3aXRjaCAobykge1xuICAgICAgICAgIGNhc2UgXCJ3Y19wYWlyaW5nUGluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25QYWlyaW5nUGluZ1Jlc3BvbnNlKHIsIG4pO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vblVua25vd25ScGNNZXRob2RSZXNwb25zZShvKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMub25QYWlyaW5nUGluZ1JlcXVlc3QgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgY29uc3QgeyBpZDogbiB9ID0gcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZFBpbmcoeyB0b3BpYzogcyB9KSwgYXdhaXQgdGhpcy5zZW5kUmVzdWx0KG4sIHMsICEwKSwgdGhpcy5ldmVudHMuZW1pdChcInBhaXJpbmdfcGluZ1wiLCB7IGlkOiBuLCB0b3BpYzogcyB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IobiwgcywgbyksIHRoaXMubG9nZ2VyLmVycm9yKG8pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25QYWlyaW5nUGluZ1Jlc3BvbnNlID0gKHMsIHIpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IG4gfSA9IHI7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaHQocikgPyB0aGlzLmV2ZW50cy5lbWl0KGtlKFwicGFpcmluZ19waW5nXCIsIG4pLCB7fSkgOiBHZShyKSAmJiB0aGlzLmV2ZW50cy5lbWl0KGtlKFwicGFpcmluZ19waW5nXCIsIG4pLCB7IGVycm9yOiByLmVycm9yIH0pO1xuICAgICAgfSwgNTAwKTtcbiAgICB9LCB0aGlzLm9uUGFpcmluZ0RlbGV0ZVJlcXVlc3QgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgY29uc3QgeyBpZDogbiB9ID0gcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZERpc2Nvbm5lY3QoeyB0b3BpYzogcyB9KSwgYXdhaXQgdGhpcy5kZWxldGVQYWlyaW5nKHMpLCB0aGlzLmV2ZW50cy5lbWl0KFwicGFpcmluZ19kZWxldGVcIiwgeyBpZDogbiwgdG9waWM6IHMgfSk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKG4sIHMsIG8pLCB0aGlzLmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uVW5rbm93blJwY01ldGhvZFJlcXVlc3QgPSBhc3luYyAocywgcikgPT4ge1xuICAgICAgY29uc3QgeyBpZDogbiwgbWV0aG9kOiBvIH0gPSByO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlZE1ldGhvZHMuaW5jbHVkZXMobykpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjID0gSmUoXCJXQ19NRVRIT0RfVU5TVVBQT1JURURcIiwgbyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKG4sIHMsIGMpLCB0aGlzLmxvZ2dlci5lcnJvcihjKTtcbiAgICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IobiwgcywgYyksIHRoaXMubG9nZ2VyLmVycm9yKGMpO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25Vbmtub3duUnBjTWV0aG9kUmVzcG9uc2UgPSAocykgPT4ge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkTWV0aG9kcy5pbmNsdWRlcyhzKSB8fCB0aGlzLmxvZ2dlci5lcnJvcihKZShcIldDX01FVEhPRF9VTlNVUFBPUlRFRFwiLCBzKSk7XG4gICAgfSwgdGhpcy5pc1ZhbGlkUGFpciA9IChzKSA9PiB7XG4gICAgICBpZiAoIUl0KHMpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogciB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcGFpcigpIHBhcmFtczogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgICBpZiAoIU1iKHMudXJpKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHIgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHBhaXIoKSB1cmk6ICR7cy51cml9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzVmFsaWRQaW5nID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIGlmICghSXQocykpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwaW5nKCkgcGFyYW1zOiAke3N9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IHIgfSA9IHM7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRQYWlyaW5nVG9waWMocik7XG4gICAgfSwgdGhpcy5pc1ZhbGlkRGlzY29ubmVjdCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICBpZiAoIUl0KHMpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZGlzY29ubmVjdCgpIHBhcmFtczogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiByIH0gPSBzO1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkUGFpcmluZ1RvcGljKHIpO1xuICAgIH0sIHRoaXMuaXNWYWxpZFBhaXJpbmdUb3BpYyA9IGFzeW5jIChzKSA9PiB7XG4gICAgICBpZiAoIWF0KHMsICExKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHIgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHBhaXJpbmcgdG9waWMgc2hvdWxkIGJlIGEgc3RyaW5nOiAke3N9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHMpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogciB9ID0gSihcIk5PX01BVENISU5HX0tFWVwiLCBgcGFpcmluZyB0b3BpYyBkb2Vzbid0IGV4aXN0OiAke3N9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaSh0aGlzLnBhaXJpbmdzLmdldChzKS5leHBpcnkpKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZGVsZXRlUGFpcmluZyhzKTtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiByIH0gPSBKKFwiRVhQSVJFRFwiLCBgcGFpcmluZyB0b3BpYzogJHtzfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSBlZS5nZW5lcmF0ZUNoaWxkTG9nZ2VyKHQsIHRoaXMubmFtZSksIHRoaXMucGFpcmluZ3MgPSBuZXcgcHIodGhpcy5jb3JlLCB0aGlzLmxvZ2dlciwgdGhpcy5uYW1lLCB0aGlzLnN0b3JhZ2VQcmVmaXgpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBKKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyUmVsYXllckV2ZW50cygpIHtcbiAgICB0aGlzLmNvcmUucmVsYXllci5vbihIZS5tZXNzYWdlLCBhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgeyB0b3BpYzogdCwgbWVzc2FnZTogcyB9ID0gZTtcbiAgICAgIGlmICh0aGlzLmlnbm9yZWRQYXlsb2FkVHlwZXMuaW5jbHVkZXModGhpcy5jb3JlLmNyeXB0by5nZXRQYXlsb2FkVHlwZShzKSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLmNvcmUuY3J5cHRvLmRlY29kZSh0LCBzKTtcbiAgICAgIGppKHIpID8gKHRoaXMuY29yZS5oaXN0b3J5LnNldCh0LCByKSwgdGhpcy5vblJlbGF5RXZlbnRSZXF1ZXN0KHsgdG9waWM6IHQsIHBheWxvYWQ6IHIgfSkpIDogT2kocikgJiYgKGF3YWl0IHRoaXMuY29yZS5oaXN0b3J5LnJlc29sdmUociksIHRoaXMub25SZWxheUV2ZW50UmVzcG9uc2UoeyB0b3BpYzogdCwgcGF5bG9hZDogciB9KSk7XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJFeHBpcmVyRXZlbnRzKCkge1xuICAgIHRoaXMuY29yZS5leHBpcmVyLm9uKCR0LmV4cGlyZWQsIGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiB0IH0gPSBTaChlLnRhcmdldCk7XG4gICAgICB0ICYmIHRoaXMucGFpcmluZ3Mua2V5cy5pbmNsdWRlcyh0KSAmJiAoYXdhaXQgdGhpcy5kZWxldGVQYWlyaW5nKHQsICEwKSwgdGhpcy5ldmVudHMuZW1pdChcInBhaXJpbmdfZXhwaXJlXCIsIHsgdG9waWM6IHQgfSkpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBFdiBleHRlbmRzIFRtIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLmNvcmUgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMucmVjb3JkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuZXZlbnRzID0gbmV3IFdlLkV2ZW50RW1pdHRlcigpLCB0aGlzLm5hbWUgPSBYMCwgdGhpcy52ZXJzaW9uID0gWjAsIHRoaXMuY2FjaGVkID0gW10sIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5zdG9yYWdlUHJlZml4ID0gdWksIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgKHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIiksIGF3YWl0IHRoaXMucmVzdG9yZSgpLCB0aGlzLmNhY2hlZC5mb3JFYWNoKChzKSA9PiB0aGlzLnJlY29yZHMuc2V0KHMuaWQsIHMpKSwgdGhpcy5jYWNoZWQgPSBbXSwgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCksIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCk7XG4gICAgfSwgdGhpcy5zZXQgPSAocywgciwgbikgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlNldHRpbmcgSlNPTi1SUEMgcmVxdWVzdCBoaXN0b3J5IHJlY29yZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwic2V0XCIsIHRvcGljOiBzLCByZXF1ZXN0OiByLCBjaGFpbklkOiBuIH0pLCB0aGlzLnJlY29yZHMuaGFzKHIuaWQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0geyBpZDogci5pZCwgdG9waWM6IHMsIHJlcXVlc3Q6IHsgbWV0aG9kOiByLm1ldGhvZCwgcGFyYW1zOiByLnBhcmFtcyB8fCBudWxsIH0sIGNoYWluSWQ6IG4gfTtcbiAgICAgIHRoaXMucmVjb3Jkcy5zZXQoby5pZCwgbyksIHRoaXMuZXZlbnRzLmVtaXQoS3QuY3JlYXRlZCwgbyk7XG4gICAgfSwgdGhpcy5yZXNvbHZlID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJVcGRhdGluZyBKU09OLVJQQyByZXNwb25zZSBoaXN0b3J5IHJlY29yZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwidXBkYXRlXCIsIHJlc3BvbnNlOiBzIH0pLCAhdGhpcy5yZWNvcmRzLmhhcyhzLmlkKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuZ2V0UmVjb3JkKHMuaWQpO1xuICAgICAgdHlwZW9mIHIucmVzcG9uc2UgPiBcInVcIiAmJiAoci5yZXNwb25zZSA9IEdlKHMpID8geyBlcnJvcjogcy5lcnJvciB9IDogeyByZXN1bHQ6IHMucmVzdWx0IH0sIHRoaXMucmVjb3Jkcy5zZXQoci5pZCwgciksIHRoaXMuZXZlbnRzLmVtaXQoS3QudXBkYXRlZCwgcikpO1xuICAgIH0sIHRoaXMuZ2V0ID0gYXN5bmMgKHMsIHIpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJHZXR0aW5nIHJlY29yZFwiKSwgdGhpcy5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwiZ2V0XCIsIHRvcGljOiBzLCBpZDogciB9KSwgYXdhaXQgdGhpcy5nZXRSZWNvcmQocikpLCB0aGlzLmRlbGV0ZSA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5sb2dnZXIuZGVidWcoXCJEZWxldGluZyByZWNvcmRcIiksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcImRlbGV0ZVwiLCBpZDogciB9KSwgdGhpcy52YWx1ZXMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBpZiAobi50b3BpYyA9PT0gcykge1xuICAgICAgICAgIGlmICh0eXBlb2YgciA8IFwidVwiICYmIG4uaWQgIT09IHIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgdGhpcy5yZWNvcmRzLmRlbGV0ZShuLmlkKSwgdGhpcy5ldmVudHMuZW1pdChLdC5kZWxldGVkLCBuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgdGhpcy5leGlzdHMgPSBhc3luYyAocywgcikgPT4gKHRoaXMuaXNJbml0aWFsaXplZCgpLCB0aGlzLnJlY29yZHMuaGFzKHIpID8gKGF3YWl0IHRoaXMuZ2V0UmVjb3JkKHIpKS50b3BpYyA9PT0gcyA6ICExKSwgdGhpcy5vbiA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbihzLCByKTtcbiAgICB9LCB0aGlzLm9uY2UgPSAocywgcikgPT4ge1xuICAgICAgdGhpcy5ldmVudHMub25jZShzLCByKTtcbiAgICB9LCB0aGlzLm9mZiA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vZmYocywgcik7XG4gICAgfSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihzLCByKTtcbiAgICB9LCB0aGlzLmxvZ2dlciA9IGVlLmdlbmVyYXRlQ2hpbGRMb2dnZXIodCwgdGhpcy5uYW1lKTtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHN0b3JhZ2VLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByZWZpeCArIHRoaXMudmVyc2lvbiArIFwiLy9cIiArIHRoaXMubmFtZTtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvcmRzLnNpemU7XG4gIH1cbiAgZ2V0IGtleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWNvcmRzLmtleXMoKSk7XG4gIH1cbiAgZ2V0IHZhbHVlcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlY29yZHMudmFsdWVzKCkpO1xuICB9XG4gIGdldCBwZW5kaW5nKCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0LnJlc3BvbnNlIDwgXCJ1XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHMgPSB7IHRvcGljOiB0LnRvcGljLCByZXF1ZXN0OiB0aSh0LnJlcXVlc3QubWV0aG9kLCB0LnJlcXVlc3QucGFyYW1zLCB0LmlkKSwgY2hhaW5JZDogdC5jaGFpbklkIH07XG4gICAgICByZXR1cm4gZS5wdXNoKHMpO1xuICAgIH0pLCBlO1xuICB9XG4gIGFzeW5jIHNldEpzb25ScGNSZWNvcmRzKGUpIHtcbiAgICBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgZSk7XG4gIH1cbiAgYXN5bmMgZ2V0SnNvblJwY1JlY29yZHMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgfVxuICBnZXRSZWNvcmQoZSkge1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IHQgPSB0aGlzLnJlY29yZHMuZ2V0KGUpO1xuICAgIGlmICghdCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBzIH0gPSBKKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGAke3RoaXMubmFtZX06ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihzKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgYXN5bmMgcGVyc2lzdCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldEpzb25ScGNSZWNvcmRzKHRoaXMudmFsdWVzKSwgdGhpcy5ldmVudHMuZW1pdChLdC5zeW5jKTtcbiAgfVxuICBhc3luYyByZXN0b3JlKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5nZXRKc29uUnBjUmVjb3JkcygpO1xuICAgICAgaWYgKHR5cGVvZiBlID4gXCJ1XCIgfHwgIWUubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5yZWNvcmRzLnNpemUpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBKKFwiUkVTVE9SRV9XSUxMX09WRVJSSURFXCIsIHRoaXMubmFtZSk7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHQpLCBuZXcgRXJyb3IodCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlZCA9IGUsIHRoaXMubG9nZ2VyLmRlYnVnKGBTdWNjZXNzZnVsbHkgUmVzdG9yZWQgcmVjb3JkcyBmb3IgJHt0aGlzLm5hbWV9YCksIHRoaXMubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcInJlc3RvcmVcIiwgcmVjb3JkczogdGhpcy52YWx1ZXMgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEZhaWxlZCB0byBSZXN0b3JlIHJlY29yZHMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci5lcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLmV2ZW50cy5vbihLdC5jcmVhdGVkLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IEt0LmNyZWF0ZWQ7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFbWl0dGluZyAke3R9YCksIHRoaXMubG9nZ2VyLmRlYnVnKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdCwgcmVjb3JkOiBlIH0pLCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KSwgdGhpcy5ldmVudHMub24oS3QudXBkYXRlZCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBLdC51cGRhdGVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIHJlY29yZDogZSB9KSwgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSksIHRoaXMuZXZlbnRzLm9uKEt0LmRlbGV0ZWQsIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gS3QuZGVsZXRlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCByZWNvcmQ6IGUgfSksIHRoaXMucGVyc2lzdCgpO1xuICAgIH0pO1xuICB9XG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IGUgfSA9IEooXCJOT1RfSU5JVElBTElaRURcIiwgdGhpcy5uYW1lKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFN2IGV4dGVuZHMgcW0ge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdCwgdGhpcy5leHBpcmF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuZXZlbnRzID0gbmV3IFdlLkV2ZW50RW1pdHRlcigpLCB0aGlzLm5hbWUgPSBldiwgdGhpcy52ZXJzaW9uID0gdHYsIHRoaXMuY2FjaGVkID0gW10sIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5zdG9yYWdlUHJlZml4ID0gdWksIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgKHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIiksIGF3YWl0IHRoaXMucmVzdG9yZSgpLCB0aGlzLmNhY2hlZC5mb3JFYWNoKChzKSA9PiB0aGlzLmV4cGlyYXRpb25zLnNldChzLnRhcmdldCwgcykpLCB0aGlzLmNhY2hlZCA9IFtdLCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5pbml0aWFsaXplZCA9ICEwKTtcbiAgICB9LCB0aGlzLmhhcyA9IChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByID0gdGhpcy5mb3JtYXRUYXJnZXQocyk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5nZXRFeHBpcmF0aW9uKHIpIDwgXCJ1XCI7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH0sIHRoaXMuc2V0ID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpO1xuICAgICAgY29uc3QgbiA9IHRoaXMuZm9ybWF0VGFyZ2V0KHMpLCBvID0geyB0YXJnZXQ6IG4sIGV4cGlyeTogciB9O1xuICAgICAgdGhpcy5leHBpcmF0aW9ucy5zZXQobiwgbyksIHRoaXMuY2hlY2tFeHBpcnkobiwgbyksIHRoaXMuZXZlbnRzLmVtaXQoJHQuY3JlYXRlZCwgeyB0YXJnZXQ6IG4sIGV4cGlyYXRpb246IG8gfSk7XG4gICAgfSwgdGhpcy5nZXQgPSAocykgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICBjb25zdCByID0gdGhpcy5mb3JtYXRUYXJnZXQocyk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRFeHBpcmF0aW9uKHIpO1xuICAgIH0sIHRoaXMuZGVsID0gKHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5oYXMocykpIHtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuZm9ybWF0VGFyZ2V0KHMpLCBuID0gdGhpcy5nZXRFeHBpcmF0aW9uKHIpO1xuICAgICAgICB0aGlzLmV4cGlyYXRpb25zLmRlbGV0ZShyKSwgdGhpcy5ldmVudHMuZW1pdCgkdC5kZWxldGVkLCB7IHRhcmdldDogciwgZXhwaXJhdGlvbjogbiB9KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9uKHMsIHIpO1xuICAgIH0sIHRoaXMub25jZSA9IChzLCByKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5vbmNlKHMsIHIpO1xuICAgIH0sIHRoaXMub2ZmID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLm9mZihzLCByKTtcbiAgICB9LCB0aGlzLnJlbW92ZUxpc3RlbmVyID0gKHMsIHIpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKHMsIHIpO1xuICAgIH0sIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBnZXQgc3RvcmFnZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJlZml4ICsgdGhpcy52ZXJzaW9uICsgXCIvL1wiICsgdGhpcy5uYW1lO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwaXJhdGlvbnMuc2l6ZTtcbiAgfVxuICBnZXQga2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmV4cGlyYXRpb25zLmtleXMoKSk7XG4gIH1cbiAgZ2V0IHZhbHVlcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmV4cGlyYXRpb25zLnZhbHVlcygpKTtcbiAgfVxuICBmb3JtYXRUYXJnZXQoZSkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGJiKGUpO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHdiKGUpO1xuICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gSihcIlVOS05PV05fVFlQRVwiLCBgVGFyZ2V0IHR5cGU6ICR7dHlwZW9mIGV9YCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICB9XG4gIGFzeW5jIHNldEV4cGlyYXRpb25zKGUpIHtcbiAgICBhd2FpdCB0aGlzLmNvcmUuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXhwaXJhdGlvbnMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29yZS5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgfVxuICBhc3luYyBwZXJzaXN0KCkge1xuICAgIGF3YWl0IHRoaXMuc2V0RXhwaXJhdGlvbnModGhpcy52YWx1ZXMpLCB0aGlzLmV2ZW50cy5lbWl0KCR0LnN5bmMpO1xuICB9XG4gIGFzeW5jIHJlc3RvcmUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmdldEV4cGlyYXRpb25zKCk7XG4gICAgICBpZiAodHlwZW9mIGUgPiBcInVcIiB8fCAhZS5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmV4cGlyYXRpb25zLnNpemUpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBKKFwiUkVTVE9SRV9XSUxMX09WRVJSSURFXCIsIHRoaXMubmFtZSk7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHQpLCBuZXcgRXJyb3IodCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlZCA9IGUsIHRoaXMubG9nZ2VyLmRlYnVnKGBTdWNjZXNzZnVsbHkgUmVzdG9yZWQgZXhwaXJhdGlvbnMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJyZXN0b3JlXCIsIGV4cGlyYXRpb25zOiB0aGlzLnZhbHVlcyB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRmFpbGVkIHRvIFJlc3RvcmUgZXhwaXJhdGlvbnMgZm9yICR7dGhpcy5uYW1lfWApLCB0aGlzLmxvZ2dlci5lcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgZ2V0RXhwaXJhdGlvbihlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZXhwaXJhdGlvbnMuZ2V0KGUpO1xuICAgIGlmICghdCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBzIH0gPSBKKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGAke3RoaXMubmFtZX06ICR7ZX1gKTtcbiAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHMpLCBuZXcgRXJyb3Iocyk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIGNoZWNrRXhwaXJ5KGUsIHQpIHtcbiAgICBjb25zdCB7IGV4cGlyeTogcyB9ID0gdDtcbiAgICBWLnRvTWlsaXNlY29uZHMocykgLSBEYXRlLm5vdygpIDw9IDAgJiYgdGhpcy5leHBpcmUoZSwgdCk7XG4gIH1cbiAgZXhwaXJlKGUsIHQpIHtcbiAgICB0aGlzLmV4cGlyYXRpb25zLmRlbGV0ZShlKSwgdGhpcy5ldmVudHMuZW1pdCgkdC5leHBpcmVkLCB7IHRhcmdldDogZSwgZXhwaXJhdGlvbjogdCB9KTtcbiAgfVxuICBjaGVja0V4cGlyYXRpb25zKCkge1xuICAgIHRoaXMuY29yZS5yZWxheWVyLmNvbm5lY3RlZCAmJiB0aGlzLmV4cGlyYXRpb25zLmZvckVhY2goKGUsIHQpID0+IHRoaXMuY2hlY2tFeHBpcnkodCwgZSkpO1xuICB9XG4gIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5jb3JlLmhlYXJ0YmVhdC5vbihXdC5IRUFSVEJFQVRfRVZFTlRTLnB1bHNlLCAoKSA9PiB0aGlzLmNoZWNrRXhwaXJhdGlvbnMoKSksIHRoaXMuZXZlbnRzLm9uKCR0LmNyZWF0ZWQsIChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gJHQuY3JlYXRlZDtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEVtaXR0aW5nICR7dH1gKSwgdGhpcy5sb2dnZXIuZGVidWcoeyB0eXBlOiBcImV2ZW50XCIsIGV2ZW50OiB0LCBkYXRhOiBlIH0pLCB0aGlzLnBlcnNpc3QoKTtcbiAgICB9KSwgdGhpcy5ldmVudHMub24oJHQuZXhwaXJlZCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSAkdC5leHBpcmVkO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRW1pdHRpbmcgJHt0fWApLCB0aGlzLmxvZ2dlci5kZWJ1Zyh7IHR5cGU6IFwiZXZlbnRcIiwgZXZlbnQ6IHQsIGRhdGE6IGUgfSksIHRoaXMucGVyc2lzdCgpO1xuICAgIH0pLCB0aGlzLmV2ZW50cy5vbigkdC5kZWxldGVkLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9ICR0LmRlbGV0ZWQ7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFbWl0dGluZyAke3R9YCksIHRoaXMubG9nZ2VyLmRlYnVnKHsgdHlwZTogXCJldmVudFwiLCBldmVudDogdCwgZGF0YTogZSB9KSwgdGhpcy5wZXJzaXN0KCk7XG4gICAgfSk7XG4gIH1cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogZSB9ID0gSihcIk5PVF9JTklUSUFMSVpFRFwiLCB0aGlzLm5hbWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgSXYgZXh0ZW5kcyBqbSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5wcm9qZWN0SWQgPSBlLCB0aGlzLmxvZ2dlciA9IHQsIHRoaXMubmFtZSA9IFRyLCB0aGlzLmluaXRpYWxpemVkID0gITEsIHRoaXMuaW5pdCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB3aCgpIHx8ICFObigpIHx8ICh0aGlzLnZlcmlmeVVybCA9IHM/LnZlcmlmeVVybCB8fCBUYSwgYXdhaXQgdGhpcy5jcmVhdGVJZnJhbWUoKSk7XG4gICAgfSwgdGhpcy5yZWdpc3RlciA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB2YXIgcjtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgfHwgYXdhaXQgdGhpcy5pbml0KCksIHRoaXMuaWZyYW1lICYmICgociA9IHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cpID09IG51bGwgfHwgci5wb3N0TWVzc2FnZShzLmF0dGVzdGF0aW9uSWQsIHRoaXMudmVyaWZ5VXJsKSwgdGhpcy5sb2dnZXIuaW5mbyhgcG9zdE1lc3NhZ2Ugc2VudDogJHtzLmF0dGVzdGF0aW9uSWR9ICR7dGhpcy52ZXJpZnlVcmx9YCkpO1xuICAgIH0sIHRoaXMucmVzb2x2ZSA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB2YXIgcjtcbiAgICAgIGlmICh0aGlzLmlzRGV2RW52KVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYHJlc29sdmluZyBhdHRlc3RhdGlvbjogJHtzLmF0dGVzdGF0aW9uSWR9YCk7XG4gICAgICBjb25zdCBuID0gdGhpcy5zdGFydEFib3J0VGltZXIoVi5GSVZFX1NFQ09ORFMpLCBvID0gYXdhaXQgZmV0Y2goYCR7dGhpcy52ZXJpZnlVcmx9L2F0dGVzdGF0aW9uLyR7cy5hdHRlc3RhdGlvbklkfWAsIHsgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwgfSk7XG4gICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG4pLCBvLnN0YXR1cyA9PT0gMjAwID8gKHIgPSBhd2FpdCBvLmpzb24oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIub3JpZ2luIDogXCJcIjtcbiAgICB9LCB0aGlzLmNyZWF0ZUlmcmFtZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbbmV3IFByb21pc2UoKHMsIHIpID0+IHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoVHIpKVxuICAgICAgICAgICAgcmV0dXJuIHMoKTtcbiAgICAgICAgICBjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgICBuLnNldEF0dHJpYnV0ZShcImlkXCIsIFRyKSwgbi5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgYCR7dGhpcy52ZXJpZnlVcmx9LyR7dGhpcy5wcm9qZWN0SWR9YCksIG4uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCBuLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMCwgcygpO1xuICAgICAgICAgIH0pLCBuLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAobykgPT4ge1xuICAgICAgICAgICAgcihvKTtcbiAgICAgICAgICB9KSwgZG9jdW1lbnQuYm9keS5hcHBlbmQobiksIHRoaXMuaWZyYW1lID0gbjtcbiAgICAgICAgfSksIG5ldyBQcm9taXNlKChzKSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzKFwiaWZyYW1lIGxvYWQgdGltZW91dFwiKSwgVi50b01pbGlzZWNvbmRzKFYuT05FX1NFQ09ORCAvIDIpKTtcbiAgICAgICAgfSldKTtcbiAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYFZlcmlmeSBpZnJhbWUgZmFpbGVkIHRvIGxvYWQ6ICR7dGhpcy52ZXJpZnlVcmx9YCksIHRoaXMubG9nZ2VyLmVycm9yKHMpO1xuICAgICAgfVxuICAgIH0sIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLnZlcmlmeVVybCA9IFRhLCB0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSwgdGhpcy5pc0RldkVudiA9IE9uKCkgJiYgcHJvY2Vzcy5lbnYuSVNfVklURVNUO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiBlZS5nZXRMb2dnZXJDb250ZXh0KHRoaXMubG9nZ2VyKTtcbiAgfVxuICBzdGFydEFib3J0VGltZXIoZSkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCksIFYudG9NaWxpc2Vjb25kcyhlKSk7XG4gIH1cbn1cbnZhciBEdiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgemEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCB4diA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIE92ID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgS2EgPSAoaSwgZSwgdCkgPT4gZSBpbiBpID8gRHYoaSwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IGlbZV0gPSB0LCBWYSA9IChpLCBlKSA9PiB7XG4gIGZvciAodmFyIHQgaW4gZSB8fCAoZSA9IHt9KSlcbiAgICB4di5jYWxsKGUsIHQpICYmIEthKGksIHQsIGVbdF0pO1xuICBpZiAoemEpXG4gICAgZm9yICh2YXIgdCBvZiB6YShlKSlcbiAgICAgIE92LmNhbGwoZSwgdCkgJiYgS2EoaSwgdCwgZVt0XSk7XG4gIHJldHVybiBpO1xufTtcbmxldCBOdiA9IGNsYXNzIGpoIGV4dGVuZHMgQW0ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSksIHRoaXMucHJvdG9jb2wgPSBMaCwgdGhpcy52ZXJzaW9uID0gUDAsIHRoaXMubmFtZSA9IENuLCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLm9uID0gKHMsIHIpID0+IHRoaXMuZXZlbnRzLm9uKHMsIHIpLCB0aGlzLm9uY2UgPSAocywgcikgPT4gdGhpcy5ldmVudHMub25jZShzLCByKSwgdGhpcy5vZmYgPSAocywgcikgPT4gdGhpcy5ldmVudHMub2ZmKHMsIHIpLCB0aGlzLnJlbW92ZUxpc3RlbmVyID0gKHMsIHIpID0+IHRoaXMuZXZlbnRzLnJlbW92ZUxpc3RlbmVyKHMsIHIpLCB0aGlzLnByb2plY3RJZCA9IGU/LnByb2plY3RJZCwgdGhpcy5yZWxheVVybCA9IGU/LnJlbGF5VXJsIHx8IHFoO1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZT8ubG9nZ2VyIDwgXCJ1XCIgJiYgdHlwZW9mIGU/LmxvZ2dlciAhPSBcInN0cmluZ1wiID8gZS5sb2dnZXIgOiBlZS5waW5vKGVlLmdldERlZmF1bHRMb2dnZXJPcHRpb25zKHsgbGV2ZWw6IGU/LmxvZ2dlciB8fCBSMC5sb2dnZXIgfSkpO1xuICAgIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLmhlYXJ0YmVhdCA9IG5ldyBXdC5IZWFydEJlYXQoKSwgdGhpcy5jcnlwdG8gPSBuZXcgc3YodGhpcywgdGhpcy5sb2dnZXIsIGU/LmtleWNoYWluKSwgdGhpcy5oaXN0b3J5ID0gbmV3IEV2KHRoaXMsIHRoaXMubG9nZ2VyKSwgdGhpcy5leHBpcmVyID0gbmV3IFN2KHRoaXMsIHRoaXMubG9nZ2VyKSwgdGhpcy5zdG9yYWdlID0gZSAhPSBudWxsICYmIGUuc3RvcmFnZSA/IGUuc3RvcmFnZSA6IG5ldyBuYyhWYShWYSh7fSwgQzApLCBlPy5zdG9yYWdlT3B0aW9ucykpLCB0aGlzLnJlbGF5ZXIgPSBuZXcgbXYoeyBjb3JlOiB0aGlzLCBsb2dnZXI6IHRoaXMubG9nZ2VyLCByZWxheVVybDogdGhpcy5yZWxheVVybCwgcHJvamVjdElkOiB0aGlzLnByb2plY3RJZCB9KSwgdGhpcy5wYWlyaW5nID0gbmV3IF92KHRoaXMsIHRoaXMubG9nZ2VyKSwgdGhpcy52ZXJpZnkgPSBuZXcgSXYodGhpcy5wcm9qZWN0SWQgfHwgXCJcIiwgdGhpcy5sb2dnZXIpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBpbml0KGUpIHtcbiAgICBjb25zdCB0ID0gbmV3IGpoKGUpO1xuICAgIHJldHVybiBhd2FpdCB0LmluaXRpYWxpemUoKSwgdDtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgdGhpcy5pbml0aWFsaXplZCB8fCBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiSW5pdGlhbGl6ZWRcIik7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY3J5cHRvLmluaXQoKSwgYXdhaXQgdGhpcy5oaXN0b3J5LmluaXQoKSwgYXdhaXQgdGhpcy5leHBpcmVyLmluaXQoKSwgYXdhaXQgdGhpcy5yZWxheWVyLmluaXQoKSwgYXdhaXQgdGhpcy5oZWFydGJlYXQuaW5pdCgpLCBhd2FpdCB0aGlzLnBhaXJpbmcuaW5pdCgpLCB0aGlzLmluaXRpYWxpemVkID0gITAsIHRoaXMubG9nZ2VyLmluZm8oXCJDb3JlIEluaXRpYWxpemF0aW9uIFN1Y2Nlc3NcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgdGhpcy5sb2dnZXIud2FybihgQ29yZSBJbml0aWFsaXphdGlvbiBGYWlsdXJlIGF0IGVwb2NoICR7RGF0ZS5ub3coKX1gLCBlKSwgdGhpcy5sb2dnZXIuZXJyb3IoZS5tZXNzYWdlKSwgZTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBQdiA9IE52LCB6aCA9IFwid2NcIiwgS2ggPSAyLCBWaCA9IFwiY2xpZW50XCIsIEFuID0gYCR7emh9QCR7S2h9OiR7Vmh9OmAsIEZyID0geyBuYW1lOiBWaCwgbG9nZ2VyOiBcImVycm9yXCIsIGNvbnRyb2xsZXI6ICExLCByZWxheVVybDogXCJ3c3M6Ly9yZWxheS53YWxsZXRjb25uZWN0LmNvbVwiIH0sIFJ2ID0gXCJwcm9wb3NhbFwiLCBDdiA9IFwiUHJvcG9zYWwgZXhwaXJlZFwiLCBBdiA9IFwic2Vzc2lvblwiLCBMcyA9IFYuU0VWRU5fREFZUywgVHYgPSBcImVuZ2luZVwiLCBucyA9IHsgd2Nfc2Vzc2lvblByb3Bvc2U6IHsgcmVxOiB7IHR0bDogVi5GSVZFX01JTlVURVMsIHByb21wdDogITAsIHRhZzogMTEwMCB9LCByZXM6IHsgdHRsOiBWLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMSwgdGFnOiAxMTAxIH0gfSwgd2Nfc2Vzc2lvblNldHRsZTogeyByZXE6IHsgdHRsOiBWLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMSwgdGFnOiAxMTAyIH0sIHJlczogeyB0dGw6IFYuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICExLCB0YWc6IDExMDMgfSB9LCB3Y19zZXNzaW9uVXBkYXRlOiB7IHJlcTogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMTA0IH0sIHJlczogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMTA1IH0gfSwgd2Nfc2Vzc2lvbkV4dGVuZDogeyByZXE6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMTEwNiB9LCByZXM6IHsgdHRsOiBWLk9ORV9EQVksIHByb21wdDogITEsIHRhZzogMTEwNyB9IH0sIHdjX3Nlc3Npb25SZXF1ZXN0OiB7IHJlcTogeyB0dGw6IFYuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICEwLCB0YWc6IDExMDggfSwgcmVzOiB7IHR0bDogVi5GSVZFX01JTlVURVMsIHByb21wdDogITEsIHRhZzogMTEwOSB9IH0sIHdjX3Nlc3Npb25FdmVudDogeyByZXE6IHsgdHRsOiBWLkZJVkVfTUlOVVRFUywgcHJvbXB0OiAhMCwgdGFnOiAxMTEwIH0sIHJlczogeyB0dGw6IFYuRklWRV9NSU5VVEVTLCBwcm9tcHQ6ICExLCB0YWc6IDExMTEgfSB9LCB3Y19zZXNzaW9uRGVsZXRlOiB7IHJlcTogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMTEyIH0sIHJlczogeyB0dGw6IFYuT05FX0RBWSwgcHJvbXB0OiAhMSwgdGFnOiAxMTEzIH0gfSwgd2Nfc2Vzc2lvblBpbmc6IHsgcmVxOiB7IHR0bDogVi5USElSVFlfU0VDT05EUywgcHJvbXB0OiAhMSwgdGFnOiAxMTE0IH0sIHJlczogeyB0dGw6IFYuVEhJUlRZX1NFQ09ORFMsIHByb21wdDogITEsIHRhZzogMTExNSB9IH0gfSwgVXIgPSB7IG1pbjogVi5GSVZFX01JTlVURVMsIG1heDogVi5TRVZFTl9EQVlTIH0sICR2ID0gXCJyZXF1ZXN0XCIsIEZ2ID0gW1wid2Nfc2Vzc2lvblByb3Bvc2VcIiwgXCJ3Y19zZXNzaW9uUmVxdWVzdFwiLCBcIndjX2F1dGhSZXF1ZXN0XCJdO1xudmFyIFV2ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBMdiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBNdiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLCBCYSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIHF2ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwganYgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBrYSA9IChpLCBlLCB0KSA9PiBlIGluIGkgPyBVdihpLCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiB0IH0pIDogaVtlXSA9IHQsIEF0ID0gKGksIGUpID0+IHtcbiAgZm9yICh2YXIgdCBpbiBlIHx8IChlID0ge30pKVxuICAgIHF2LmNhbGwoZSwgdCkgJiYga2EoaSwgdCwgZVt0XSk7XG4gIGlmIChCYSlcbiAgICBmb3IgKHZhciB0IG9mIEJhKGUpKVxuICAgICAganYuY2FsbChlLCB0KSAmJiBrYShpLCB0LCBlW3RdKTtcbiAgcmV0dXJuIGk7XG59LCBMciA9IChpLCBlKSA9PiBMdihpLCBNdihlKSk7XG5jbGFzcyB6diBleHRlbmRzIEttIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLm5hbWUgPSBUdiwgdGhpcy5ldmVudHMgPSBuZXcgaXIoKSwgdGhpcy5pbml0aWFsaXplZCA9ICExLCB0aGlzLmlnbm9yZWRQYXlsb2FkVHlwZXMgPSBbTmldLCB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkIHx8IChhd2FpdCB0aGlzLmNsZWFudXAoKSwgdGhpcy5yZWdpc3RlclJlbGF5ZXJFdmVudHMoKSwgdGhpcy5yZWdpc3RlckV4cGlyZXJFdmVudHMoKSwgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnJlZ2lzdGVyKHsgbWV0aG9kczogT2JqZWN0LmtleXMobnMpIH0pLCB0aGlzLmluaXRpYWxpemVkID0gITApO1xuICAgIH0sIHRoaXMuY29ubmVjdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgIGNvbnN0IHMgPSBMcihBdCh7fSwgdCksIHsgcmVxdWlyZWROYW1lc3BhY2VzOiB0LnJlcXVpcmVkTmFtZXNwYWNlcyB8fCB7fSwgb3B0aW9uYWxOYW1lc3BhY2VzOiB0Lm9wdGlvbmFsTmFtZXNwYWNlcyB8fCB7fSB9KTtcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZENvbm5lY3Qocyk7XG4gICAgICBjb25zdCB7IHBhaXJpbmdUb3BpYzogciwgcmVxdWlyZWROYW1lc3BhY2VzOiBuLCBvcHRpb25hbE5hbWVzcGFjZXM6IG8sIHNlc3Npb25Qcm9wZXJ0aWVzOiBjLCByZWxheXM6IHUgfSA9IHM7XG4gICAgICBsZXQgZCA9IHIsIHAsIGIgPSAhMTtcbiAgICAgIGlmIChkICYmIChiID0gdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXJpbmdzLmdldChkKS5hY3RpdmUpLCAhZCB8fCAhYikge1xuICAgICAgICBjb25zdCB7IHRvcGljOiBELCB1cmk6IHkgfSA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5jcmVhdGUoKTtcbiAgICAgICAgZCA9IEQsIHAgPSB5O1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmdlbmVyYXRlS2V5UGFpcigpLCBPID0gQXQoeyByZXF1aXJlZE5hbWVzcGFjZXM6IG4sIG9wdGlvbmFsTmFtZXNwYWNlczogbywgcmVsYXlzOiB1ID8/IFt7IHByb3RvY29sOiBNaCB9XSwgcHJvcG9zZXI6IHsgcHVibGljS2V5OiB4LCBtZXRhZGF0YTogdGhpcy5jbGllbnQubWV0YWRhdGEgfSB9LCBjICYmIHsgc2Vzc2lvblByb3BlcnRpZXM6IGMgfSksIHsgcmVqZWN0OiBfLCByZXNvbHZlOiBDLCBkb25lOiBGIH0gPSBUaShWLkZJVkVfTUlOVVRFUywgQ3YpO1xuICAgICAgaWYgKHRoaXMuZXZlbnRzLm9uY2Uoa2UoXCJzZXNzaW9uX2Nvbm5lY3RcIiksIGFzeW5jICh7IGVycm9yOiBELCBzZXNzaW9uOiB5IH0pID0+IHtcbiAgICAgICAgaWYgKEQpXG4gICAgICAgICAgXyhEKTtcbiAgICAgICAgZWxzZSBpZiAoeSkge1xuICAgICAgICAgIHkuc2VsZi5wdWJsaWNLZXkgPSB4O1xuICAgICAgICAgIGNvbnN0IHcgPSBMcihBdCh7fSwgeSksIHsgcmVxdWlyZWROYW1lc3BhY2VzOiB5LnJlcXVpcmVkTmFtZXNwYWNlcywgb3B0aW9uYWxOYW1lc3BhY2VzOiB5Lm9wdGlvbmFsTmFtZXNwYWNlcyB9KTtcbiAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5zZXNzaW9uLnNldCh5LnRvcGljLCB3KSwgYXdhaXQgdGhpcy5zZXRFeHBpcnkoeS50b3BpYywgeS5leHBpcnkpLCBkICYmIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy51cGRhdGVNZXRhZGF0YSh7IHRvcGljOiBkLCBtZXRhZGF0YTogeS5wZWVyLm1ldGFkYXRhIH0pLCBDKHcpO1xuICAgICAgICB9XG4gICAgICB9KSwgIWQpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBEIH0gPSBKKFwiTk9fTUFUQ0hJTkdfS0VZXCIsIGBjb25uZWN0KCkgcGFpcmluZyB0b3BpYzogJHtkfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRCk7XG4gICAgICB9XG4gICAgICBjb25zdCBLID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChkLCBcIndjX3Nlc3Npb25Qcm9wb3NlXCIsIE8pLCBJID0gSHQoVi5GSVZFX01JTlVURVMpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0UHJvcG9zYWwoSywgQXQoeyBpZDogSywgZXhwaXJ5OiBJIH0sIE8pKSwgeyB1cmk6IHAsIGFwcHJvdmFsOiBGIH07XG4gICAgfSwgdGhpcy5wYWlyID0gYXN5bmMgKHQpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXIodCkpLCB0aGlzLmFwcHJvdmUgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZEFwcHJvdmUodCk7XG4gICAgICBjb25zdCB7IGlkOiBzLCByZWxheVByb3RvY29sOiByLCBuYW1lc3BhY2VzOiBuLCBzZXNzaW9uUHJvcGVydGllczogbyB9ID0gdCwgYyA9IHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldChzKTtcbiAgICAgIGxldCB7IHBhaXJpbmdUb3BpYzogdSwgcHJvcG9zZXI6IGQsIHJlcXVpcmVkTmFtZXNwYWNlczogcCwgb3B0aW9uYWxOYW1lc3BhY2VzOiBiIH0gPSBjO1xuICAgICAgdSA9IHUgfHwgXCJcIiwgdXMocCkgfHwgKHAgPSBUYihuLCBcImFwcHJvdmUoKVwiKSk7XG4gICAgICBjb25zdCB4ID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZ2VuZXJhdGVLZXlQYWlyKCksIE8gPSBkLnB1YmxpY0tleSwgXyA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmdlbmVyYXRlU2hhcmVkS2V5KHgsIE8pO1xuICAgICAgdSAmJiBzICYmIChhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcudXBkYXRlTWV0YWRhdGEoeyB0b3BpYzogdSwgbWV0YWRhdGE6IGQubWV0YWRhdGEgfSksIGF3YWl0IHRoaXMuc2VuZFJlc3VsdChzLCB1LCB7IHJlbGF5OiB7IHByb3RvY29sOiByID8/IFwiaXJuXCIgfSwgcmVzcG9uZGVyUHVibGljS2V5OiB4IH0pLCBhd2FpdCB0aGlzLmNsaWVudC5wcm9wb3NhbC5kZWxldGUocywgSmUoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5hY3RpdmF0ZSh7IHRvcGljOiB1IH0pKTtcbiAgICAgIGNvbnN0IEMgPSBBdCh7IHJlbGF5OiB7IHByb3RvY29sOiByID8/IFwiaXJuXCIgfSwgbmFtZXNwYWNlczogbiwgcmVxdWlyZWROYW1lc3BhY2VzOiBwLCBvcHRpb25hbE5hbWVzcGFjZXM6IGIsIHBhaXJpbmdUb3BpYzogdSwgY29udHJvbGxlcjogeyBwdWJsaWNLZXk6IHgsIG1ldGFkYXRhOiB0aGlzLmNsaWVudC5tZXRhZGF0YSB9LCBleHBpcnk6IEh0KExzKSB9LCBvICYmIHsgc2Vzc2lvblByb3BlcnRpZXM6IG8gfSk7XG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIuc3Vic2NyaWJlKF8pLCBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KF8sIFwid2Nfc2Vzc2lvblNldHRsZVwiLCBDKTtcbiAgICAgIGNvbnN0IEYgPSBMcihBdCh7fSwgQyksIHsgdG9waWM6IF8sIHBhaXJpbmdUb3BpYzogdSwgYWNrbm93bGVkZ2VkOiAhMSwgc2VsZjogQy5jb250cm9sbGVyLCBwZWVyOiB7IHB1YmxpY0tleTogZC5wdWJsaWNLZXksIG1ldGFkYXRhOiBkLm1ldGFkYXRhIH0sIGNvbnRyb2xsZXI6IHggfSk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi5zZXQoXywgRiksIGF3YWl0IHRoaXMuc2V0RXhwaXJ5KF8sIEh0KExzKSksIHsgdG9waWM6IF8sIGFja25vd2xlZGdlZDogKCkgPT4gbmV3IFByb21pc2UoKEspID0+IHNldFRpbWVvdXQoKCkgPT4gSyh0aGlzLmNsaWVudC5zZXNzaW9uLmdldChfKSksIDUwMCkpIH07XG4gICAgfSwgdGhpcy5yZWplY3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZFJlamVjdCh0KTtcbiAgICAgIGNvbnN0IHsgaWQ6IHMsIHJlYXNvbjogciB9ID0gdCwgeyBwYWlyaW5nVG9waWM6IG4gfSA9IHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldChzKTtcbiAgICAgIG4gJiYgKGF3YWl0IHRoaXMuc2VuZEVycm9yKHMsIG4sIHIpLCBhd2FpdCB0aGlzLmNsaWVudC5wcm9wb3NhbC5kZWxldGUocywgSmUoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSkpO1xuICAgIH0sIHRoaXMudXBkYXRlID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRVcGRhdGUodCk7XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCBuYW1lc3BhY2VzOiByIH0gPSB0LCBuID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChzLCBcIndjX3Nlc3Npb25VcGRhdGVcIiwgeyBuYW1lc3BhY2VzOiByIH0pLCB7IGRvbmU6IG8sIHJlc29sdmU6IGMsIHJlamVjdDogdSB9ID0gVGkoKTtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50cy5vbmNlKGtlKFwic2Vzc2lvbl91cGRhdGVcIiwgbiksICh7IGVycm9yOiBkIH0pID0+IHtcbiAgICAgICAgZCA/IHUoZCkgOiBjKCk7XG4gICAgICB9KSwgYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi51cGRhdGUocywgeyBuYW1lc3BhY2VzOiByIH0pLCB7IGFja25vd2xlZGdlZDogbyB9O1xuICAgIH0sIHRoaXMuZXh0ZW5kID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRFeHRlbmQodCk7XG4gICAgICBjb25zdCB7IHRvcGljOiBzIH0gPSB0LCByID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChzLCBcIndjX3Nlc3Npb25FeHRlbmRcIiwge30pLCB7IGRvbmU6IG4sIHJlc29sdmU6IG8sIHJlamVjdDogYyB9ID0gVGkoKTtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50cy5vbmNlKGtlKFwic2Vzc2lvbl9leHRlbmRcIiwgciksICh7IGVycm9yOiB1IH0pID0+IHtcbiAgICAgICAgdSA/IGModSkgOiBvKCk7XG4gICAgICB9KSwgYXdhaXQgdGhpcy5zZXRFeHBpcnkocywgSHQoTHMpKSwgeyBhY2tub3dsZWRnZWQ6IG4gfTtcbiAgICB9LCB0aGlzLnJlcXVlc3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkKCksIGF3YWl0IHRoaXMuaXNWYWxpZFJlcXVlc3QodCk7XG4gICAgICBjb25zdCB7IGNoYWluSWQ6IHMsIHJlcXVlc3Q6IHIsIHRvcGljOiBuLCBleHBpcnk6IG8gfSA9IHQsIGMgPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KG4sIFwid2Nfc2Vzc2lvblJlcXVlc3RcIiwgeyByZXF1ZXN0OiByLCBjaGFpbklkOiBzIH0sIG8pLCB7IGRvbmU6IHUsIHJlc29sdmU6IGQsIHJlamVjdDogcCB9ID0gVGkobyk7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudHMub25jZShrZShcInNlc3Npb25fcmVxdWVzdFwiLCBjKSwgKHsgZXJyb3I6IGIsIHJlc3VsdDogeCB9KSA9PiB7XG4gICAgICAgIGIgPyBwKGIpIDogZCh4KTtcbiAgICAgIH0pLCB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fcmVxdWVzdF9zZW50XCIsIHsgdG9waWM6IG4sIHJlcXVlc3Q6IHIsIGNoYWluSWQ6IHMsIGlkOiBjIH0pLCBhd2FpdCB1KCk7XG4gICAgfSwgdGhpcy5yZXNwb25kID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRSZXNwb25kKHQpO1xuICAgICAgY29uc3QgeyB0b3BpYzogcywgcmVzcG9uc2U6IHIgfSA9IHQsIHsgaWQ6IG4gfSA9IHI7XG4gICAgICBodChyKSA/IGF3YWl0IHRoaXMuc2VuZFJlc3VsdChuLCBzLCByLnJlc3VsdCkgOiBHZShyKSAmJiBhd2FpdCB0aGlzLnNlbmRFcnJvcihuLCBzLCByLmVycm9yKSwgdGhpcy5kZWxldGVQZW5kaW5nU2Vzc2lvblJlcXVlc3QodC5yZXNwb25zZS5pZCwgeyBtZXNzYWdlOiBcImZ1bGZpbGxlZFwiLCBjb2RlOiAwIH0pO1xuICAgIH0sIHRoaXMucGluZyA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgYXdhaXQgdGhpcy5pc1ZhbGlkUGluZyh0KTtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHMgfSA9IHQ7XG4gICAgICBpZiAodGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKHMpKSB7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHMsIFwid2Nfc2Vzc2lvblBpbmdcIiwge30pLCB7IGRvbmU6IG4sIHJlc29sdmU6IG8sIHJlamVjdDogYyB9ID0gVGkoKTtcbiAgICAgICAgdGhpcy5ldmVudHMub25jZShrZShcInNlc3Npb25fcGluZ1wiLCByKSwgKHsgZXJyb3I6IHUgfSkgPT4ge1xuICAgICAgICAgIHUgPyBjKHUpIDogbygpO1xuICAgICAgICB9KSwgYXdhaXQgbigpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5wYWlyaW5ncy5rZXlzLmluY2x1ZGVzKHMpICYmIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5waW5nKHsgdG9waWM6IHMgfSk7XG4gICAgfSwgdGhpcy5lbWl0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWRFbWl0KHQpO1xuICAgICAgY29uc3QgeyB0b3BpYzogcywgZXZlbnQ6IHIsIGNoYWluSWQ6IG4gfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHMsIFwid2Nfc2Vzc2lvbkV2ZW50XCIsIHsgZXZlbnQ6IHIsIGNoYWluSWQ6IG4gfSk7XG4gICAgfSwgdGhpcy5kaXNjb25uZWN0ID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCgpLCBhd2FpdCB0aGlzLmlzVmFsaWREaXNjb25uZWN0KHQpO1xuICAgICAgY29uc3QgeyB0b3BpYzogcyB9ID0gdDtcbiAgICAgIHRoaXMuY2xpZW50LnNlc3Npb24ua2V5cy5pbmNsdWRlcyhzKSA/IChhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHMsIFwid2Nfc2Vzc2lvbkRlbGV0ZVwiLCBKZShcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgYXdhaXQgdGhpcy5kZWxldGVTZXNzaW9uKHMpKSA6IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5kaXNjb25uZWN0KHsgdG9waWM6IHMgfSk7XG4gICAgfSwgdGhpcy5maW5kID0gKHQpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXRBbGwoKS5maWx0ZXIoKHMpID0+IFViKHMsIHQpKSksIHRoaXMuZ2V0UGVuZGluZ1Nlc3Npb25SZXF1ZXN0cyA9ICgpID0+ICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSwgdGhpcy5jbGllbnQucGVuZGluZ1JlcXVlc3QuZ2V0QWxsKCkpLCB0aGlzLmNsZWFudXBEdXBsaWNhdGVQYWlyaW5ncyA9IGFzeW5jICh0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXJpbmdzLmdldCh0LnBhaXJpbmdUb3BpYyksIHIgPSB0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcmluZ3MuZ2V0QWxsKCkuZmlsdGVyKChuKSA9PiB7XG4gICAgICAgICAgdmFyIG8sIGM7XG4gICAgICAgICAgcmV0dXJuICgobyA9IG4ucGVlck1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogby51cmwpICYmICgoYyA9IG4ucGVlck1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogYy51cmwpID09PSB0LnNlbGYubWV0YWRhdGEudXJsICYmIG4udG9waWMgIT09IHMudG9waWM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoci5sZW5ndGggPT09IDApXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIuaW5mbyhgQ2xlYW5pbmcgdXAgJHtyLmxlbmd0aH0gZHVwbGljYXRlIHBhaXJpbmcocylgKSwgYXdhaXQgUHJvbWlzZS5hbGwoci5tYXAoKG4pID0+IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5kaXNjb25uZWN0KHsgdG9waWM6IG4udG9waWMgfSkpKSwgdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oXCJEdXBsaWNhdGUgcGFpcmluZ3MgY2xlYW4gdXAgZmluaXNoZWRcIik7XG4gICAgICB9IGNhdGNoIChzKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihzKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmRlbGV0ZVNlc3Npb24gPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBzZWxmOiByIH0gPSB0aGlzLmNsaWVudC5zZXNzaW9uLmdldCh0KTtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci51bnN1YnNjcmliZSh0KSwgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuY2xpZW50LnNlc3Npb24uZGVsZXRlKHQsIEplKFwiVVNFUl9ESVNDT05ORUNURURcIikpLCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5kZWxldGVLZXlQYWlyKHIucHVibGljS2V5KSwgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZGVsZXRlU3ltS2V5KHQpLCBzID8gUHJvbWlzZS5yZXNvbHZlKCkgOiB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuZGVsKHQpXSk7XG4gICAgfSwgdGhpcy5kZWxldGVQcm9wb3NhbCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5jbGllbnQucHJvcG9zYWwuZGVsZXRlKHQsIEplKFwiVVNFUl9ESVNDT05ORUNURURcIikpLCBzID8gUHJvbWlzZS5yZXNvbHZlKCkgOiB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuZGVsKHQpXSk7XG4gICAgfSwgdGhpcy5kZWxldGVQZW5kaW5nU2Vzc2lvblJlcXVlc3QgPSBhc3luYyAodCwgcywgciA9ICExKSA9PiB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5jbGllbnQucGVuZGluZ1JlcXVlc3QuZGVsZXRlKHQsIHMpLCByID8gUHJvbWlzZS5yZXNvbHZlKCkgOiB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuZGVsKHQpXSk7XG4gICAgfSwgdGhpcy5zZXRFeHBpcnkgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgdGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKHQpICYmIGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24udXBkYXRlKHQsIHsgZXhwaXJ5OiBzIH0pLCB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuc2V0KHQsIHMpO1xuICAgIH0sIHRoaXMuc2V0UHJvcG9zYWwgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQucHJvcG9zYWwuc2V0KHQsIHMpLCB0aGlzLmNsaWVudC5jb3JlLmV4cGlyZXIuc2V0KHQsIHMuZXhwaXJ5KTtcbiAgICB9LCB0aGlzLnNldFBlbmRpbmdTZXNzaW9uUmVxdWVzdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBjb25zdCBzID0gbnMud2Nfc2Vzc2lvblJlcXVlc3QucmVxLnR0bCwgeyBpZDogciwgdG9waWM6IG4sIHBhcmFtczogbyB9ID0gdDtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnBlbmRpbmdSZXF1ZXN0LnNldChyLCB7IGlkOiByLCB0b3BpYzogbiwgcGFyYW1zOiBvIH0pLCBzICYmIHRoaXMuY2xpZW50LmNvcmUuZXhwaXJlci5zZXQociwgSHQocykpO1xuICAgIH0sIHRoaXMuc2VuZFJlcXVlc3QgPSBhc3luYyAodCwgcywgciwgbikgPT4ge1xuICAgICAgY29uc3QgbyA9IHRpKHMsIHIpO1xuICAgICAgaWYgKE5uKCkgJiYgRnYuaW5jbHVkZXMocykpIHtcbiAgICAgICAgY29uc3QgZCA9IFVpKEpTT04uc3RyaW5naWZ5KG8pKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY29yZS52ZXJpZnkucmVnaXN0ZXIoeyBhdHRlc3RhdGlvbklkOiBkIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgYyA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmVuY29kZSh0LCBvKSwgdSA9IG5zW3NdLnJlcTtcbiAgICAgIHJldHVybiBuICYmICh1LnR0bCA9IG4pLCB0aGlzLmNsaWVudC5jb3JlLmhpc3Rvcnkuc2V0KHQsIG8pLCB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIucHVibGlzaCh0LCBjLCB1KSwgby5pZDtcbiAgICB9LCB0aGlzLnNlbmRSZXN1bHQgPSBhc3luYyAodCwgcywgcikgPT4ge1xuICAgICAgY29uc3QgbiA9IHhpKHQsIHIpLCBvID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5jcnlwdG8uZW5jb2RlKHMsIG4pLCBjID0gYXdhaXQgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LmdldChzLCB0KSwgdSA9IG5zW2MucmVxdWVzdC5tZXRob2RdLnJlcztcbiAgICAgIHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5wdWJsaXNoKHMsIG8sIHUpLCBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkucmVzb2x2ZShuKTtcbiAgICB9LCB0aGlzLnNlbmRFcnJvciA9IGFzeW5jICh0LCBzLCByKSA9PiB7XG4gICAgICBjb25zdCBuID0gcWkodCwgciksIG8gPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmNyeXB0by5lbmNvZGUocywgbiksIGMgPSBhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkuZ2V0KHMsIHQpLCB1ID0gbnNbYy5yZXF1ZXN0Lm1ldGhvZF0ucmVzO1xuICAgICAgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLnB1Ymxpc2gocywgbywgdSksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuaGlzdG9yeS5yZXNvbHZlKG4pO1xuICAgIH0sIHRoaXMuY2xlYW51cCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBbXSwgcyA9IFtdO1xuICAgICAgdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXRBbGwoKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIGNpKHIuZXhwaXJ5KSAmJiB0LnB1c2goci50b3BpYyk7XG4gICAgICB9KSwgdGhpcy5jbGllbnQucHJvcG9zYWwuZ2V0QWxsKCkuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICBjaShyLmV4cGlyeSkgJiYgcy5wdXNoKHIuaWQpO1xuICAgICAgfSksIGF3YWl0IFByb21pc2UuYWxsKFsuLi50Lm1hcCgocikgPT4gdGhpcy5kZWxldGVTZXNzaW9uKHIpKSwgLi4ucy5tYXAoKHIpID0+IHRoaXMuZGVsZXRlUHJvcG9zYWwocikpXSk7XG4gICAgfSwgdGhpcy5vblJlbGF5RXZlbnRSZXF1ZXN0ID0gKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHMsIHBheWxvYWQ6IHIgfSA9IHQsIG4gPSByLm1ldGhvZDtcbiAgICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblByb3Bvc2VcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25Qcm9wb3NlUmVxdWVzdChzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25TZXR0bGVcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25TZXR0bGVSZXF1ZXN0KHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblVwZGF0ZVwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblVwZGF0ZVJlcXVlc3Qocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uRXh0ZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uRXh0ZW5kUmVxdWVzdChzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25QaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uUGluZ1JlcXVlc3Qocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uRGVsZXRlXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uRGVsZXRlUmVxdWVzdChzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25SZXF1ZXN0XCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uUmVxdWVzdChzLCByKTtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25FdmVudFwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvbkV2ZW50UmVxdWVzdChzLCByKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oYFVuc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kICR7bn1gKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uUmVsYXlFdmVudFJlc3BvbnNlID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHMsIHBheWxvYWQ6IHIgfSA9IHQsIG4gPSAoYXdhaXQgdGhpcy5jbGllbnQuY29yZS5oaXN0b3J5LmdldChzLCByLmlkKSkucmVxdWVzdC5tZXRob2Q7XG4gICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSBcIndjX3Nlc3Npb25Qcm9wb3NlXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlKHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblNldHRsZVwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblNldHRsZVJlc3BvbnNlKHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblVwZGF0ZVwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblVwZGF0ZVJlc3BvbnNlKHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvbkV4dGVuZFwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvbkV4dGVuZFJlc3BvbnNlKHMsIHIpO1xuICAgICAgICBjYXNlIFwid2Nfc2Vzc2lvblBpbmdcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblNlc3Npb25QaW5nUmVzcG9uc2Uocywgcik7XG4gICAgICAgIGNhc2UgXCJ3Y19zZXNzaW9uUmVxdWVzdFwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLm9uU2Vzc2lvblJlcXVlc3RSZXNwb25zZShzLCByKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oYFVuc3VwcG9ydGVkIHJlc3BvbnNlIG1ldGhvZCAke259YCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblNlc3Npb25Qcm9wb3NlUmVxdWVzdCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IHBhcmFtczogciwgaWQ6IG4gfSA9IHM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWRDb25uZWN0KEF0KHt9LCBzLnBhcmFtcykpO1xuICAgICAgICBjb25zdCBvID0gSHQoVi5GSVZFX01JTlVURVMpLCBjID0gQXQoeyBpZDogbiwgcGFpcmluZ1RvcGljOiB0LCBleHBpcnk6IG8gfSwgcik7XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0UHJvcG9zYWwobiwgYyk7XG4gICAgICAgIGNvbnN0IHUgPSBVaShKU09OLnN0cmluZ2lmeShzKSksIGQgPSBhd2FpdCB0aGlzLmdldFZlcmlmeUNvbnRleHQodSwgYy5wcm9wb3Nlci5tZXRhZGF0YSk7XG4gICAgICAgIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9wcm9wb3NhbFwiLCB7IGlkOiBuLCBwYXJhbXM6IGMsIHZlcmlmeUNvbnRleHQ6IGQgfSk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKG4sIHQsIG8pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iobyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblNlc3Npb25Qcm9wb3NlUmVzcG9uc2UgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIGlmIChodChzKSkge1xuICAgICAgICBjb25zdCB7IHJlc3VsdDogbiB9ID0gcztcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcIm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZVwiLCByZXN1bHQ6IG4gfSk7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLmNsaWVudC5wcm9wb3NhbC5nZXQocik7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJvblNlc3Npb25Qcm9wb3NlUmVzcG9uc2VcIiwgcHJvcG9zYWw6IG8gfSk7XG4gICAgICAgIGNvbnN0IGMgPSBvLnByb3Bvc2VyLnB1YmxpY0tleTtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyLnRyYWNlKHsgdHlwZTogXCJtZXRob2RcIiwgbWV0aG9kOiBcIm9uU2Vzc2lvblByb3Bvc2VSZXNwb25zZVwiLCBzZWxmUHVibGljS2V5OiBjIH0pO1xuICAgICAgICBjb25zdCB1ID0gbi5yZXNwb25kZXJQdWJsaWNLZXk7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJvblNlc3Npb25Qcm9wb3NlUmVzcG9uc2VcIiwgcGVlclB1YmxpY0tleTogdSB9KTtcbiAgICAgICAgY29uc3QgZCA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmdlbmVyYXRlU2hhcmVkS2V5KGMsIHUpO1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIudHJhY2UoeyB0eXBlOiBcIm1ldGhvZFwiLCBtZXRob2Q6IFwib25TZXNzaW9uUHJvcG9zZVJlc3BvbnNlXCIsIHNlc3Npb25Ub3BpYzogZCB9KTtcbiAgICAgICAgY29uc3QgcCA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucmVsYXllci5zdWJzY3JpYmUoZCk7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlci50cmFjZSh7IHR5cGU6IFwibWV0aG9kXCIsIG1ldGhvZDogXCJvblNlc3Npb25Qcm9wb3NlUmVzcG9uc2VcIiwgc3Vic2NyaXB0aW9uSWQ6IHAgfSksIGF3YWl0IHRoaXMuY2xpZW50LmNvcmUucGFpcmluZy5hY3RpdmF0ZSh7IHRvcGljOiB0IH0pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIEdlKHMpICYmIChhd2FpdCB0aGlzLmNsaWVudC5wcm9wb3NhbC5kZWxldGUociwgSmUoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSksIHRoaXMuZXZlbnRzLmVtaXQoa2UoXCJzZXNzaW9uX2Nvbm5lY3RcIiksIHsgZXJyb3I6IHMuZXJyb3IgfSkpO1xuICAgIH0sIHRoaXMub25TZXNzaW9uU2V0dGxlUmVxdWVzdCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByLCBwYXJhbXM6IG4gfSA9IHM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWRTZXNzaW9uU2V0dGxlUmVxdWVzdChuKTtcbiAgICAgICAgY29uc3QgeyByZWxheTogbywgY29udHJvbGxlcjogYywgZXhwaXJ5OiB1LCBuYW1lc3BhY2VzOiBkLCByZXF1aXJlZE5hbWVzcGFjZXM6IHAsIG9wdGlvbmFsTmFtZXNwYWNlczogYiwgc2Vzc2lvblByb3BlcnRpZXM6IHgsIHBhaXJpbmdUb3BpYzogTyB9ID0gcy5wYXJhbXMsIF8gPSBBdCh7IHRvcGljOiB0LCByZWxheTogbywgZXhwaXJ5OiB1LCBuYW1lc3BhY2VzOiBkLCBhY2tub3dsZWRnZWQ6ICEwLCBwYWlyaW5nVG9waWM6IE8sIHJlcXVpcmVkTmFtZXNwYWNlczogcCwgb3B0aW9uYWxOYW1lc3BhY2VzOiBiLCBjb250cm9sbGVyOiBjLnB1YmxpY0tleSwgc2VsZjogeyBwdWJsaWNLZXk6IFwiXCIsIG1ldGFkYXRhOiB0aGlzLmNsaWVudC5tZXRhZGF0YSB9LCBwZWVyOiB7IHB1YmxpY0tleTogYy5wdWJsaWNLZXksIG1ldGFkYXRhOiBjLm1ldGFkYXRhIH0gfSwgeCAmJiB7IHNlc3Npb25Qcm9wZXJ0aWVzOiB4IH0pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRSZXN1bHQocy5pZCwgdCwgITApLCB0aGlzLmV2ZW50cy5lbWl0KGtlKFwic2Vzc2lvbl9jb25uZWN0XCIpLCB7IHNlc3Npb246IF8gfSksIHRoaXMuY2xlYW51cER1cGxpY2F0ZVBhaXJpbmdzKF8pO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihyLCB0LCBvKSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG8pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uU2V0dGxlUmVzcG9uc2UgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIGh0KHMpID8gKGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24udXBkYXRlKHQsIHsgYWNrbm93bGVkZ2VkOiAhMCB9KSwgdGhpcy5ldmVudHMuZW1pdChrZShcInNlc3Npb25fYXBwcm92ZVwiLCByKSwge30pKSA6IEdlKHMpICYmIChhd2FpdCB0aGlzLmNsaWVudC5zZXNzaW9uLmRlbGV0ZSh0LCBKZShcIlVTRVJfRElTQ09OTkVDVEVEXCIpKSwgdGhpcy5ldmVudHMuZW1pdChrZShcInNlc3Npb25fYXBwcm92ZVwiLCByKSwgeyBlcnJvcjogcy5lcnJvciB9KSk7XG4gICAgfSwgdGhpcy5vblNlc3Npb25VcGRhdGVSZXF1ZXN0ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zOiByLCBpZDogbiB9ID0gcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZFVwZGF0ZShBdCh7IHRvcGljOiB0IH0sIHIpKSwgYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi51cGRhdGUodCwgeyBuYW1lc3BhY2VzOiByLm5hbWVzcGFjZXMgfSksIGF3YWl0IHRoaXMuc2VuZFJlc3VsdChuLCB0LCAhMCksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl91cGRhdGVcIiwgeyBpZDogbiwgdG9waWM6IHQsIHBhcmFtczogciB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IobiwgdCwgbyksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uU2Vzc2lvblVwZGF0ZVJlc3BvbnNlID0gKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIgfSA9IHM7XG4gICAgICBodChzKSA/IHRoaXMuZXZlbnRzLmVtaXQoa2UoXCJzZXNzaW9uX3VwZGF0ZVwiLCByKSwge30pIDogR2UocykgJiYgdGhpcy5ldmVudHMuZW1pdChrZShcInNlc3Npb25fdXBkYXRlXCIsIHIpLCB7IGVycm9yOiBzLmVycm9yIH0pO1xuICAgIH0sIHRoaXMub25TZXNzaW9uRXh0ZW5kUmVxdWVzdCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByIH0gPSBzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pc1ZhbGlkRXh0ZW5kKHsgdG9waWM6IHQgfSksIGF3YWl0IHRoaXMuc2V0RXhwaXJ5KHQsIEh0KExzKSksIGF3YWl0IHRoaXMuc2VuZFJlc3VsdChyLCB0LCAhMCksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9leHRlbmRcIiwgeyBpZDogciwgdG9waWM6IHQgfSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVycm9yKHIsIHQsIG4pLCB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iobik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5vblNlc3Npb25FeHRlbmRSZXNwb25zZSA9ICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByIH0gPSBzO1xuICAgICAgaHQocykgPyB0aGlzLmV2ZW50cy5lbWl0KGtlKFwic2Vzc2lvbl9leHRlbmRcIiwgciksIHt9KSA6IEdlKHMpICYmIHRoaXMuZXZlbnRzLmVtaXQoa2UoXCJzZXNzaW9uX2V4dGVuZFwiLCByKSwgeyBlcnJvcjogcy5lcnJvciB9KTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvblBpbmdSZXF1ZXN0ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIgfSA9IHM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWRQaW5nKHsgdG9waWM6IHQgfSksIGF3YWl0IHRoaXMuc2VuZFJlc3VsdChyLCB0LCAhMCksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9waW5nXCIsIHsgaWQ6IHIsIHRvcGljOiB0IH0pO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihyLCB0LCBuKSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG4pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uUGluZ1Jlc3BvbnNlID0gKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIgfSA9IHM7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaHQocykgPyB0aGlzLmV2ZW50cy5lbWl0KGtlKFwic2Vzc2lvbl9waW5nXCIsIHIpLCB7fSkgOiBHZShzKSAmJiB0aGlzLmV2ZW50cy5lbWl0KGtlKFwic2Vzc2lvbl9waW5nXCIsIHIpLCB7IGVycm9yOiBzLmVycm9yIH0pO1xuICAgICAgfSwgNTAwKTtcbiAgICB9LCB0aGlzLm9uU2Vzc2lvbkRlbGV0ZVJlcXVlc3QgPSBhc3luYyAodCwgcykgPT4ge1xuICAgICAgY29uc3QgeyBpZDogciB9ID0gcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZERpc2Nvbm5lY3QoeyB0b3BpYzogdCwgcmVhc29uOiBzLnBhcmFtcyB9KSwgYXdhaXQgUHJvbWlzZS5hbGwoW25ldyBQcm9taXNlKChuKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbGllbnQuY29yZS5yZWxheWVyLm9uY2UoSGUucHVibGlzaCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbihhd2FpdCB0aGlzLmRlbGV0ZVNlc3Npb24odCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgdGhpcy5zZW5kUmVzdWx0KHIsIHQsICEwKV0pLCB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fZGVsZXRlXCIsIHsgaWQ6IHIsIHRvcGljOiB0IH0pO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihyLCB0LCBuKSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG4pO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25TZXNzaW9uUmVxdWVzdCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByLCBwYXJhbXM6IG4gfSA9IHM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlzVmFsaWRSZXF1ZXN0KEF0KHsgdG9waWM6IHQgfSwgbikpLCBhd2FpdCB0aGlzLnNldFBlbmRpbmdTZXNzaW9uUmVxdWVzdCh7IGlkOiByLCB0b3BpYzogdCwgcGFyYW1zOiBuIH0pO1xuICAgICAgICBjb25zdCBvID0gVWkoSlNPTi5zdHJpbmdpZnkocykpLCBjID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQodCksIHUgPSBhd2FpdCB0aGlzLmdldFZlcmlmeUNvbnRleHQobywgYy5wZWVyLm1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5jbGllbnQuZXZlbnRzLmVtaXQoXCJzZXNzaW9uX3JlcXVlc3RcIiwgeyBpZDogciwgdG9waWM6IHQsIHBhcmFtczogbiwgdmVyaWZ5Q29udGV4dDogdSB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRXJyb3IociwgdCwgbyksIHRoaXMuY2xpZW50LmxvZ2dlci5lcnJvcihvKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uU2Vzc2lvblJlcXVlc3RSZXNwb25zZSA9ICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCB7IGlkOiByIH0gPSBzO1xuICAgICAgaHQocykgPyB0aGlzLmV2ZW50cy5lbWl0KGtlKFwic2Vzc2lvbl9yZXF1ZXN0XCIsIHIpLCB7IHJlc3VsdDogcy5yZXN1bHQgfSkgOiBHZShzKSAmJiB0aGlzLmV2ZW50cy5lbWl0KGtlKFwic2Vzc2lvbl9yZXF1ZXN0XCIsIHIpLCB7IGVycm9yOiBzLmVycm9yIH0pO1xuICAgIH0sIHRoaXMub25TZXNzaW9uRXZlbnRSZXF1ZXN0ID0gYXN5bmMgKHQsIHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQ6IHIsIHBhcmFtczogbiB9ID0gcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaXNWYWxpZEVtaXQoQXQoeyB0b3BpYzogdCB9LCBuKSksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwic2Vzc2lvbl9ldmVudFwiLCB7IGlkOiByLCB0b3BpYzogdCwgcGFyYW1zOiBuIH0pO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFcnJvcihyLCB0LCBvKSwgdGhpcy5jbGllbnQubG9nZ2VyLmVycm9yKG8pO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaXNWYWxpZENvbm5lY3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFJdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHUgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGNvbm5lY3QoKSBwYXJhbXM6ICR7SlNPTi5zdHJpbmdpZnkodCl9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgcGFpcmluZ1RvcGljOiBzLCByZXF1aXJlZE5hbWVzcGFjZXM6IHIsIG9wdGlvbmFsTmFtZXNwYWNlczogbiwgc2Vzc2lvblByb3BlcnRpZXM6IG8sIHJlbGF5czogYyB9ID0gdDtcbiAgICAgIGlmICh3dChzKSB8fCBhd2FpdCB0aGlzLmlzVmFsaWRQYWlyaW5nVG9waWMocyksICFXYihjLCAhMCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB1IH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBjb25uZWN0KCkgcmVsYXlzOiAke2N9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1KTtcbiAgICAgIH1cbiAgICAgICF3dChyKSAmJiB1cyhyKSAhPT0gMCAmJiB0aGlzLnZhbGlkYXRlTmFtZXNwYWNlcyhyLCBcInJlcXVpcmVkTmFtZXNwYWNlc1wiKSwgIXd0KG4pICYmIHVzKG4pICE9PSAwICYmIHRoaXMudmFsaWRhdGVOYW1lc3BhY2VzKG4sIFwib3B0aW9uYWxOYW1lc3BhY2VzXCIpLCB3dChvKSB8fCB0aGlzLnZhbGlkYXRlU2Vzc2lvblByb3BzKG8sIFwic2Vzc2lvblByb3BlcnRpZXNcIik7XG4gICAgfSwgdGhpcy52YWxpZGF0ZU5hbWVzcGFjZXMgPSAodCwgcykgPT4ge1xuICAgICAgY29uc3QgciA9IEdiKHQsIFwiY29ubmVjdCgpXCIsIHMpO1xuICAgICAgaWYgKHIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyLm1lc3NhZ2UpO1xuICAgIH0sIHRoaXMuaXNWYWxpZEFwcHJvdmUgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFJdCh0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGFwcHJvdmUoKSBwYXJhbXM6ICR7dH1gKS5tZXNzYWdlKTtcbiAgICAgIGNvbnN0IHsgaWQ6IHMsIG5hbWVzcGFjZXM6IHIsIHJlbGF5UHJvdG9jb2w6IG4sIHNlc3Npb25Qcm9wZXJ0aWVzOiBvIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkUHJvcG9zYWxJZChzKTtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmNsaWVudC5wcm9wb3NhbC5nZXQocyksIHUgPSBCcyhyLCBcImFwcHJvdmUoKVwiKTtcbiAgICAgIGlmICh1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodS5tZXNzYWdlKTtcbiAgICAgIGNvbnN0IGQgPSBJYShjLnJlcXVpcmVkTmFtZXNwYWNlcywgciwgXCJhcHByb3ZlKClcIik7XG4gICAgICBpZiAoZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGQubWVzc2FnZSk7XG4gICAgICBpZiAoIWF0KG4sICEwKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHAgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGFwcHJvdmUoKSByZWxheVByb3RvY29sOiAke259YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwKTtcbiAgICAgIH1cbiAgICAgIHd0KG8pIHx8IHRoaXMudmFsaWRhdGVTZXNzaW9uUHJvcHMobywgXCJzZXNzaW9uUHJvcGVydGllc1wiKTtcbiAgICB9LCB0aGlzLmlzVmFsaWRSZWplY3QgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFJdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlamVjdCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGlkOiBzLCByZWFzb246IHIgfSA9IHQ7XG4gICAgICBpZiAoYXdhaXQgdGhpcy5pc1ZhbGlkUHJvcG9zYWxJZChzKSwgIUpiKHIpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogbiB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVqZWN0KCkgcmVhc29uOiAke0pTT04uc3RyaW5naWZ5KHIpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1ZhbGlkU2Vzc2lvblNldHRsZVJlcXVlc3QgPSAodCkgPT4ge1xuICAgICAgaWYgKCFJdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGQgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYG9uU2Vzc2lvblNldHRsZVJlcXVlc3QoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGQpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyByZWxheTogcywgY29udHJvbGxlcjogciwgbmFtZXNwYWNlczogbiwgZXhwaXJ5OiBvIH0gPSB0O1xuICAgICAgaWYgKCFEaChzKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGQgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgXCJvblNlc3Npb25TZXR0bGVSZXF1ZXN0KCkgcmVsYXkgcHJvdG9jb2wgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjID0gemIociwgXCJvblNlc3Npb25TZXR0bGVSZXF1ZXN0KClcIik7XG4gICAgICBpZiAoYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMubWVzc2FnZSk7XG4gICAgICBjb25zdCB1ID0gQnMobiwgXCJvblNlc3Npb25TZXR0bGVSZXF1ZXN0KClcIik7XG4gICAgICBpZiAodSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUubWVzc2FnZSk7XG4gICAgICBpZiAoY2kobykpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBkIH0gPSBKKFwiRVhQSVJFRFwiLCBcIm9uU2Vzc2lvblNldHRsZVJlcXVlc3QoKVwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGQpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaXNWYWxpZFVwZGF0ZSA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIUl0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdSB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgdXBkYXRlKCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IHMsIG5hbWVzcGFjZXM6IHIgfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uVG9waWMocyk7XG4gICAgICBjb25zdCBuID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQocyksIG8gPSBCcyhyLCBcInVwZGF0ZSgpXCIpO1xuICAgICAgaWYgKG8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihvLm1lc3NhZ2UpO1xuICAgICAgY29uc3QgYyA9IElhKG4ucmVxdWlyZWROYW1lc3BhY2VzLCByLCBcInVwZGF0ZSgpXCIpO1xuICAgICAgaWYgKGMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjLm1lc3NhZ2UpO1xuICAgIH0sIHRoaXMuaXNWYWxpZEV4dGVuZCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIUl0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogciB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZXh0ZW5kKCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IHMgfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uVG9waWMocyk7XG4gICAgfSwgdGhpcy5pc1ZhbGlkUmVxdWVzdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIUl0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdSB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVxdWVzdCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodSk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCByZXF1ZXN0OiByLCBjaGFpbklkOiBuLCBleHBpcnk6IG8gfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uVG9waWMocyk7XG4gICAgICBjb25zdCB7IG5hbWVzcGFjZXM6IGMgfSA9IHRoaXMuY2xpZW50LnNlc3Npb24uZ2V0KHMpO1xuICAgICAgaWYgKCFTYShjLCBuKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IHUgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlcXVlc3QoKSBjaGFpbklkOiAke259YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1KTtcbiAgICAgIH1cbiAgICAgIGlmICghUWIocikpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB1IH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZXF1ZXN0KCkgJHtKU09OLnN0cmluZ2lmeShyKX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUpO1xuICAgICAgfVxuICAgICAgaWYgKCFldyhjLCBuLCByLm1ldGhvZCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiB1IH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZXF1ZXN0KCkgbWV0aG9kOiAke3IubWV0aG9kfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodSk7XG4gICAgICB9XG4gICAgICBpZiAobyAmJiAhcncobywgVXIpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogdSB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgcmVxdWVzdCgpIGV4cGlyeTogJHtvfS4gRXhwaXJ5IG11c3QgYmUgYSBudW1iZXIgKGluIHNlY29uZHMpIGJldHdlZW4gJHtVci5taW59IGFuZCAke1VyLm1heH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHUpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaXNWYWxpZFJlc3BvbmQgPSBhc3luYyAodCkgPT4ge1xuICAgICAgaWYgKCFJdCh0KSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG4gfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHJlc3BvbmQoKSBwYXJhbXM6ICR7dH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG4pO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB0b3BpYzogcywgcmVzcG9uc2U6IHIgfSA9IHQ7XG4gICAgICBpZiAoYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvblRvcGljKHMpLCAhWGIocikpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGByZXNwb25kKCkgcmVzcG9uc2U6ICR7SlNPTi5zdHJpbmdpZnkocil9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmlzVmFsaWRQaW5nID0gYXN5bmMgKHQpID0+IHtcbiAgICAgIGlmICghSXQodCkpIHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiByIH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwaW5nKCkgcGFyYW1zOiAke3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdG9waWM6IHMgfSA9IHQ7XG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uT3JQYWlyaW5nVG9waWMocyk7XG4gICAgfSwgdGhpcy5pc1ZhbGlkRW1pdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIUl0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogYyB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZW1pdCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYyk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBzLCBldmVudDogciwgY2hhaW5JZDogbiB9ID0gdDtcbiAgICAgIGF3YWl0IHRoaXMuaXNWYWxpZFNlc3Npb25Ub3BpYyhzKTtcbiAgICAgIGNvbnN0IHsgbmFtZXNwYWNlczogbyB9ID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQocyk7XG4gICAgICBpZiAoIVNhKG8sIG4pKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogYyB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZW1pdCgpIGNoYWluSWQ6ICR7bn1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMpO1xuICAgICAgfVxuICAgICAgaWYgKCFaYihyKSkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGMgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYGVtaXQoKSBldmVudDogJHtKU09OLnN0cmluZ2lmeShyKX1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMpO1xuICAgICAgfVxuICAgICAgaWYgKCF0dyhvLCBuLCByLm5hbWUpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogYyB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZW1pdCgpIGV2ZW50OiAke0pTT04uc3RyaW5naWZ5KHIpfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYyk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pc1ZhbGlkRGlzY29ubmVjdCA9IGFzeW5jICh0KSA9PiB7XG4gICAgICBpZiAoIUl0KHQpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZTogciB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgZGlzY29ubmVjdCgpIHBhcmFtczogJHt0fWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcGljOiBzIH0gPSB0O1xuICAgICAgYXdhaXQgdGhpcy5pc1ZhbGlkU2Vzc2lvbk9yUGFpcmluZ1RvcGljKHMpO1xuICAgIH0sIHRoaXMuZ2V0VmVyaWZ5Q29udGV4dCA9IGFzeW5jICh0LCBzKSA9PiB7XG4gICAgICBjb25zdCByID0geyB2ZXJpZmllZDogeyB2ZXJpZnlVcmw6IHMudmVyaWZ5VXJsIHx8IFwiXCIsIHZhbGlkYXRpb246IFwiVU5LTk9XTlwiLCBvcmlnaW46IHMudXJsIHx8IFwiXCIgfSB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbiA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUudmVyaWZ5LnJlc29sdmUoeyBhdHRlc3RhdGlvbklkOiB0LCB2ZXJpZnlVcmw6IHMudmVyaWZ5VXJsIH0pO1xuICAgICAgICBuICYmIChyLnZlcmlmaWVkLm9yaWdpbiA9IG4sIHIudmVyaWZpZWQudmFsaWRhdGlvbiA9IG4gPT09IHMudXJsID8gXCJWQUxJRFwiIDogXCJJTlZBTElEXCIpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIuZXJyb3Iobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jbGllbnQubG9nZ2VyLmluZm8oYFZlcmlmeSBjb250ZXh0OiAke0pTT04uc3RyaW5naWZ5KHIpfWApLCByO1xuICAgIH0sIHRoaXMudmFsaWRhdGVTZXNzaW9uUHJvcHMgPSAodCwgcykgPT4ge1xuICAgICAgT2JqZWN0LnZhbHVlcyh0KS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgIGlmICghYXQociwgITEpKSB7XG4gICAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBuIH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGAke3N9IG11c3QgYmUgaW4gUmVjb3JkPHN0cmluZywgc3RyaW5nPiBmb3JtYXQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHIpfWApO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBpc0luaXRpYWxpemVkKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiBlIH0gPSBKKFwiTk9UX0lOSVRJQUxJWkVEXCIsIHRoaXMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyUmVsYXllckV2ZW50cygpIHtcbiAgICB0aGlzLmNsaWVudC5jb3JlLnJlbGF5ZXIub24oSGUubWVzc2FnZSwgYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHQsIG1lc3NhZ2U6IHMgfSA9IGU7XG4gICAgICBpZiAodGhpcy5pZ25vcmVkUGF5bG9hZFR5cGVzLmluY2x1ZGVzKHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmdldFBheWxvYWRUeXBlKHMpKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuY2xpZW50LmNvcmUuY3J5cHRvLmRlY29kZSh0LCBzKTtcbiAgICAgIGppKHIpID8gKHRoaXMuY2xpZW50LmNvcmUuaGlzdG9yeS5zZXQodCwgciksIHRoaXMub25SZWxheUV2ZW50UmVxdWVzdCh7IHRvcGljOiB0LCBwYXlsb2FkOiByIH0pKSA6IE9pKHIpICYmIChhd2FpdCB0aGlzLmNsaWVudC5jb3JlLmhpc3RvcnkucmVzb2x2ZShyKSwgdGhpcy5vblJlbGF5RXZlbnRSZXNwb25zZSh7IHRvcGljOiB0LCBwYXlsb2FkOiByIH0pKTtcbiAgICB9KTtcbiAgfVxuICByZWdpc3RlckV4cGlyZXJFdmVudHMoKSB7XG4gICAgdGhpcy5jbGllbnQuY29yZS5leHBpcmVyLm9uKCR0LmV4cGlyZWQsIGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCB7IHRvcGljOiB0LCBpZDogcyB9ID0gU2goZS50YXJnZXQpO1xuICAgICAgaWYgKHMgJiYgdGhpcy5jbGllbnQucGVuZGluZ1JlcXVlc3Qua2V5cy5pbmNsdWRlcyhzKSlcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVsZXRlUGVuZGluZ1Nlc3Npb25SZXF1ZXN0KHMsIEooXCJFWFBJUkVEXCIpLCAhMCk7XG4gICAgICB0ID8gdGhpcy5jbGllbnQuc2Vzc2lvbi5rZXlzLmluY2x1ZGVzKHQpICYmIChhd2FpdCB0aGlzLmRlbGV0ZVNlc3Npb24odCwgITApLCB0aGlzLmNsaWVudC5ldmVudHMuZW1pdChcInNlc3Npb25fZXhwaXJlXCIsIHsgdG9waWM6IHQgfSkpIDogcyAmJiAoYXdhaXQgdGhpcy5kZWxldGVQcm9wb3NhbChzLCAhMCksIHRoaXMuY2xpZW50LmV2ZW50cy5lbWl0KFwicHJvcG9zYWxfZXhwaXJlXCIsIHsgaWQ6IHMgfSkpO1xuICAgIH0pO1xuICB9XG4gIGlzVmFsaWRQYWlyaW5nVG9waWMoZSkge1xuICAgIGlmICghYXQoZSwgITEpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IEooXCJNSVNTSU5HX09SX0lOVkFMSURcIiwgYHBhaXJpbmcgdG9waWMgc2hvdWxkIGJlIGEgc3RyaW5nOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXJpbmdzLmtleXMuaW5jbHVkZXMoZSkpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gSihcIk5PX01BVENISU5HX0tFWVwiLCBgcGFpcmluZyB0b3BpYyBkb2Vzbid0IGV4aXN0OiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmIChjaSh0aGlzLmNsaWVudC5jb3JlLnBhaXJpbmcucGFpcmluZ3MuZ2V0KGUpLmV4cGlyeSkpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gSihcIkVYUElSRURcIiwgYHBhaXJpbmcgdG9waWM6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaXNWYWxpZFNlc3Npb25Ub3BpYyhlKSB7XG4gICAgaWYgKCFhdChlLCAhMSkpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgc2Vzc2lvbiB0b3BpYyBzaG91bGQgYmUgYSBzdHJpbmc6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNsaWVudC5zZXNzaW9uLmtleXMuaW5jbHVkZXMoZSkpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gSihcIk5PX01BVENISU5HX0tFWVwiLCBgc2Vzc2lvbiB0b3BpYyBkb2Vzbid0IGV4aXN0OiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICAgIGlmIChjaSh0aGlzLmNsaWVudC5zZXNzaW9uLmdldChlKS5leHBpcnkpKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlbGV0ZVNlc3Npb24oZSk7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IEooXCJFWFBJUkVEXCIsIGBzZXNzaW9uIHRvcGljOiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGlzVmFsaWRTZXNzaW9uT3JQYWlyaW5nVG9waWMoZSkge1xuICAgIGlmICh0aGlzLmNsaWVudC5zZXNzaW9uLmtleXMuaW5jbHVkZXMoZSkpXG4gICAgICBhd2FpdCB0aGlzLmlzVmFsaWRTZXNzaW9uVG9waWMoZSk7XG4gICAgZWxzZSBpZiAodGhpcy5jbGllbnQuY29yZS5wYWlyaW5nLnBhaXJpbmdzLmtleXMuaW5jbHVkZXMoZSkpXG4gICAgICB0aGlzLmlzVmFsaWRQYWlyaW5nVG9waWMoZSk7XG4gICAgZWxzZSBpZiAoYXQoZSwgITEpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IEooXCJOT19NQVRDSElOR19LRVlcIiwgYHNlc3Npb24gb3IgcGFpcmluZyB0b3BpYyBkb2Vzbid0IGV4aXN0OiAke2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZTogdCB9ID0gSihcIk1JU1NJTkdfT1JfSU5WQUxJRFwiLCBgc2Vzc2lvbiBvciBwYWlyaW5nIHRvcGljIHNob3VsZCBiZSBhIHN0cmluZzogJHtlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBpc1ZhbGlkUHJvcG9zYWxJZChlKSB7XG4gICAgaWYgKCFZYihlKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBKKFwiTUlTU0lOR19PUl9JTlZBTElEXCIsIGBwcm9wb3NhbCBpZCBzaG91bGQgYmUgYSBudW1iZXI6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNsaWVudC5wcm9wb3NhbC5rZXlzLmluY2x1ZGVzKGUpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2U6IHQgfSA9IEooXCJOT19NQVRDSElOR19LRVlcIiwgYHByb3Bvc2FsIGlkIGRvZXNuJ3QgZXhpc3Q6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gICAgaWYgKGNpKHRoaXMuY2xpZW50LnByb3Bvc2FsLmdldChlKS5leHBpcnkpKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlbGV0ZVByb3Bvc2FsKGUpO1xuICAgICAgY29uc3QgeyBtZXNzYWdlOiB0IH0gPSBKKFwiRVhQSVJFRFwiLCBgcHJvcG9zYWwgaWQ6ICR7ZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0KTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEt2IGV4dGVuZHMgcHIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCwgUnYsIEFuKSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59XG5jbGFzcyBWdiBleHRlbmRzIHByIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQsIEF2LCBBbiksIHRoaXMuY29yZSA9IGUsIHRoaXMubG9nZ2VyID0gdDtcbiAgfVxufVxuY2xhc3MgQnYgZXh0ZW5kcyBwciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0LCAkdiwgQW4sIChzKSA9PiBzLmlkKSwgdGhpcy5jb3JlID0gZSwgdGhpcy5sb2dnZXIgPSB0O1xuICB9XG59XG5jbGFzcyBUbiBleHRlbmRzIHptIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLnByb3RvY29sID0gemgsIHRoaXMudmVyc2lvbiA9IEtoLCB0aGlzLm5hbWUgPSBGci5uYW1lLCB0aGlzLmV2ZW50cyA9IG5ldyBXZS5FdmVudEVtaXR0ZXIoKSwgdGhpcy5vbiA9IChzLCByKSA9PiB0aGlzLmV2ZW50cy5vbihzLCByKSwgdGhpcy5vbmNlID0gKHMsIHIpID0+IHRoaXMuZXZlbnRzLm9uY2UocywgciksIHRoaXMub2ZmID0gKHMsIHIpID0+IHRoaXMuZXZlbnRzLm9mZihzLCByKSwgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IChzLCByKSA9PiB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcihzLCByKSwgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSAocykgPT4gdGhpcy5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKHMpLCB0aGlzLmNvbm5lY3QgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLmNvbm5lY3Qocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5wYWlyID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5wYWlyKHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMuYXBwcm92ZSA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUuYXBwcm92ZShzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnJlamVjdCA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUucmVqZWN0KHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMudXBkYXRlID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS51cGRhdGUocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5leHRlbmQgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLmV4dGVuZChzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnJlcXVlc3QgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLnJlcXVlc3Qocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5yZXNwb25kID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5yZXNwb25kKHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMucGluZyA9IGFzeW5jIChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbmdpbmUucGluZyhzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmVtaXQgPSBhc3luYyAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5naW5lLmVtaXQocyk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRocm93IHRoaXMubG9nZ2VyLmVycm9yKHIubWVzc2FnZSksIHI7XG4gICAgICB9XG4gICAgfSwgdGhpcy5kaXNjb25uZWN0ID0gYXN5bmMgKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmVuZ2luZS5kaXNjb25uZWN0KHMpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihyLm1lc3NhZ2UpLCByO1xuICAgICAgfVxuICAgIH0sIHRoaXMuZmluZCA9IChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUuZmluZChzKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5sb2dnZXIuZXJyb3Ioci5tZXNzYWdlKSwgcjtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmdldFBlbmRpbmdTZXNzaW9uUmVxdWVzdHMgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUuZ2V0UGVuZGluZ1Nlc3Npb25SZXF1ZXN0cygpO1xuICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICB0aHJvdyB0aGlzLmxvZ2dlci5lcnJvcihzLm1lc3NhZ2UpLCBzO1xuICAgICAgfVxuICAgIH0sIHRoaXMubmFtZSA9IGU/Lm5hbWUgfHwgRnIubmFtZSwgdGhpcy5tZXRhZGF0YSA9IGU/Lm1ldGFkYXRhIHx8IGZiKCk7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBlPy5sb2dnZXIgPCBcInVcIiAmJiB0eXBlb2YgZT8ubG9nZ2VyICE9IFwic3RyaW5nXCIgPyBlLmxvZ2dlciA6IGVlLnBpbm8oZWUuZ2V0RGVmYXVsdExvZ2dlck9wdGlvbnMoeyBsZXZlbDogZT8ubG9nZ2VyIHx8IEZyLmxvZ2dlciB9KSk7XG4gICAgdGhpcy5jb3JlID0gZT8uY29yZSB8fCBuZXcgUHYoZSksIHRoaXMubG9nZ2VyID0gZWUuZ2VuZXJhdGVDaGlsZExvZ2dlcih0LCB0aGlzLm5hbWUpLCB0aGlzLnNlc3Npb24gPSBuZXcgVnYodGhpcy5jb3JlLCB0aGlzLmxvZ2dlciksIHRoaXMucHJvcG9zYWwgPSBuZXcgS3YodGhpcy5jb3JlLCB0aGlzLmxvZ2dlciksIHRoaXMucGVuZGluZ1JlcXVlc3QgPSBuZXcgQnYodGhpcy5jb3JlLCB0aGlzLmxvZ2dlciksIHRoaXMuZW5naW5lID0gbmV3IHp2KHRoaXMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBpbml0KGUpIHtcbiAgICBjb25zdCB0ID0gbmV3IFRuKGUpO1xuICAgIHJldHVybiBhd2FpdCB0LmluaXRpYWxpemUoKSwgdDtcbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gZWUuZ2V0TG9nZ2VyQ29udGV4dCh0aGlzLmxvZ2dlcik7XG4gIH1cbiAgZ2V0IHBhaXJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29yZS5wYWlyaW5nLnBhaXJpbmdzO1xuICB9XG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJJbml0aWFsaXplZFwiKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jb3JlLnN0YXJ0KCksIGF3YWl0IHRoaXMuc2Vzc2lvbi5pbml0KCksIGF3YWl0IHRoaXMucHJvcG9zYWwuaW5pdCgpLCBhd2FpdCB0aGlzLnBlbmRpbmdSZXF1ZXN0LmluaXQoKSwgYXdhaXQgdGhpcy5lbmdpbmUuaW5pdCgpLCB0aGlzLmNvcmUudmVyaWZ5LmluaXQoeyB2ZXJpZnlVcmw6IHRoaXMubWV0YWRhdGEudmVyaWZ5VXJsIH0pLCB0aGlzLmxvZ2dlci5pbmZvKFwiU2lnbkNsaWVudCBJbml0aWFsaXphdGlvbiBTdWNjZXNzXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IHRoaXMubG9nZ2VyLmluZm8oXCJTaWduQ2xpZW50IEluaXRpYWxpemF0aW9uIEZhaWx1cmVcIiksIHRoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSksIGU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBrdihpKSB7XG4gIHJldHVybiB0eXBlb2YgaSA8IFwidVwiICYmIHR5cGVvZiBpLmNvbnRleHQgPCBcInVcIjtcbn1cbmNvbnN0IEd0ID0geyBpbml0OiBcInNpZ25lcl9pbml0XCIsIHVyaTogXCJzaWduZXJfdXJpXCIsIGNyZWF0ZWQ6IFwic2lnbmVyX2NyZWF0ZWRcIiwgdXBkYXRlZDogXCJzaWduZXJfdXBkYXRlZFwiLCBkZWxldGVkOiBcInNpZ25lcl9kZWxldGVkXCIsIGV2ZW50OiBcInNpZ25lcl9ldmVudFwiIH07XG5jbGFzcyBIdiBleHRlbmRzIERnIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMuZXZlbnRzID0gbmV3IFdlLkV2ZW50RW1pdHRlcigpLCB0aGlzLnBlbmRpbmcgPSAhMSwgdGhpcy5pbml0aWFsaXppbmcgPSAhMSwgdGhpcy5yZXF1aXJlZE5hbWVzcGFjZXMgPSBlPy5yZXF1aXJlZE5hbWVzcGFjZXMgfHwge30sIHRoaXMub3B0cyA9IGU/LmNsaWVudDtcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5zZXNzaW9uIDwgXCJ1XCI7XG4gIH1cbiAgZ2V0IGNvbm5lY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZztcbiAgfVxuICBnZXQgY2hhaW5zKCkge1xuICAgIHJldHVybiB0aGlzLnNlc3Npb24gPyBZbSh0aGlzLnNlc3Npb24ubmFtZXNwYWNlcykgOiBKbSh0aGlzLnJlcXVpcmVkTmFtZXNwYWNlcyk7XG4gIH1cbiAgZ2V0IGFjY291bnRzKCkge1xuICAgIHJldHVybiB0aGlzLnNlc3Npb24gPyBXbSh0aGlzLnNlc3Npb24ubmFtZXNwYWNlcykgOiBbXTtcbiAgfVxuICBvbihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMub24oZSwgdCk7XG4gIH1cbiAgb25jZShlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMub25jZShlLCB0KTtcbiAgfVxuICBvZmYoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzLm9mZihlLCB0KTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHMucmVtb3ZlTGlzdGVuZXIoZSwgdCk7XG4gIH1cbiAgYXN5bmMgb3BlbigpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChlLCB0KSA9PiB7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uY2UoXCJvcGVuXCIsICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5ldmVudHMub25jZShcIm9wZW5fZXJyb3JcIiwgKHMpID0+IHtcbiAgICAgICAgICAgIHQocyk7XG4gICAgICAgICAgfSksIHR5cGVvZiB0aGlzLmNsaWVudCA+IFwidVwiKVxuICAgICAgICAgICAgcmV0dXJuIHQobmV3IEVycm9yKFwiU2lnbiBDbGllbnQgbm90IGluaXRpYWxpemVkXCIpKTtcbiAgICAgICAgICBlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGVuZGluZyA9ICEwO1xuICAgICAgY29uc3QgZSA9IGF3YWl0IHRoaXMucmVnaXN0ZXIoKSwgdCA9IGUuZmluZCh7IHJlcXVpcmVkTmFtZXNwYWNlczogdGhpcy5yZXF1aXJlZE5hbWVzcGFjZXMgfSk7XG4gICAgICBpZiAodC5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0aGlzLm9uT3Blbih0WzBdKTtcbiAgICAgIGNvbnN0IHsgdXJpOiBzLCBhcHByb3ZhbDogciB9ID0gYXdhaXQgZS5jb25uZWN0KHsgcmVxdWlyZWROYW1lc3BhY2VzOiB0aGlzLnJlcXVpcmVkTmFtZXNwYWNlcyB9KTtcbiAgICAgIHRoaXMuZXZlbnRzLmVtaXQoR3QudXJpLCB7IHVyaTogcyB9KSwgdGhpcy5zZXNzaW9uID0gYXdhaXQgcigpLCB0aGlzLmV2ZW50cy5lbWl0KEd0LmNyZWF0ZWQsIHRoaXMuc2Vzc2lvbiksIHRoaXMub25PcGVuKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgdGhpcy5ldmVudHMuZW1pdChcIm9wZW5fZXJyb3JcIiwgZSksIGU7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHR5cGVvZiB0aGlzLnNlc3Npb24gPiBcInVcIiB8fCAoYXdhaXQgKGF3YWl0IHRoaXMucmVnaXN0ZXIoKSkuZGlzY29ubmVjdCh7IHRvcGljOiB0aGlzLnNlc3Npb24udG9waWMsIHJlYXNvbjogSmUoXCJVU0VSX0RJU0NPTk5FQ1RFRFwiKSB9KSwgdGhpcy5vbkNsb3NlKCkpO1xuICB9XG4gIGFzeW5jIHNlbmQoZSwgdCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5jbGllbnQgPiBcInVcIiAmJiAodGhpcy5jbGllbnQgPSBhd2FpdCB0aGlzLnJlZ2lzdGVyKCksIHRoaXMuY29ubmVjdGVkIHx8IGF3YWl0IHRoaXMub3BlbigpKSwgdHlwZW9mIHRoaXMuc2Vzc2lvbiA+IFwidVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbmVyIGNvbm5lY3Rpb24gaXMgbWlzc2luZyBzZXNzaW9uXCIpO1xuICAgIHRoaXMuY2xpZW50LnJlcXVlc3QoeyB0b3BpYzogdGhpcy5zZXNzaW9uLnRvcGljLCByZXF1ZXN0OiBlLCBjaGFpbklkOiB0Py5jaGFpbklkIH0pLnRoZW4oKHMpID0+IHRoaXMuZXZlbnRzLmVtaXQoXCJwYXlsb2FkXCIsIHhpKGUuaWQsIHMpKSkuY2F0Y2goKHMpID0+IHRoaXMuZXZlbnRzLmVtaXQoXCJwYXlsb2FkXCIsIHFpKGUuaWQsIHMubWVzc2FnZSkpKTtcbiAgfVxuICBhc3luYyByZWdpc3RlcihlID0gdGhpcy5vcHRzKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmNsaWVudCA8IFwidVwiKVxuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50O1xuICAgIGlmICh0aGlzLmluaXRpYWxpemluZylcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgodCwgcykgPT4ge1xuICAgICAgICB0aGlzLmV2ZW50cy5vbmNlKFwicmVnaXN0ZXJfZXJyb3JcIiwgKHIpID0+IHtcbiAgICAgICAgICBzKHIpO1xuICAgICAgICB9KSwgdGhpcy5ldmVudHMub25jZShHdC5pbml0LCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNsaWVudCA+IFwidVwiKVxuICAgICAgICAgICAgcmV0dXJuIHMobmV3IEVycm9yKFwiU2lnbiBDbGllbnQgbm90IGluaXRpYWxpemVkXCIpKTtcbiAgICAgICAgICB0KHRoaXMuY2xpZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICBpZiAoa3YoZSkpXG4gICAgICByZXR1cm4gdGhpcy5jbGllbnQgPSBlLCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5jbGllbnQ7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemluZyA9ICEwLCB0aGlzLmNsaWVudCA9IGF3YWl0IFRuLmluaXQoZSksIHRoaXMuaW5pdGlhbGl6aW5nID0gITEsIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLmV2ZW50cy5lbWl0KEd0LmluaXQpLCB0aGlzLmNsaWVudDtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICB0aHJvdyB0aGlzLmV2ZW50cy5lbWl0KFwicmVnaXN0ZXJfZXJyb3JcIiwgdCksIHQ7XG4gICAgfVxuICB9XG4gIG9uT3BlbihlKSB7XG4gICAgdGhpcy5wZW5kaW5nID0gITEsIGUgJiYgKHRoaXMuc2Vzc2lvbiA9IGUpLCB0aGlzLmV2ZW50cy5lbWl0KFwib3BlblwiKTtcbiAgfVxuICBvbkNsb3NlKCkge1xuICAgIHRoaXMucGVuZGluZyA9ICExLCB0aGlzLmNsaWVudCAmJiAodGhpcy5jbGllbnQgPSB2b2lkIDApLCB0aGlzLmV2ZW50cy5lbWl0KFwiY2xvc2VcIik7XG4gIH1cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0eXBlb2YgdGhpcy5jbGllbnQgPCBcInVcIiAmJiAodGhpcy5jbGllbnQub24oXCJzZXNzaW9uX2V2ZW50XCIsIChlKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgIHRoaXMuc2Vzc2lvbiAmJiAoKHQgPSB0aGlzLnNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiB0LnRvcGljKSAhPT0gZS50b3BpYyB8fCB0aGlzLmV2ZW50cy5lbWl0KEd0LmV2ZW50LCBlLnBhcmFtcyk7XG4gICAgfSksIHRoaXMuY2xpZW50Lm9uKFwic2Vzc2lvbl91cGRhdGVcIiwgKGUpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgdHlwZW9mIHRoaXMuY2xpZW50IDwgXCJ1XCIgJiYgKHRoaXMuc2Vzc2lvbiAmJiAoKHQgPSB0aGlzLnNlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiB0LnRvcGljKSAhPT0gZS50b3BpYyB8fCAodGhpcy5zZXNzaW9uID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5nZXQoZS50b3BpYyksIHRoaXMuZXZlbnRzLmVtaXQoR3QudXBkYXRlZCwgdGhpcy5zZXNzaW9uKSkpO1xuICAgIH0pLCB0aGlzLmNsaWVudC5vbihcInNlc3Npb25fZGVsZXRlXCIsIChlKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgIHRoaXMuc2Vzc2lvbiAmJiAodGhpcy5zZXNzaW9uICYmICgodCA9IHRoaXMuc2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IHQudG9waWMpICE9PSBlLnRvcGljIHx8ICh0aGlzLm9uQ2xvc2UoKSwgdGhpcy5ldmVudHMuZW1pdChHdC5kZWxldGVkLCB0aGlzLnNlc3Npb24pLCB0aGlzLnNlc3Npb24gPSB2b2lkIDApKTtcbiAgICB9KSk7XG4gIH1cbn1cbmNvbnN0IEJoID0gXCI6XCI7XG5mdW5jdGlvbiBHdihpKSB7XG4gIGNvbnN0IHsgbmFtZXNwYWNlOiBlLCByZWZlcmVuY2U6IHQgfSA9IGk7XG4gIHJldHVybiBbZSwgdF0uam9pbihCaCk7XG59XG5mdW5jdGlvbiBXdihpKSB7XG4gIGNvbnN0IFtlLCB0LCBzXSA9IGkuc3BsaXQoQmgpO1xuICByZXR1cm4geyBuYW1lc3BhY2U6IGUsIHJlZmVyZW5jZTogdCwgYWRkcmVzczogcyB9O1xufVxuZnVuY3Rpb24gWXYoaSwgZSkge1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiBpLmZvckVhY2goKHMpID0+IHtcbiAgICBjb25zdCByID0gZShzKTtcbiAgICB0LmluY2x1ZGVzKHIpIHx8IHQucHVzaChyKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBKdihpKSB7XG4gIGNvbnN0IHsgbmFtZXNwYWNlOiBlLCByZWZlcmVuY2U6IHQgfSA9IFd2KGkpO1xuICByZXR1cm4gR3YoeyBuYW1lc3BhY2U6IGUsIHJlZmVyZW5jZTogdCB9KTtcbn1cbmZ1bmN0aW9uIFF2KGkpIHtcbiAgcmV0dXJuIFl2KGksIEp2KTtcbn1cbmZ1bmN0aW9uIFh2KGksIGUgPSBbXSkge1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgaWYgKGUubGVuZ3RoICYmICFlLmluY2x1ZGVzKHMpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSBpW3NdO1xuICAgIHQucHVzaCguLi5yLmFjY291bnRzKTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBadihpLCBlID0gW10pIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gT2JqZWN0LmtleXMoaSkuZm9yRWFjaCgocykgPT4ge1xuICAgIGlmIChlLmxlbmd0aCAmJiAhZS5pbmNsdWRlcyhzKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gaVtzXTtcbiAgICB0LnB1c2goLi4uUXYoci5hY2NvdW50cykpO1xuICB9KSwgdDtcbn1cbmNsYXNzIGVfIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgd2UodGhpcywgXCJhY2NvdW50c1wiLCBbXSk7XG4gICAgd2UodGhpcywgXCJldmVudEVtaXR0ZXJcIiwgbmV3IFdlLkV2ZW50RW1pdHRlcigpKTtcbiAgICB3ZSh0aGlzLCBcInVwZGF0ZVNlc3Npb25cIiwgKGUpID0+IHtcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkU2Vzc2lvbihlKSlcbiAgICAgICAgdGhyb3cgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwidXBkYXRlU2Vzc2lvbiBpbmNvbXBhdGlibGUgc2Vzc2lvblwiLFxuICAgICAgICAgIGUsXG4gICAgICAgICAgXCJmb3IgYWRhcHRlclwiLFxuICAgICAgICAgIHRoaXMuZm9ybWF0Q2hhaW5JZCh0aGlzLmNoYWluSWQpXG4gICAgICAgICksIG5ldyBFcnJvcihcIkludmFsaWQgc2Vzc2lvblwiKTtcbiAgICAgIHRoaXMuc2Vzc2lvbiA9IGU7XG4gICAgICBjb25zdCB0ID0gWnYoZS5uYW1lc3BhY2VzLCBbdGhpcy5uYW1lc3BhY2VdKTtcbiAgICAgIHRoaXMuc2V0Q2hhaW5JZHModCk7XG4gICAgICBjb25zdCBzID0gWHYoZS5uYW1lc3BhY2VzLCBbXG4gICAgICAgIHRoaXMubmFtZXNwYWNlXG4gICAgICBdKTtcbiAgICAgIHRoaXMuc2V0QWNjb3VudHMocyk7XG4gICAgfSk7XG4gICAgd2UodGhpcywgXCJpc1ZhbGlkU2Vzc2lvblwiLCAoe1xuICAgICAgbmFtZXNwYWNlczogZSxcbiAgICAgIHJlcXVpcmVkTmFtZXNwYWNlczogdFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmZvcm1hdENoYWluSWQodGhpcy5jaGFpbklkKTtcbiAgICAgIHJldHVybiB0ID8gISF0W3RoaXMubmFtZXNwYWNlXT8uY2hhaW5zPy5pbmNsdWRlcyhzKSA6ICEhZT8uW3RoaXMubmFtZXNwYWNlXT8uYWNjb3VudHMuc29tZShcbiAgICAgICAgKHIpID0+IHIuc3RhcnRzV2l0aChzKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBnZXRSZXF1aXJlZE5hbWVzcGFjZXMoKSB7XG4gICAgY29uc3QgZSA9IFt0aGlzLmZvcm1hdENoYWluSWQodGhpcy5jaGFpbklkKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIFt0aGlzLm5hbWVzcGFjZV06IHsgY2hhaW5zOiBlLCBtZXRob2RzOiB0aGlzLm1ldGhvZHMsIGV2ZW50czogdGhpcy5ldmVudHMgfVxuICAgIH07XG4gIH1cbiAgaXNDb21wYXRpYmxlQ2hhaW5JZChlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlLnN0YXJ0c1dpdGgoYCR7dGhpcy5uYW1lc3BhY2V9OmApIDogITE7XG4gIH1cbiAgc2V0Q2hhaW5JZHMoZSkge1xuICAgIGNvbnN0IHMgPSBlLmZpbHRlcigocikgPT4gdGhpcy5pc0NvbXBhdGlibGVDaGFpbklkKHIpKS5tYXAoKHIpID0+IHRoaXMucGFyc2VDaGFpbklkKHIpKS5maWx0ZXIoKHIpID0+IHIgIT09IHRoaXMuY2hhaW5JZCk7XG4gICAgcy5sZW5ndGggJiYgKHRoaXMuY2hhaW5JZCA9IHNbMF0sIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJjaGFpbkNoYW5nZWRcIiwgdGhpcy5jaGFpbklkKSk7XG4gIH1cbiAgc2V0Q2hhaW5JZChlKSB7XG4gICAgaWYgKHRoaXMuaXNDb21wYXRpYmxlQ2hhaW5JZChlKSkge1xuICAgICAgY29uc3QgdCA9IHRoaXMucGFyc2VDaGFpbklkKGUpO1xuICAgICAgdGhpcy5jaGFpbklkID0gdCwgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdChcImNoYWluQ2hhbmdlZFwiLCB0aGlzLmNoYWluSWQpO1xuICAgIH1cbiAgfVxuICBwYXJzZUFjY291bnRJZChlKSB7XG4gICAgY29uc3QgW3QsIHMsIHJdID0gZS5zcGxpdChcIjpcIik7XG4gICAgcmV0dXJuIHsgY2hhaW5JZDogYCR7dH06JHtzfWAsIGFkZHJlc3M6IHIgfTtcbiAgfVxuICBnZXRTaWduZXJDb25uZWN0aW9uKGUpIHtcbiAgICByZXR1cm4gbmV3IEh2KHtcbiAgICAgIHJlcXVpcmVkTmFtZXNwYWNlczoge1xuICAgICAgICBbdGhpcy5uYW1lc3BhY2VdOiB7XG4gICAgICAgICAgY2hhaW5zOiB0aGlzLnJwYy5jaGFpbnMsXG4gICAgICAgICAgbWV0aG9kczogdGhpcy5ycGMubWV0aG9kcyxcbiAgICAgICAgICBldmVudHM6IHRoaXMucnBjLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xpZW50OiBlXG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLnJwY1Byb3ZpZGVyLm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IGNoYWluczogZSwgYWNjb3VudHM6IHQgfSA9IHRoaXMuc2lnbmVyQ29ubmVjdGlvbjtcbiAgICAgIGU/Lmxlbmd0aCAmJiB0aGlzLnNldENoYWluSWRzKGUpLCB0Py5sZW5ndGggJiYgdGhpcy5zZXRBY2NvdW50cyh0KTtcbiAgICB9KSwgdGhpcy5zaWduZXJDb25uZWN0aW9uLm9uKEd0LmNyZWF0ZWQsIHRoaXMudXBkYXRlU2Vzc2lvbiksIHRoaXMuc2lnbmVyQ29ubmVjdGlvbi5vbihHdC51cGRhdGVkLCB0aGlzLnVwZGF0ZVNlc3Npb24pLCB0aGlzLnNpZ25lckNvbm5lY3Rpb24ub24oR3QuZXZlbnQsIChlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucnBjLmNoYWlucy5pbmNsdWRlcyhlLmNoYWluSWQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IGV2ZW50OiB0IH0gPSBlO1xuICAgICAgdC5uYW1lID09PSBcImFjY291bnRzQ2hhbmdlZFwiID8gKHRoaXMuYWNjb3VudHMgPSB0LmRhdGEsIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJhY2NvdW50c0NoYW5nZWRcIiwgdGhpcy5hY2NvdW50cykpIDogdC5uYW1lID09PSBcImNoYWluQ2hhbmdlZFwiID8gdGhpcy5zZXRDaGFpbklkKHQuZGF0YSkgOiB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KHQubmFtZSwgdC5kYXRhKTtcbiAgICB9KSwgdGhpcy5ycGNQcm92aWRlci5vbihcImRpc2Nvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEhhIGV4dGVuZHMgJHUge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBzLCByKSB7XG4gICAgc3VwZXIoZSwgdCwgcyksIHRoaXMud2FsbGV0ID0gcjtcbiAgfVxuICBhc3luYyBleGVjdXRlKGUsIHQgPSB2b2lkIDAsIHMgPSB7fSkge1xuICAgIHJldHVybiBlID0gQXJyYXkuaXNBcnJheShlKSA/IGUgOiBbZV0sIGF3YWl0IHRoaXMud2FsbGV0LnN0YXJrbmV0X3JlcXVlc3RBZGRJbnZva2VUcmFuc2FjdGlvbih7XG4gICAgICBhY2NvdW50QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgZXhlY3V0aW9uUmVxdWVzdDogeyBjYWxsczogZSwgYWJpczogdCwgaW52b2NhdGlvbkRldGFpbHM6IHMgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlY2xhcmUoZSwgdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQgdmlhIEFyZ2VudCBMb2dpblwiKTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50KGUsIHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIHZpYSBBcmdlbnQgTG9naW5cIik7XG4gIH1cbn1cbmNsYXNzIHRfIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMud2FsbGV0ID0gZTtcbiAgfVxuICBhc3luYyBnZXRQdWJLZXkoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCB2aWEgQXJnZW50IExvZ2luXCIpO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKGUsIHQpIHtcbiAgICBjb25zdCB7IHNpZ25hdHVyZTogcyB9ID0gYXdhaXQgdGhpcy53YWxsZXQuc3RhcmtuZXRfc2lnblR5cGVkRGF0YSh7XG4gICAgICBhY2NvdW50QWRkcmVzczogdCxcbiAgICAgIHR5cGVkRGF0YTogZVxuICAgIH0pO1xuICAgIHJldHVybiBzO1xuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihlLCB0LCBzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCB2aWEgQXJnZW50IExvZ2luXCIpO1xuICB9XG4gIGFzeW5jIHNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQgdmlhIEFyZ2VudCBMb2dpblwiKTtcbiAgfVxuICBhc3luYyBzaWduRGVjbGFyZVRyYW5zYWN0aW9uKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIHZpYSBBcmdlbnQgTG9naW5cIik7XG4gIH1cbn1cbmNvbnN0IGlfID0gKGkpID0+IGkucmVwbGFjZSgvXlNOXy8sIFwiU05cIiksIHNfID0gKGkpID0+IGkucmVwbGFjZSgvXlNOLywgXCJTTl9cIik7XG5jbGFzcyByXyBleHRlbmRzIGVfIHtcbiAgY29uc3RydWN0b3IoeyBjbGllbnQ6IHQsIGNoYWluSWQ6IHMsIHJwY1VybDogciwgcHJvdmlkZXI6IG4gfSkge1xuICAgIHN1cGVyKCk7XG4gICAgd2UodGhpcywgXCJpZFwiLCBcImFyZ2VudE1vYmlsZVwiKTtcbiAgICB3ZSh0aGlzLCBcIm5hbWVcIiwgXCJBcmdlbnQgTW9iaWxlXCIpO1xuICAgIHdlKHRoaXMsIFwidmVyc2lvblwiLCBcIjAuMS4wXCIpO1xuICAgIHdlKHRoaXMsIFwiaWNvblwiLCBcIlwiKTtcbiAgICB3ZSh0aGlzLCBcInByb3ZpZGVyXCIpO1xuICAgIHdlKHRoaXMsIFwic2lnbmVyXCIpO1xuICAgIHdlKHRoaXMsIFwiYWNjb3VudFwiKTtcbiAgICB3ZSh0aGlzLCBcInNlbGVjdGVkQWRkcmVzc1wiLCBcIlwiKTtcbiAgICAvLyBOYW1lc3BhY2VBZGFwdGVyXG4gICAgd2UodGhpcywgXCJuYW1lc3BhY2VcIiwgXCJzdGFya25ldFwiKTtcbiAgICB3ZSh0aGlzLCBcIm1ldGhvZHNcIiwgW1xuICAgICAgXCJzdGFya25ldF9zaWduVHlwZWREYXRhXCIsXG4gICAgICBcInN0YXJrbmV0X3JlcXVlc3RBZGRJbnZva2VUcmFuc2FjdGlvblwiXG4gICAgXSk7XG4gICAgd2UodGhpcywgXCJldmVudHNcIiwgW1wiY2hhaW5DaGFuZ2VkXCIsIFwiYWNjb3VudHNDaGFuZ2VkXCJdKTtcbiAgICB3ZSh0aGlzLCBcInJlbW90ZVNpZ25lclwiKTtcbiAgICB3ZSh0aGlzLCBcInNpZ25lckNvbm5lY3Rpb25cIik7XG4gICAgd2UodGhpcywgXCJycGNQcm92aWRlclwiKTtcbiAgICB3ZSh0aGlzLCBcImNoYWluSWRcIik7XG4gICAgd2UodGhpcywgXCJjbGllbnRcIik7XG4gICAgd2UodGhpcywgXCJzZXNzaW9uXCIpO1xuICAgIHdlKHRoaXMsIFwicnBjXCIpO1xuICAgIHdlKHRoaXMsIFwid2FsbGV0UnBjXCIpO1xuICAgIHdlKHRoaXMsIFwib25cIiwgKHQsIHMpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLm9uKHQsIHMpO1xuICAgIH0pO1xuICAgIHdlKHRoaXMsIFwib2ZmXCIsICh0LCBzKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50RW1pdHRlci5vZmYodCwgcyk7XG4gICAgfSk7XG4gICAgdGhpcy5jaGFpbklkID0gU3RyaW5nKHMgPz8gTXMuTmV0d29ya05hbWUuU05fTUFJTiksIHRoaXMucnBjID0ge1xuICAgICAgY2hhaW5zOiBzID8gW3RoaXMuZm9ybWF0Q2hhaW5JZCh0aGlzLmNoYWluSWQpXSA6IFtdLFxuICAgICAgbWV0aG9kczogdGhpcy5tZXRob2RzLFxuICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50c1xuICAgIH0sIHRoaXMuc2lnbmVyQ29ubmVjdGlvbiA9IHRoaXMuZ2V0U2lnbmVyQ29ubmVjdGlvbih0KSwgdGhpcy5ycGNQcm92aWRlciA9IG5ldyBfbih0aGlzLnNpZ25lckNvbm5lY3Rpb24pLCB0aGlzLmNsaWVudCA9IHQsIHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVycygpLCB0aGlzLndhbGxldFJwYyA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgZ2V0OiAobywgYykgPT4gKHUpID0+IHRoaXMucmVxdWVzdFdhbGxldCh7IG1ldGhvZDogYywgcGFyYW1zOiB1IH0pXG4gICAgfSksIHRoaXMucmVtb3RlU2lnbmVyID0gbmV3IHRfKHRoaXMud2FsbGV0UnBjKSwgdGhpcy5wcm92aWRlciA9IG4gfHwgbmV3IEZ1KHsgbm9kZVVybDogciB9KSwgdGhpcy5hY2NvdW50ID0gbmV3IEhhKFxuICAgICAgdGhpcy5wcm92aWRlcixcbiAgICAgIFwiXCIsXG4gICAgICB0aGlzLnJlbW90ZVNpZ25lcixcbiAgICAgIHRoaXMud2FsbGV0UnBjXG4gICAgKTtcbiAgfVxuICBnZXROZXR3b3JrTmFtZSh0KSB7XG4gICAgaWYgKHQgPT09IFwiU05fU0VQT0xJQVwiKVxuICAgICAgcmV0dXJuIE1zLk5ldHdvcmtOYW1lLlNOX1NFUE9MSUE7XG4gICAgaWYgKHQgPT09IFwiU05fTUFJTlwiKVxuICAgICAgcmV0dXJuIE1zLk5ldHdvcmtOYW1lLlNOX01BSU47XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0YXJrbmV0LmpzIG5ldHdvcmsgbmFtZSBmb3IgY2hhaW5JZCAke3R9YCk7XG4gIH1cbiAgLy8gU3RhcmtuZXRXaW5kb3dPYmplY3RcbiAgYXN5bmMgcmVxdWVzdCh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkOiAucmVxdWVzdCgpXCIpO1xuICB9XG4gIGFzeW5jIGVuYWJsZSgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5ycGNQcm92aWRlci5jb25uZWN0KCksIHRoaXMuYWNjb3VudHM7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIGdldCBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgYXN5bmMgaXNQcmVhdXRob3JpemVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuY2xpZW50LnNlc3Npb24uZ2V0QWxsKCkuZmluZCh0aGlzLmlzVmFsaWRTZXNzaW9uKTtcbiAgfVxuICBhc3luYyByZXF1ZXN0V2FsbGV0KHQpIHtcbiAgICBpZiAoIXRoaXMuc2Vzc2lvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNlc3Npb25cIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdG9waWM6IHMgfSA9IHRoaXMuc2Vzc2lvbiwgciA9IHRoaXMuZm9ybWF0Q2hhaW5JZCh0aGlzLmNoYWluSWQpO1xuICAgICAga3Quc2hvd0FwcHJvdmFsTW9kYWwodCk7XG4gICAgICBjb25zdCBuID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7IHRvcGljOiBzLCBjaGFpbklkOiByLCByZXF1ZXN0OiB0IH0pO1xuICAgICAgcmV0dXJuIGt0LmNsb3NlTW9kYWwoXCJhbmltYXRlU3VjY2Vzc1wiKSwgbjtcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICB0aHJvdyBrdC5jbG9zZU1vZGFsKCksIHMgaW5zdGFuY2VvZiBFcnJvciA/IG5ldyBFcnJvcihzLm1lc3NhZ2UpIDogbmV3IEVycm9yKFwiVW5rbm93IGVycm9yIG9uIHJlcXVlc3RXYWxsZXRcIik7XG4gICAgfVxuICB9XG4gIC8vIE5hbWVzcGFjZUFkYXB0ZXJcbiAgZ2V0IGlzQ29ubmVjdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduZXJDb25uZWN0aW9uLmNvbm5lY3Rpbmc7XG4gIH1cbiAgYXN5bmMgZGlzYWJsZSgpIHtcbiAgICBhd2FpdCB0aGlzLnJwY1Byb3ZpZGVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBnZXQgaXNXYWxsZXRDb25uZWN0KCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvLyBOYW1lc3BhY2VBZGFwdGVyIHByaXZhdGUgbWV0aG9kc1xuICByZWdpc3RlckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHN1cGVyLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5ldmVudEVtaXR0ZXIub24oXCJjaGFpbkNoYW5nZWRcIiwgKHQpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZDogY2hhaW5DaGFuZ2VkXCIpO1xuICAgIH0pO1xuICB9XG4gIGZvcm1hdENoYWluSWQodCkge1xuICAgIHJldHVybiBgJHt0aGlzLm5hbWVzcGFjZX06JHtpXyh0KX1gO1xuICB9XG4gIHBhcnNlQ2hhaW5JZCh0KSB7XG4gICAgcmV0dXJuIHNfKHQuc3BsaXQoXCI6XCIpWzFdKTtcbiAgfVxuICBzZXRBY2NvdW50cyh0KSB7XG4gICAgdGhpcy5hY2NvdW50cyA9IHQuZmlsdGVyKFxuICAgICAgKG4pID0+IHRoaXMucGFyc2VDaGFpbklkKHRoaXMucGFyc2VBY2NvdW50SWQobikuY2hhaW5JZCkgPT09IHRoaXMuY2hhaW5JZFxuICAgICkubWFwKChuKSA9PiB0aGlzLnBhcnNlQWNjb3VudElkKG4pLmFkZHJlc3MpO1xuICAgIGNvbnN0IHsgYWRkcmVzczogcyB9ID0gdGhpcy5wYXJzZUFjY291bnRJZCh0WzBdKSwgciA9IHMuc3RhcnRzV2l0aChcIjB4XCIpID8gcyA6IGAweCR7c31gO1xuICAgIHRoaXMuYWNjb3VudCA9IG5ldyBIYShcbiAgICAgIHRoaXMucHJvdmlkZXIsXG4gICAgICByLFxuICAgICAgdGhpcy5yZW1vdGVTaWduZXIsXG4gICAgICB0aGlzLndhbGxldFJwY1xuICAgICksIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJhY2NvdW50c0NoYW5nZWRcIiwgdGhpcy5hY2NvdW50cyksIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gcjtcbiAgfVxufVxuY29uc3QgWV8gPSBhc3luYyAoaSkgPT4gUG0oaSwgcl8pO1xuZXhwb3J0IHtcbiAgWV8gYXMgZ2V0U3RhcmtuZXRXaW5kb3dPYmplY3Rcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknetkit/dist/index-00451f1a.js\n"));

/***/ })

}]);